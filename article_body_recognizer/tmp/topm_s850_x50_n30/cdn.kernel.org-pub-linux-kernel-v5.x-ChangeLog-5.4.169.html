<!DOCTYPE html>
<html>
<head>

      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

        <script> var url = encodeURIComponent('https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.4.169');</script>

        <script> var body_html = 'PGJvZHk+PHA+Y29tbWl0IDRjYTJlYWYxZDQ3N2NlNDMxNjk4OWIyMmU3NjVmYjkxNTY1MmI4NmUgQXV0aG9yOiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gRGF0ZTogV2VkIERlYyAyOSAxMjoyMzozOCAyMDIxICswMTAwIExpbnV4IDUuNC4xNjkgTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8yMDIxMTIyNzE1MTMyMC44MDE3MTQ0MjlAbGludXhmb3VuZGF0aW9uLm9yZyBUZXN0ZWQtYnk6IEZsb3JpYW4gRmFpbmVsbGkgPGYuZmFpbmVsbGk+IFRlc3RlZC1ieTogSHVsayBSb2JvdCA8aHVsa3JvYm90PiBUZXN0ZWQtYnk6IExpbnV4IEtlcm5lbCBGdW5jdGlvbmFsIFRlc3RpbmcgPGxrZnQ+IFRlc3RlZC1ieTogU3VkaXAgTXVraGVyamVlIDxzdWRpcC5tdWtoZXJqZWU+IFRlc3RlZC1ieTogR3VlbnRlciBSb2VjayA8bGludXg+IFRlc3RlZC1ieTogU2h1YWggS2hhbiA8c2toYW4+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgNDhjNzZmYzUzNTgyZTdmMTNjMWUwYjExYzkxNmU1MDMyNTZjNGQwYiBBdXRob3I6IFLDqW1pIERlbmlzLUNvdXJtb250IDxyZW1pPiBEYXRlOiBTdW4gRGVjIDE5IDE5OjAzOjM5IDIwMjEgKzAyMDAgcGhvbmV0L3BlcDogcmVmdXNlIHRvIGVuYWJsZSBhbiB1bmJvdW5kIHBpcGUgY29tbWl0IDc1YTJmMzE1MjAwOTU2MDBmNjUwNTk3YzBhYzQxZjQ4YjViYTAwNjggdXBzdHJlYW0uIFRoaXMgaW9jdGwoKSBpbXBsaWNpdGx5IGFzc3VtZWQgdGhhdCB0aGUgc29ja2V0IHdhcyBhbHJlYWR5IGJvdW5kIHRvIGEgdmFsaWQgbG9jYWwgc29ja2V0IG5hbWUsIGkuZS4gUGhvbmV0IG9iamVjdC4gSWYgdGhlIHNvY2tldCB3YXMgbm90IGJvdW5kLCB0d28gc2VwYXJhdGUgcHJvYmxlbXMgd291bGQgb2NjdXI6IDEpIFdlJ2Qgc2VuZCBhbiBwaXBlIGVuYWJsZW1lbnQgcmVxdWVzdCB3aXRoIGFuIGludmFsaWQgc291cmNlIG9iamVjdC4gMikgTGF0ZXIgc29ja2V0IGNhbGxzIGNvdWxkIEJVRyBvbiB0aGUgc29ja2V0IHVuZXhwZWN0ZWRseSBiZWluZyBjb25uZWN0ZWQgeWV0IG5vdCBib3VuZCB0byBhIHZhbGlkIG9iamVjdC4gUmVwb3J0ZWQtYnk6IHN5emJvdCsyZGM5MWU3ZmMzZGVhODhiMWU4YUBzeXprYWxsZXIuYXBwc3BvdG1haWwuY29tIFNpZ25lZC1vZmYtYnk6IFLDqW1pIERlbmlzLUNvdXJtb250IDxyZW1pPiBTaWduZWQtb2ZmLWJ5OiBEYXZpZCBTLiBNaWxsZXIgPGRhdmVtPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGE1YzZhMTNlOTA1NmQ4NzgwNWJhMzA0MmMyMDhmYmQ0MTY0YWQyMmIgQXV0aG9yOiBMaW4gTWEgPGxpbm1hPiBEYXRlOiBGcmkgRGVjIDE3IDEwOjEzOjU2IDIwMjEgKzA4MDAgaGFtcmFkaW86IGltcHJvdmUgdGhlIGluY29tcGxldGUgZml4IHRvIGF2b2lkIE5QRCBjb21taXQgYjJmMzdhZWFkMWI4MmE3NzBjNDhiNWQ1ODNmMzVlYzIyYWFiYjYxZSB1cHN0cmVhbS4gVGhlIHByZXZpb3VzIGNvbW1pdCAzZTA1ODhjMjkxZDYgKCJoYW1yYWRpbzogZGVmZXIgYXgyNSBrZnJlZSBhZnRlciB1bnJlZ2lzdGVyX25ldGRldiIpIHJlb3JkZXIgdGhlIGtmcmVlIG9wZXJhdGlvbnMgYW5kIHVucmVnaXN0ZXJfbmV0ZGV2IG9wZXJhdGlvbiB0byBwcmV2ZW50IFVBRi4gVGhpcyBjb21taXQgaW1wcm92ZXMgdGhlIHByZXZpb3VzIG9uZSBieSBhbHNvIGRlZmVycmluZyB0aGUgbnVsbGlmeSBvZiB0aGUgYXgtJmd0O3R0eSBwb2ludGVyLiBPdGhlcndpc2UsIGEgTlVMTCBwb2ludGVyIGRlcmVmZXJlbmNlIGJ1ZyBvY2N1cnMuIFBhcnRpYWwgb2YgdGhlIHN0YWNrIHRyYWNlIGlzIHNob3duIGJlbG93LiBCVUc6IGtlcm5lbCBOVUxMIHBvaW50ZXIgZGVyZWZlcmVuY2UsIGFkZHJlc3M6IDAwMDAwMDAwMDAwMDA1MzggUklQOiAwMDEwOmF4X3htaXQrMHgxZjkvMHg0MDAgLi4uIENhbGwgVHJhY2U6IGRldl9oYXJkX3N0YXJ0X3htaXQrMHhlYy8weDMyMCBzY2hfZGlyZWN0X3htaXQrMHhlYS8weDI0MCBfX3FkaXNjX3J1bisweDE2Ni8weDVjMCBfX2Rldl9xdWV1ZV94bWl0KzB4MmM3LzB4YWYwIGF4MjVfc3RkX2VzdGFibGlzaF9kYXRhX2xpbmsrMHg1OS8weDYwIGF4MjVfY29ubmVjdCsweDNhMC8weDUwMCA/IHNlY3VyaXR5X3NvY2tldF9jb25uZWN0KzB4MmIvMHg0MCBfX3N5c19jb25uZWN0KzB4OTYvMHhjMCA/IF9faHJ0aW1lcl9pbml0KzB4YzAvMHhjMCA/IGNvbW1vbl9uc2xlZXArMHgyZS8weDUwID8gc3dpdGNoX2ZwdV9yZXR1cm4rMHgxMzkvMHgxYTAgX194NjRfc3lzX2Nvbm5lY3QrMHgxMS8weDIwIGRvX3N5c2NhbGxfNjQrMHgzMy8weDQwIGVudHJ5X1NZU0NBTExfNjRfYWZ0ZXJfaHdmcmFtZSsweDQ0LzB4YTkgVGhlIGNyYXNoIHBvaW50IGlzIHNob3duIGFzIGJlbG93IHN0YXRpYyB2b2lkIGF4X2VuY2FwcyguLi4pIHsgLi4uIHNldF9iaXQoVFRZX0RPX1dSSVRFX1dBS0VVUCwgYXgtJmd0O3R0eS0mZ3Q7ZmxhZ3MpOyAvLyBheC0mZ3Q7dHR5ID0gTlVMTCEgLi4uIH0gQnkgcGxhY2luZyB0aGUgbnVsbGlmeSBhY3Rpb24gYWZ0ZXIgdGhlIHVucmVnaXN0ZXJfbmV0ZGV2LCB0aGUgYXgtJmd0O3R0eSBwb2ludGVyIHdvbid0IGJlIGFzc2lnbmVkIGFzIE5VTEwgbmV0X2RldmljZSBmcmFtZXdvcmsgbGF5ZXIgaXMgd2VsbCBzeW5jaHJvbml6ZWQuIFNpZ25lZC1vZmYtYnk6IExpbiBNYSA8bGlubWE+IFNpZ25lZC1vZmYtYnk6IERhdmlkIFMuIE1pbGxlciA8ZGF2ZW0+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgZWY1ZjdiZmExOWUzZmMzNjZmNGM2ZDFhODQxY2VhZGRmN2E5ZjVkNCBBdXRob3I6IExpbiBNYSA8bGlubWE+IERhdGU6IE1vbiBOb3YgOCAxODozNzoyMSAyMDIxICswODAwIGhhbXJhZGlvOiBkZWZlciBheDI1IGtmcmVlIGFmdGVyIHVucmVnaXN0ZXJfbmV0ZGV2IGNvbW1pdCAzZTA1ODhjMjkxZDZjZTIyNWYyYjg5MTc1M2NhNDFkNDViYTQyNDY5IHVwc3RyZWFtLiBUaGVyZSBpcyBhIHBvc3NpYmxlIHJhY2UgY29uZGl0aW9uICh1c2UtYWZ0ZXItZnJlZSkgbGlrZSBiZWxvdyAoVVNFKSB8IChGUkVFKSBheDI1X3NlbmRtc2cgfCBheDI1X3F1ZXVlX3htaXQgfCBkZXZfcXVldWVfeG1pdCB8IF9fZGV2X3F1ZXVlX3htaXQgfCBfX2Rldl94bWl0X3NrYiB8IHNjaF9kaXJlY3RfeG1pdCB8IC4uLiB4bWl0X29uZSB8IG5ldGRldl9zdGFydF94bWl0IHwgdHR5X2xkaXNjX2tpbGwgX19uZXRkZXZfc3RhcnRfeG1pdCB8IG1raXNzX2Nsb3NlIGF4X3htaXQgfCBrZnJlZSBheF9lbmNhcHMgfCB8IEV2ZW4gdGhvdWdoIHRoZXJlIGFyZSB0d28gc3luY2hyb25pemF0aW9uIHByaW1pdGl2ZXMgYmVmb3JlIHRoZSBrZnJlZTogMS4gd2FpdF9mb3JfY29tcGxldGlvbihheC0mZ3Q7ZGVhZCkuIFRoaXMgY2FuIHByZXZlbnQgdGhlIHJhY2Ugd2l0aCByb3V0aW5lcyBmcm9tIG1raXNzX2lvY3RsLiBIb3dldmVyLCBpdCBjYW5ub3Qgc3RvcCB0aGUgcm91dGluZSBjb21pbmcgZnJvbSB1cHBlciBsYXllciwgaS5lLiwgdGhlIGF4MjVfc2VuZG1zZy4gMi4gbmV0aWZfc3RvcF9xdWV1ZShheC0mZ3Q7ZGV2KS4gSXQgc2VlbXMgdGhhdCB0aGlzIGxpbmUgb2YgY29kZSBhaW1zIHRvIGhhbHQgdGhlIHRyYW5zbWl0IHF1ZXVlIGJ1dCBpdCBmYWlscyB0byBzdG9wIHRoZSByb3V0aW5lIHRoYXQgYWxyZWFkeSBiZWluZyB4bWl0LiBUaGlzIHBhdGNoIHJlb3JkZXIgdGhlIGtmcmVlIGFmdGVyIHRoZSB1bnJlZ2lzdGVyX25ldGRldiB0byBhdm9pZCB0aGUgcG9zc2libGUgVUFGIGFzIHRoZSB1bnJlZ2lzdGVyX25ldGRldigpIGlzIHdlbGwgc3luY2hyb25pemVkIGFuZCB3b24ndCByZXR1cm4gaWYgdGhlcmUgaXMgYSBydW5uaW5nIHJvdXRpbmUuIFNpZ25lZC1vZmYtYnk6IExpbiBNYSA8bGlubWE+IFNpZ25lZC1vZmYtYnk6IERhdmlkIFMuIE1pbGxlciA8ZGF2ZW0+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgZGY4Zjc5YmNjMmU0MzFiYjZlMWYwYTgyMDJjZDJiMDZmZDQyOTg4OSBBdXRob3I6IExpbiBNYSA8bGlubWE+IERhdGU6IEZyaSBEZWMgMTcgMTA6Mjk6NDEgMjAyMSArMDgwMCBheDI1OiBOUEQgYnVnIHdoZW4gZGV0YWNoaW5nIEFYMjUgZGV2aWNlIGNvbW1pdCAxYWRlNDhkMGMyN2Q1ZGExY2NmNGI1ODNkOGM1ZmM4YjUzNGEzYWM4IHVwc3RyZWFtLiBUaGUgZXhpc3RpbmcgY2xlYW51cCByb3V0aW5lIGltcGxlbWVudGF0aW9uIGlzIG5vdCB3ZWxsIHN5bmNocm9uaXplZCB3aXRoIHRoZSBzeXNjYWxsIHJvdXRpbmUuIFdoZW4gYSBkZXZpY2UgaXMgZGV0YWNoaW5nLCBiZWxvdyByYWNlIGNvdWxkIG9jY3VyLiBzdGF0aWMgaW50IGF4MjVfc2VuZG1zZyguLi4pIHsgLi4uIGxvY2tfc29jaygpIGF4MjUgPSBza190b19heDI1KHNrKTsgaWYgKGF4MjUtJmd0O2F4MjVfZGV2ID09IE5VTEwpIC8vIENIRUNLIC4uLiBheDI1X3F1ZXVlX3htaXQoc2tiLCBheDI1LSZndDtheDI1X2Rldi0mZ3Q7ZGV2KTsgLy8gVVNFIC4uLiB9IHN0YXRpYyB2b2lkIGF4MjVfa2lsbF9ieV9kZXZpY2UoLi4uKSB7IC4uLiBpZiAocy0mZ3Q7YXgyNV9kZXYgPT0gYXgyNV9kZXYpIHsgcy0mZ3Q7YXgyNV9kZXYgPSBOVUxMOyAuLi4gfSBPdGhlciBzeXNjYWxsIGZ1bmN0aW9ucyBsaWtlIGF4MjVfZ2V0c29ja29wdCwgYXgyNV9nZXRuYW1lLCBheDI1X2luZm9fc2hvdyBhbHNvIHN1ZmZlciBmcm9tIHNpbWlsYXIgcmFjZXMuIFRvIGZpeCB0aGVtLCB0aGlzIHBhdGNoIGludHJvZHVjZSBsb2NrX3NvY2soKSBpbnRvIGF4MjVfa2lsbF9ieV9kZXZpY2UgaW4gb3JkZXIgdG8gZ3VhcmFudGVlIHRoYXQgdGhlIG51bGxpZnkgYWN0aW9uIGluIGNsZWFudXAgcm91dGluZSBjYW5ub3QgcHJvY2VlZCB3aGVuIGFub3RoZXIgc29ja2V0IHJlcXVlc3QgaXMgcGVuZGluZy4gU2lnbmVkLW9mZi1ieTogSGFuamllIFd1IDxuYWdpPiBTaWduZWQtb2ZmLWJ5OiBMaW4gTWEgPGxpbm1hPiBTaWduZWQtb2ZmLWJ5OiBEYXZpZCBTLiBNaWxsZXIgPGRhdmVtPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDAzMzNlYWYzODUwMGNhYTA1YzVjODFkZTE0YTEzMzI4ZDA1NDRmM2MgQXV0aG9yOiBHdWVudGVyIFJvZWNrIDxsaW51eD4gRGF0ZTogRnJpIERlYyAzIDEzOjQyOjIyIDIwMjEgLTA4MDAgaHdtb246IChsbTkwKSBEbyBub3QgcmVwb3J0ICdidXN5JyBzdGF0dXMgYml0IGFzIGFsYXJtIGNvbW1pdCBjZGM1Mjg3YWNhZDllZGUxMjE5MjRhOWM5MzEzNTQ0YjgwZDE1ODQyIHVwc3RyZWFtLiBCaXQgNyBvZiB0aGUgc3RhdHVzIHJlZ2lzdGVyIGluZGljYXRlcyB0aGF0IHRoZSBjaGlwIGlzIGJ1c3kgZG9pbmcgYSBjb252ZXJzaW9uLiBJdCBkb2VzIG5vdCBpbmRpY2F0ZSBhbiBhbGFybSBzdGF0dXMuIFN0b3AgcmVwb3J0aW5nIGl0IGFzIGFsYXJtIHN0YXR1cyBiaXQuIFNpZ25lZC1vZmYtYnk6IEd1ZW50ZXIgUm9lY2sgPGxpbnV4PiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGJmMjYwZmY0YTQyZjM4ODI0ZGY4YjlhYWFjMDhiNzgwZTgwYTc0MzIgQXV0aG9yOiBHdWVudGVyIFJvZWNrIDxsaW51eD4gRGF0ZTogRnJpIE5vdiAyNiAyMjo0MzozOSAyMDIxIC0wODAwIGh3bW9tOiAobG05MCkgRml4IGNpdGljYWwgYWxhcm0gc3RhdHVzIGZvciBNQVg2NjgwL01BWDY2ODEgY29tbWl0IGRhN2RjMDU2ODQ5MTEwNGM3YWNiNjMyZTlkNDFkZGNlOWFhYWJiYjEgdXBzdHJlYW0uIFRlc3RzIHdpdGggYSByZWFsIGNoaXAgYW5kIGEgY2xvc2VyIGxvb2sgaW50byB0aGUgZGF0YXNoZWV0IHJldmVhbHMgdGhhdCB0aGUgbG9jYWwgYW5kIHJlbW90ZSBjcml0aWNhbCBhbGFybSBzdGF0dXMgYml0cyBhcmUgc3dhcHBlZCBmb3IgTUFYNjY4MC9NQVg2NjgxLiBTaWduZWQtb2ZmLWJ5OiBHdWVudGVyIFJvZWNrIDxsaW51eD4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCBmMzczMjk4ZTFiZjBjNmVhMDk3YzBiY2M1NThkYzQzYWQ1M2U0MjFmIEF1dGhvcjogR3VvZG9uZyBMaXUgPGd1b2RvbmcubGl1PiBEYXRlOiBXZWQgTm92IDEwIDE1OjE5OjAwIDIwMjEgKzA4MDAgcGluY3RybDogbWVkaWF0ZWs6IGZpeCBnbG9iYWwtb3V0LW9mLWJvdW5kcyBpc3N1ZSBjb21taXQgMmQ1NDQ2ZGE1YWNlY2Y5YzY3ZGIxYzlkNTVhZTJjM2U1ZGUwMWY4ZCB1cHN0cmVhbS4gV2hlbiBlaW50IHZpcnR1YWwgZWludCBudW1iZXIgaXMgZ3JlYXRlciB0aGFuIGdwaW8gbnVtYmVyLCBpdCBtYXliZSBwcm9kdWNlICdkZXNjW2VpbnRfbl0nIHNpemUgZ2xvYmxlLW91dC1vZi1ib3VuZHMgaXNzdWUuIFNpZ25lZC1vZmYtYnk6IEd1b2RvbmcgTGl1IDxndW9kb25nLmxpdT4gU2lnbmVkLW9mZi1ieTogWmhpeW9uZyBUYW8gPHpoaXlvbmcudGFvPiBSZXZpZXdlZC1ieTogQ2hlbi1ZdSBUc2FpIDx3ZW5zdD4gTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8yMDIxMTExMDA3MTkwMC40NDkwLTItemhpeW9uZy50YW9AbWVkaWF0ZWsuY29tIFNpZ25lZC1vZmYtYnk6IExpbnVzIFdhbGxlaWogPGxpbnVzLndhbGxlaWo+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgYmYwNGFmYjYxMzdmYjc2YTlkODUxN2ZiMDczNzNmZmNkMGYzZjI4MyBBdXRob3I6IEFuZHJleSBSeWFiaW5pbiA8YXJibj4gRGF0ZTogRnJpIERlYyAyNCAyMToxMjozNSAyMDIxIC0wODAwIG1tOiBtZW1wb2xpY3k6IGZpeCBUSFAgYWxsb2NhdGlvbnMgZXNjYXBpbmcgbWVtcG9saWN5IHJlc3RyaWN0aW9ucyBjb21taXQgMzM4NjM1MzQwNjY5ZDViMzE3YzdlOGRjZjRmZmY0YTBmMzY1MWQ4NyB1cHN0cmVhbS4gYWxsb2NfcGFnZXNfdm1hKCkgbWF5IHRyeSB0byBhbGxvY2F0ZSBUSFAgcGFnZSBvbiB0aGUgbG9jYWwgTlVNQSBub2RlIGZpcnN0OiBwYWdlID0gX19hbGxvY19wYWdlc19ub2RlKGhwYWdlX25vZGUsIGdmcCB8IF9fR0ZQX1RISVNOT0RFIHwgX19HRlBfTk9SRVRSWSwgb3JkZXIpOyBBbmQgaWYgdGhlIGFsbG9jYXRpb24gZmFpbHMgaXQgcmV0cmllcyBhbGxvd2luZyByZW1vdGUgbWVtb3J5OiBpZiAoIXBhZ2UgKGdmcCBfX0dGUF9ESVJFQ1RfUkVDTEFJTSkpIHBhZ2UgPSBfX2FsbG9jX3BhZ2VzX25vZGUoaHBhZ2Vfbm9kZSwgZ2ZwLCBvcmRlcik7IEhvd2V2ZXIsIHRoaXMgcmV0cnkgYWxsb2NhdGlvbiBjb21wbGV0ZWx5IGlnbm9yZXMgbWVtb3J5IHBvbGljeSBub2RlbWFzayBhbGxvd2luZyBhbGxvY2F0aW9uIHRvIGVzY2FwZSByZXN0cmljdGlvbnMuIFRoZSBmaXJzdCBhcHBlYXJhbmNlIG9mIHRoaXMgYnVnIHNlZW1zIHRvIGJlIHRoZSBjb21taXQgYWM1YjJjMTg5MTFmICgibW06IHRocDogcmVsYXggX19HRlBfVEhJU05PREUgZm9yIE1BRFZfSFVHRVBBR0UgbWFwcGluZ3MiKS4gVGhlIGJ1ZyBkaXNhcHBlYXJlZCBsYXRlciBpbiB0aGUgY29tbWl0IDg5YzgzZmI1MzlmOSAoIm1tLCB0aHA6IGNvbnNvbGlkYXRlIFRIUCBnZnAgaGFuZGxpbmcgaW50byBhbGxvY19odWdlcGFnZV9kaXJlY3RfZ2ZwbWFzayIpIGFuZCByZWFwcGVhcmVkIGFnYWluIGluIHNsaWdodGx5IGRpZmZlcmVudCBmb3JtIGluIHRoZSBjb21taXQgNzZlNjU0Y2M5MWJiICgibW0sIHBhZ2VfYWxsb2M6IGFsbG93IGh1Z2VwYWdlIGZhbGxiYWNrIHRvIHJlbW90ZSBub2RlcyB3aGVuIG1hZHZpc2VkIikgRml4IHRoaXMgYnkgcGFzc2luZyBjb3JyZWN0IG5vZGVtYXNrIHRvIHRoZSBfX2FsbG9jX3BhZ2VzKCkgY2FsbC4gVGhlIGRlbW9uc3RyYXRpb24vcmVwcm9kdWNlciBvZiB0aGUgcHJvYmxlbTogJCBtb3VudCAtb3JlbW91bnQsc2l6ZT00RyxodWdlPWFsd2F5cyAvZGV2L3NobS8gJCBlY2hvIGFsd2F5cyAmZ3Q7IC9zeXMva2VybmVsL21tL3RyYW5zcGFyZW50X2h1Z2VwYWdlL2RlZnJhZyAkIGNhdCBtYmluZF90aHAuYyAjaW5jbHVkZSA8dW5pc3RkLmg+ICNpbmNsdWRlIDxzeXM+ICNpbmNsdWRlIDxzeXM+ICNpbmNsdWRlIDxmY250bC5oPiAjaW5jbHVkZSA8YXNzZXJ0Lmg+ICNpbmNsdWRlIDxzdGRsaWIuaD4gI2luY2x1ZGUgPHN0ZGlvLmg+ICNpbmNsdWRlIDxudW1haWYuaD4gI2RlZmluZSBTSVpFIDJVTEwgJmx0OyZsdDsgMzAgaW50IG1haW4oaW50IGFyZ2MsIGNoYXIgKiphcmd2KSB7IGludCBmZDsgdW5zaWduZWQgbG9uZyBsb25nIGk7IGNoYXIgKmFkZHI7IHBpZF90IHBpZDsgY2hhciBidWZbMTAwXTsgdW5zaWduZWQgbG9uZyBub2RlbWFzayA9IDE7IGZkID0gb3BlbigiL2Rldi9zaG0vdGVzdCIsIE9fUkRXUnxPX0NSRUFUKTsgYXNzZXJ0KGZkICZndDsgMCk7IGFzc2VydChmdHJ1bmNhdGUoZmQsIFNJWkUpID09IDApOyBhZGRyID0gbW1hcChOVUxMLCBTSVpFLCBQUk9UX1JFQUR8UFJPVF9XUklURSwgTUFQX1NIQVJFRCwgZmQsIDApOyBhc3NlcnQobWJpbmQoYWRkciwgU0laRSwgTVBPTF9CSU5ELCBub2RlbWFzaywgMiwgTVBPTF9NRl9TVFJJQ1R8TVBPTF9NRl9NT1ZFKT09MCk7IGZvciAoaSA9IDA7IGkgJmx0OyBTSVpFOyBpKz00MDk2KSB7IGFkZHJbaV0gPSAxOyB9IHBpZCA9IGdldHBpZCgpOyBzbnByaW50ZihidWYsIHNpemVvZihidWYpLCAiZ3JlcCBzaG0gL3Byb2MvJWQvbnVtYV9tYXBzIiwgcGlkKTsgc3lzdGVtKGJ1Zik7IHNsZWVwKDEwMDAwKTsgcmV0dXJuIDA7IH0gJCBnY2MgbWJpbmRfdGhwLmMgLW8gbWJpbmRfdGhwIC1sbnVtYSAkIG51bWFjdGwgLUggYXZhaWxhYmxlOiAyIG5vZGVzICgwLTEpIG5vZGUgMCBjcHVzOiAwIDIgbm9kZSAwIHNpemU6IDE5MTggTUIgbm9kZSAwIGZyZWU6IDE1OTUgTUIgbm9kZSAxIGNwdXM6IDEgMyBub2RlIDEgc2l6ZTogMjAxNCBNQiBub2RlIDEgZnJlZTogMTczMSBNQiBub2RlIGRpc3RhbmNlczogbm9kZSAwIDEgMDogMTAgMjAgMTogMjAgMTAgJCBybSAtZiAvZGV2L3NobS90ZXN0OyB0YXNrc2V0IC1jIDAgLi9tYmluZF90aHAgN2ZkOTcwYTAwMDAwIGJpbmQ6MCBmaWxlPS9kZXYvc2htL3Rlc3QgZGlydHk9NTI0Mjg4IGFjdGl2ZT0wIE4wPTM5NjgwMCBOMT0xMjc0ODgga2VybmVscGFnZXNpemVfa0I9NCBMaW5rOiBodHRwczovL2xrbWwua2VybmVsLm9yZy9yLzIwMjExMjA4MTY1MzQzLjIyMzQ5LTEtYXJibkB5YW5kZXgtdGVhbS5jb20gRml4ZXM6IGFjNWIyYzE4OTExZiAoIm1tOiB0aHA6IHJlbGF4IF9fR0ZQX1RISVNOT0RFIGZvciBNQURWX0hVR0VQQUdFIG1hcHBpbmdzIikgU2lnbmVkLW9mZi1ieTogQW5kcmV5IFJ5YWJpbmluIDxhcmJuPiBBY2tlZC1ieTogTWljaGFsIEhvY2tvIDxtaG9ja28+IEFja2VkLWJ5OiBNZWwgR29ybWFuIDxtZ29ybWFuPiBBY2tlZC1ieTogRGF2aWQgUmllbnRqZXMgPHJpZW50amVzPiBDYzogQW5kcmVhIEFyY2FuZ2VsaSA8YWFyY2FuZ2U+IENjOiA8c3RhYmxlPiBTaWduZWQtb2ZmLWJ5OiBBbmRyZXcgTW9ydG9uIDxha3BtPiBTaWduZWQtb2ZmLWJ5OiBMaW51cyBUb3J2YWxkcyA8dG9ydmFsZHM+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgZjVkYjZiYzkzNDk0OWY4NmZiYzgxZWVmM2ZlODgwMDQ2MWJkYTYyNCBBdXRob3I6IFNlYW4gQ2hyaXN0b3BoZXJzb24gPHNlYW5qYz4gRGF0ZTogVHVlIERlYyA3IDE5OjMwOjA1IDIwMjEgKzAwMDAgS1ZNOiBWTVg6IEZpeCBzdGFsZSBkb2NzIGZvciBrdm0taW50ZWwuZW11bGF0ZV9pbnZhbGlkX2d1ZXN0X3N0YXRlIGNvbW1pdCAwZmYyOTcwMWZmYWQ5YTVkNWEyNDM0NGQ4YjA5ZjNhZjdiOTZmZmRhIHVwc3RyZWFtLiBVcGRhdGUgdGhlIGRvY3VtZW50YXRpb24gZm9yIGt2bS1pbnRlbCdzIGVtdWxhdGVfaW52YWxpZF9ndWVzdF9zdGF0ZSB0byByZWN0aWZ5IHRoZSBkZXNjcmlwdGlvbiBvZiBLVk0ncyBkZWZhdWx0IGJlaGF2aW9yLCBhbmQgdG8gZG9jdW1lbnQgdGhhdCB0aGUgYmVoYXZpb3IgYW5kIHRodXMgcGFyYW1ldGVyIG9ubHkgYXBwbGllcyB0byBMMS4gRml4ZXM6IGEyNzY4NWMzM2FjYyAoIktWTTogVk1YOiBFbXVsYXRlIGludmFsaWQgZ3Vlc3Qgc3RhdGUgYnkgZGVmYXVsdCIpIFNpZ25lZC1vZmYtYnk6IFNlYW4gQ2hyaXN0b3BoZXJzb24gPHNlYW5qYz4gTWVzc2FnZS1JZDogJmx0OzIwMjExMjA3MTkzMDA2LjEyMDk5Ny00LXNlYW5qY0Bnb29nbGUuY29tJmd0OyBSZXZpZXdlZC1ieTogTWF4aW0gTGV2aXRza3kgPG1sZXZpdHNrPiBTaWduZWQtb2ZmLWJ5OiBQYW9sbyBCb256aW5pIDxwYm9uemluaT4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCAwNmMxM2UwMzlkOTI3NjY0NWMyMWFkOWE1ODBmOTdjYWIyYmFkNDY0IEF1dGhvcjogTWFyaWFuIFBvc3RldmNhIDxwb3N0ZXVjYT4gRGF0ZTogU2F0IERlYyA0IDIzOjQ5OjEyIDIwMjEgKzAyMDAgdXNiOiBnYWRnZXQ6IHVfZXRoZXI6IGZpeCByYWNlIGluIHNldHRpbmcgTUFDIGFkZHJlc3MgaW4gc2V0dXAgcGhhc2UgY29tbWl0IDg5MGQ1YjQwOTA4YmZkMWE3OWJlMDE4ZDJkMjk3Y2Y5ZGY2MGY0ZWUgdXBzdHJlYW0uIFdoZW4gbGlzdGVuaW5nIGZvciBub3RpZmljYXRpb25zIHRocm91Z2ggbmV0bGluayBvZiBhIG5ldyBpbnRlcmZhY2UgYmVpbmcgcmVnaXN0ZXJlZCwgc3BvcmFkaWNhbGx5LCBpdCBpcyBwb3NzaWJsZSBmb3IgdGhlIE1BQyB0byBiZSByZWFkIGFzIHplcm8uIFRoZSB6ZXJvIE1BQyBhZGRyZXNzIGxhc3RzIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgYW5kIHRoZW4gc3dpdGNoZXMgdG8gYSB2YWxpZCByYW5kb20gTUFDIGFkZHJlc3MuIFRoaXMgY2F1c2VzIHByb2JsZW1zIGZvciBuZXRkIGluIEFuZHJvaWQsIHdoaWNoIGFzc3VtZXMgdGhhdCB0aGUgaW50ZXJmYWNlIGlzIG1hbGZ1bmN0aW9uaW5nIGFuZCB3aWxsIG5vdCB1c2UgaXQuIEluIHRoZSBnb29kIGNhc2Ugd2UgZ2V0IHRoaXMgbG9nOiBJbnRlcmZhY2VDb250cm9sbGVyOjpnZXRDZmcoKSBpZk5hbWUgdXNiMCBod0FkZHIgOTI6YTg6ZjA6NzM6Nzk6NWIgaXB2NEFkZHIgMC4wLjAuMCBmbGFncyAweDEwMDIgSW4gdGhlIGVycm9yIGNhc2Ugd2UgZ2V0IHRoZXNlIGxvZ3M6IEludGVyZmFjZUNvbnRyb2xsZXI6OmdldENmZygpIGlmTmFtZSB1c2IwIGh3QWRkciAwMDowMDowMDowMDowMDowMCBpcHY0QWRkciAwLjAuMC4wIGZsYWdzIDB4MTAwMiBuZXRkIDogaW50ZXJmYWNlR2V0Q2ZnKCJ1c2IwIikgbmV0ZCA6IGludGVyZmFjZVNldENmZygpIC0mZ3Q7IFNlcnZpY2VTcGVjaWZpY0V4Y2VwdGlvbiAoOTksICJbQ2Fubm90IGFzc2lnbiByZXF1ZXN0ZWQgYWRkcmVzc10gOiBpb2N0bCgpIGZhaWxlZCIpIFRoZSByZWFzb24gZm9yIHRoZSBpc3N1ZSBpcyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlIGludGVyZmFjZSBpcyBzZXR1cCwgaXQgaXMgZmlyc3QgcmVnaXN0ZXJlZCB0aHJvdWdoIHJlZ2lzdGVyX25ldGRldigpIGFuZCBhZnRlciB0aGUgTUFDIGFkZHJlc3MgaXMgc2V0LiBGaXhlZCBieSBmaXJzdCBzZXR0aW5nIHRoZSBNQUMgYWRkcmVzcyBvZiB0aGUgbmV0X2RldmljZSBhbmQgYWZ0ZXIgdGhhdCBjYWxsaW5nIHJlZ2lzdGVyX25ldGRldigpLiBGaXhlczogYmNkNGExYzQwYmVlODg1ZSAoInVzYjogZ2FkZ2V0OiB1X2V0aGVyOiBjb25zdHJ1Y3Qgd2l0aCBkZWZhdWx0IHZhbHVlcyBhbmQgYWRkIHNldHRlcnMvZ2V0dGVycyIpIENjOiBzdGFibGVAdmdlci5rZXJuZWwub3JnIFNpZ25lZC1vZmYtYnk6IE1hcmlhbiBQb3N0ZXZjYSA8cG9zdGV1Y2E+IExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMjAyMTEyMDQyMTQ5MTIuMTc2MjctMS1wb3N0ZXVjYUBtdXRleC5vbmUgU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCBiMDQwNmI1ZWY0ZTJjNGZiMjFkOWU3ZDVjMzZhMDQ1M2I0Mjc5ZTliIEF1dGhvcjogQ2hhbyBZdSA8Y2hhbz4gRGF0ZTogU3VuIERlYyAxMiAxNzoxNjozMCAyMDIxICswODAwIGYyZnM6IGZpeCB0byBkbyBzYW5pdHkgY2hlY2sgb24gbGFzdCB4YXR0ciBlbnRyeSBpbiBfX2YyZnNfc2V0eGF0dHIoKSBjb21taXQgNTU5OGIyNGVmYWY0ODkyNzQxYzc5OGI0MjVkNTQzZTRiZWQzNTdhMSB1cHN0cmVhbS4gQXMgV2VucWluZyBMaXUgcmVwb3J0ZWQgaW4gYnVnemlsbGE6IGh0dHBzOi8vYnVnemlsbGEua2VybmVsLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjE1MjM1IC0gT3ZlcnZpZXcgcGFnZSBmYXVsdCBpbiBmMmZzX3NldHhhdHRyKCkgd2hlbiBtb3VudCBhbmQgb3BlcmF0ZSBvbiBjb3JydXB0ZWQgaW1hZ2UgLSBSZXByb2R1Y2UgdGVzdGVkIG9uIGtlcm5lbCA1LjE2LXJjMywgNS4xNS5YIHVuZGVyIHJvb3QgMS4gdW56aXAgdG1wNy56aXAgMi4gLi9zaW5nbGUuc2ggZjJmcyA3IFNvbWV0aW1lcyBuZWVkIHRvIHJ1biB0aGUgc2NyaXB0IHNldmVyYWwgdGltZXMgLSBLZXJuZWwgZHVtcCBsb29wMDogZGV0ZWN0ZWQgY2FwYWNpdHkgY2hhbmdlIGZyb20gMCB0byAxMzEwNzIgRjJGUy1mcyAobG9vcDApOiBGb3VuZCBuYXRfYml0cyBpbiBjaGVja3BvaW50IEYyRlMtZnMgKGxvb3AwKTogTW91bnRlZCB3aXRoIGNoZWNrcG9pbnQgdmVyc2lvbiA9IDc1NDhjMmVlIEJVRzogdW5hYmxlIHRvIGhhbmRsZSBwYWdlIGZhdWx0IGZvciBhZGRyZXNzOiBmZmZmZTQ3YmM3MTIzZjQ4IFJJUDogMDAxMDprZnJlZSsweDY2LzB4MzIwIENhbGwgVHJhY2U6IF9fZjJmc19zZXR4YXR0cisweDJhYS8weGMwMCBbZjJmc10gZjJmc19zZXR4YXR0cisweGZhLzB4NDgwIFtmMmZzXSBfX2YyZnNfc2V0X2FjbCsweDE5Yi8weDMzMCBbZjJmc10gX192ZnNfcmVtb3ZleGF0dHIrMHg1Mi8weDcwIF9fdmZzX3JlbW92ZXhhdHRyX2xvY2tlZCsweGIxLzB4MTQwIHZmc19yZW1vdmV4YXR0cisweDU2LzB4MTAwIHJlbW92ZXhhdHRyKzB4NTcvMHg4MCBwYXRoX3JlbW92ZXhhdHRyKzB4YTMvMHhjMCBfX3g2NF9zeXNfcmVtb3ZleGF0dHIrMHgxNy8weDIwIGRvX3N5c2NhbGxfNjQrMHgzNy8weGIwIGVudHJ5X1NZU0NBTExfNjRfYWZ0ZXJfaHdmcmFtZSsweDQ0LzB4YWUgVGhlIHJvb3QgY2F1c2UgaXMgaW4gX19mMmZzX3NldHhhdHRyKCksIHdlIG1pc3NlZCB0byBkbyBzYW5pdHkgY2hlY2sgb24gbGFzdCB4YXR0ciBlbnRyeSwgcmVzdWx0IGluIG91dC1vZi1ib3VuZCBtZW1vcnkgYWNjZXNzIGR1cmluZyB1cGRhdGluZyBpbmNvbnNpc3RlbnQgeGF0dHIgZGF0YSBvZiB0YXJnZXQgaW5vZGUuIEFmdGVyIHRoZSBmaXgsIGl0IGNhbiBkZXRlY3Qgc3VjaCB4YXR0ciBpbmNvbnNpc3RlbmN5IGFzIGJlbG93OiBGMkZTLWZzIChsb29wMTEpOiBpbm9kZSAoNykgaGFzIGludmFsaWQgbGFzdCB4YXR0ciBlbnRyeSwgZW50cnlfc2l6ZTogNjA2NzYgRjJGUy1mcyAobG9vcDExKTogaW5vZGUgKDgpIGhhcyBjb3JydXB0ZWQgeGF0dHIgRjJGUy1mcyAobG9vcDExKTogaW5vZGUgKDgpIGhhcyBjb3JydXB0ZWQgeGF0dHIgRjJGUy1mcyAobG9vcDExKTogaW5vZGUgKDgpIGhhcyBpbnZhbGlkIGxhc3QgeGF0dHIgZW50cnksIGVudHJ5X3NpemU6IDQ3NzM2IENjOiBzdGFibGVAdmdlci5rZXJuZWwub3JnIFJlcG9ydGVkLWJ5OiBXZW5xaW5nIExpdSA8d2VucWluZ2xpdTAxMjA+IFNpZ25lZC1vZmYtYnk6IENoYW8gWXUgPGNoYW8+IFNpZ25lZC1vZmYtYnk6IEphZWdldWsgS2ltIDxqYWVnZXVrPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDgwNjE0MmM4MDVjYWNkMDk4ZTYxYmRjMGY3MmM3NzhhMjM4OWZlNGEgQXV0aG9yOiBTdW1pdCBHYXJnIDxzdW1pdC5nYXJnPiBEYXRlOiBUaHUgRGVjIDE2IDExOjE3OjI1IDIwMjEgKzA1MzAgdGVlOiBvcHRlZTogRml4IGluY29ycmVjdCBwYWdlIGZyZWUgYnVnIGNvbW1pdCAxODU0OWJmNGIyMWM3MzlhOWRlZjM5ZjI3ZGNhYzUzZTI3Mjg2YWI1IHVwc3RyZWFtLiBQb2ludGVyIHRvIHRoZSBhbGxvY2F0ZWQgcGFnZXMgKHN0cnVjdCBwYWdlICpwYWdlKSBoYXMgYWxyZWFkeSBwcm9ncmVzc2VkIHRvd2FyZHMgdGhlIGVuZCBvZiBhbGxvY2F0aW9uLiBJdCBpcyBpbmNvcnJlY3QgdG8gcGVyZm9ybSBfX2ZyZWVfcGFnZXMocGFnZSwgb3JkZXIpIHVzaW5nIHRoaXMgcG9pbnRlciBhcyB3ZSB3b3VsZCBmcmVlIGFueSBhcmJpdHJhcnkgcGFnZXMuIEZpeCB0aGlzIGJ5IHN0b3AgbW9kaWZ5aW5nIHRoZSBwYWdlIHBvaW50ZXIuIEZpeGVzOiBlYzE4NWRkM2FiMjUgKCJvcHRlZTogRml4IG1lbW9yeSBsZWFrIHdoZW4gZmFpbGluZyB0byByZWdpc3RlciBzaG0gcGFnZXMiKSBDYzogc3RhYmxlQHZnZXIua2VybmVsLm9yZyBSZXBvcnRlZC1ieTogUGF0cmlrIExhbnR6IDxwYXRyaWsubGFudHo+IFNpZ25lZC1vZmYtYnk6IFN1bWl0IEdhcmcgPHN1bWl0Lmdhcmc+IFJldmlld2VkLWJ5OiBUeWxlciBIaWNrcyA8dHloaWNrcz4gU2lnbmVkLW9mZi1ieTogSmVucyBXaWtsYW5kZXIgPGplbnMud2lrbGFuZGVyPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDU0NzhiOTAyNzBhMzU2OWNmNmY1OTY5NTliMDkwMGM5ZjhlZjhmZTQgQXV0aG9yOiBBcmQgQmllc2hldXZlbCA8YXJkYj4gRGF0ZTogV2VkIERlYyAxNSAwOTozMTozNiAyMDIxICswMTAwIEFSTTogOTE2OS8xOiBlbnRyeTogZml4IFRodW1iMiBidWcgaW4gaVdNTVh0IGV4Y2VwdGlvbiBoYW5kbGluZyBjb21taXQgODUzNmE1ZWY4ODYwMDViYzQ0M2MyZGE5Yjg0MmQ2OWZkM2Q3NjQ3ZiB1cHN0cmVhbS4gVGhlIFRodW1iMiB2ZXJzaW9uIG9mIHRoZSBGUCBleGNlcHRpb24gaGFuZGxpbmcgZW50cnkgY29kZSB0cmVhdHMgdGhlIHJlZ2lzdGVyIGhvbGRpbmcgdGhlIENQIG51bWJlciAoUjgpIGRpZmZlcmVudGx5LCByZXN1bHRpbmcgaW4gdGhlIGlXTU1YVCBDUCBudW1iZXIgY2hlY2sgdG8gYmUgaW5jb3JyZWN0LiBGaXggdGhpcyBieSB1bmlmeWluZyB0aGUgQVJNIGFuZCBUaHVtYjIgY29kZSBwYXRocywgYW5kIHN3aXRjaCB0aGUgb3JkZXIgb2YgdGhlIGFkZGl0aW9ucyBvZiB0aGUgVElfVVNFRF9DUCBvZmZzZXQgYW5kIHRoZSBzaGlmdGVkIENQIGluZGV4LiBDYzogPHN0YWJsZT4gRml4ZXM6IGI4NjA0MGE1OWZlYiAoIlRodW1iLTI6IEltcGxlbWVudGF0aW9uIG9mIHRoZSB1bmlmaWVkIHN0YXJ0LXVwIGFuZCBleGNlcHRpb25zIGNvZGUiKSBTaWduZWQtb2ZmLWJ5OiBBcmQgQmllc2hldXZlbCA8YXJkYj4gU2lnbmVkLW9mZi1ieTogUnVzc2VsbCBLaW5nIChPcmFjbGUpIDxybWs+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgMWMzZDQxMjJiZWM2MzJmZmJkNmM0MGVmOTMyMWIxN2E1NWZmODEwZCBBdXRob3I6IFVsZiBIYW5zc29uIDx1bGYuaGFuc3Nvbj4gRGF0ZTogRnJpIERlYyAzIDE1OjE1OjU0IDIwMjEgKzAxMDAgbW1jOiBjb3JlOiBEaXNhYmxlIGNhcmQgZGV0ZWN0IGR1cmluZyBzaHV0ZG93biBjb21taXQgNjZjOTE1ZDA5Yjk0MmZiM2IyYjBjYjJmNTY1NjIxODA5MDFmYmExNyB1cHN0cmVhbS4gSXQncyBzZWVtcyBwcm9uZSB0byBwcm9ibGVtcyBieSBhbGxvd2luZyBjYXJkIGRldGVjdCBhbmQgaXRzIGNvcnJlc3BvbmRpbmcgbW1jX3Jlc2NhbigpIHdvcmsgdG8gcnVuLCBkdXJpbmcgcGxhdGZvcm0gc2h1dGRvd24uIEZvciBleGFtcGxlLCB3ZSBtYXkgZW5kIHVwIHR1cm5pbmcgb2ZmIHRoZSBwb3dlciB3aGlsZSBpbml0aWFsaXppbmcgYSBjYXJkLCB3aGljaCBwb3RlbnRpYWxseSBjb3VsZCBkYW1hZ2UgaXQuIFRvIGF2b2lkIHRoaXMgc2NlbmFyaW8sIGxldCdzIGFkZCAtJmd0O3NodXRkb3duX3ByZSgpIGNhbGxiYWNrIGZvciB0aGUgbW1jIGhvc3QgY2xhc3MgZGV2aWNlIGFuZCB0aGVuIHR1cm4gb2YgdGhlIGNhcmQgZGV0ZWN0IGZyb20gdGhlcmUuIFJlcG9ydGVkLWJ5OiBBbCBDb29wZXIgPGFsY29vcGVyeD4gU3VnZ2VzdGVkLWJ5OiBBZHJpYW4gSHVudGVyIDxhZHJpYW4uaHVudGVyPiBTaWduZWQtb2ZmLWJ5OiBVbGYgSGFuc3NvbiA8dWxmLmhhbnNzb24+IENjOiBzdGFibGVAdmdlci5rZXJuZWwub3JnIExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMjAyMTEyMDMxNDE1NTUuMTA1MzUxLTEtdWxmLmhhbnNzb25AbGluYXJvLm9yZyBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGU5ZGI4ZmM2YzdhZjZjYWMyNWQwYjJkNTFmMzA0MzkzODE3ZWZjZWYgQXV0aG9yOiBQcmF0aGFtZXNoIFNoZXRlIDxwc2hldGU+IERhdGU6IFR1ZSBEZWMgMTQgMTc6MDY6NTMgMjAyMSArMDUzMCBtbWM6IHNkaGNpLXRlZ3JhOiBGaXggc3dpdGNoIHRvIEhTNDAwRVMgbW9kZSBjb21taXQgNGZjNzI2MWRiYWIxMzlkM2M2NGMzYjYxODI2MjUwNGUxNmNmZTdlZSB1cHN0cmVhbS4gV2hlbiBDTUQxMyBpcyBzZW50IGFmdGVyIHN3aXRjaGluZyB0byBIUzQwMEVTIG1vZGUsIHRoZSBidXMgaXMgb3BlcmF0aW5nIGF0IGVpdGhlciBNTUNfSElHSF8yNl9NQVhfRFRSIG9yIE1NQ19ISUdIXzUyX01BWF9EVFIuIFRvIG1lZXQgVGVncmEgU0RIQ0kgcmVxdWlyZW1lbnQgYXQgSFM0MDBFUyBtb2RlLCBmb3JjZSBTREhDSSBpbnRlcmZhY2UgY2xvY2sgdG8gTU1DX0hTMjAwX01BWF9EVFIgKDIwMCBNSHopIHNvIHRoYXQgaG9zdCBjb250cm9sbGVyIENBUiBjbG9jayBhbmQgdGhlIGludGVyZmFjZSBjbG9jayBhcmUgcmF0ZSBtYXRjaGVkLiBTaWduZWQtb2ZmLWJ5OiBQcmF0aGFtZXNoIFNoZXRlIDxwc2hldGU+IEFja2VkLWJ5OiBBZHJpYW4gSHVudGVyIDxhZHJpYW4uaHVudGVyPiBGaXhlczogZGZjOTcwMGNlZjc3ICgibW1jOiB0ZWdyYTogSW1wbGVtZW50IEhTNDAwIGVuaGFuY2VkIHN0cm9iZSIpIENjOiBzdGFibGVAdmdlci5rZXJuZWwub3JnIExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMjAyMTEyMTQxMTM2NTMuNDYzMS0xLXBzaGV0ZUBudmlkaWEuY29tIFNpZ25lZC1vZmYtYnk6IFVsZiBIYW5zc29uIDx1bGYuaGFuc3Nvbj4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCBkOTAzMWNlMGIwNzE4OTlkMjgyYjk1NTM5Yzc0MDdkZGMwN2NmMzYyIEF1dGhvcjogRmFiaWVuIERlc3Nlbm5lIDxmYWJpZW4uZGVzc2VubmU+IERhdGU6IFdlZCBEZWMgMTUgMTA6NTg6MDggMjAyMSArMDEwMCBwaW5jdHJsOiBzdG0zMjogY29uc2lkZXIgdGhlIEdQSU8gb2Zmc2V0IHRvIGV4cG9zZSBhbGwgdGhlIEdQSU8gbGluZXMgY29tbWl0IGI2NzIxMGNjMjE3ZjljYTFjNTc2OTA5NDU0ZDg0Njk3MGMxM2RmZDQgdXBzdHJlYW0uIENvbnNpZGVyIHRoZSBHUElPIGNvbnRyb2xsZXIgb2Zmc2V0IChmcm9tICJncGlvLXJhbmdlcyIpIHRvIGNvbXB1dGUgdGhlIG1heGltdW0gR1BJTyBsaW5lIG51bWJlci4gVGhpcyBmaXhlcyBhbiBpc3N1ZSB3aGVyZSBncGlvLXJhbmdlcyB1c2VzIGEgbm9uLW51bGwgb2Zmc2V0LiBlLmcuOiBncGlvLXJhbmdlcyA9IEluIHRoYXQgY2FzZSB0aGUgbGFzdCB2YWxpZCBHUElPIGxpbmUgaXMgbm90IDkgYnV0IDE1ICg2ICsgMTAgLSAxKSBDYzogc3RhYmxlQHZnZXIua2VybmVsLm9yZyBGaXhlczogNjdlMjk5NmY3MmM3ICgicGluY3RybDogc3RtMzI6IGZpeCB0aGUgcmVwb3J0ZWQgbnVtYmVyIG9mIEdQSU8gbGluZXMgcGVyIGJhbmsiKSBSZXBvcnRlZC1ieTogQ2hyaXN0b3BoIEZyaXR6IDxjaGYuZnJpdHo+IFNpZ25lZC1vZmYtYnk6IEZhYmllbiBEZXNzZW5uZSA8ZmFiaWVuLmRlc3Nlbm5lPiBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMjE1MDk1ODA4LjYyMTcxNi0xLWZhYmllbi5kZXNzZW5uZUBmb3NzLnN0LmNvbSBTaWduZWQtb2ZmLWJ5OiBMaW51cyBXYWxsZWlqIDxsaW51cy53YWxsZWlqPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGM3YjJlNTg1MGJhNjViZGQ0M2FmYzE3ZTVhZGY4NjAzYzljNWNmYmQgQXV0aG9yOiBBbmRyZXcgQ29vcGVyIDxhbmRyZXcuY29vcGVyMz4gRGF0ZTogVGh1IERlYyAxNiAwMDowODo1NiAyMDIxICswMDAwIHg4Ni9wa2V5OiBGaXggdW5kZWZpbmVkIGJlaGF2aW91ciB3aXRoIFBLUlVfV0RfQklUIGNvbW1pdCA1NzY5MDU1NGFiZTEzNWZlZTgxZDZhYzMzY2M5NGQ3NWE3ZTIyNGJiIHVwc3RyZWFtLiBCb3RoIF9fcGtydV9hbGxvd3Nfd3JpdGUoKSBhbmQgYXJjaF9zZXRfdXNlcl9wa2V5X2FjY2VzcygpIHNoaWZ0IFBLUlVfV0RfQklUIChhIHNpZ25lZCBjb25zdGFudCkgYnkgdXAgdG8gMzAgYml0cywgaGl0dGluZyB0aGUgc2lnbiBiaXQuIFVzZSB1bnNpZ25lZCBjb25zdGFudHMgaW5zdGVhZC4gQ2xlYXJseSBwa2V5IDE1IGhhcyBub3QgYmVlbiB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggVUJTQU4geWV0LiBOb3RpY2VkIGJ5IGNvZGUgaW5zcGVjdGlvbiBvbmx5LiBJIGNhbid0IGFjdHVhbGx5IHByb3Zva2UgdGhlIGNvbXBpbGVyIGludG8gZ2VuZXJhdGluZyBpbmNvcnJlY3QgbG9naWMgYXMgZmFyIGFzIHRoaXMgc2hpZnQgaXMgY29uY2VybmVkLiBbIGRoYW5zZW46IGFkZCBzdGFibGVAIHRhZywgcGx1cyBtaW5vciBjaGFuZ2Vsb2cgbWFzc2FnaW5nLCBGb3IgYW55b25lIGRvaW5nIGJhY2twb3J0cywgdGhlc2UgI2RlZmluZXMgd2VyZSBpbiBhcmNoL3g4Ni9pbmNsdWRlL2FzbS9wZ3RhYmxlLmggYmVmb3JlIDc4NGE0NjYxOGY2LiBdIEZpeGVzOiAzM2E3MDliMjVhNzYgKCJtbS9ndXAsIHg4Ni9tbS9wa2V5czogQ2hlY2sgVk1BcyBhbmQgUFRFcyBmb3IgcHJvdGVjdGlvbiBrZXlzIikgU2lnbmVkLW9mZi1ieTogQW5kcmV3IENvb3BlciA8YW5kcmV3LmNvb3BlcjM+IFNpZ25lZC1vZmYtYnk6IERhdmUgSGFuc2VuIDxkYXZlLmhhbnNlbj4gU2lnbmVkLW9mZi1ieTogQm9yaXNsYXYgUGV0a292IDxicD4gQ2M6IHN0YWJsZUB2Z2VyLmtlcm5lbC5vcmcgTGluazogaHR0cHM6Ly9sa21sLmtlcm5lbC5vcmcvci8yMDIxMTIxNjAwMDg1Ni40NDgwLTEtYW5kcmV3LmNvb3BlcjNAY2l0cml4LmNvbSBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGRkYzFkNDllMTBhN2NhMDNjN2Q4M2FhN2FmYzEyNjdmOGI0ODRlYzIgQXV0aG9yOiBKb2huIERhdmlkIEFuZ2xpbiA8ZGF2ZS5hbmdsaW4+IERhdGU6IFR1ZSBEZWMgMjEgMTM6MjE6MjIgMjAyMSAtMDUwMCBwYXJpc2M6IENvcnJlY3QgY29tcGxldGVyIGluIGx3cyBzdGFydCBjb21taXQgOGY2NmZjZTBmNDY1NjBiOWU5MTA3ODdmZjdhZDA5NzQ0NDFjNGY5YyB1cHN0cmVhbS4gVGhlIGNvbXBsZXRlciBpbiB0aGUgIm9yLGV2ICVyMSwlcjMwLCVyMzAiIGluc3RydWN0aW9uIGlzIHJldmVyc2VkLCBzbyB3ZSBhcmUgbm90IGNsaXBwaW5nIHRoZSBMV1MgbnVtYmVyIHdoZW4gd2UgYXJlIGNhbGxlZCBmcm9tIGEgMzItYml0IHByb2Nlc3MgKFc9MCkuIFdlIG5lZWQgdG8gbnVsaWZ5IHRoZSBmb2xsb3dpbmcgZGVwZGkgaW5zdHJ1Y3Rpb24gd2hlbiB0aGUgbGVhc3Qtc2lnbmlmaWNhbnQgYml0IG9mICVyMzAgaXMgMS4gSWYgdGhlICVyMjAgcmVnaXN0ZXIgaXMgbm90IGNsaXBwZWQsIGEgdXNlciBwcm9jZXNzIGNvdWxkIHBlcmZvcm0gYSBMV1MgY2FsbCB0aGF0IHdvdWxkIGJyYW5jaCB0byBhbiB1bmRlZmluZWQgbG9jYXRpb24gaW4gdGhlIGtlcm5lbCBhbmQgcG90ZW50aWFsbHkgY3Jhc2ggdGhlIG1hY2hpbmUuIFNpZ25lZC1vZmYtYnk6IEpvaG4gRGF2aWQgQW5nbGluIDxkYXZlLmFuZ2xpbj4gQ2M6IHN0YWJsZUB2Z2VyLmtlcm5lbC5vcmcgIyA0LjE5KyBTaWduZWQtb2ZmLWJ5OiBIZWxnZSBEZWxsZXIgU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCA4NDY3YzhjYjk0YTQwNmNjMGM1NGQ5MzA2YjYxZDBkYjg2Yzk0MDQ4IEF1dGhvcjogVGhhZGV1IExpbWEgZGUgU291emEgQ2FzY2FyZG8gPGNhc2NhcmRvPiBEYXRlOiBGcmkgRGVjIDE3IDEyOjQ0OjEwIDIwMjEgLTAzMDAgaXBtaTogZml4IGluaXRpYWxpemF0aW9uIHdoZW4gd29ya3F1ZXVlIGFsbG9jYXRpb24gZmFpbHMgY29tbWl0IDc1ZDcwZDc2Y2I3YjkyN2NhY2UyY2IzNDI2NWQ2OGViYjMzMDZiMTMgdXBzdHJlYW0uIElmIHRoZSB3b3JrcXVldWUgYWxsb2NhdGlvbiBmYWlscywgdGhlIGRyaXZlciBpcyBtYXJrZWQgYXMgbm90IGluaXRpYWxpemVkLCBhbmQgdGltZXIgYW5kIHBhbmljX25vdGlmaWVyIHdpbGwgYmUgbGVmdCByZWdpc3RlcmVkLiBJbnN0ZWFkIG9mIHJlbW92aW5nIHRob3NlIHdoZW4gd29ya3F1ZXVlIGFsbG9jYXRpb24gZmFpbHMsIGRvIHRoZSB3b3JrcXVldWUgaW5pdGlhbGl6YXRpb24gYmVmb3JlIGRvaW5nIGl0LCBhbmQgY2xlYW51cCBzcmN1X3N0cnVjdCBpZiBpdCBmYWlscy4gRml4ZXM6IDFkNDllYjkxZTg2ZSAoImlwbWk6IE1vdmUgcmVtb3ZlX3dvcmsgdG8gZGVkaWNhdGVkIHdvcmtxdWV1ZSIpIFNpZ25lZC1vZmYtYnk6IFRoYWRldSBMaW1hIGRlIFNvdXphIENhc2NhcmRvIDxjYXNjYXJkbz4gQ2M6IENvcmV5IE1pbnlhcmQgPGNtaW55YXJkPiBDYzogSW9hbm5hIEFsaWZpZXJha2kgPGlvYW5uYS1tYXJpYS5hbGlmaWVyYWtpPiBDYzogc3RhYmxlQHZnZXIua2VybmVsLm9yZyBNZXNzYWdlLUlkOiAmbHQ7MjAyMTEyMTcxNTQ0MTAuMTIyODY3My0yLWNhc2NhcmRvQGNhbm9uaWNhbC5jb20mZ3Q7IFNpZ25lZC1vZmYtYnk6IENvcmV5IE1pbnlhcmQgPGNtaW55YXJkPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDhlZmQ2YTMzOTFmN2IwYjE5ZmIwYzM4ZTUwYWRkMDZjYTMwYzk0YWYgQXV0aG9yOiBNaWFuIFlvdXNhZiBLYXVrYWIgPHlrYXVrYWI+IERhdGU6IFdlZCBEZWMgOCAxMDozMjozOSAyMDIxICswMTAwIGlwbWk6IHNzaWY6IGluaXRpYWxpemUgc3NpZl9pbmZvLSZndDtjbGllbnQgZWFybHkgY29tbWl0IDM0ZjM1ZjhmMTRiYzQwNmVmYzA2ZWU0ZmY3MzIwMmM2ZmQyNDVkMTUgdXBzdHJlYW0uIER1cmluZyBwcm9iZSBzc2lmX2luZm8tJmd0O2NsaWVudCBpcyBkZXJlZmVyZW5jZWQgaW4gZXJyb3IgcGF0aC4gSG93ZXZlciwgaXQgaXMgc2V0IHdoZW4gc29tZSBvZiB0aGUgZXJyb3IgY2hlY2tpbmcgaGFzIGFscmVhZHkgYmVlbiBkb25lLiBUaGlzIGNhdXNlcyBmb2xsb3dpbmcga2VybmVsIGNyYXNoIGlmIGFuIGVycm9yIHBhdGggaXMgdGFrZW46IFsgMzAuNjQ1NTkzXVsgVDY3NF0gaXBtaV9zc2lmIDAtMDAwZTogaXBtaV9zc2lmOiBOb3QgcHJvYmluZywgSW50ZXJmYWNlIGFscmVhZHkgcHJlc2VudCBbIDMwLjY1NzYxNl1bIFQ2NzRdIFVuYWJsZSB0byBoYW5kbGUga2VybmVsIE5VTEwgcG9pbnRlciBkZXJlZmVyZW5jZSBhdCB2aXJ0dWFsIGFkZHJlc3MgMDAwMDAwMDAwMDAwMDA4OCAuLi4gWyAzMC42NTc3MjNdWyBUNjc0XSBwYyA6IF9fZGV2X3ByaW50aysweDI4LzB4YTAgWyAzMC42NTc3MzJdWyBUNjc0XSBsciA6IF9kZXZfZXJyKzB4N2MvMHhhMCAuLi4gWyAzMC42NTc3NzJdWyBUNjc0XSBDYWxsIHRyYWNlOiBbIDMwLjY1Nzc3NV1bIFQ2NzRdIF9fZGV2X3ByaW50aysweDI4LzB4YTAgWyAzMC42NTc3NzhdWyBUNjc0XSBfZGV2X2VycisweDdjLzB4YTAgWyAzMC42NTc3ODFdWyBUNjc0XSBzc2lmX3Byb2JlKzB4NTQ4LzB4OTAwIFtpcG1pX3NzaWYgNjJjZTRiMDhiYWRjMTQ1OGZkODk2MjA2ZDllZjY5YTNjMzFmM2QzZV0gWyAzMC42NTc3OTFdWyBUNjc0XSBpMmNfZGV2aWNlX3Byb2JlKzB4MzdjLzB4M2MwIC4uLiBJbml0aWFsaXplIHNzaWZfaW5mby0mZ3Q7Y2xpZW50IGJlZm9yZSBhbnkgZXJyb3IgcGF0aCBjYW4gYmUgdGFrZW4uIENsZWFyIGkyY19jbGllbnQgZGF0YSBpbiB0aGUgZXJyb3IgcGF0aCB0byBwcmV2ZW50IHRoZSBkYW5nbGluZyBwb2ludGVyIGZyb20gbGVha2luZy4gRml4ZXM6IGM0NDM2YzkxNDljNSAoImlwbWlfc3NpZjogYXZvaWQgcmVnaXN0ZXJpbmcgZHVwbGljYXRlIHNzaWYgaW50ZXJmYWNlIikgQ2M6IHN0YWJsZUB2Z2VyLmtlcm5lbC5vcmcgIyA1LjQueCBTdWdnZXN0ZWQtYnk6IFRha2FzaGkgSXdhaSA8dGl3YWk+IFNpZ25lZC1vZmYtYnk6IE1pYW4gWW91c2FmIEthdWthYiA8eWthdWthYj4gTWVzc2FnZS1JZDogJmx0OzIwMjExMjA4MDkzMjM5LjQ0MzItMS15a2F1a2FiQHN1c2UuZGUmZ3Q7IFNpZ25lZC1vZmYtYnk6IENvcmV5IE1pbnlhcmQgPGNtaW55YXJkPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGNkMjRiYWZlZmMxNzk0NzUzMjAwOGMzNjY3NjM3YWVlNzQ3MWQ3YTggQXV0aG9yOiBUaGFkZXUgTGltYSBkZSBTb3V6YSBDYXNjYXJkbyA8Y2FzY2FyZG8+IERhdGU6IEZyaSBEZWMgMTcgMTI6NDQ6MDkgMjAyMSAtMDMwMCBpcG1pOiBiYWlsIG91dCBpZiBpbml0X3NyY3Vfc3RydWN0IGZhaWxzIGNvbW1pdCAyYjUxNjBiMTIwOTEyODVjNWFjYTQ1OTgwZjEwMGE5Mjk0YWY3YjA0IHVwc3RyZWFtLiBJbiBjYXNlLCBpbml0X3NyY3Vfc3RydWN0IGZhaWxzIChiZWNhdXNlIG9mIG1lbW9yeSBhbGxvY2F0aW9uIGZhaWx1cmUpLCB3ZSBtaWdodCBwcm9jZWVkIHdpdGggdGhlIGRyaXZlciBpbml0aWFsaXphdGlvbiBkZXNwaXRlIHNyY3Vfc3RydWN0IG5vdCBiZWluZyBlbnRpcmVseSBpbml0aWFsaXplZC4gRml4ZXM6IDkxM2E4OWYwMDlkOSAoImlwbWk6IERvbid0IGluaXRpYWxpemUgYW55dGhpbmcgaW4gdGhlIGNvcmUgdW50aWwgc29tZXRoaW5nIHVzZXMgaXQiKSBTaWduZWQtb2ZmLWJ5OiBUaGFkZXUgTGltYSBkZSBTb3V6YSBDYXNjYXJkbyA8Y2FzY2FyZG8+IENjOiBDb3JleSBNaW55YXJkIDxjbWlueWFyZD4gQ2M6IHN0YWJsZUB2Z2VyLmtlcm5lbC5vcmcgTWVzc2FnZS1JZDogJmx0OzIwMjExMjE3MTU0NDEwLjEyMjg2NzMtMS1jYXNjYXJkb0BjYW5vbmljYWwuY29tJmd0OyBTaWduZWQtb2ZmLWJ5OiBDb3JleSBNaW55YXJkIDxjbWlueWFyZD4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCA1NTI1ZDgwZGM5ZGQ0NmFkNWQyMTUwZGEyNjQxNjUyMjZiOWMwZmRhIEF1dGhvcjogSm9zw6kgRXhww7NzaXRvIDxqb3NlLmV4cG9zaXRvODk+IERhdGU6IFN1biBEZWMgMTIgMjE6MDE6NDkgMjAyMSAtMDgwMCBJbnB1dDogYXRtZWxfbXh0X3RzIC0gZml4IGRvdWJsZSBmcmVlIGluIG14dF9yZWFkX2luZm9fYmxvY2sgY29tbWl0IDEyZjI0N2FiNTkwYTA4ODU2NDQxZWZkYmQzNTFjZjJjYzhmNjBhMmQgdXBzdHJlYW0uIFRoZSAiaWRfYnVmIiBidWZmZXIgaXMgc3RvcmVkIGluICJkYXRhLSZndDtyYXdfaW5mb19ibG9jayIgYW5kIGZyZWVkIGJ5ICJteHRfZnJlZV9vYmplY3RfdGFibGUiIGluIGNhc2Ugb2YgZXJyb3IuIFJldHVybiBpbnN0ZWFkIG9mIGp1bXBpbmcgdG8gYXZvaWQgYSBkb3VibGUgZnJlZS4gQWRkcmVzc2VzLUNvdmVyaXR5LUlEOiAxNDc0NTgyICgiRG91YmxlIGZyZWUiKSBGaXhlczogMDY4YmRiNjdlZjc0ICgiSW5wdXQ6IGF0bWVsX214dF90cyAtIGZpeCB0aGUgZmlybXdhcmUgdXBkYXRlIikgU2lnbmVkLW9mZi1ieTogSm9zw6kgRXhww7NzaXRvIDxqb3NlLmV4cG9zaXRvODk+IExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMjAyMTEyMTIxOTQyNTcuNjg4NzktMS1qb3NlLmV4cG9zaXRvODlAZ21haWwuY29tIENjOiBzdGFibGVAdmdlci5rZXJuZWwub3JnIFNpZ25lZC1vZmYtYnk6IERtaXRyeSBUb3Jva2hvdiA8ZG1pdHJ5LnRvcm9raG92PiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDczN2E5OGQ5MWIwNzRlYjBjOWMxN2VkMTZmMDQ0NjlmODQwYzRjMjcgQXV0aG9yOiBCcmFkbGV5IFNjb3R0IERhdGU6IE1vbiBEZWMgMTMgMTA6NDk6MzkgMjAyMSAtMDUwMCBBTFNBOiBoZGEvcmVhbHRlazogQW1wIGluaXQgZml4dXAgZm9yIEhQIFpCb29rIDE1IEc2IGNvbW1pdCBkMjk2YTc0YjdiNTlmZjkxMTYyMzZjMTdlZGIyNWYyNjkzNWRiZjcwIHVwc3RyZWFtLiBIUCBaQm9vayAxNSBHNiAoU1NJRCAxMDNjOjg2MGYpIG5lZWRzIHRoZSBzYW1lIHNwZWFrZXIgYW1wbGlmaWVyIGluaXRpYWxpemF0aW9uIGFzIHVzZWQgb24gc2V2ZXJhbCBvdGhlciBIUCBsYXB0b3BzIHVzaW5nIEFMQzI4NS4gU2lnbmVkLW9mZi1ieTogQnJhZGxleSBTY290dCBDYzogPHN0YWJsZT4gTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8yMDIxMTIxMzE1NDkzOC41MDMyMDEtMS1CcmFkbGV5LlNjb3R0QHplYnJhLmNvbSBTaWduZWQtb2ZmLWJ5OiBUYWthc2hpIEl3YWkgPHRpd2FpPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDhkZjAzNmJlZmJjM2M2ZWViZDMwODdkMmZmODIwNWM4M2I0OGM4ODEgQXV0aG9yOiBDb2xpbiBJYW4gS2luZyA8Y29saW4ua2luZz4gRGF0ZTogU3VuIERlYyAxMiAxNzoyMDoyNSAyMDIxICswMDAwIEFMU0E6IGRyaXZlcnM6IG9wbDM6IEZpeCBpbmNvcnJlY3QgdXNlIG9mIHZwLSZndDtzdGF0ZSBjb21taXQgMmRlZTU0YjI4OWZiYzgxMDY2OWExYjJiOGEwODg3ZmExYzlhMTRkNyB1cHN0cmVhbS4gU3RhdGljIGFuYWx5c2lzIHdpdGggc2Nhbi1idWlsZCBoYXMgZm91bmQgYW4gYXNzaWdubWVudCB0byB2cDIgdGhhdCBpcyBuZXZlciB1c2VkLiBJdCBzZWVtcyB0aGF0IHRoZSBjaGVjayBvbiB2cC0mZ3Q7c3RhdGUgJmd0OyAwIHNob3VsZCBiZSBhY3R1YWxseSBvbiB2cDItJmd0O3N0YXRlIGluc3RlYWQuIEZpeCB0aGlzLiBUaGlzIGRhdGVzIGJhY2sgdG8gMjAwMiwgSSBmb3VuZCB0aGUgb2ZmZW5kaW5nIGNvbW1pdCBmcm9tIHRoZSBnaXQgaGlzdG9yeSBnaXQ6Ly9naXQua2VybmVsLm9yZy9wdWIvc2NtL2xpbnV4L2tlcm5lbC9naXQvdGdseC9oaXN0b3J5LmdpdCwgY29tbWl0IDkxZTM5NTIxYmJmNiAoIltQQVRDSF0gQUxTQSBwYXRjaCBmb3IgMi41LjQiKSBTaWduZWQtb2ZmLWJ5OiBDb2xpbiBJYW4gS2luZyA8Y29saW4uaS5raW5nPiBDYzogPHN0YWJsZT4gTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8yMDIxMTIxMjE3MjAyNS40NzAzNjctMS1jb2xpbi5pLmtpbmdAZ21haWwuY29tIFNpZ25lZC1vZmYtYnk6IFRha2FzaGkgSXdhaSA8dGl3YWk+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgZmRhZjQxOTc3ZDc3NDdjYTkxNGU5MWM4NTY2NWRmMDA5YjQ1NmEwOCBBdXRob3I6IFhpYW9rZSBXYW5nIDx4a2VybmVsLndhbmc+IERhdGU6IE1vbiBEZWMgMTMgMTU6Mzk6MzEgMjAyMSArMDgwMCBBTFNBOiBqYWNrOiBDaGVjayB0aGUgcmV0dXJuIHZhbHVlIG9mIGtzdHJkdXAoKSBjb21taXQgYzAxYzFkYjFkYzYzMmVkYWZiMGRmZjMyZDQwZGFmNGY5YzFhNGUxOSB1cHN0cmVhbS4ga3N0cmR1cCgpIGNhbiByZXR1cm4gTlVMTCwgaXQgaXMgYmV0dGVyIHRvIGNoZWNrIHRoZSByZXR1cm4gdmFsdWUgb2YgaXQuIFNpZ25lZC1vZmYtYnk6IFhpYW9rZSBXYW5nIDx4a2VybmVsLndhbmc+IENjOiA8c3RhYmxlPiBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yL3RlbmNlbnRfMDk0ODE2RjM1MjJFMERDNzA0MDU2Qzc4OTM1MkVCQkYwNjA2QHFxLmNvbSBTaWduZWQtb2ZmLWJ5OiBUYWthc2hpIEl3YWkgPHRpd2FpPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDQ0Yzc0M2Y2M2RkM2U5MmYxYmZiMmI0M2MwMzc0NDA2YmM2MDIxM2YgQXV0aG9yOiBHdWVudGVyIFJvZWNrIDxsaW51eD4gRGF0ZTogU2F0IE5vdiAxMyAwODo1NTowNiAyMDIxIC0wODAwIGh3bW9uOiAobG05MCkgRHJvcCBjcml0aWNhbCBhdHRyaWJ1dGUgc3VwcG9ydCBmb3IgTUFYNjY1NCBbIFVwc3RyZWFtIGNvbW1pdCAxNmJhNTFiNWRjZDNmNmRkZTJlNTFkNWNjYzg2MzEzMTE5ZGNmODg5IF0gVGVzdHMgd2l0aCBhIHJlYWwgY2hpcCBhbmQgYSBjbG9zZXIgbG9vayBpbnRvIHRoZSBkYXRhc2hlZXQgc2hvdyB0aGF0IE1BWDY2NTQgZG9lcyBub3Qgc3VwcG9ydCBDUklUL1RIRVJNL09WRVJURU1QIGxpbWl0cywgc28gZHJvcCBzdXBwb3J0IG9mIHRoZSByZXNwZWN0aXZlIGF0dHJpYnV0ZXMgZm9yIHRoaXMgY2hpcC4gSW50cm9kdWNlIExNOTBfSEFWRV9DUklUIGZsYWcgYW5kIHVzZSBpdCB0byBpbnN0YW50aWF0ZSBjcml0aWNhbCBsaW1pdCBhdHRyaWJ1dGVzIHRvIHNvbHZlIHRoZSBwcm9ibGVtLiBDYzogSm9zaCBMZWhhbiA8a3JlbGxhbj4gRml4ZXM6IDIyOWQ0OTVkODE4OSAoImh3bW9uOiAobG05MCkgQWRkIG1heDY2NTQgc3VwcG9ydCB0byBsbTkwIGRyaXZlciIpIFNpZ25lZC1vZmYtYnk6IEd1ZW50ZXIgUm9lY2sgPGxpbnV4PiBTaWduZWQtb2ZmLWJ5OiBTYXNoYSBMZXZpbiA8c2FzaGFsPiBjb21taXQgNDYxNWM5NzQwNTc1ZTVhNzcyMzMyYmIwMzE2NTIwZGZjZTViZWJjMyBBdXRob3I6IEd1ZW50ZXIgUm9lY2sgPGxpbnV4PiBEYXRlOiBUaHUgT2N0IDIxIDAxOjQ5OjUwIDIwMjEgLTA3MDAgaHdtb246IChsbTkwKSBJbnRyb2R1Y2UgZmxhZyBpbmRpY2F0aW5nIGV4dGVuZGVkIHRlbXBlcmF0dXJlIHN1cHBvcnQgWyBVcHN0cmVhbSBjb21taXQgZjM0N2UyNDlmY2Y5MjBhZDY5NzRjYmQ4OThlMmVjMGIzNjZhMWMzNCBdIEEgZmxhZyBpbmRpY2F0aW5nIGV4dGVuZGVkIHRlbXBlcmF0dXJlIHN1cHBvcnQgbWFrZXMgaXQgZWFzaWVyIHRvIGFkZCBzdXBwb3J0IGZvciBhZGRpdGlvbmFsIGNoaXBzIHdpdGggdGhpcyBmdW5jdGlvbmFsaXR5LiBDYzogRGF2aWQgVC4gV2lsc29uIDxkYXZpZC53aWxzb24+IFNpZ25lZC1vZmYtYnk6IEd1ZW50ZXIgUm9lY2sgPGxpbnV4PiBTaWduZWQtb2ZmLWJ5OiBTYXNoYSBMZXZpbiA8c2FzaGFsPiBjb21taXQgYzIyNDI0NzhmMjhkZDg0NTg1YWU5YzZmOTNiMzRkN2JkYWVmODBhMyBBdXRob3I6IEd1ZW50ZXIgUm9lY2sgPGxpbnV4PiBEYXRlOiBNb24gT2N0IDE4IDIwOjAzOjMyIDIwMjEgLTA3MDAgaHdtb246IChsbTkwKSBBZGQgYmFzaWMgc3VwcG9ydCBmb3IgVEkgVE1QNDYxIFsgVXBzdHJlYW0gY29tbWl0IGY4MzQ0Zjc2OTNhMjVkOTAyNWE1OWQxNjQ0NTBiNTBjNmY1YWEzYzAgXSBUTVA0NjEgaXMgYWxtb3N0IGlkZW50aWNhbCB0byBUTVA0NTEgYW5kIHdhcyBhY3R1YWxseSBkZXRlY3RlZCBhcyBUTVA0NTEgd2l0aCB0aGUgZXhpc3RpbmcgbG05MCBkcml2ZXIgaWYgaXRzIEkyQyBhZGRyZXNzIGlzIDB4NGMuIEFkZCBzdXBwb3J0IGZvciBpdCB0byB0aGUgbG05MCBkcml2ZXIuIEF0IHRoZSBzYW1lIHRpbWUsIGltcHJvdmUgdGhlIGNoaXAgZGV0ZWN0aW9uIGZ1bmN0aW9uIHRvIGF0IGxlYXN0IHRyeSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIFRNUDQ1MSBhbmQgVE1QNDYxLiBBcyBhIHNpZGUgZWZmZWN0LCB0aGlzIGZpeGVzIGNvbW1pdCAyNDMzM2FjMjZkMDEgKCJod21vbjogKHRtcDQwMSkgdXNlIHNtYiB3b3JkIG9wZXJhdGlvbnMgaW5zdGVhZCBvZiAyIHNtYiBieXRlIG9wZXJhdGlvbnMiKS4gVE1QNDYxIGRvZXMgbm90IHN1cHBvcnQgd29yZCBvcGVyYXRpb25zIG9uIHRlbXBlcmF0dXJlIHJlZ2lzdGVycywgd2hpY2ggY2F1c2VzIGJhZCB0ZW1wZXJhdHVyZSByZWFkaW5ncyB3aXRoIHRoZSB0bXA0MDEgZHJpdmVyLiBUaGUgbG05MCBkcml2ZXIgZG9lcyBub3QgcGVyZm9ybSB3b3JkIG9wZXJhdGlvbnMgb24gdGVtcGVyYXR1cmUgcmVnaXN0ZXJzIGFuZCB0aHVzIGRvZXMgbm90IGhhdmUgdGhpcyBwcm9ibGVtLiBTdXBwb3J0IGlzIGxpc3RlZCBhcyBiYXNpYyBiZWNhdXNlIFRNUDQ2MSBzdXBwb3J0cyBhIHNlbnNvciByZXNvbHV0aW9uIG9mIDAuMDYyNSBkZWdyZWVzIEMsIHdoaWxlIHRoZSBsbTkwIGRyaXZlciBhc3N1bWVzIGEgcmVzb2x1dGlvbiBvZiAwLjEyNSBkZWdyZWVzIEMuIEFsc28sIHRoZSBUTVA0NjEgc3VwcG9ydHMgbmVnYXRpdmUgdGVtcGVyYXR1cmVzIHdpdGggaXRzIGRlZmF1bHQgdGVtcGVyYXR1cmUgcmFuZ2UsIHdoaWNoIGlzIG5vdCB0aGUgY2FzZSBmb3Igc2ltaWxhciBjaGlwcyBzdXBwb3J0ZWQgYnkgdGhlIGxtOTAgYW5kIHRoZSB0bXA0MDEgZHJpdmVycy4gVGhvc2UgbGltaXRhdGlvbnMgd2lsbCBiZSBhZGRyZXNzZWQgd2l0aCBmb2xsb3ctdXAgcGF0Y2hlcy4gRml4ZXM6IDI0MzMzYWMyNmQwMSAoImh3bW9uOiAodG1wNDAxKSB1c2Ugc21iIHdvcmQgb3BlcmF0aW9ucyBpbnN0ZWFkIG9mIDIgc21iIGJ5dGUgb3BlcmF0aW9ucyIpIFJlcG9ydGVkLWJ5OiBEYXZpZCBULiBXaWxzb24gPGRhdmlkLndpbHNvbj4gQ2M6IERhdmlkIFQuIFdpbHNvbiA8ZGF2aWQud2lsc29uPiBTaWduZWQtb2ZmLWJ5OiBHdWVudGVyIFJvZWNrIDxsaW51eD4gU2lnbmVkLW9mZi1ieTogU2FzaGEgTGV2aW4gPHNhc2hhbD4gY29tbWl0IGQ5Mzk2NjBlZmY2MjU0NjcxZmJjOTE0ZTYxMzJiOWE1YzZjMzMzYzQgQXV0aG9yOiBKb3NoIExlaGFuIDxrcmVsbGFuPiBEYXRlOiBXZWQgTWF5IDEzIDExOjQyOjQ4IDIwMjAgLTA3MDAgaHdtb246IChsbTkwKSBBZGQgbWF4NjY1NCBzdXBwb3J0IHRvIGxtOTAgZHJpdmVyIFsgVXBzdHJlYW0gY29tbWl0IDIyOWQ0OTVkODE4OWFlNzg1ZGFjZWU3MmU1NjMzYTU4ZWRjMjVkZGYgXSBBZGQgc3VwcG9ydCBmb3IgdGhlIE1heGltIE1BWDY2NTQgdG8gdGhlIGxtOTAgZHJpdmVyLiBUaGUgTUFYNjY1NCBpcyBhIHRlbXBlcmF0dXJlIHNlbnNvciwgc2ltaWxhciB0byB0aGUgb3RoZXJzLCBidXQgd2l0aCBzb21lIGRpZmZlcmVuY2VzIHJlZ2FyZGluZyB0aGUgY29uZmlndXJhdGlvbiByZWdpc3RlciwgYW5kIHRoZSBzYW1wbGluZyByYXRlIGF0IHdoaWNoIGV4dGVuZGVkIHJlc29sdXRpb24gYmVjb21lcyBwb3NzaWJsZS4gU2lnbmVkLW9mZi1ieTogSm9zaCBMZWhhbiA8a3JlbGxhbj4gTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8yMDIwMDUxMzE4NDI0OC4xNDU3NjUtMS1rcmVsbGFuQGdvb2dsZS5jb20gU2lnbmVkLW9mZi1ieTogR3VlbnRlciBSb2VjayA8bGludXg+IFNpZ25lZC1vZmYtYnk6IFNhc2hhIExldmluIDxzYXNoYWw+IGNvbW1pdCAwNTVjYTk4ZDQ4YmE1YTEyN2I0YWI3MmY5ZThkZWZhYmY4OTZlMzFjIEF1dGhvcjogR3VlbnRlciBSb2VjayA8bGludXg+IERhdGU6IFNhdCBOb3YgNiAxMDowMjo0NCAyMDIxIC0wNzAwIGh3bW9uOiAobG05MCkgRml4IHVzYWdlIG9mIENPTkZJRzIgcmVnaXN0ZXIgaW4gZGV0ZWN0IGZ1bmN0aW9uIFsgVXBzdHJlYW0gY29tbWl0IGZjZTE1YzQ1ZDNmYmQ5ZmMxZmVhYWYzMjEwZDhlM2Y4YjMzZGZkM2EgXSBUaGUgZGV0ZWN0IGZ1bmN0aW9uIGhhZCBhIGNvbW1lbnQgIk1ha2UgY29tcGlsZXIgaGFwcHkiIHdoZW4gaWQgZGlkIG5vdCByZWFkIHRoZSBzZWNvbmQgY29uZmlndXJhdGlvbiByZWdpc3Rlci4gQXMgaXQgdHVybnMgb3V0LCB0aGUgY29kZSB3YXMgY2hlY2tpbmcgdGhlIGNvbnRlbnRzIG9mIHRoaXMgcmVnaXN0ZXIgZm9yIG1hbnVmYWN0dXJlciBJRCAweEExIChOWFAgU2VtaWNvbmR1Y3Rvci9QaGlsaXBzKSwgYnV0IG5ldmVyIGFjdHVhbGx5IHJlYWQgdGhlIHJlZ2lzdGVyLiBTbyBpdCB3YXNuJ3Qgc3VycHJpc2luZyB0aGF0IHRoZSBjb21waWxlciBjb21wbGFpbmVkLCBhbmQgaXQgaW5kZWVkIGhhZCBhIHBvaW50LiBGaXggdGhlIGNvZGUgdG8gcmVhZCB0aGUgcmVnaXN0ZXIgY29udGVudHMgZm9yIG1hbnVmYWN0dXJlciBJRCAweGExLiBBdCB0aGUgc2FtZSB0aW1lLCB0aGUgY29kZSB3YXMgcmVhZGluZyB0aGUgcmVnaXN0ZXIgZm9yIG1hbnVmYWN0dXJlciBJRCAweDQxIChBbmFsb2cgRGV2aWNlcyksIGJ1dCBpdCB3YXMgbm90IHVzaW5nIHRoZSByZXN1bHRzLiBJbiBlZmZlY3QgaXQgd2FzIGp1c3QgY2hlY2tpbmcgaWYgcmVhZGluZyB0aGUgcmVnaXN0ZXIgcmV0dXJuZWQgYW4gZXJyb3IuIFRoYXQgZG9lc24ndCByZWFsbHkgYWRkIG11Y2ggaWYgYW55IHZhbHVlLCBzbyBzdG9wIGRvaW5nIHRoYXQuIEZpeGVzOiBmOTBiZTQyZmIzODMgKCJod21vbjogKGxtOTApIFJlZmFjdG9yIHJlYWRpbmcgb2YgY29uZmlnMiByZWdpc3RlciIpIFNpZ25lZC1vZmYtYnk6IEd1ZW50ZXIgUm9lY2sgPGxpbnV4PiBTaWduZWQtb2ZmLWJ5OiBTYXNoYSBMZXZpbiA8c2FzaGFsPiBjb21taXQgYTdmOTUzMjhjNmYwYWZmZmRjNDU1NWYxNmUzYmJhYjhiYmYwZDliZSBBdXRob3I6IEFuZHJlYSBSaWdoaSA8YW5kcmVhLnJpZ2hpPiBEYXRlOiBNb24gTm92IDI5IDAwOjA4OjEzIDIwMjEgLTA4MDAgSW5wdXQ6IGVsYW50ZWNoIC0gZml4IHN0YWNrIG91dCBvZiBib3VuZCBhY2Nlc3MgaW4gZWxhbnRlY2hfY2hhbmdlX3JlcG9ydF9pZCgpIFsgVXBzdHJlYW0gY29tbWl0IDFkNzJkOWY5NjBjY2YxMDUyYTA2MzBhNjhjM2QzNTg3OTFkYmRhYWEgXSBUaGUgYXJyYXkgcGFyYW1bXSBpbiBlbGFudGVjaF9jaGFuZ2VfcmVwb3J0X2lkKCkgbXVzdCBiZSBhdCBsZWFzdCAzIGJ5dGVzLCBiZWNhdXNlIGVsYW50ZWNoX3JlYWRfcmVnX3BhcmFtcygpIGlzIGNhbGxpbmcgcHMyX2NvbW1hbmQoKSB3aXRoIFBTTU9VU0VfQ01EX0dFVElORk8sIHRoYXQgaXMgZ29pbmcgdG8gYWNjZXNzIDMgYnl0ZXMgZnJvbSBwYXJhbVtdLCBidXQgaXQncyBkZWZpbmVkIGluIHRoZSBzdGFjayBhcyBhbiBhcnJheSBvZiAyIGJ5dGVzLCB0aGVyZWZvcmUgd2UgaGF2ZSBhIHBvdGVudGlhbCBzdGFjayBvdXQtb2YtYm91bmRzIGFjY2VzcyBoZXJlLCBhbHNvIGNvbmZpcm1lZCBieSBLQVNBTjogWyA2LjUxMjM3NF0gQlVHOiBLQVNBTjogc3RhY2stb3V0LW9mLWJvdW5kcyBpbiBfX3BzMl9jb21tYW5kKzB4MzcyLzB4N2UwIFsgNi41MTIzOTddIFJlYWQgb2Ygc2l6ZSAxIGF0IGFkZHIgZmZmZjg4ODEwMjRkNzdjMiBieSB0YXNrIGt3b3JrZXIvMjoxLzExOCBbIDYuNTEyNDE2XSBDUFU6IDIgUElEOiAxMTggQ29tbToga3dvcmtlci8yOjEgTm90IHRhaW50ZWQgNS4xMy4wLTIyLWdlbmVyaWMgIzIyK2FyaWdoaTIwMjExMTEwIFsgNi41MTI0MjhdIEhhcmR3YXJlIG5hbWU6IExFTk9WTyAyMFQ4MDAwUUdFLzIwVDgwMDBRR0UsIEJJT1MgUjFBRVQzMlcgKDEuMDggKSAwOC8xNC8yMDIwIFsgNi41MTI0MzZdIFdvcmtxdWV1ZTogZXZlbnRzX2xvbmcgc2VyaW9faGFuZGxlX2V2ZW50IFsgNi41MTI0NTNdIENhbGwgVHJhY2U6IFsgNi41MTI0NjJdIHNob3dfc3RhY2srMHg1Mi8weDU4IFsgNi41MTI0NzRdIGR1bXBfc3RhY2srMHhhMS8weGQzIFsgNi41MTI0ODddIHByaW50X2FkZHJlc3NfZGVzY3JpcHRpb24uY29uc3Rwcm9wLjArMHgxZC8weDE0MCBbIDYuNTEyNTAyXSA/IF9fcHMyX2NvbW1hbmQrMHgzNzIvMHg3ZTAgWyA2LjUxMjUxNl0gX19rYXNhbl9yZXBvcnQuY29sZCsweDdkLzB4MTEyIFsgNi41MTI1MjddID8gX3Jhd193cml0ZV9sb2NrX2lycSsweDIwLzB4ZDAgWyA2LjUxMjUzOV0gPyBfX3BzMl9jb21tYW5kKzB4MzcyLzB4N2UwIFsgNi41MTI1NTJdIGthc2FuX3JlcG9ydCsweDNjLzB4NTAgWyA2LjUxMjU2NF0gX19hc2FuX2xvYWQxKzB4NmEvMHg3MCBbIDYuNTEyNTc1XSBfX3BzMl9jb21tYW5kKzB4MzcyLzB4N2UwIFsgNi41MTI1ODldID8gcHMyX2RyYWluKzB4MjQwLzB4MjQwIFsgNi41MTI2MDFdID8gZGV2X3ByaW50a19lbWl0KzB4YTIvMHhkMyBbIDYuNTEyNjEyXSA/IGRldl92cHJpbnRrX2VtaXQrMHhjNS8weGM1IFsgNi41MTI2MjFdID8gX19rYXNhbl9jaGVja193cml0ZSsweDE0LzB4MjAgWyA2LjUxMjYzNF0gPyBtdXRleF9sb2NrKzB4OGYvMHhlMCBbIDYuNTEyNjQzXSA/IF9fbXV0ZXhfbG9ja19zbG93cGF0aCsweDIwLzB4MjAgWyA2LjUxMjY1NV0gcHMyX2NvbW1hbmQrMHg1Mi8weDkwIFsgNi41MTI2NzBdIGVsYW50ZWNoX3BzMl9jb21tYW5kKzB4NGYvMHhjMCBbcHNtb3VzZV0gWyA2LjUxMjczNF0gZWxhbnRlY2hfY2hhbmdlX3JlcG9ydF9pZCsweDFlNi8weDI1NiBbcHNtb3VzZV0gWyA2LjUxMjc5OV0gPyBlbGFudGVjaF9yZXBvcnRfdHJhY2twb2ludC5jb25zdHByb3AuMC5jb2xkKzB4ZC8weGQgW3BzbW91c2VdIFsgNi41MTI4NjNdID8gcHMyX2NvbW1hbmQrMHg3Zi8weDkwIFsgNi41MTI4NzddIGVsYW50ZWNoX3F1ZXJ5X2luZm8uY29sZCsweDZiZC8weDllZCBbcHNtb3VzZV0gWyA2LjUxMjk0M10gPyBlbGFudGVjaF9zZXR1cF9wczIrMHg0NjAvMHg0NjAgW3BzbW91c2VdIFsgNi41MTMwMDVdID8gcHNtb3VzZV9yZXNldCsweDY5LzB4YjAgW3BzbW91c2VdIFsgNi41MTMwNjRdID8gcHNtb3VzZV9hdHRyX3NldF9oZWxwZXIrMHgyYTAvMHgyYTAgW3BzbW91c2VdIFsgNi41MTMxMjJdID8gcGh5c19wbWRfaW5pdCsweDMwZS8weDUyMSBbIDYuNTEzMTM3XSBlbGFudGVjaF9pbml0KzB4OGEvMHgyMDAgW3BzbW91c2VdIFsgNi41MTMyMDBdID8gZWxhbnRlY2hfaW5pdF9wczIrMHhmMC8weGYwIFtwc21vdXNlXSBbIDYuNTEzMjQ5XSA/IGVsYW50ZWNoX3F1ZXJ5X2luZm8rMHg0NDAvMHg0NDAgW3BzbW91c2VdIFsgNi41MTMyOTZdID8gc3luYXB0aWNzX3NlbmRfY21kKzB4NjAvMHg2MCBbcHNtb3VzZV0gWyA2LjUxMzM0Ml0gPyBlbGFudGVjaF9xdWVyeV9pbmZvKzB4NDQwLzB4NDQwIFtwc21vdXNlXSBbIDYuNTEzMzg4XSA/IHBzbW91c2VfdHJ5X3Byb3RvY29sKzB4MTFlLzB4MTcwIFtwc21vdXNlXSBbIDYuNTEzNDMyXSBwc21vdXNlX2V4dGVuc2lvbnMrMHg2NWQvMHg2ZTAgW3BzbW91c2VdIFsgNi41MTM0NzZdID8gcHNtb3VzZV90cnlfcHJvdG9jb2wrMHgxNzAvMHgxNzAgW3BzbW91c2VdIFsgNi41MTM1MTldID8gbXV0ZXhfdW5sb2NrKzB4MjIvMHg0MCBbIDYuNTEzNTI2XSA/IHBzMl9jb21tYW5kKzB4N2YvMHg5MCBbIDYuNTEzNTM2XSA/IHBzbW91c2VfcHJvYmUrMHhhMy8weGYwIFtwc21vdXNlXSBbIDYuNTEzNTgwXSBwc21vdXNlX3N3aXRjaF9wcm90b2NvbCsweDI3ZC8weDJlMCBbcHNtb3VzZV0gWyA2LjUxMzYyNF0gcHNtb3VzZV9jb25uZWN0KzB4MjcyLzB4NTMwIFtwc21vdXNlXSBbIDYuNTEzNjY5XSBzZXJpb19kcml2ZXJfcHJvYmUrMHg1NS8weDcwIFsgNi41MTM2NzldIHJlYWxseV9wcm9iZSsweDE5MC8weDcyMCBbIDYuNTEzNjg5XSBkcml2ZXJfcHJvYmVfZGV2aWNlKzB4MTYwLzB4MWYwIFsgNi41MTM2OTddIGRldmljZV9kcml2ZXJfYXR0YWNoKzB4MTE5LzB4MTMwIFsgNi41MTM3MDVdID8gZGV2aWNlX2RyaXZlcl9hdHRhY2grMHgxMzAvMHgxMzAgWyA2LjUxMzcxM10gX19kcml2ZXJfYXR0YWNoKzB4ZTcvMHgxYTAgWyA2LjUxMzcyMF0gPyBkZXZpY2VfZHJpdmVyX2F0dGFjaCsweDEzMC8weDEzMCBbIDYuNTEzNzI4XSBidXNfZm9yX2VhY2hfZGV2KzB4ZmIvMHgxNTAgWyA2LjUxMzczOF0gPyBzdWJzeXNfZGV2X2l0ZXJfZXhpdCsweDEwLzB4MTAgWyA2LjUxMzc0OF0gPyBfcmF3X3dyaXRlX3VubG9ja19iaCsweDMwLzB4MzAgWyA2LjUxMzc1N10gZHJpdmVyX2F0dGFjaCsweDJkLzB4NDAgWyA2LjUxMzc2NF0gc2VyaW9faGFuZGxlX2V2ZW50KzB4MTk5LzB4M2QwIFsgNi41MTM3NzVdIHByb2Nlc3Nfb25lX3dvcmsrMHg0NzEvMHg3NDAgWyA2LjUxMzc4NV0gd29ya2VyX3RocmVhZCsweDJkMi8weDc5MCBbIDYuNTEzNzk0XSA/IHByb2Nlc3Nfb25lX3dvcmsrMHg3NDAvMHg3NDAgWyA2LjUxMzgwMl0ga3RocmVhZCsweDFiNC8weDFlMCBbIDYuNTEzODA5XSA/IHNldF9rdGhyZWFkX3N0cnVjdCsweDgwLzB4ODAgWyA2LjUxMzgxNl0gcmV0X2Zyb21fZm9yaysweDIyLzB4MzAgWyA2LjUxMzgzMl0gVGhlIGJ1Z2d5IGFkZHJlc3MgYmVsb25ncyB0byB0aGUgcGFnZTogWyA2LjUxMzgzOF0gcGFnZTowMDAwMDAwMGJjMzVlMTg5IHJlZmNvdW50OjAgbWFwY291bnQ6MCBtYXBwaW5nOjAwMDAwMDAwMDAwMDAwMDAgaW5kZXg6MHgwIHBmbjoweDEwMjRkNyBbIDYuNTEzODQ3XSBmbGFnczogMHgxN2ZmZmZjMDAwMDAwMChub2RlPTB8em9uZT0yfGxhc3RjcHVwaWQ9MHgxZmZmZmYpIFsgNi41MTM4NjBdIHJhdzogMDAxN2ZmZmZjMDAwMDAwMCBkZWFkMDAwMDAwMDAwMTAwIGRlYWQwMDAwMDAwMDAxMjIgMDAwMDAwMDAwMDAwMDAwMCBbIDYuNTEzODY3XSByYXc6IDAwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMGZmZmZmZmZmIDAwMDAwMDAwMDAwMDAwMDAgWyA2LjUxMzg3Ml0gcGFnZSBkdW1wZWQgYmVjYXVzZToga2FzYW46IGJhZCBhY2Nlc3MgZGV0ZWN0ZWQgWyA2LjUxMzg3OV0gYWRkciBmZmZmODg4MTAyNGQ3N2MyIGlzIGxvY2F0ZWQgaW4gc3RhY2sgb2YgdGFzayBrd29ya2VyLzI6MS8xMTggYXQgb2Zmc2V0IDM0IGluIGZyYW1lOiBbIDYuNTEzODg3XSBlbGFudGVjaF9jaGFuZ2VfcmVwb3J0X2lkKzB4MC8weDI1NiBbcHNtb3VzZV0gWyA2LjUxMzk0MV0gdGhpcyBmcmFtZSBoYXMgMSBvYmplY3Q6IFsgNi41MTM5NDddIFszMiwgMzQpICdwYXJhbScgWyA2LjUxMzk1Nl0gTWVtb3J5IHN0YXRlIGFyb3VuZCB0aGUgYnVnZ3kgYWRkcmVzczogWyA2LjUxMzk2Ml0gZmZmZjg4ODEwMjRkNzY4MDogZjIgZjIgZjIgZjIgZjIgMDAgMDAgZjMgZjMgMDAgMDAgMDAgMDAgMDAgMDAgMDAgWyA2LjUxMzk2OV0gZmZmZjg4ODEwMjRkNzcwMDogMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgWyA2LjUxMzk3Nl0gJmd0O2ZmZmY4ODgxMDI0ZDc3ODA6IDAwIDAwIDAwIDAwIGYxIGYxIGYxIGYxIDAyIGYzIGYzIGYzIDAwIDAwIDAwIDAwIFsgNi41MTM5ODJdIF4gWyA2LjUxMzk4OF0gZmZmZjg4ODEwMjRkNzgwMDogMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgWyA2LjUxMzk5NV0gZmZmZjg4ODEwMjRkNzg4MDogMDAgZjEgZjEgZjEgZjEgMDMgZjIgMDMgZjIgMDMgZjMgZjMgZjMgMDAgMDAgMDAgWyA2LjUxNDAwMF0gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IERlZmluZSBwYXJhbVtdIGluIGVsYW50ZWNoX2NoYW5nZV9yZXBvcnRfaWQoKSBhcyBhbiBhcnJheSBvZiAzIGJ5dGVzIHRvIHByZXZlbnQgdGhlIG91dC1vZi1ib3VuZHMgYWNjZXNzIGluIHRoZSBzdGFjay4gRml4ZXM6IGU0YzkwNjI3MTdmZSAoIklucHV0OiBlbGFudGVjaCAtIGZpeCBwcm90b2NvbCBlcnJvcnMgZm9yIHNvbWUgdHJhY2twb2ludHMgaW4gU01CdXMgbW9kZSIpIEJ1Z0xpbms6IGh0dHBzOi8vYnVncy5sYXVuY2hwYWQubmV0L2J1Z3MvMTk0NTU5MCBTaWduZWQtb2ZmLWJ5OiBBbmRyZWEgUmlnaGkgPGFuZHJlYS5yaWdoaT4gUmV2aWV3ZWQtYnk6IFdvbGZyYW0gU2FuZyA8d3NhPiBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMTE2MDk1NTU5LjI0Mzk1LTEtYW5kcmVhLnJpZ2hpQGNhbm9uaWNhbC5jb20gU2lnbmVkLW9mZi1ieTogRG1pdHJ5IFRvcm9raG92IDxkbWl0cnkudG9yb2tob3Y+IFNpZ25lZC1vZmYtYnk6IFNhc2hhIExldmluIDxzYXNoYWw+IGNvbW1pdCBlMTJkY2Q0YWE3ZjQxODQ1ZWNjNmM2NWE1N2RiZmIxZDZhM2E2NWM0IEF1dGhvcjogSmlhc2hlbmcgSmlhbmcgPGppYXNoZW5nPiBEYXRlOiBNb24gRGVjIDIwIDIyOjAzOjQ0IDIwMjEgKzA4MDAgc2ZjOiBmYWxjb246IENoZWNrIG51bGwgcG9pbnRlciBvZiByeF9xdWV1ZS0mZ3Q7cGFnZV9yaW5nIFsgVXBzdHJlYW0gY29tbWl0IDliOGJkZDFlYjU4OTBhZWVhYjczOTFkZGRjZjhiZDUxZjdiMDcyMTYgXSBCZWNhdXNlIG9mIHRoZSBwb3NzaWJsZSBmYWlsdXJlIG9mIHRoZSBrY2FsbG9jLCBpdCBzaG91bGQgYmUgYmV0dGVyIHRvIHNldCByeF9xdWV1ZS0mZ3Q7cGFnZV9wdHJfbWFzayB0byAwIHdoZW4gaXQgaGFwcGVucyBpbiBvcmRlciB0byBtYWludGFpbiB0aGUgY29uc2lzdGVuY3kuIEZpeGVzOiA1YTY2ODFlMjJjMTQgKCJzZmM6IHNlcGFyYXRlIG91dCBTRkM0MDAwICgiRmFsY29uIikgc3VwcG9ydCBpbnRvIG5ldyBzZmMtZmFsY29uIGRyaXZlciIpIFNpZ25lZC1vZmYtYnk6IEppYXNoZW5nIEppYW5nIDxqaWFzaGVuZz4gQWNrZWQtYnk6IE1hcnRpbiBIYWJldHMgPGhhYmV0c20ueGlsaW54PiBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMjIwMTQwMzQ0Ljk3ODQwOC0xLWppYXNoZW5nQGlzY2FzLmFjLmNuIFNpZ25lZC1vZmYtYnk6IEpha3ViIEtpY2luc2tpIDxrdWJhPiBTaWduZWQtb2ZmLWJ5OiBTYXNoYSBMZXZpbiA8c2FzaGFsPiBjb21taXQgYzExYTQxZTI2OTg1ZWVhMzhlYTE4ZGY3OThhOWNkYThhZGU0Yjc4ZSBBdXRob3I6IEppYXNoZW5nIEppYW5nIDxqaWFzaGVuZz4gRGF0ZTogV2VkIERlYyAyMiAxNTo0MToxMiAyMDIxICswODAwIGRyaXZlcnM6IG5ldDogc21jOTExeDogQ2hlY2sgZm9yIGVycm9yIGlycSBbIFVwc3RyZWFtIGNvbW1pdCBjYjkzYjNlMTFkNDA1ZjIwYTQwNWEwNzQ4MmQwMTE0N2VmNDkzNGEzIF0gQmVjYXVzZSBwbGF0Zm9ybV9nZXRfaXJxKCkgY291bGQgZmFpbCBhbmQgcmV0dXJuIGVycm9yIGlycS4gVGhlcmVmb3JlLCBpdCBtaWdodCBiZSBiZXR0ZXIgdG8gY2hlY2sgaXQgaWYgb3JkZXIgdG8gYXZvaWQgdGhlIHVzZSBvZiBlcnJvciBpcnEuIEZpeGVzOiBhZTE1MDQzNWI1OWUgKCJzbXNjOiBNb3ZlIHRoZSBTTUMgKFNNU0MpIGRyaXZlcnMiKSBTaWduZWQtb2ZmLWJ5OiBKaWFzaGVuZyBKaWFuZyA8amlhc2hlbmc+IFNpZ25lZC1vZmYtYnk6IERhdmlkIFMuIE1pbGxlciA8ZGF2ZW0+IFNpZ25lZC1vZmYtYnk6IFNhc2hhIExldmluIDxzYXNoYWw+IGNvbW1pdCA1ZDU1NmIxNDM3ZTFkYjZlNTJjZGEzNTViMmM0Y2Y0MDIxMmZjNzJmIEF1dGhvcjogSmlhc2hlbmcgSmlhbmcgPGppYXNoZW5nPiBEYXRlOiBXZWQgRGVjIDIyIDE1OjEyOjA3IDIwMjEgKzA4MDAgZmplczogQ2hlY2sgZm9yIGVycm9yIGlycSBbIFVwc3RyZWFtIGNvbW1pdCBkYjZkNmFmZTM4MmRlNWE2NWQ2Y2NmNTEyNTNhYjQ4YjhlODMzNmMzIF0gSSBmaW5kIHRoYXQgcGxhdGZvcm1fZ2V0X2lycSgpIHdpbGwgbm90IGFsd2F5cyBzdWNjZWVkLiBJdCB3aWxsIHJldHVybiBlcnJvciBpcnEgaW4gY2FzZSBvZiB0aGUgZmFpbHVyZS4gVGhlcmVmb3JlLCBpdCBtaWdodCBiZSBiZXR0ZXIgdG8gY2hlY2sgaXQgaWYgb3JkZXIgdG8gYXZvaWQgdGhlIHVzZSBvZiBlcnJvciBpcnEuIEZpeGVzOiA2NThkNDM5YjIyOTIgKCJmamVzOiBJbnRyb2R1Y2UgRlVKSVRTVSBFeHRlbmRlZCBTb2NrZXQgTmV0d29yayBEZXZpY2UgZHJpdmVyIikgU2lnbmVkLW9mZi1ieTogSmlhc2hlbmcgSmlhbmcgPGppYXNoZW5nPiBTaWduZWQtb2ZmLWJ5OiBEYXZpZCBTLiBNaWxsZXIgPGRhdmVtPiBTaWduZWQtb2ZmLWJ5OiBTYXNoYSBMZXZpbiA8c2FzaGFsPiBjb21taXQgZDcwMjQwODBkYjgyZWJhZGRmOTNjNTNkZWE1Yzg2MWJjZGQzYWE0ZiBBdXRob3I6IEZlcm5hbmRvIEZlcm5hbmRleiBNYW5jZXJhIDxmZm1hbmNlcmE+IERhdGU6IFR1ZSBEZWMgMjEgMTI6MTM6NDUgMjAyMSArMDEwMCBib25kaW5nOiBmaXggYWRfYWN0b3Jfc3lzdGVtIG9wdGlvbiBzZXR0aW5nIHRvIGRlZmF1bHQgWyBVcHN0cmVhbSBjb21taXQgMWMxNWIwNWJhZWE3MWE1ZmY5ODIzNTc4M2UzZTRhZDIyNzc2MDg3NiBdIFdoZW4gODAyLjNhZCBib25kIG1vZGUgaXMgY29uZmlndXJlZCB0aGUgYWRfYWN0b3Jfc3lzdGVtIG9wdGlvbiBpcyBzZXQgdG8gIjAwOjAwOjAwOjAwOjAwOjAwIi4gQnV0IHdoZW4gdHJ5aW5nIHRvIHNldCB0aGUgYWxsLXplcm9lcyBNQUMgYXMgYWN0b3JzJyBzeXN0ZW0gYWRkcmVzcyBpdCB3YXMgZmFpbGluZyB3aXRoIEVJTlZBTC4gQW4gYWxsLXplcm9lcyBldGhlcm5ldCBhZGRyZXNzIGlzIHZhbGlkLCBvbmx5IG11bHRpY2FzdCBhZGRyZXNzZXMgYXJlIG5vdCB2YWxpZCB2YWx1ZXMuIEZpeGVzOiAxNzFhNDJjMzhjNmUgKCJib25kaW5nOiBhZGQgbmV0bGluayBzdXBwb3J0IGZvciBzeXMgcHJpbywgYWN0b3Igc3lzIG1hYywgYW5kIHBvcnQga2V5IikgU2lnbmVkLW9mZi1ieTogRmVybmFuZG8gRmVybmFuZGV6IE1hbmNlcmEgPGZmbWFuY2VyYT4gQWNrZWQtYnk6IEpheSBWb3NidXJnaCA8amF5LnZvc2J1cmdoPiBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMjIxMTExMzQ1LjI0NjItMS1mZm1hbmNlcmFAcmlzZXVwLm5ldCBTaWduZWQtb2ZmLWJ5OiBKYWt1YiBLaWNpbnNraSA8a3ViYT4gU2lnbmVkLW9mZi1ieTogU2FzaGEgTGV2aW4gPHNhc2hhbD4gY29tbWl0IDk5MjY0OWI4YjE2ODQzZDI3ZWIzOWNlZWE1ZjljZjg1ZmZiNTBhMTggQXV0aG9yOiBXdSBCbyA8d3VibzQwPiBEYXRlOiBUdWUgRGVjIDIxIDE1OjAwOjM0IDIwMjEgKzA4MDAgaXBtaTogRml4IFVBRiB3aGVuIHVuaW5zdGFsbCBpcG1pX3NpIGFuZCBpcG1pX21zZ2hhbmRsZXIgbW9kdWxlIFsgVXBzdHJlYW0gY29tbWl0IGZmYjc2YTg2ZjgwOTZhODIwNmJlMDNiMTRhZGRhNjA5MmUxOGUyNzUgXSBIaSwgV2hlbiB0ZXN0aW5nIGluc3RhbGwgYW5kIHVuaW5zdGFsbCBvZiBpcG1pX3NpLmtvIGFuZCBpcG1pX21zZ2hhbmRsZXIua28sIHRoZSBzeXN0ZW0gY3Jhc2hlZC4gVGhlIGxvZyBhcyBmb2xsb3dzOiBbIDE0MS4wODcwMjZdIEJVRzogdW5hYmxlIHRvIGhhbmRsZSBrZXJuZWwgcGFnaW5nIHJlcXVlc3QgYXQgZmZmZmZmZmZjMDliM2E1YSBbIDE0MS4wODcyNDFdIFBHRCA4ZmU0YzBkMDY3IFA0RCA4ZmU0YzBkMDY3IFBVRCA4ZmU0YzBmMDY3IFBNRCAxMDNhZDg5MDY3IFBURSAwIFsgMTQxLjA4NzQ2NF0gT29wczogMDAxMCBbIzFdIFNNUCBOT1BUSSBbIDE0MS4wODc1ODBdIENQVTogNjcgUElEOiA2NjggQ29tbToga3dvcmtlci82NzoxIEtkdW1wOiBsb2FkZWQgTm90IHRhaW50ZWQgNC4xOC4wLng4Nl82NCAjNDcgWyAxNDEuMDg4MDA5XSBXb3JrcXVldWU6IGV2ZW50cyAweGZmZmZmZmZmYzA5YjNhNDAgWyAxNDEuMDg4MDA5XSBSSVA6IDAwMTA6MHhmZmZmZmZmZmMwOWIzYTVhIFsgMTQxLjA4ODAwOV0gQ29kZTogQmFkIFJJUCB2YWx1ZS4gWyAxNDEuMDg4MDA5XSBSU1A6IDAwMTg6ZmZmZmI5MDk0ZTJjM2U4OCBFRkxBR1M6IDAwMDEwMjQ2IFsgMTQxLjA4ODAwOV0gUkFYOiAwMDAwMDAwMDAwMDAwMDAwIFJCWDogZmZmZjlhYmZkYjFmMDRhMCBSQ1g6IDAwMDAwMDAwMDAwMDAwMDAgWyAxNDEuMDg4MDA5XSBSRFg6IDAwMDAwMDAwMDAwMDAwMDAgUlNJOiAwMDAwMDAwMDAwMDAwMjQ2IFJESTogMDAwMDAwMDAwMDAwMDI0NiBbIDE0MS4wODgwMDldIFJCUDogMDAwMDAwMDAwMDAwMDAwMCBSMDg6IGZmZmY5YWJmZmZlZTNjYjggUjA5OiAwMDAwMDAwMDAwMDAwMmUxIFsgMTQxLjA4ODAwOV0gUjEwOiBmZmZmYjkwOTRjYjczZDkwIFIxMTogMDAwMDAwMDAwMDBmNDI0MCBSMTI6IGZmZmY5YWJmZmZlZTg3MDAgWyAxNDEuMDg4MDA5XSBSMTM6IDAwMDAwMDAwMDAwMDAwMDAgUjE0OiBmZmZmOWFiZmRiMWYwNGEwIFIxNTogZmZmZjlhYmZkYjFmMDRhOCBbIDE0MS4wODgwMDldIEZTOiAwMDAwMDAwMDAwMDAwMDAwKDAwMDApIEdTOmZmZmY5YWJmZmZlYzAwMDAoMDAwMCkga25sR1M6MDAwMDAwMDAwMDAwMDAwMCBbIDE0MS4wODgwMDldIENTOiAwMDEwIERTOiAwMDAwIEVTOiAwMDAwIENSMDogMDAwMDAwMDA4MDA1MDAzMyBbIDE0MS4wODgwMDldIENSMjogZmZmZmZmZmZjMDliM2EzMCBDUjM6IDAwMDAwMDhmZTRjMGEwMDEgQ1I0OiAwMDAwMDAwMDAwNzYwNmUwIFsgMTQxLjA4ODAwOV0gRFIwOiAwMDAwMDAwMDAwMDAwMDAwIERSMTogMDAwMDAwMDAwMDAwMDAwMCBEUjI6IDAwMDAwMDAwMDAwMDAwMDAgWyAxNDEuMDg4MDA5XSBEUjM6IDAwMDAwMDAwMDAwMDAwMDAgRFI2OiAwMDAwMDAwMGZmZmUwZmYwIERSNzogMDAwMDAwMDAwMDAwMDQwMCBbIDE0MS4wODgwMDldIFBLUlU6IDU1NTU1NTU0IFsgMTQxLjA4ODAwOV0gQ2FsbCBUcmFjZTogWyAxNDEuMDg4MDA5XSA/IHByb2Nlc3Nfb25lX3dvcmsrMHgxOTUvMHgzOTAgWyAxNDEuMDg4MDA5XSA/IHdvcmtlcl90aHJlYWQrMHgzMC8weDM5MCBbIDE0MS4wODgwMDldID8gcHJvY2Vzc19vbmVfd29yaysweDM5MC8weDM5MCBbIDE0MS4wODgwMDldID8ga3RocmVhZCsweDEwZC8weDEzMCBbIDE0MS4wODgwMDldID8ga3RocmVhZF9mbHVzaF93b3JrX2ZuKzB4MTAvMHgxMCBbIDE0MS4wODgwMDldID8gcmV0X2Zyb21fZm9yaysweDM1LzB4NDBdIEJVRzogdW5hYmxlIHRvIGhhbmRsZSBrZXJuZWwgcGFnaW5nIHJlcXVlc3QgYXQgZmZmZmZmZmZjMGIyOGE1YSBbIDIwMC4yMjMyNDBdIFBHRCA5N2ZlMDBkMDY3IFA0RCA5N2ZlMDBkMDY3IFBVRCA5N2ZlMDBmMDY3IFBNRCBhNTgwY2JmMDY3IFBURSAwIFsgMjAwLjIyMzQ2NF0gT29wczogMDAxMCBbIzFdIFNNUCBOT1BUSSBbIDIwMC4yMjM1NzldIENQVTogNjMgUElEOiA2NjQgQ29tbToga3dvcmtlci82MzoxIEtkdW1wOiBsb2FkZWQgTm90IHRhaW50ZWQgNC4xOC4wLng4Nl82NCAjNDYgWyAyMDAuMjI0MDA4XSBXb3JrcXVldWU6IGV2ZW50cyAweGZmZmZmZmZmYzBiMjhhNDAgWyAyMDAuMjI0MDA4XSBSSVA6IDAwMTA6MHhmZmZmZmZmZmMwYjI4YTVhIFsgMjAwLjIyNDAwOF0gQ29kZTogQmFkIFJJUCB2YWx1ZS4gWyAyMDAuMjI0MDA4XSBSU1A6IDAwMTg6ZmZmZmJmM2M4ZTJhM2U4OCBFRkxBR1M6IDAwMDEwMjQ2IFsgMjAwLjIyNDAwOF0gUkFYOiAwMDAwMDAwMDAwMDAwMDAwIFJCWDogZmZmZmEwNzk5YWQ2YmNhMCBSQ1g6IDAwMDAwMDAwMDAwMDAwMDAgWyAyMDAuMjI0MDA4XSBSRFg6IDAwMDAwMDAwMDAwMDAwMDAgUlNJOiAwMDAwMDAwMDAwMDAwMjQ2IFJESTogMDAwMDAwMDAwMDAwMDI0NiBbIDIwMC4yMjQwMDhdIFJCUDogMDAwMDAwMDAwMDAwMDAwMCBSMDg6IGZmZmY5ZmU0M2ZkZTNjYjggUjA5OiAwMDAwMDAwMDAwMDAwMGQ1IFsgMjAwLjIyNDAwOF0gUjEwOiBmZmZmYmYzYzhjYjUzZDkwIFIxMTogMDAwMDAwMDAwMDBmNDI0MCBSMTI6IGZmZmY5ZmU0M2ZkZTg3MDAgWyAyMDAuMjI0MDA4XSBSMTM6IDAwMDAwMDAwMDAwMDAwMDAgUjE0OiBmZmZmYTA3OTlhZDZiY2EwIFIxNTogZmZmZmEwNzk5YWQ2YmNhOCBbIDIwMC4yMjQwMDhdIEZTOiAwMDAwMDAwMDAwMDAwMDAwKDAwMDApIEdTOmZmZmY5ZmU0M2ZkYzAwMDAoMDAwMCkga25sR1M6MDAwMDAwMDAwMDAwMDAwMCBbIDIwMC4yMjQwMDhdIENTOiAwMDEwIERTOiAwMDAwIEVTOiAwMDAwIENSMDogMDAwMDAwMDA4MDA1MDAzMyBbIDIwMC4yMjQwMDhdIENSMjogZmZmZmZmZmZjMGIyOGEzMCBDUjM6IDAwMDAwMDk3ZmUwMGEwMDIgQ1I0OiAwMDAwMDAwMDAwNzYwNmUwIFsgMjAwLjIyNDAwOF0gRFIwOiAwMDAwMDAwMDAwMDAwMDAwIERSMTogMDAwMDAwMDAwMDAwMDAwMCBEUjI6IDAwMDAwMDAwMDAwMDAwMDAgWyAyMDAuMjI0MDA4XSBEUjM6IDAwMDAwMDAwMDAwMDAwMDAgRFI2OiAwMDAwMDAwMGZmZmUwZmYwIERSNzogMDAwMDAwMDAwMDAwMDQwMCBbIDIwMC4yMjQwMDhdIFBLUlU6IDU1NTU1NTU0IFsgMjAwLjIyNDAwOF0gQ2FsbCBUcmFjZTogWyAyMDAuMjI0MDA4XSA/IHByb2Nlc3Nfb25lX3dvcmsrMHgxOTUvMHgzOTAgWyAyMDAuMjI0MDA4XSA/IHdvcmtlcl90aHJlYWQrMHgzMC8weDM5MCBbIDIwMC4yMjQwMDhdID8gcHJvY2Vzc19vbmVfd29yaysweDM5MC8weDM5MCBbIDIwMC4yMjQwMDhdID8ga3RocmVhZCsweDEwZC8weDEzMCBbIDIwMC4yMjQwMDhdID8ga3RocmVhZF9mbHVzaF93b3JrX2ZuKzB4MTAvMHgxMCBbIDIwMC4yMjQwMDhdID8gcmV0X2Zyb21fZm9yaysweDM1LzB4NDAgWyAyMDAuMjI0MDA4XSBrZXJuZWwgZmF1bHQoMHgxKSBub3RpZmljYXRpb24gc3RhcnRpbmcgb24gQ1BVIDYzIFsgMjAwLjIyNDAwOF0ga2VybmVsIGZhdWx0KDB4MSkgbm90aWZpY2F0aW9uIGZpbmlzaGVkIG9uIENQVSA2MyBbIDIwMC4yMjQwMDhdIENSMjogZmZmZmZmZmZjMGIyOGE1YSBbIDIwMC4yMjQwMDhdIC0tLVsgZW5kIHRyYWNlIGM4MmE0MTJkOTNmNTc0MTIgXS0tLSBUaGUgcmVhc29uIGlzIGFzIGZvbGxvd3M6IFQxOiBybW1vZCBpcG1pX3NpLiAtJmd0O2lwbWlfdW5yZWdpc3Rlcl9zbWkoKSAtJmd0OyBpcG1pX2JtY191bnJlZ2lzdGVyKCkgLSZndDsgX19pcG1pX2JtY191bnJlZ2lzdGVyKCkgLSZndDsga3JlZl9wdXQoYm1jLSZndDt1c2Vjb3VudCwgY2xlYW51cF9ibWNfZGV2aWNlKTsgLSZndDsgc2NoZWR1bGVfd29yayhibWMtJmd0O3JlbW92ZV93b3JrKTsgVDI6IHJtbW9kIGlwbWlfbXNnaGFuZGxlci4gaXBtaV9tc2doYW5kZXIgbW9kdWxlIHVuaW5zdGFsbGVkLCBhbmQgdGhlIG1vZHVsZSBzcGFjZSB3aWxsIGJlIGZyZWVkLiBUMzogYm1jLSZndDtyZW1vdmVfd29yayBkb2luZyBjbGVhbnVwIHRoZSBibWMgcmVzb3VyY2UuIC0mZ3Q7IGNsZWFudXBfYm1jX3dvcmsoKSAtJmd0OyBwbGF0Zm9ybV9kZXZpY2VfdW5yZWdpc3RlcihibWMtJmd0O3BkZXYpOyAtJmd0OyBwbGF0Zm9ybV9kZXZpY2VfZGVsKHBkZXYpOyAtJmd0OyBkZXZpY2VfZGVsKHBkZXYtJmd0O2Rldik7IC0mZ3Q7IGtvYmplY3RfdWV2ZW50KGRldi0mZ3Q7a29iaiwgS09CSl9SRU1PVkUpOyAtJmd0OyBrb2JqZWN0X3VldmVudF9lbnYoKSAtJmd0OyBkZXZfdWV2ZW50KCkgLSZndDsgaWYgKGRldi0mZ3Q7dHlwZSBkZXYtJmd0O3R5cGUtJmd0O25hbWUpICdkZXYtJmd0O3R5cGUnKGJtY19kZXZpY2VfdHlwZSkgcG9pbnRlciBzcGFjZSBoYXMgZnJlZWQgd2hlbiB1bmluc3RhbGwgaXBtaV9tc2doYW5kZXIgbW9kdWxlLCAnZGV2LSZndDt0eXBlLSZndDtuYW1lJyBjYXVzZSB0aGUgc3lzdGVtIGNyYXNoLiBkcml2ZXJzL2NoYXIvaXBtaS9pcG1pX21zZ2hhbmRsZXIuYzogMjgyMCBzdGF0aWMgY29uc3Qgc3RydWN0IGRldmljZV90eXBlIGJtY19kZXZpY2VfdHlwZSA9IHsgMjgyMSAuZ3JvdXBzID0gYm1jX2Rldl9hdHRyX2dyb3VwcywgMjgyMiB9OyBTdGVwcyB0byByZXByb2R1Y2U6IEFkZCBhIHRpbWUgZGVsYXkgaW4gY2xlYW51cF9ibWNfd29yaygpIGZ1bmN0aW9uLCBhbmQgdW5pbnN0YWxsIGlwbWlfc2kgYW5kIGlwbWlfbXNnaGFuZGxlciBtb2R1bGUuIDI5MTAgc3RhdGljIHZvaWQgY2xlYW51cF9ibWNfd29yayhzdHJ1Y3Qgd29ya19zdHJ1Y3QgKndvcmspIDI5MTEgeyAyOTEyIHN0cnVjdCBibWNfZGV2aWNlICpibWMgPSBjb250YWluZXJfb2Yod29yaywgc3RydWN0IGJtY19kZXZpY2UsIDI5MTMgcmVtb3ZlX3dvcmspOyAyOTE0IGludCBpZCA9IGJtYy0mZ3Q7cGRldi5pZDsgLyogVW5yZWdpc3RlciBvdmVyd3JpdGVzIGlkICovIDI5MTUgMjkxNiBtc2xlZXAoMzAwMCk7IHBkZXYpOyAyOTE4IGlkYV9zaW1wbGVfcmVtb3ZlKGlwbWlfYm1jX2lkYSwgaWQpOyAyOTE5IH0gVXNlICdyZW1vdmVfd29ya193cScgaW5zdGVhZCBvZiAnc3lzdGVtX3dxJyB0byBzb2x2ZSB0aGlzIGlzc3Vlcy4gRml4ZXM6IGIyY2ZkOGFiNGFkZCAoImlwbWk6IFJld29yayBkZXZpY2UgaWQgYW5kIGd1aWQgaGFuZGxpbmcgdG8gY2F0Y2ggY2hhbmdpbmcgQk1DcyIpIFNpZ25lZC1vZmYtYnk6IFd1IEJvIDx3dWJvNDA+IE1lc3NhZ2UtSWQ6ICZsdDsxNjQwMDcwMDM0LTU2NjcxLTEtZ2l0LXNlbmQtZW1haWwtd3VibzQwQGh1YXdlaS5jb20mZ3Q7IFNpZ25lZC1vZmYtYnk6IENvcmV5IE1pbnlhcmQgPGNtaW55YXJkPiBTaWduZWQtb2ZmLWJ5OiBTYXNoYSBMZXZpbiA8c2FzaGFsPiBjb21taXQgMjQ2MGQ5NmMxOWE4NzU3NDVjYTMyODQyMTMwOGNhMWY2OTBjOTIzZSBBdXRob3I6IFdpbGxlbSBkZSBCcnVpam4gPHdpbGxlbWI+IERhdGU6IE1vbiBEZWMgMjAgMDk6NTA6MjcgMjAyMSAtMDUwMCBuZXQ6IHNraXAgdmlydGlvX25ldF9oZHJfc2V0X3Byb3RvIGlmIHByb3RvY29sIGFscmVhZHkgc2V0IFsgVXBzdHJlYW0gY29tbWl0IDFlZDFkNTkyMTEzOTU5ZjAwY2M1NTJjM2I5ZjQ3Y2EyZDE1Nzc2OGYgXSB2aXJ0aW9fbmV0X2hkcl9zZXRfcHJvdG8gaW5mZXJzIHNrYi0mZ3Q7cHJvdG9jb2wgZnJvbSB0aGUgdmlydGlvX25ldF9oZHIgZ3NvX3R5cGUsIHRvIGF2b2lkIHBhY2tldHMgZ2V0dGluZyBkcm9wcGVkIGZvciBsYWNrIG9mIGEgcHJvdG8gdHlwZS4gSXRzIHByb3RvY29sIGNob2ljZSBpcyBhIGd1ZXNzLCBlc3BlY2lhbGx5IGluIHRoZSBjYXNlIG9mIFVGTywgd2hlcmUgdGhlIHNpbmdsZSBWSVJUSU9fTkVUX0hEUl9HU09fVURQIGxhYmVsIGNvdmVycyBib3RoIFVGT3Y0IGFuZCBVRk92Ni4gU2tpcCB0aGlzIGJlc3QgZWZmb3J0IGlmIHRoZSBmaWVsZCBpcyBhbHJlYWR5IGluaXRpYWxpemVkLiBXaGV0aGVyIGV4cGxpY2l0bHkgZnJvbSB1c2Vyc3BhY2UsIG9yIGltcGxpY2l0bHkgYmFzZWQgb24gYW4gZWFybGllciBjYWxsIHRvIGRldl9wYXJzZV9oZWFkZXJfcHJvdG9jb2wgKHdoaWNoIGlzIG1vcmUgcm9idXN0LCBidXQgd2FzIGludHJvZHVjZWQgYWZ0ZXIgdGhpcyBwYXRjaCkuIEZpeGVzOiA5ZDJmNjdlNDNiNzMgKCJuZXQvcGFja2V0OiBmaXggcGFja2V0IGRyb3AgYXMgb2YgdmlydGlvIGdzbyIpIFNpZ25lZC1vZmYtYnk6IFdpbGxlbSBkZSBCcnVpam4gPHdpbGxlbWI+IExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMjAyMTEyMjAxNDUwMjcuMjc4NDI5My0xLXdpbGxlbWRlYnJ1aWpuLmtlcm5lbEBnbWFpbC5jb20gU2lnbmVkLW9mZi1ieTogSmFrdWIgS2ljaW5za2kgPGt1YmE+IFNpZ25lZC1vZmYtYnk6IFNhc2hhIExldmluIDxzYXNoYWw+IGNvbW1pdCA2MjFkNTUzNmI0NTJjM2RmMmE3ZDA5Y2RmODQ3OTNjZWQ1YzQ3NTZkIEF1dGhvcjogV2lsbGVtIGRlIEJydWlqbiA8d2lsbGVtYj4gRGF0ZTogTW9uIERlYyAyMCAwOTo0OTowMSAyMDIxIC0wNTAwIG5ldDogYWNjZXB0IFVGT3Y2IHBhY2thZ2VzIGluIHZpcnRpb19uZXRfaGRyX3RvX3NrYiBbIFVwc3RyZWFtIGNvbW1pdCA3ZTVjY2VkOWNhODRkZjUyZDg3NGFjYTZiNjMyZjkzMGIzZGM1YmM2IF0gU2tiIHdpdGggc2tiLSZndDtwcm90b2NvbCAwIGF0IHRoZSB0aW1lIG9mIHZpcnRpb19uZXRfaGRyX3RvX3NrYiBtYXkgaGF2ZSBhIHByb3RvY29sIGluZmVycmVkIGZyb20gdmlydGlvX25ldF9oZHIgd2l0aCB2aXJ0aW9fbmV0X2hkcl9zZXRfcHJvdG8uIFVubGlrZSBUQ1AsIFVEUCBkb2VzIG5vdCBoYXZlIHNlcGFyYXRlIHR5cGVzIGZvciBJUHY0IGFuZCBJUHY2LiBUeXBlIFZJUlRJT19ORVRfSERSX0dTT19VRFAgaXMgZ3Vlc3NlZCB0byBiZSBJUHY0L1VEUC4gQXMgb2YgdGhlIGJlbG93IGNvbW1pdCwgVUZPdjYgcGFja2V0cyBhcmUgZHJvcHBlZCBkdWUgdG8gbm90IG1hdGNoaW5nIHRoZSBwcm90b2NvbCBhcyBvYnRhaW5lZCBmcm9tIGRldl9wYXJzZV9oZWFkZXJfcHJvdG9jb2wuIEludmVydCB0aGUgdGVzdCB0byB0YWtlIHRoYXQgTDIgcHJvdG9jb2wgZmllbGQgYXMgc3RhcnRpbmcgcG9pbnQgYW5kIHBhc3MgYm90aCBVRk92NCBhbmQgVUZPdjYgZm9yIFZJUlRJT19ORVRfSERSX0dTT19VRFAuIEZpeGVzOiA5MjRhOWJjMzYyYTUgKCJuZXQ6IGNoZWNrIGlmIHByb3RvY29sIGV4dHJhY3RlZCBieSB2aXJ0aW9fbmV0X2hkcl9zZXRfcHJvdG8gaXMgY29ycmVjdCIpIExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL25ldGRldi9DQUJjcTNwRzlHUkNZcUZEQkFKNDhIMXZwbm5YPTQxdStNaFFuYXlGMXp0TEg0V1gwRndAbWFpbC5nbWFpbC5jb20vIFJlcG9ydGVkLWJ5OiBBbmRyZXcgTWVsbmljaGVua28gPGFuZHJldz4gU2lnbmVkLW9mZi1ieTogV2lsbGVtIGRlIEJydWlqbiA8d2lsbGVtYj4gTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8yMDIxMTIyMDE0NDkwMS4yNzg0MDMwLTEtd2lsbGVtZGVicnVpam4ua2VybmVsQGdtYWlsLmNvbSBTaWduZWQtb2ZmLWJ5OiBKYWt1YiBLaWNpbnNraSA8a3ViYT4gU2lnbmVkLW9mZi1ieTogU2FzaGEgTGV2aW4gPHNhc2hhbD4gY29tbWl0IDBiMDFjNTFjNGY0N2Y1OWFkN2ViMWVhNWJhYzQ3ZmFiMTRiMTg4YTUgQXV0aG9yOiBKaWFzaGVuZyBKaWFuZyA8amlhc2hlbmc+IERhdGU6IEZyaSBEZWMgMTcgMTc6Mzk6MTEgMjAyMSArMDgwMCBxbGNuaWM6IHBvdGVudGlhbCBkZXJlZmVyZW5jZSBudWxsIHBvaW50ZXIgb2YgcnhfcXVldWUtJmd0O3BhZ2VfcmluZyBbIFVwc3RyZWFtIGNvbW1pdCA2MGVjN2ZjZmU3Njg5MmExNDc5YWZhYjUxZmYxN2E0MjgxOTIzMTU2IF0gVGhlIHJldHVybiB2YWx1ZSBvZiBrY2FsbG9jKCkgbmVlZHMgdG8gYmUgY2hlY2tlZC4gVG8gYXZvaWQgZGVyZWZlcmVuY2Ugb2YgbnVsbCBwb2ludGVyIGluIGNhc2Ugb2YgdGhlIGZhaWx1cmUgb2YgYWxsb2MuIFRoZXJlZm9yZSwgaXQgbWlnaHQgYmUgYmV0dGVyIHRvIGNoYW5nZSB0aGUgcmV0dXJuIHR5cGUgb2YgcWxjbmljX3NyaW92X2FsbG9jX3ZsYW5zKCkgYW5kIHJldHVybiAtRU5PTUVNIHdoZW4gYWxsb2MgZmFpbHMgYW5kIHJldHVybiAwIHRoZSBvdGhlcnMuIEFsc28sIHFsY25pY19zcmlvdl9zZXRfZ3Vlc3Rfdmxhbl9tb2RlKCkgYW5kIF9fcWxjbmljX3BjaV9zcmlvdl9lbmFibGUoKSBzaG91bGQgZGVhbCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgcWxjbmljX3NyaW92X2FsbG9jX3ZsYW5zKCkuIEZpeGVzOiAxNTRkMGM4MTBjNTMgKCJxbGNuaWM6IFZMQU4gZW5oYW5jZW1lbnQgZm9yIDg0WFggYWRhcHRlcnMiKSBTaWduZWQtb2ZmLWJ5OiBKaWFzaGVuZyBKaWFuZyA8amlhc2hlbmc+IFNpZ25lZC1vZmYtYnk6IERhdmlkIFMuIE1pbGxlciA8ZGF2ZW0+IFNpZ25lZC1vZmYtYnk6IFNhc2hhIExldmluIDxzYXNoYWw+IGNvbW1pdCA2ODVmYzhkMjI0ODlhYTMxOTQ2NWQwZGRmODQ4ZTZkNzIxMGFlMTdhIEF1dGhvcjogSWduYWN5IEdhd8SZZHpraSA8aWduYWN5Lmdhd2VkemtpPiBEYXRlOiBGcmkgRGVjIDEwIDE2OjMxOjI3IDIwMjEgKzAxMDAgbmV0ZmlsdGVyOiBmaXggcmVncmVzc2lvbiBpbiBsb29wZWQgKGJyb2FkfG11bHRpKWNhc3QncyBNQUMgaGFuZGxpbmcgWyBVcHN0cmVhbSBjb21taXQgZWJiOTY2ZDNiZGZlZDU4MWVjY2NiYjRhNzQzMjM0MWJhZjc2MTliNCBdIEluIGNvbW1pdCA1NjQ4YjVlMTE2OWYgKCJuZXRmaWx0ZXI6IG5mbmV0bGlua19xdWV1ZTogZml4IE9PQiB3aGVuIG1hYyBoZWFkZXIgd2FzIGNsZWFyZWQiKSwgdGhlIHRlc3QgZm9yIG5vbi1lbXB0eSBNQUMgaGVhZGVyIGludHJvZHVjZWQgaW4gY29tbWl0IDJjMzhkZTRjMWY4ZGE3ICgibmV0ZmlsdGVyOiBmaXggbG9vcGVkIChicm9hZHxtdWx0aSljYXN0J3MgTUFDIGhhbmRsaW5nIikgaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBhIHRlc3QgZm9yIGEgc2V0IE1BQyBoZWFkZXIuIFRoaXMgYnJlYWtzIHRoZSBjYXNlIHdoZW4gdGhlIE1BQyBoZWFkZXIgaGFzIGJlZW4gcmVzZXQgKHVzaW5nIHNrYl9yZXNldF9tYWNfaGVhZGVyKSwgYXMgaXMgdGhlIGNhc2Ugd2l0aCBsb29wZWQtYmFjayBtdWx0aWNhc3QgcGFja2V0cy4gQXMgYSByZXN1bHQsIHRoZSBwYWNrZXRzIGVuZGluZyB1cCBpbiBORlFVRVVFIGdldCBhIGJvZ3VzIGh3YWRkciBpbnRlcnByZXRlZCBmcm9tIHRoZSBmaXJzdCBieXRlcyBvZiB0aGUgSVAgaGVhZGVyLiBUaGlzIHBhdGNoIGFkZHMgYSB0ZXN0IGZvciBhIG5vbi1lbXB0eSBNQUMgaGVhZGVyIGluIGFkZGl0aW9uIHRvIHRoZSB0ZXN0IGZvciBhIHNldCBNQUMgaGVhZGVyLiBUaGUgc2FtZSB0d28gdGVzdHMgYXJlIGFsc28gaW1wbGVtZW50ZWQgaW4gbmZuZXRsaW5rX2xvZy5jLCB3aGVyZSB0aGUgaW5pdGlhbCBjb2RlIG9mIGNvbW1pdCAyYzM4ZGU0YzFmOGRhNyAoIm5ldGZpbHRlcjogZml4IGxvb3BlZCAoYnJvYWR8bXVsdGkpY2FzdCdzIE1BQyBoYW5kbGluZyIpIGhhcyBub3QgYmVlbiB0b3VjaGVkLCBidXQgd2hlcmUgc3VwcG9zZWRseSB0aGUgc2FtZSBzaXR1YXRpb24gbWF5IGhhcHBlbi4gRml4ZXM6IDU2NDhiNWUxMTY5ZiAoIm5ldGZpbHRlcjogbmZuZXRsaW5rX3F1ZXVlOiBmaXggT09CIHdoZW4gbWFjIGhlYWRlciB3YXMgY2xlYXJlZCIpIFNpZ25lZC1vZmYtYnk6IElnbmFjeSBHYXfEmWR6a2kgPGlnbmFjeS5nYXdlZHpraT4gUmV2aWV3ZWQtYnk6IEZsb3JpYW4gV2VzdHBoYWwgPGZ3PiBTaWduZWQtb2ZmLWJ5OiBQYWJsbyBOZWlyYSBBeXVzbyA8cGFibG8+IFNpZ25lZC1vZmYtYnk6IFNhc2hhIExldmluIDxzYXNoYWw+IGNvbW1pdCA3OWRjYmQ4MTc2MTUyYjg2MDAyOGI2MmY4MWE2MzVkOTg3MzY1NzUyIEF1dGhvcjogSm9zw6kgRXhww7NzaXRvIDxqb3NlLmV4cG9zaXRvODk+IERhdGU6IFdlZCBEZWMgOCAxODo1MjozOCAyMDIxICswMTAwIElCL3FpYjogRml4IG1lbW9yeSBsZWFrIGluIHFpYl91c2VyX3NkbWFfcXVldWVfcGt0cygpIFsgVXBzdHJlYW0gY29tbWl0IGJlZTkwOTExZTAxMzhjNzZlZTY3NDU4YWMwZDU4YjM4YTMxOTBmNjUgXSBUaGUgd3JvbmcgZ290byBsYWJlbCB3YXMgdXNlZCBmb3IgdGhlIGVycm9yIGNhc2UgYW5kIG1pc3NlZCBjbGVhbnVwIG9mIHRoZSBwa3QgYWxsb2NhdGlvbi4gRml4ZXM6IGQzOWJmNDBlNTVlNiAoIklCL3FpYjogUHJvdGVjdCBmcm9tIGJ1ZmZlciBvdmVyZmxvdyBpbiBzdHJ1Y3QgcWliX3VzZXJfc2RtYV9wa3QgZmllbGRzIikgTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8yMDIxMTIwODE3NTIzOC4yOTk4My0xLWpvc2UuZXhwb3NpdG84OUBnbWFpbC5jb20gQWRkcmVzc2VzLUNvdmVyaXR5LUlEOiAxNDkzMzUyICgiUmVzb3VyY2UgbGVhayIpIFNpZ25lZC1vZmYtYnk6IEpvc8OpIEV4cMOzc2l0byA8am9zZS5leHBvc2l0bzg5PiBBY2tlZC1ieTogTWlrZSBNYXJjaW5pc3p5biA8bWlrZS5tYXJjaW5pc3p5bj4gU2lnbmVkLW9mZi1ieTogSmFzb24gR3VudGhvcnBlIDxqZ2c+IFNpZ25lZC1vZmYtYnk6IFNhc2hhIExldmluIDxzYXNoYWw+IGNvbW1pdCA3ODg3NGJjYTRmMjcxZDk2Y2Y2NmJiYTQ5YTRiYzc5NmU3ODBjZTg5IEF1dGhvcjogRG9uZ2xpYW5nIE11IDxtdWRvbmdsaWFuZ2FiY2Q+IERhdGU6IE1vbiBEZWMgNiAxODoxOTozMSAyMDIxICswODAwIHNwaTogY2hhbmdlIGNsa19kaXNhYmxlX3VucHJlcGFyZSB0byBjbGtfdW5wcmVwYXJlIFsgVXBzdHJlYW0gY29tbWl0IGRiNjY4OWI2NDNkODY1MzA5MmY1ODUzNzUxZWEyY2RiYzI5OWY4ZDMgXSBUaGUgY29ycmVzcG9uZGluZyBBUEkgZm9yIGNsa19wcmVwYXJlIGlzIGNsa191bnByZXBhcmUsIG90aGVyIHRoYW4gY2xrX2Rpc2FibGVfdW5wcmVwYXJlLiBGaXggdGhpcyBieSBjaGFuZ2luZyBjbGtfZGlzYWJsZV91bnByZXBhcmUgdG8gY2xrX3VucHJlcGFyZS4gRml4ZXM6IDU3NjJhYjcxZWIyNCAoInNwaTogQWRkIHN1cHBvcnQgZm9yIEFybWFkYSAzNzAwIFNQSSBDb250cm9sbGVyIikgU2lnbmVkLW9mZi1ieTogRG9uZ2xpYW5nIE11IDxtdWRvbmdsaWFuZ2FiY2Q+IExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMjAyMTEyMDYxMDE5MzEuMjgxNjU5Ny0xLW11ZG9uZ2xpYW5nYWJjZEBnbWFpbC5jb20gU2lnbmVkLW9mZi1ieTogTWFyayBCcm93biBTaWduZWQtb2ZmLWJ5OiBTYXNoYSBMZXZpbiA8c2FzaGFsPiBjb21taXQgMGMwYWMyNTQ3Yzg3M2QyMzQyZjYwZGIzYTQwNTQ1ZjZiM2Y2ZDUxOSBBdXRob3I6IFJvYmVydCBNYXJrbyA8cm9iZXJ0Lm1hcmtvPiBEYXRlOiBXZWQgTm92IDE3IDE1OjAyOjIyIDIwMjEgKzAxMDAgYXJtNjQ6IGR0czogYWxsd2lubmVyOiBvcmFuZ2VwaS16ZXJvLXBsdXM6IGZpeCBQSFkgbW9kZSBbIFVwc3RyZWFtIGNvbW1pdCAwOGQyMDYxZmY5YzUzMTlhMDdiZjljYTZiYmYxMWZkZWM2OGY3MDRhIF0gT3JhbmdlIFBpIFplcm8gUGx1cyB1c2VzIGEgUmVhbHRlayBSVEw4MjExRSBSR01JSSBHaWdhYml0IFBIWSwgYnV0IGl0cyBjdXJyZW50bHkgc2V0IHRvIHBsYWluIFJHTUlJIG1vZGUgbWVhbmluZyB0aGF0IGl0IGRvZXNuJ3QgaW50cm9kdWNlIGRlbGF5cy4gV2l0aCB0aGlzIHNldHVwLCBUWCBwYWNrZXRzIGFyZSBjb21wbGV0ZWx5IGxvc3QgYW5kIGNoYW5naW5nIHRoZSBtb2RlIHRvIFJHTUlJLUlEIHNvIHRoZSBQSFkgd2lsbCBhZGQgZGVsYXlzIGludGVybmFsbHkgZml4ZXMgdGhlIGlzc3VlLiBGaXhlczogYTdhZmZiMTNiMjcxICgiYXJtNjQ6IGFsbHdpbm5lcjogSDU6IEFkZCBYdW5sb25nIE9yYW5nZSBQaSBaZXJvIFBsdXMiKSBBY2tlZC1ieTogQ2hlbi1ZdSBUc2FpIDx3ZW5zPiBUZXN0ZWQtYnk6IFJvbiBHb29zc2VucyA8cmdvb3NzZW5zPiBUZXN0ZWQtYnk6IFNhbXVlbCBIb2xsYW5kIDxzYW11ZWw+IFNpZ25lZC1vZmYtYnk6IFJvYmVydCBNYXJrbyA8cm9iZXJ0Lm1hcmtvPiBTaWduZWQtb2ZmLWJ5OiBNYXhpbWUgUmlwYXJkIDxtYXhpbWU+IExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMjAyMTExMTcxNDAyMjIuNDM2OTItMS1yb2JlcnQubWFya29Ac2FydHVyYS5ociBTaWduZWQtb2ZmLWJ5OiBTYXNoYSBMZXZpbiA8c2FzaGFsPiBjb21taXQgNmZhNGUyOTkyNzE3YzY3YzMyNDNlODhhODM0MmI3OTViOTM5ZTVhMiBBdXRob3I6IEJlbmphbWluIFRpc3NvaXJlcyA8YmVuamFtaW4udGlzc29pcmVzPiBEYXRlOiBNb24gRGVjIDIwIDEwOjUxOjIwIDIwMjEgKzAxMDAgSElEOiBob2x0ZWs6IGZpeCBtb3VzZSBwcm9iaW5nIGNvbW1pdCA5M2EyMjA3YzI1NGNhMTAyZWJiZGFlNDdiMDBmMTliYmZiZmE3ZWNkIHVwc3RyZWFtLiBBbiBvdmVybG9vayBmcm9tIHRoZSBwcmV2aW91cyBjb21taXQ6IHdlIGRvbid0IGV2ZW4gcGFyc2Ugb3Igc3RhcnQgdGhlIGRldmljZSwgbWVhbmluZyB0aGF0IHRoZSBkZXZpY2UgaXMgbm90IHByZXNlbnRlZCB0byB1c2VyIHNwYWNlLiBGaXhlczogOTMwMjA5NTNkMGZhICgiSElEOiBjaGVjayBmb3IgdmFsaWQgVVNCIGRldmljZSBmb3IgbWFueSBISUQgZHJpdmVycyIpIENjOiBzdGFibGVAdmdlci5rZXJuZWwub3JnIExpbms6IGh0dHBzOi8vYnVncy5hcmNobGludXgub3JnL3Rhc2svNzMwNDggTGluazogaHR0cHM6Ly9idWd6aWxsYS5rZXJuZWwub3JnL3Nob3dfYnVnLmNnaT9pZD0yMTUzNDEgTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci9lNGVmYmYxMy1iZDhkLTAzNzAtNjI5Yi02YzgwYzAwNDRiMTVAbGVlbWh1aXMuaW5mby8gU2lnbmVkLW9mZi1ieTogQmVuamFtaW4gVGlzc29pcmVzIDxiZW5qYW1pbi50aXNzb2lyZXM+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgMjcxMjgxNmMxMGIzYzU5OTA5Mzk5ZjQ4Y2NlMmRjNmQyMTgwYzdlOSBBdXRob3I6IEppLVplIEhvbmcgKFBldGVyIEhvbmcpIDxocGV0ZXI+IERhdGU6IFdlZCBEZWMgMTUgMTU6NTg6MzUgMjAyMSArMDgwMCBzZXJpYWw6IDgyNTBfZmludGVrOiBGaXggZ2FyYmxlZCB0ZXh0IGZvciBjb25zb2xlIGNvbW1pdCA2YzMzZmY3Mjg4MTJhYTE4NzkyYWZmZmFmMmM5ODczYjg5OGU3NTEyIHVwc3RyZWFtLiBDb21taXQgZmFiOGEwMmI3M2ViICgic2VyaWFsOiA4MjUwX2ZpbnRlazogRW5hYmxlIGhpZ2ggc3BlZWQgbW9kZSBvbiBGaW50ZWsgRjgxODY2IikgaW50cm9kdWNlZCBzdXBwb3J0IHRvIHVzZSBoaWdoIGJhdWRyYXRlIHdpdGggRmludGVrIFN1cGVySU8gVUFSVHMuIEl0J2xsIGNoYW5nZSBjbG9ja3NvdXJjZXMgd2hlbiB0aGUgVUFSVCBwcm9iZWQuIEJ1dCB3aGVuIHVzZXIgYWRkIGtlcm5lbCBwYXJhbWV0ZXIgImNvbnNvbGU9dHR5UzAsMTE1MjAwIGNvbnNvbGU9dHR5MCIgdG8gbWFrZSB0aGUgVUFSVCBhcyBjb25zb2xlIG91dHB1dCwgdGhlIGNvbnNvbGUgd2lsbCBvdXRwdXQgZ2FyYmxlZCB0ZXh0IGFmdGVyIHRoZSBmb2xsb3dpbmcga2VybmVsIG1lc3NhZ2UuIFsgMy42ODExODhdIFNlcmlhbDogODI1MC8xNjU1MCBkcml2ZXIsIDMyIHBvcnRzLCBJUlEgc2hhcmluZyBlbmFibGVkIFRoZSBpc3N1ZSBpcyBvY2N1cnMgaW4gZm9sbG93aW5nIHN0ZXA6IHByb2JlX3NldHVwX3BvcnQoKSAtJmd0OyBmaW50ZWtfODI1MF9nb3RvX2hpZ2hzcGVlZCgpIEl0IGNoYW5nZSBjbG9ja3NvdXJjZSBmcm9tIDExNTIwMCB0byA5MjE2MDAgd2l0aCB3cm9uZyB0aW1lLCBpdCBzaG91bGQgY2hhbmdlIGNsb2Nrc291cmNlIGluIHNldF90ZXJtaW9zKCkgbm90IGluIHByb2JlZC4gVGhlIGZvbGxvd2luZyAzIHBhdGNoZXMgYXJlIGltcGxlbWVudGVkIGNoYW5nZSBjbG9ja3NvdXJjZSBpbiBmaW50ZWtfODI1MF9zZXRfdGVybWlvcygpLiBDb21taXQgNTgxNzg5MTRhZTViICgic2VyaWFsOiA4MjUwX2ZpbnRlazogVUFSVCBkeW5hbWljIGNsb2Nrc291cmNlIG9uIEZpbnRlayBGODEyMTZIIikgQ29tbWl0IDE5NTYzOGI2ZDQ0ZiAoInNlcmlhbDogODI1MF9maW50ZWs6IFVBUlQgZHluYW1pYyBjbG9ja3NvdXJjZSBvbiBGaW50ZWsgRjgxODY2IikgQ29tbWl0IDQyM2Q5MTE4YzYyNCAoInNlcmlhbDogODI1MF9maW50ZWs6IEFkZCBGODE5NjYgU3VwcG9ydCIpIER1ZSB0byB0aGUgaGlnaCBiYXVkIHJhdGUgaGFkIGltcGxlbWVudGVkIGFib3ZlIDMgcGF0Y2hlcyBhbmQgdGhlIHBhdGNoIENvbW1pdCBmYWI4YTAyYjczZWIgKCJzZXJpYWw6IDgyNTBfZmludGVrOiBFbmFibGUgaGlnaCBzcGVlZCBtb2RlIG9uIEZpbnRlayBGODE4NjYiKSBpcyBidWdnZWQsIFNvIHRoaXMgcGF0Y2ggd2lsbCByZW1vdmUgaXQuIEZpeGVzOiBmYWI4YTAyYjczZWIgKCJzZXJpYWw6IDgyNTBfZmludGVrOiBFbmFibGUgaGlnaCBzcGVlZCBtb2RlIG9uIEZpbnRlayBGODE4NjYiKSBTaWduZWQtb2ZmLWJ5OiBKaS1aZSBIb25nIChQZXRlciBIb25nKSA8aHBldGVyPiBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMjE1MDc1ODM1LjIwNzItMS1ocGV0ZXIrbGludXhfa2VybmVsQGdtYWlsLmNvbSBDYzogc3RhYmxlIDxzdGFibGU+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgNTFjOTI1YTliY2NjYzY0MjM5N2FkMzI4M2MwNGNjYzRlNmIxMzUzNCBBdXRob3I6IEdyZWcgSmVzaW9ub3dza2kgPGplc2lvbm93c2tpZ3JlZz4gRGF0ZTogVHVlIERlYyAxNCAxNToxMDoyNyAyMDIxIC0wNzAwIG5ldDogdXNiOiBsYW43OHh4OiBhZGQgQWxsaWVkIFRlbGVzaXMgQVQyOU0yLUFGIGNvbW1pdCBlZjhhMGY2ZWFiMWNhNWQxYTc1YzI0MmM1YzdiOWQzODY3MzVmYTBhIHVwc3RyZWFtLiBUaGlzIGFkZHMgdGhlIHZlbmRvciBhbmQgcHJvZHVjdCBJRHMgZm9yIHRoZSBBVDI5TTItQUYgd2hpY2ggaXMgYSBsYW43ODAxLWJhc2VkIGRldmljZS4gU2lnbmVkLW9mZi1ieTogR3JlZyBKZXNpb25vd3NraSA8amVzaW9ub3dza2lncmVnPiBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMjE0MjIxMDI3LjMwNTc4NC0xLWplc2lvbm93c2tpZ3JlZ0BnbWFpbC5jb20gU2lnbmVkLW9mZi1ieTogSmFrdWIgS2ljaW5za2kgPGt1YmE+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPjwvZ3JlZ2toPjwva3ViYT48L2plc2lvbm93c2tpZ3JlZz48L2plc2lvbm93c2tpZ3JlZz48L2dyZWdraD48L3N0YWJsZT48L2hwZXRlcj48L2hwZXRlcj48L2dyZWdraD48L2JlbmphbWluLnRpc3NvaXJlcz48L2JlbmphbWluLnRpc3NvaXJlcz48L3Nhc2hhbD48L21heGltZT48L3JvYmVydC5tYXJrbz48L3NhbXVlbD48L3Jnb29zc2Vucz48L3dlbnM+PC9yb2JlcnQubWFya28+PC9zYXNoYWw+PC9icm9vbmllPjwvbXVkb25nbGlhbmdhYmNkPjwvbXVkb25nbGlhbmdhYmNkPjwvc2FzaGFsPjwvamdnPjwvbWlrZS5tYXJjaW5pc3p5bj48L2pvc2UuZXhwb3NpdG84OT48L2pvc2UuZXhwb3NpdG84OT48L3Nhc2hhbD48L3BhYmxvPjwvZnc+PC9pZ25hY3kuZ2F3ZWR6a2k+PC9pZ25hY3kuZ2F3ZWR6a2k+PC9zYXNoYWw+PC9kYXZlbT48L2ppYXNoZW5nPjwvamlhc2hlbmc+PC9zYXNoYWw+PC9rdWJhPjwvd2lsbGVtYj48L2FuZHJldz48L3dpbGxlbWI+PC9zYXNoYWw+PC9rdWJhPjwvd2lsbGVtYj48L3dpbGxlbWI+PC9zYXNoYWw+PC9jbWlueWFyZD48L3d1Ym80MD48L3d1Ym80MD48L3Nhc2hhbD48L2t1YmE+PC9qYXkudm9zYnVyZ2g+PC9mZm1hbmNlcmE+PC9mZm1hbmNlcmE+PC9zYXNoYWw+PC9kYXZlbT48L2ppYXNoZW5nPjwvamlhc2hlbmc+PC9zYXNoYWw+PC9kYXZlbT48L2ppYXNoZW5nPjwvamlhc2hlbmc+PC9zYXNoYWw+PC9rdWJhPjwvaGFiZXRzbS54aWxpbng+PC9qaWFzaGVuZz48L2ppYXNoZW5nPjwvc2FzaGFsPjwvZG1pdHJ5LnRvcm9raG92Pjwvd3NhPjwvYW5kcmVhLnJpZ2hpPjwvYW5kcmVhLnJpZ2hpPjwvc2FzaGFsPjwvbGludXg+PC9saW51eD48L3Nhc2hhbD48L2xpbnV4Pjwva3JlbGxhbj48L2tyZWxsYW4+PC9zYXNoYWw+PC9saW51eD48L2RhdmlkLndpbHNvbj48L2RhdmlkLndpbHNvbj48L2xpbnV4Pjwvc2FzaGFsPjwvbGludXg+PC9kYXZpZC53aWxzb24+PC9saW51eD48L3Nhc2hhbD48L2xpbnV4Pjwva3JlbGxhbj48L2xpbnV4PjwvZ3JlZ2toPjwvdGl3YWk+PC9zdGFibGU+PC94a2VybmVsLndhbmc+PC94a2VybmVsLndhbmc+PC9ncmVna2g+PC90aXdhaT48L3N0YWJsZT48L2NvbGluLmkua2luZz48L2NvbGluLmtpbmc+PC9ncmVna2g+PC90aXdhaT48L3N0YWJsZT48L2JyYWRsZXkuc2NvdHQ+PC9icmFkbGV5LnNjb3R0PjwvZ3JlZ2toPjwvZG1pdHJ5LnRvcm9raG92Pjwvam9zZS5leHBvc2l0bzg5Pjwvam9zZS5leHBvc2l0bzg5PjwvZ3JlZ2toPjwvY21pbnlhcmQ+PC9jbWlueWFyZD48L2Nhc2NhcmRvPjwvY2FzY2FyZG8+PC9ncmVna2g+PC9jbWlueWFyZD48L3lrYXVrYWI+PC90aXdhaT48L3lrYXVrYWI+PC9ncmVna2g+PC9jbWlueWFyZD48L2lvYW5uYS1tYXJpYS5hbGlmaWVyYWtpPjwvY21pbnlhcmQ+PC9jYXNjYXJkbz48L2Nhc2NhcmRvPjwvZ3JlZ2toPjwvZGF2ZS5hbmdsaW4+PC9kYXZlLmFuZ2xpbj48L2dyZWdraD48L2JwPjwvZGF2ZS5oYW5zZW4+PC9hbmRyZXcuY29vcGVyMz48L2FuZHJldy5jb29wZXIzPjwvZ3JlZ2toPjwvbGludXMud2FsbGVpaj48L2ZhYmllbi5kZXNzZW5uZT48L2NoZi5mcml0ej48L2ZhYmllbi5kZXNzZW5uZT48L2dyZWdraD48L3VsZi5oYW5zc29uPjwvYWRyaWFuLmh1bnRlcj48L3BzaGV0ZT48L3BzaGV0ZT48L2dyZWdraD48L3VsZi5oYW5zc29uPjwvYWRyaWFuLmh1bnRlcj48L2FsY29vcGVyeD48L3VsZi5oYW5zc29uPjwvZ3JlZ2toPjwvcm1rPjwvYXJkYj48L3N0YWJsZT48L2FyZGI+PC9ncmVna2g+PC9qZW5zLndpa2xhbmRlcj48L3R5aGlja3M+PC9zdW1pdC5nYXJnPjwvcGF0cmlrLmxhbnR6Pjwvc3VtaXQuZ2FyZz48L2dyZWdraD48L2phZWdldWs+PC9jaGFvPjwvd2VucWluZ2xpdTAxMjA+PC9jaGFvPjwvZ3JlZ2toPjwvcG9zdGV1Y2E+PC9wb3N0ZXVjYT48L2dyZWdraD48L3Bib256aW5pPjwvbWxldml0c2s+PC9zZWFuamM+PC9zZWFuamM+PC9ncmVna2g+PC90b3J2YWxkcz48L2FrcG0+PC9zdGFibGU+PC9hYXJjYW5nZT48L3JpZW50amVzPjwvbWdvcm1hbj48L21ob2Nrbz48L2FyYm4+PC9udW1haWYuaD48L3N0ZGlvLmg+PC9zdGRsaWIuaD48L2Fzc2VydC5oPjwvZmNudGwuaD48L3N5cz48L3N5cz48L3VuaXN0ZC5oPjwvYXJibj48L2dyZWdraD48L2xpbnVzLndhbGxlaWo+PC93ZW5zdD48L3poaXlvbmcudGFvPjwvZ3VvZG9uZy5saXU+PC9ndW9kb25nLmxpdT48L2dyZWdraD48L2xpbnV4PjwvbGludXg+PC9ncmVna2g+PC9saW51eD48L2xpbnV4PjwvZ3JlZ2toPjwvZGF2ZW0+PC9saW5tYT48L25hZ2k+PC9saW5tYT48L2dyZWdraD48L2RhdmVtPjwvbGlubWE+PC9saW5tYT48L2dyZWdraD48L2RhdmVtPjwvbGlubWE+PC9saW5tYT48L2dyZWdraD48L2RhdmVtPjwvcmVtaT48L3JlbWk+PC9ncmVna2g+PC9za2hhbj48L2xpbnV4Pjwvc3VkaXAubXVraGVyamVlPjwvbGtmdD48L2h1bGtyb2JvdD48L2YuZmFpbmVsbGk+PC9ncmVna2g+PC9wPjwvYm9keT4='</script>

      </head>
        <body class="valid" valid="valid" title="valid: True, node: 1, tag: body, level: 1" node_number="1"><p class="valid" valid="valid" title="valid: True, node: 2, tag: p, level: 2" node_number="2">commit 4ca2eaf1d477ce4316989b22e765fb915652b86e Author: Greg Kroah-Hartman <gregkh class="valid" valid="valid" title="valid: True, node: 3, tag: gregkh, level: 3" node_number="3"> Date: Wed Dec 29 12:23:38 2021 +0100 Linux 5.4.169 Link: https://lore.kernel.org/r/20211227151320.801714429@linuxfoundation.org Tested-by: Florian Fainelli <f.fainelli class="valid" valid="valid" title="valid: True, node: 4, tag: f.fainelli, level: 4" node_number="4"> Tested-by: Hulk Robot <hulkrobot class="valid" valid="valid" title="valid: True, node: 5, tag: hulkrobot, level: 5" node_number="5"> Tested-by: Linux Kernel Functional Testing <lkft class="valid" valid="valid" title="valid: True, node: 6, tag: lkft, level: 6" node_number="6"> Tested-by: Sudip Mukherjee <sudip.mukherjee class="valid" valid="valid" title="valid: True, node: 7, tag: sudip.mukherjee, level: 7" node_number="7"> Tested-by: Guenter Roeck <linux class="valid" valid="valid" title="valid: True, node: 8, tag: linux, level: 8" node_number="8"> Tested-by: Shuah Khan <skhan class="valid" valid="valid" title="valid: True, node: 9, tag: skhan, level: 9" node_number="9"> Signed-off-by: Greg Kroah-Hartman <gregkh class="valid" valid="valid" title="valid: True, node: 10, tag: gregkh, level: 10" node_number="10"> commit 48c76fc53582e7f13c1e0b11c916e503256c4d0b Author: R&#233;mi Denis-Courmont <remi class="valid" valid="valid" title="valid: True, node: 11, tag: remi, level: 11" node_number="11"> Date: Sun Dec 19 19:03:39 2021 +0200 phonet/pep: refuse to enable an unbound pipe commit 75a2f31520095600f650597c0ac41f48b5ba0068 upstream. This ioctl() implicitly assumed that the socket was already bound to a valid local socket name, i.e. Phonet object. If the socket was not bound, two separate problems would occur: 1) We'd send an pipe enablement request with an invalid source object. 2) Later socket calls could BUG on the socket unexpectedly being connected yet not bound to a valid object. Reported-by: syzbot+2dc91e7fc3dea88b1e8a@syzkaller.appspotmail.com Signed-off-by: R&#233;mi Denis-Courmont <remi class="valid" valid="valid" title="valid: True, node: 12, tag: remi, level: 12" node_number="12"> Signed-off-by: David S. Miller <davem class="valid" valid="valid" title="valid: True, node: 13, tag: davem, level: 13" node_number="13"> Signed-off-by: Greg Kroah-Hartman <gregkh class="valid" valid="valid" title="valid: True, node: 14, tag: gregkh, level: 14" node_number="14"> commit a5c6a13e9056d87805ba3042c208fbd4164ad22b Author: Lin Ma <linma title="valid: False, node: 15, tag: linma, level: 15" node_number="15"> Date: Fri Dec 17 10:13:56 2021 +0800 hamradio: improve the incomplete fix to avoid NPD commit b2f37aead1b82a770c48b5d583f35ec22aabb61e upstream. The previous commit 3e0588c291d6 ("hamradio: defer ax25 kfree after unregister_netdev") reorder the kfree operations and unregister_netdev operation to prevent UAF. This commit improves the previous one by also deferring the nullify of the ax-&gt;tty pointer. Otherwise, a NULL pointer dereference bug occurs. Partial of the stack trace is shown below. BUG: kernel NULL pointer dereference, address: 0000000000000538 RIP: 0010:ax_xmit+0x1f9/0x400 ... Call Trace: dev_hard_start_xmit+0xec/0x320 sch_direct_xmit+0xea/0x240 __qdisc_run+0x166/0x5c0 __dev_queue_xmit+0x2c7/0xaf0 ax25_std_establish_data_link+0x59/0x60 ax25_connect+0x3a0/0x500 ? security_socket_connect+0x2b/0x40 __sys_connect+0x96/0xc0 ? __hrtimer_init+0xc0/0xc0 ? common_nsleep+0x2e/0x50 ? switch_fpu_return+0x139/0x1a0 __x64_sys_connect+0x11/0x20 do_syscall_64+0x33/0x40 entry_SYSCALL_64_after_hwframe+0x44/0xa9 The crash point is shown as below static void ax_encaps(...) { ... set_bit(TTY_DO_WRITE_WAKEUP, ax-&gt;tty-&gt;flags); // ax-&gt;tty = NULL! ... } By placing the nullify action after the unregister_netdev, the ax-&gt;tty pointer won't be assigned as NULL net_device framework layer is well synchronized. Signed-off-by: Lin Ma <linma title="valid: False, node: 16, tag: linma, level: 16" node_number="16"> Signed-off-by: David S. Miller <davem title="valid: False, node: 17, tag: davem, level: 17" node_number="17"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 18, tag: gregkh, level: 18" node_number="18"> commit ef5f7bfa19e3fc366f4c6d1a841ceaddf7a9f5d4 Author: Lin Ma <linma title="valid: False, node: 19, tag: linma, level: 19" node_number="19"> Date: Mon Nov 8 18:37:21 2021 +0800 hamradio: defer ax25 kfree after unregister_netdev commit 3e0588c291d6ce225f2b891753ca41d45ba42469 upstream. There is a possible race condition (use-after-free) like below (USE) | (FREE) ax25_sendmsg | ax25_queue_xmit | dev_queue_xmit | __dev_queue_xmit | __dev_xmit_skb | sch_direct_xmit | ... xmit_one | netdev_start_xmit | tty_ldisc_kill __netdev_start_xmit | mkiss_close ax_xmit | kfree ax_encaps | | Even though there are two synchronization primitives before the kfree: 1. wait_for_completion(ax-&gt;dead). This can prevent the race with routines from mkiss_ioctl. However, it cannot stop the routine coming from upper layer, i.e., the ax25_sendmsg. 2. netif_stop_queue(ax-&gt;dev). It seems that this line of code aims to halt the transmit queue but it fails to stop the routine that already being xmit. This patch reorder the kfree after the unregister_netdev to avoid the possible UAF as the unregister_netdev() is well synchronized and won't return if there is a running routine. Signed-off-by: Lin Ma <linma title="valid: False, node: 20, tag: linma, level: 20" node_number="20"> Signed-off-by: David S. Miller <davem title="valid: False, node: 21, tag: davem, level: 21" node_number="21"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 22, tag: gregkh, level: 22" node_number="22"> commit df8f79bcc2e431bb6e1f0a8202cd2b06fd429889 Author: Lin Ma <linma title="valid: False, node: 23, tag: linma, level: 23" node_number="23"> Date: Fri Dec 17 10:29:41 2021 +0800 ax25: NPD bug when detaching AX25 device commit 1ade48d0c27d5da1ccf4b583d8c5fc8b534a3ac8 upstream. The existing cleanup routine implementation is not well synchronized with the syscall routine. When a device is detaching, below race could occur. static int ax25_sendmsg(...) { ... lock_sock() ax25 = sk_to_ax25(sk); if (ax25-&gt;ax25_dev == NULL) // CHECK ... ax25_queue_xmit(skb, ax25-&gt;ax25_dev-&gt;dev); // USE ... } static void ax25_kill_by_device(...) { ... if (s-&gt;ax25_dev == ax25_dev) { s-&gt;ax25_dev = NULL; ... } Other syscall functions like ax25_getsockopt, ax25_getname, ax25_info_show also suffer from similar races. To fix them, this patch introduce lock_sock() into ax25_kill_by_device in order to guarantee that the nullify action in cleanup routine cannot proceed when another socket request is pending. Signed-off-by: Hanjie Wu <nagi title="valid: False, node: 24, tag: nagi, level: 24" node_number="24"> Signed-off-by: Lin Ma <linma title="valid: False, node: 25, tag: linma, level: 25" node_number="25"> Signed-off-by: David S. Miller <davem title="valid: False, node: 26, tag: davem, level: 26" node_number="26"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 27, tag: gregkh, level: 27" node_number="27"> commit 0333eaf38500caa05c5c81de14a13328d0544f3c Author: Guenter Roeck <linux title="valid: False, node: 28, tag: linux, level: 28" node_number="28"> Date: Fri Dec 3 13:42:22 2021 -0800 hwmon: (lm90) Do not report 'busy' status bit as alarm commit cdc5287acad9ede121924a9c9313544b80d15842 upstream. Bit 7 of the status register indicates that the chip is busy doing a conversion. It does not indicate an alarm status. Stop reporting it as alarm status bit. Signed-off-by: Guenter Roeck <linux title="valid: False, node: 29, tag: linux, level: 29" node_number="29"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 30, tag: gregkh, level: 30" node_number="30"> commit bf260ff4a42f38824df8b9aaac08b780e80a7432 Author: Guenter Roeck <linux title="valid: False, node: 31, tag: linux, level: 31" node_number="31"> Date: Fri Nov 26 22:43:39 2021 -0800 hwmom: (lm90) Fix citical alarm status for MAX6680/MAX6681 commit da7dc0568491104c7acb632e9d41ddce9aaabbb1 upstream. Tests with a real chip and a closer look into the datasheet reveals that the local and remote critical alarm status bits are swapped for MAX6680/MAX6681. Signed-off-by: Guenter Roeck <linux title="valid: False, node: 32, tag: linux, level: 32" node_number="32"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 33, tag: gregkh, level: 33" node_number="33"> commit f373298e1bf0c6ea097c0bcc558dc43ad53e421f Author: Guodong Liu <guodong.liu title="valid: False, node: 34, tag: guodong.liu, level: 34" node_number="34"> Date: Wed Nov 10 15:19:00 2021 +0800 pinctrl: mediatek: fix global-out-of-bounds issue commit 2d5446da5acecf9c67db1c9d55ae2c3e5de01f8d upstream. When eint virtual eint number is greater than gpio number, it maybe produce 'desc[eint_n]' size globle-out-of-bounds issue. Signed-off-by: Guodong Liu <guodong.liu title="valid: False, node: 35, tag: guodong.liu, level: 35" node_number="35"> Signed-off-by: Zhiyong Tao <zhiyong.tao title="valid: False, node: 36, tag: zhiyong.tao, level: 36" node_number="36"> Reviewed-by: Chen-Yu Tsai <wenst title="valid: False, node: 37, tag: wenst, level: 37" node_number="37"> Link: https://lore.kernel.org/r/20211110071900.4490-2-zhiyong.tao@mediatek.com Signed-off-by: Linus Walleij <linus.walleij title="valid: False, node: 38, tag: linus.walleij, level: 38" node_number="38"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 39, tag: gregkh, level: 39" node_number="39"> commit bf04afb6137fb76a9d8517fb07373ffcd0f3f283 Author: Andrey Ryabinin <arbn title="valid: False, node: 40, tag: arbn, level: 40" node_number="40"> Date: Fri Dec 24 21:12:35 2021 -0800 mm: mempolicy: fix THP allocations escaping mempolicy restrictions commit 338635340669d5b317c7e8dcf4fff4a0f3651d87 upstream. alloc_pages_vma() may try to allocate THP page on the local NUMA node first: page = __alloc_pages_node(hpage_node, gfp | __GFP_THISNODE | __GFP_NORETRY, order); And if the allocation fails it retries allowing remote memory: if (!page (gfp __GFP_DIRECT_RECLAIM)) page = __alloc_pages_node(hpage_node, gfp, order); However, this retry allocation completely ignores memory policy nodemask allowing allocation to escape restrictions. The first appearance of this bug seems to be the commit ac5b2c18911f ("mm: thp: relax __GFP_THISNODE for MADV_HUGEPAGE mappings"). The bug disappeared later in the commit 89c83fb539f9 ("mm, thp: consolidate THP gfp handling into alloc_hugepage_direct_gfpmask") and reappeared again in slightly different form in the commit 76e654cc91bb ("mm, page_alloc: allow hugepage fallback to remote nodes when madvised") Fix this by passing correct nodemask to the __alloc_pages() call. The demonstration/reproducer of the problem: $ mount -oremount,size=4G,huge=always /dev/shm/ $ echo always &gt; /sys/kernel/mm/transparent_hugepage/defrag $ cat mbind_thp.c #include <unistd.h title="valid: False, node: 41, tag: unistd.h, level: 41" node_number="41"> #include <sys title="valid: False, node: 42, tag: sys, level: 42" node_number="42"> #include <sys title="valid: False, node: 43, tag: sys, level: 43" node_number="43"> #include <fcntl.h title="valid: False, node: 44, tag: fcntl.h, level: 44" node_number="44"> #include <assert.h title="valid: False, node: 45, tag: assert.h, level: 45" node_number="45"> #include <stdlib.h title="valid: False, node: 46, tag: stdlib.h, level: 46" node_number="46"> #include <stdio.h title="valid: False, node: 47, tag: stdio.h, level: 47" node_number="47"> #include <numaif.h title="valid: False, node: 48, tag: numaif.h, level: 48" node_number="48"> #define SIZE 2ULL &lt;&lt; 30 int main(int argc, char **argv) { int fd; unsigned long long i; char *addr; pid_t pid; char buf[100]; unsigned long nodemask = 1; fd = open("/dev/shm/test", O_RDWR|O_CREAT); assert(fd &gt; 0); assert(ftruncate(fd, SIZE) == 0); addr = mmap(NULL, SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); assert(mbind(addr, SIZE, MPOL_BIND, nodemask, 2, MPOL_MF_STRICT|MPOL_MF_MOVE)==0); for (i = 0; i &lt; SIZE; i+=4096) { addr[i] = 1; } pid = getpid(); snprintf(buf, sizeof(buf), "grep shm /proc/%d/numa_maps", pid); system(buf); sleep(10000); return 0; } $ gcc mbind_thp.c -o mbind_thp -lnuma $ numactl -H available: 2 nodes (0-1) node 0 cpus: 0 2 node 0 size: 1918 MB node 0 free: 1595 MB node 1 cpus: 1 3 node 1 size: 2014 MB node 1 free: 1731 MB node distances: node 0 1 0: 10 20 1: 20 10 $ rm -f /dev/shm/test; taskset -c 0 ./mbind_thp 7fd970a00000 bind:0 file=/dev/shm/test dirty=524288 active=0 N0=396800 N1=127488 kernelpagesize_kB=4 Link: https://lkml.kernel.org/r/20211208165343.22349-1-arbn@yandex-team.com Fixes: ac5b2c18911f ("mm: thp: relax __GFP_THISNODE for MADV_HUGEPAGE mappings") Signed-off-by: Andrey Ryabinin <arbn title="valid: False, node: 49, tag: arbn, level: 49" node_number="49"> Acked-by: Michal Hocko <mhocko title="valid: False, node: 50, tag: mhocko, level: 50" node_number="50"> Acked-by: Mel Gorman <mgorman title="valid: False, node: 51, tag: mgorman, level: 51" node_number="51"> Acked-by: David Rientjes <rientjes title="valid: False, node: 52, tag: rientjes, level: 52" node_number="52"> Cc: Andrea Arcangeli <aarcange title="valid: False, node: 53, tag: aarcange, level: 53" node_number="53"> Cc: <stable title="valid: False, node: 54, tag: stable, level: 54" node_number="54"> Signed-off-by: Andrew Morton <akpm title="valid: False, node: 55, tag: akpm, level: 55" node_number="55"> Signed-off-by: Linus Torvalds <torvalds title="valid: False, node: 56, tag: torvalds, level: 56" node_number="56"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 57, tag: gregkh, level: 57" node_number="57"> commit f5db6bc934949f86fbc81eef3fe8800461bda624 Author: Sean Christopherson <seanjc title="valid: False, node: 58, tag: seanjc, level: 58" node_number="58"> Date: Tue Dec 7 19:30:05 2021 +0000 KVM: VMX: Fix stale docs for kvm-intel.emulate_invalid_guest_state commit 0ff29701ffad9a5d5a24344d8b09f3af7b96ffda upstream. Update the documentation for kvm-intel's emulate_invalid_guest_state to rectify the description of KVM's default behavior, and to document that the behavior and thus parameter only applies to L1. Fixes: a27685c33acc ("KVM: VMX: Emulate invalid guest state by default") Signed-off-by: Sean Christopherson <seanjc title="valid: False, node: 59, tag: seanjc, level: 59" node_number="59"> Message-Id: &lt;20211207193006.120997-4-seanjc@google.com&gt; Reviewed-by: Maxim Levitsky <mlevitsk title="valid: False, node: 60, tag: mlevitsk, level: 60" node_number="60"> Signed-off-by: Paolo Bonzini <pbonzini title="valid: False, node: 61, tag: pbonzini, level: 61" node_number="61"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 62, tag: gregkh, level: 62" node_number="62"> commit 06c13e039d9276645c21ad9a580f97cab2bad464 Author: Marian Postevca <posteuca title="valid: False, node: 63, tag: posteuca, level: 63" node_number="63"> Date: Sat Dec 4 23:49:12 2021 +0200 usb: gadget: u_ether: fix race in setting MAC address in setup phase commit 890d5b40908bfd1a79be018d2d297cf9df60f4ee upstream. When listening for notifications through netlink of a new interface being registered, sporadically, it is possible for the MAC to be read as zero. The zero MAC address lasts a short period of time and then switches to a valid random MAC address. This causes problems for netd in Android, which assumes that the interface is malfunctioning and will not use it. In the good case we get this log: InterfaceController::getCfg() ifName usb0 hwAddr 92:a8:f0:73:79:5b ipv4Addr 0.0.0.0 flags 0x1002 In the error case we get these logs: InterfaceController::getCfg() ifName usb0 hwAddr 00:00:00:00:00:00 ipv4Addr 0.0.0.0 flags 0x1002 netd : interfaceGetCfg("usb0") netd : interfaceSetCfg() -&gt; ServiceSpecificException (99, "[Cannot assign requested address] : ioctl() failed") The reason for the issue is the order in which the interface is setup, it is first registered through register_netdev() and after the MAC address is set. Fixed by first setting the MAC address of the net_device and after that calling register_netdev(). Fixes: bcd4a1c40bee885e ("usb: gadget: u_ether: construct with default values and add setters/getters") Cc: stable@vger.kernel.org Signed-off-by: Marian Postevca <posteuca title="valid: False, node: 64, tag: posteuca, level: 64" node_number="64"> Link: https://lore.kernel.org/r/20211204214912.17627-1-posteuca@mutex.one Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 65, tag: gregkh, level: 65" node_number="65"> commit b0406b5ef4e2c4fb21d9e7d5c36a0453b4279e9b Author: Chao Yu <chao title="valid: False, node: 66, tag: chao, level: 66" node_number="66"> Date: Sun Dec 12 17:16:30 2021 +0800 f2fs: fix to do sanity check on last xattr entry in __f2fs_setxattr() commit 5598b24efaf4892741c798b425d543e4bed357a1 upstream. As Wenqing Liu reported in bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=215235 - Overview page fault in f2fs_setxattr() when mount and operate on corrupted image - Reproduce tested on kernel 5.16-rc3, 5.15.X under root 1. unzip tmp7.zip 2. ./single.sh f2fs 7 Sometimes need to run the script several times - Kernel dump loop0: detected capacity change from 0 to 131072 F2FS-fs (loop0): Found nat_bits in checkpoint F2FS-fs (loop0): Mounted with checkpoint version = 7548c2ee BUG: unable to handle page fault for address: ffffe47bc7123f48 RIP: 0010:kfree+0x66/0x320 Call Trace: __f2fs_setxattr+0x2aa/0xc00 [f2fs] f2fs_setxattr+0xfa/0x480 [f2fs] __f2fs_set_acl+0x19b/0x330 [f2fs] __vfs_removexattr+0x52/0x70 __vfs_removexattr_locked+0xb1/0x140 vfs_removexattr+0x56/0x100 removexattr+0x57/0x80 path_removexattr+0xa3/0xc0 __x64_sys_removexattr+0x17/0x20 do_syscall_64+0x37/0xb0 entry_SYSCALL_64_after_hwframe+0x44/0xae The root cause is in __f2fs_setxattr(), we missed to do sanity check on last xattr entry, result in out-of-bound memory access during updating inconsistent xattr data of target inode. After the fix, it can detect such xattr inconsistency as below: F2FS-fs (loop11): inode (7) has invalid last xattr entry, entry_size: 60676 F2FS-fs (loop11): inode (8) has corrupted xattr F2FS-fs (loop11): inode (8) has corrupted xattr F2FS-fs (loop11): inode (8) has invalid last xattr entry, entry_size: 47736 Cc: stable@vger.kernel.org Reported-by: Wenqing Liu <wenqingliu0120 title="valid: False, node: 67, tag: wenqingliu0120, level: 67" node_number="67"> Signed-off-by: Chao Yu <chao title="valid: False, node: 68, tag: chao, level: 68" node_number="68"> Signed-off-by: Jaegeuk Kim <jaegeuk title="valid: False, node: 69, tag: jaegeuk, level: 69" node_number="69"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 70, tag: gregkh, level: 70" node_number="70"> commit 806142c805cacd098e61bdc0f72c778a2389fe4a Author: Sumit Garg <sumit.garg title="valid: False, node: 71, tag: sumit.garg, level: 71" node_number="71"> Date: Thu Dec 16 11:17:25 2021 +0530 tee: optee: Fix incorrect page free bug commit 18549bf4b21c739a9def39f27dcac53e27286ab5 upstream. Pointer to the allocated pages (struct page *page) has already progressed towards the end of allocation. It is incorrect to perform __free_pages(page, order) using this pointer as we would free any arbitrary pages. Fix this by stop modifying the page pointer. Fixes: ec185dd3ab25 ("optee: Fix memory leak when failing to register shm pages") Cc: stable@vger.kernel.org Reported-by: Patrik Lantz <patrik.lantz title="valid: False, node: 72, tag: patrik.lantz, level: 72" node_number="72"> Signed-off-by: Sumit Garg <sumit.garg title="valid: False, node: 73, tag: sumit.garg, level: 73" node_number="73"> Reviewed-by: Tyler Hicks <tyhicks title="valid: False, node: 74, tag: tyhicks, level: 74" node_number="74"> Signed-off-by: Jens Wiklander <jens.wiklander title="valid: False, node: 75, tag: jens.wiklander, level: 75" node_number="75"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 76, tag: gregkh, level: 76" node_number="76"> commit 5478b90270a3569cf6f596959b0900c9f8ef8fe4 Author: Ard Biesheuvel <ardb title="valid: False, node: 77, tag: ardb, level: 77" node_number="77"> Date: Wed Dec 15 09:31:36 2021 +0100 ARM: 9169/1: entry: fix Thumb2 bug in iWMMXt exception handling commit 8536a5ef886005bc443c2da9b842d69fd3d7647f upstream. The Thumb2 version of the FP exception handling entry code treats the register holding the CP number (R8) differently, resulting in the iWMMXT CP number check to be incorrect. Fix this by unifying the ARM and Thumb2 code paths, and switch the order of the additions of the TI_USED_CP offset and the shifted CP index. Cc: <stable title="valid: False, node: 78, tag: stable, level: 78" node_number="78"> Fixes: b86040a59feb ("Thumb-2: Implementation of the unified start-up and exceptions code") Signed-off-by: Ard Biesheuvel <ardb title="valid: False, node: 79, tag: ardb, level: 79" node_number="79"> Signed-off-by: Russell King (Oracle) <rmk title="valid: False, node: 80, tag: rmk, level: 80" node_number="80"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 81, tag: gregkh, level: 81" node_number="81"> commit 1c3d4122bec632ffbd6c40ef9321b17a55ff810d Author: Ulf Hansson <ulf.hansson title="valid: False, node: 82, tag: ulf.hansson, level: 82" node_number="82"> Date: Fri Dec 3 15:15:54 2021 +0100 mmc: core: Disable card detect during shutdown commit 66c915d09b942fb3b2b0cb2f56562180901fba17 upstream. It's seems prone to problems by allowing card detect and its corresponding mmc_rescan() work to run, during platform shutdown. For example, we may end up turning off the power while initializing a card, which potentially could damage it. To avoid this scenario, let's add -&gt;shutdown_pre() callback for the mmc host class device and then turn of the card detect from there. Reported-by: Al Cooper <alcooperx title="valid: False, node: 83, tag: alcooperx, level: 83" node_number="83"> Suggested-by: Adrian Hunter <adrian.hunter title="valid: False, node: 84, tag: adrian.hunter, level: 84" node_number="84"> Signed-off-by: Ulf Hansson <ulf.hansson title="valid: False, node: 85, tag: ulf.hansson, level: 85" node_number="85"> Cc: stable@vger.kernel.org Link: https://lore.kernel.org/r/20211203141555.105351-1-ulf.hansson@linaro.org Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 86, tag: gregkh, level: 86" node_number="86"> commit e9db8fc6c7af6cac25d0b2d51f304393817efcef Author: Prathamesh Shete <pshete title="valid: False, node: 87, tag: pshete, level: 87" node_number="87"> Date: Tue Dec 14 17:06:53 2021 +0530 mmc: sdhci-tegra: Fix switch to HS400ES mode commit 4fc7261dbab139d3c64c3b618262504e16cfe7ee upstream. When CMD13 is sent after switching to HS400ES mode, the bus is operating at either MMC_HIGH_26_MAX_DTR or MMC_HIGH_52_MAX_DTR. To meet Tegra SDHCI requirement at HS400ES mode, force SDHCI interface clock to MMC_HS200_MAX_DTR (200 MHz) so that host controller CAR clock and the interface clock are rate matched. Signed-off-by: Prathamesh Shete <pshete title="valid: False, node: 88, tag: pshete, level: 88" node_number="88"> Acked-by: Adrian Hunter <adrian.hunter title="valid: False, node: 89, tag: adrian.hunter, level: 89" node_number="89"> Fixes: dfc9700cef77 ("mmc: tegra: Implement HS400 enhanced strobe") Cc: stable@vger.kernel.org Link: https://lore.kernel.org/r/20211214113653.4631-1-pshete@nvidia.com Signed-off-by: Ulf Hansson <ulf.hansson title="valid: False, node: 90, tag: ulf.hansson, level: 90" node_number="90"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 91, tag: gregkh, level: 91" node_number="91"> commit d9031ce0b071899d282b95539c7407ddc07cf362 Author: Fabien Dessenne <fabien.dessenne title="valid: False, node: 92, tag: fabien.dessenne, level: 92" node_number="92"> Date: Wed Dec 15 10:58:08 2021 +0100 pinctrl: stm32: consider the GPIO offset to expose all the GPIO lines commit b67210cc217f9ca1c576909454d846970c13dfd4 upstream. Consider the GPIO controller offset (from "gpio-ranges") to compute the maximum GPIO line number. This fixes an issue where gpio-ranges uses a non-null offset. e.g.: gpio-ranges = In that case the last valid GPIO line is not 9 but 15 (6 + 10 - 1) Cc: stable@vger.kernel.org Fixes: 67e2996f72c7 ("pinctrl: stm32: fix the reported number of GPIO lines per bank") Reported-by: Christoph Fritz <chf.fritz title="valid: False, node: 93, tag: chf.fritz, level: 93" node_number="93"> Signed-off-by: Fabien Dessenne <fabien.dessenne title="valid: False, node: 94, tag: fabien.dessenne, level: 94" node_number="94"> Link: https://lore.kernel.org/r/20211215095808.621716-1-fabien.dessenne@foss.st.com Signed-off-by: Linus Walleij <linus.walleij title="valid: False, node: 95, tag: linus.walleij, level: 95" node_number="95"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 96, tag: gregkh, level: 96" node_number="96"> commit c7b2e5850ba65bdd43afc17e5adf8603c9c5cfbd Author: Andrew Cooper <andrew.cooper3 title="valid: False, node: 97, tag: andrew.cooper3, level: 97" node_number="97"> Date: Thu Dec 16 00:08:56 2021 +0000 x86/pkey: Fix undefined behaviour with PKRU_WD_BIT commit 57690554abe135fee81d6ac33cc94d75a7e224bb upstream. Both __pkru_allows_write() and arch_set_user_pkey_access() shift PKRU_WD_BIT (a signed constant) by up to 30 bits, hitting the sign bit. Use unsigned constants instead. Clearly pkey 15 has not been used in combination with UBSAN yet. Noticed by code inspection only. I can't actually provoke the compiler into generating incorrect logic as far as this shift is concerned. [ dhansen: add stable@ tag, plus minor changelog massaging, For anyone doing backports, these #defines were in arch/x86/include/asm/pgtable.h before 784a46618f6. ] Fixes: 33a709b25a76 ("mm/gup, x86/mm/pkeys: Check VMAs and PTEs for protection keys") Signed-off-by: Andrew Cooper <andrew.cooper3 title="valid: False, node: 98, tag: andrew.cooper3, level: 98" node_number="98"> Signed-off-by: Dave Hansen <dave.hansen title="valid: False, node: 99, tag: dave.hansen, level: 99" node_number="99"> Signed-off-by: Borislav Petkov <bp title="valid: False, node: 100, tag: bp, level: 100" node_number="100"> Cc: stable@vger.kernel.org Link: https://lkml.kernel.org/r/20211216000856.4480-1-andrew.cooper3@citrix.com Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 101, tag: gregkh, level: 101" node_number="101"> commit ddc1d49e10a7ca03c7d83aa7afc1267f8b484ec2 Author: John David Anglin <dave.anglin title="valid: False, node: 102, tag: dave.anglin, level: 102" node_number="102"> Date: Tue Dec 21 13:21:22 2021 -0500 parisc: Correct completer in lws start commit 8f66fce0f46560b9e910787ff7ad0974441c4f9c upstream. The completer in the "or,ev %r1,%r30,%r30" instruction is reversed, so we are not clipping the LWS number when we are called from a 32-bit process (W=0). We need to nulify the following depdi instruction when the least-significant bit of %r30 is 1. If the %r20 register is not clipped, a user process could perform a LWS call that would branch to an undefined location in the kernel and potentially crash the machine. Signed-off-by: John David Anglin <dave.anglin title="valid: False, node: 103, tag: dave.anglin, level: 103" node_number="103"> Cc: stable@vger.kernel.org # 4.19+ Signed-off-by: Helge Deller Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 104, tag: gregkh, level: 104" node_number="104"> commit 8467c8cb94a406cc0c54d9306b61d0db86c94048 Author: Thadeu Lima de Souza Cascardo <cascardo title="valid: False, node: 105, tag: cascardo, level: 105" node_number="105"> Date: Fri Dec 17 12:44:10 2021 -0300 ipmi: fix initialization when workqueue allocation fails commit 75d70d76cb7b927cace2cb34265d68ebb3306b13 upstream. If the workqueue allocation fails, the driver is marked as not initialized, and timer and panic_notifier will be left registered. Instead of removing those when workqueue allocation fails, do the workqueue initialization before doing it, and cleanup srcu_struct if it fails. Fixes: 1d49eb91e86e ("ipmi: Move remove_work to dedicated workqueue") Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo title="valid: False, node: 106, tag: cascardo, level: 106" node_number="106"> Cc: Corey Minyard <cminyard title="valid: False, node: 107, tag: cminyard, level: 107" node_number="107"> Cc: Ioanna Alifieraki <ioanna-maria.alifieraki title="valid: False, node: 108, tag: ioanna-maria.alifieraki, level: 108" node_number="108"> Cc: stable@vger.kernel.org Message-Id: &lt;20211217154410.1228673-2-cascardo@canonical.com&gt; Signed-off-by: Corey Minyard <cminyard title="valid: False, node: 109, tag: cminyard, level: 109" node_number="109"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 110, tag: gregkh, level: 110" node_number="110"> commit 8efd6a3391f7b0b19fb0c38e50add06ca30c94af Author: Mian Yousaf Kaukab <ykaukab title="valid: False, node: 111, tag: ykaukab, level: 111" node_number="111"> Date: Wed Dec 8 10:32:39 2021 +0100 ipmi: ssif: initialize ssif_info-&gt;client early commit 34f35f8f14bc406efc06ee4ff73202c6fd245d15 upstream. During probe ssif_info-&gt;client is dereferenced in error path. However, it is set when some of the error checking has already been done. This causes following kernel crash if an error path is taken: [ 30.645593][ T674] ipmi_ssif 0-000e: ipmi_ssif: Not probing, Interface already present [ 30.657616][ T674] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000088 ... [ 30.657723][ T674] pc : __dev_printk+0x28/0xa0 [ 30.657732][ T674] lr : _dev_err+0x7c/0xa0 ... [ 30.657772][ T674] Call trace: [ 30.657775][ T674] __dev_printk+0x28/0xa0 [ 30.657778][ T674] _dev_err+0x7c/0xa0 [ 30.657781][ T674] ssif_probe+0x548/0x900 [ipmi_ssif 62ce4b08badc1458fd896206d9ef69a3c31f3d3e] [ 30.657791][ T674] i2c_device_probe+0x37c/0x3c0 ... Initialize ssif_info-&gt;client before any error path can be taken. Clear i2c_client data in the error path to prevent the dangling pointer from leaking. Fixes: c4436c9149c5 ("ipmi_ssif: avoid registering duplicate ssif interface") Cc: stable@vger.kernel.org # 5.4.x Suggested-by: Takashi Iwai <tiwai title="valid: False, node: 112, tag: tiwai, level: 112" node_number="112"> Signed-off-by: Mian Yousaf Kaukab <ykaukab title="valid: False, node: 113, tag: ykaukab, level: 113" node_number="113"> Message-Id: &lt;20211208093239.4432-1-ykaukab@suse.de&gt; Signed-off-by: Corey Minyard <cminyard title="valid: False, node: 114, tag: cminyard, level: 114" node_number="114"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 115, tag: gregkh, level: 115" node_number="115"> commit cd24bafefc17947532008c3667637aee7471d7a8 Author: Thadeu Lima de Souza Cascardo <cascardo title="valid: False, node: 116, tag: cascardo, level: 116" node_number="116"> Date: Fri Dec 17 12:44:09 2021 -0300 ipmi: bail out if init_srcu_struct fails commit 2b5160b12091285c5aca45980f100a9294af7b04 upstream. In case, init_srcu_struct fails (because of memory allocation failure), we might proceed with the driver initialization despite srcu_struct not being entirely initialized. Fixes: 913a89f009d9 ("ipmi: Don't initialize anything in the core until something uses it") Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo title="valid: False, node: 117, tag: cascardo, level: 117" node_number="117"> Cc: Corey Minyard <cminyard title="valid: False, node: 118, tag: cminyard, level: 118" node_number="118"> Cc: stable@vger.kernel.org Message-Id: &lt;20211217154410.1228673-1-cascardo@canonical.com&gt; Signed-off-by: Corey Minyard <cminyard title="valid: False, node: 119, tag: cminyard, level: 119" node_number="119"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 120, tag: gregkh, level: 120" node_number="120"> commit 5525d80dc9dd46ad5d2150da264165226b9c0fda Author: Jos&#233; Exp&#243;sito <jose.exposito89 title="valid: False, node: 121, tag: jose.exposito89, level: 121" node_number="121"> Date: Sun Dec 12 21:01:49 2021 -0800 Input: atmel_mxt_ts - fix double free in mxt_read_info_block commit 12f247ab590a08856441efdbd351cf2cc8f60a2d upstream. The "id_buf" buffer is stored in "data-&gt;raw_info_block" and freed by "mxt_free_object_table" in case of error. Return instead of jumping to avoid a double free. Addresses-Coverity-ID: 1474582 ("Double free") Fixes: 068bdb67ef74 ("Input: atmel_mxt_ts - fix the firmware update") Signed-off-by: Jos&#233; Exp&#243;sito <jose.exposito89 title="valid: False, node: 122, tag: jose.exposito89, level: 122" node_number="122"> Link: https://lore.kernel.org/r/20211212194257.68879-1-jose.exposito89@gmail.com Cc: stable@vger.kernel.org Signed-off-by: Dmitry Torokhov <dmitry.torokhov title="valid: False, node: 123, tag: dmitry.torokhov, level: 123" node_number="123"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 124, tag: gregkh, level: 124" node_number="124"> commit 737a98d91b074eb0c9c17ed16f04469f840c4c27 Author: Bradley Scott Date: Mon Dec 13 10:49:39 2021 -0500 ALSA: hda/realtek: Amp init fixup for HP ZBook 15 G6 commit d296a74b7b59ff9116236c17edb25f26935dbf70 upstream. HP ZBook 15 G6 (SSID 103c:860f) needs the same speaker amplifier initialization as used on several other HP laptops using ALC285. Signed-off-by: Bradley Scott Cc: <stable title="valid: False, node: 125, tag: stable, level: 125" node_number="125"> Link: https://lore.kernel.org/r/20211213154938.503201-1-Bradley.Scott@zebra.com Signed-off-by: Takashi Iwai <tiwai title="valid: False, node: 126, tag: tiwai, level: 126" node_number="126"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 127, tag: gregkh, level: 127" node_number="127"> commit 8df036befbc3c6eebd3087d2ff8205c83b48c881 Author: Colin Ian King <colin.king title="valid: False, node: 128, tag: colin.king, level: 128" node_number="128"> Date: Sun Dec 12 17:20:25 2021 +0000 ALSA: drivers: opl3: Fix incorrect use of vp-&gt;state commit 2dee54b289fbc810669a1b2b8a0887fa1c9a14d7 upstream. Static analysis with scan-build has found an assignment to vp2 that is never used. It seems that the check on vp-&gt;state &gt; 0 should be actually on vp2-&gt;state instead. Fix this. This dates back to 2002, I found the offending commit from the git history git://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git, commit 91e39521bbf6 ("[PATCH] ALSA patch for 2.5.4") Signed-off-by: Colin Ian King <colin.i.king title="valid: False, node: 129, tag: colin.i.king, level: 129" node_number="129"> Cc: <stable title="valid: False, node: 130, tag: stable, level: 130" node_number="130"> Link: https://lore.kernel.org/r/20211212172025.470367-1-colin.i.king@gmail.com Signed-off-by: Takashi Iwai <tiwai title="valid: False, node: 131, tag: tiwai, level: 131" node_number="131"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 132, tag: gregkh, level: 132" node_number="132"> commit fdaf41977d7747ca914e91c85665df009b456a08 Author: Xiaoke Wang <xkernel.wang title="valid: False, node: 133, tag: xkernel.wang, level: 133" node_number="133"> Date: Mon Dec 13 15:39:31 2021 +0800 ALSA: jack: Check the return value of kstrdup() commit c01c1db1dc632edafb0dff32d40daf4f9c1a4e19 upstream. kstrdup() can return NULL, it is better to check the return value of it. Signed-off-by: Xiaoke Wang <xkernel.wang title="valid: False, node: 134, tag: xkernel.wang, level: 134" node_number="134"> Cc: <stable title="valid: False, node: 135, tag: stable, level: 135" node_number="135"> Link: https://lore.kernel.org/r/tencent_094816F3522E0DC704056C789352EBBF0606@qq.com Signed-off-by: Takashi Iwai <tiwai title="valid: False, node: 136, tag: tiwai, level: 136" node_number="136"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 137, tag: gregkh, level: 137" node_number="137"> commit 44c743f63dd3e92f1bfb2b43c0374406bc60213f Author: Guenter Roeck <linux title="valid: False, node: 138, tag: linux, level: 138" node_number="138"> Date: Sat Nov 13 08:55:06 2021 -0800 hwmon: (lm90) Drop critical attribute support for MAX6654 [ Upstream commit 16ba51b5dcd3f6dde2e51d5ccc86313119dcf889 ] Tests with a real chip and a closer look into the datasheet show that MAX6654 does not support CRIT/THERM/OVERTEMP limits, so drop support of the respective attributes for this chip. Introduce LM90_HAVE_CRIT flag and use it to instantiate critical limit attributes to solve the problem. Cc: Josh Lehan <krellan title="valid: False, node: 139, tag: krellan, level: 139" node_number="139"> Fixes: 229d495d8189 ("hwmon: (lm90) Add max6654 support to lm90 driver") Signed-off-by: Guenter Roeck <linux title="valid: False, node: 140, tag: linux, level: 140" node_number="140"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 141, tag: sashal, level: 141" node_number="141"> commit 4615c9740575e5a772332bb0316520dfce5bebc3 Author: Guenter Roeck <linux title="valid: False, node: 142, tag: linux, level: 142" node_number="142"> Date: Thu Oct 21 01:49:50 2021 -0700 hwmon: (lm90) Introduce flag indicating extended temperature support [ Upstream commit f347e249fcf920ad6974cbd898e2ec0b366a1c34 ] A flag indicating extended temperature support makes it easier to add support for additional chips with this functionality. Cc: David T. Wilson <david.wilson title="valid: False, node: 143, tag: david.wilson, level: 143" node_number="143"> Signed-off-by: Guenter Roeck <linux title="valid: False, node: 144, tag: linux, level: 144" node_number="144"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 145, tag: sashal, level: 145" node_number="145"> commit c2242478f28dd84585ae9c6f93b34d7bdaef80a3 Author: Guenter Roeck <linux title="valid: False, node: 146, tag: linux, level: 146" node_number="146"> Date: Mon Oct 18 20:03:32 2021 -0700 hwmon: (lm90) Add basic support for TI TMP461 [ Upstream commit f8344f7693a25d9025a59d164450b50c6f5aa3c0 ] TMP461 is almost identical to TMP451 and was actually detected as TMP451 with the existing lm90 driver if its I2C address is 0x4c. Add support for it to the lm90 driver. At the same time, improve the chip detection function to at least try to distinguish between TMP451 and TMP461. As a side effect, this fixes commit 24333ac26d01 ("hwmon: (tmp401) use smb word operations instead of 2 smb byte operations"). TMP461 does not support word operations on temperature registers, which causes bad temperature readings with the tmp401 driver. The lm90 driver does not perform word operations on temperature registers and thus does not have this problem. Support is listed as basic because TMP461 supports a sensor resolution of 0.0625 degrees C, while the lm90 driver assumes a resolution of 0.125 degrees C. Also, the TMP461 supports negative temperatures with its default temperature range, which is not the case for similar chips supported by the lm90 and the tmp401 drivers. Those limitations will be addressed with follow-up patches. Fixes: 24333ac26d01 ("hwmon: (tmp401) use smb word operations instead of 2 smb byte operations") Reported-by: David T. Wilson <david.wilson title="valid: False, node: 147, tag: david.wilson, level: 147" node_number="147"> Cc: David T. Wilson <david.wilson title="valid: False, node: 148, tag: david.wilson, level: 148" node_number="148"> Signed-off-by: Guenter Roeck <linux title="valid: False, node: 149, tag: linux, level: 149" node_number="149"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 150, tag: sashal, level: 150" node_number="150"> commit d939660eff6254671fbc914e6132b9a5c6c333c4 Author: Josh Lehan <krellan title="valid: False, node: 151, tag: krellan, level: 151" node_number="151"> Date: Wed May 13 11:42:48 2020 -0700 hwmon: (lm90) Add max6654 support to lm90 driver [ Upstream commit 229d495d8189ae785dacee72e5633a58edc25ddf ] Add support for the Maxim MAX6654 to the lm90 driver. The MAX6654 is a temperature sensor, similar to the others, but with some differences regarding the configuration register, and the sampling rate at which extended resolution becomes possible. Signed-off-by: Josh Lehan <krellan title="valid: False, node: 152, tag: krellan, level: 152" node_number="152"> Link: https://lore.kernel.org/r/20200513184248.145765-1-krellan@google.com Signed-off-by: Guenter Roeck <linux title="valid: False, node: 153, tag: linux, level: 153" node_number="153"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 154, tag: sashal, level: 154" node_number="154"> commit 055ca98d48ba5a127b4ab72f9e8defabf896e31c Author: Guenter Roeck <linux title="valid: False, node: 155, tag: linux, level: 155" node_number="155"> Date: Sat Nov 6 10:02:44 2021 -0700 hwmon: (lm90) Fix usage of CONFIG2 register in detect function [ Upstream commit fce15c45d3fbd9fc1feaaf3210d8e3f8b33dfd3a ] The detect function had a comment "Make compiler happy" when id did not read the second configuration register. As it turns out, the code was checking the contents of this register for manufacturer ID 0xA1 (NXP Semiconductor/Philips), but never actually read the register. So it wasn't surprising that the compiler complained, and it indeed had a point. Fix the code to read the register contents for manufacturer ID 0xa1. At the same time, the code was reading the register for manufacturer ID 0x41 (Analog Devices), but it was not using the results. In effect it was just checking if reading the register returned an error. That doesn't really add much if any value, so stop doing that. Fixes: f90be42fb383 ("hwmon: (lm90) Refactor reading of config2 register") Signed-off-by: Guenter Roeck <linux title="valid: False, node: 156, tag: linux, level: 156" node_number="156"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 157, tag: sashal, level: 157" node_number="157"> commit a7f95328c6f0afffdc4555f16e3bbab8bbf0d9be Author: Andrea Righi <andrea.righi title="valid: False, node: 158, tag: andrea.righi, level: 158" node_number="158"> Date: Mon Nov 29 00:08:13 2021 -0800 Input: elantech - fix stack out of bound access in elantech_change_report_id() [ Upstream commit 1d72d9f960ccf1052a0630a68c3d358791dbdaaa ] The array param[] in elantech_change_report_id() must be at least 3 bytes, because elantech_read_reg_params() is calling ps2_command() with PSMOUSE_CMD_GETINFO, that is going to access 3 bytes from param[], but it's defined in the stack as an array of 2 bytes, therefore we have a potential stack out-of-bounds access here, also confirmed by KASAN: [ 6.512374] BUG: KASAN: stack-out-of-bounds in __ps2_command+0x372/0x7e0 [ 6.512397] Read of size 1 at addr ffff8881024d77c2 by task kworker/2:1/118 [ 6.512416] CPU: 2 PID: 118 Comm: kworker/2:1 Not tainted 5.13.0-22-generic #22+arighi20211110 [ 6.512428] Hardware name: LENOVO 20T8000QGE/20T8000QGE, BIOS R1AET32W (1.08 ) 08/14/2020 [ 6.512436] Workqueue: events_long serio_handle_event [ 6.512453] Call Trace: [ 6.512462] show_stack+0x52/0x58 [ 6.512474] dump_stack+0xa1/0xd3 [ 6.512487] print_address_description.constprop.0+0x1d/0x140 [ 6.512502] ? __ps2_command+0x372/0x7e0 [ 6.512516] __kasan_report.cold+0x7d/0x112 [ 6.512527] ? _raw_write_lock_irq+0x20/0xd0 [ 6.512539] ? __ps2_command+0x372/0x7e0 [ 6.512552] kasan_report+0x3c/0x50 [ 6.512564] __asan_load1+0x6a/0x70 [ 6.512575] __ps2_command+0x372/0x7e0 [ 6.512589] ? ps2_drain+0x240/0x240 [ 6.512601] ? dev_printk_emit+0xa2/0xd3 [ 6.512612] ? dev_vprintk_emit+0xc5/0xc5 [ 6.512621] ? __kasan_check_write+0x14/0x20 [ 6.512634] ? mutex_lock+0x8f/0xe0 [ 6.512643] ? __mutex_lock_slowpath+0x20/0x20 [ 6.512655] ps2_command+0x52/0x90 [ 6.512670] elantech_ps2_command+0x4f/0xc0 [psmouse] [ 6.512734] elantech_change_report_id+0x1e6/0x256 [psmouse] [ 6.512799] ? elantech_report_trackpoint.constprop.0.cold+0xd/0xd [psmouse] [ 6.512863] ? ps2_command+0x7f/0x90 [ 6.512877] elantech_query_info.cold+0x6bd/0x9ed [psmouse] [ 6.512943] ? elantech_setup_ps2+0x460/0x460 [psmouse] [ 6.513005] ? psmouse_reset+0x69/0xb0 [psmouse] [ 6.513064] ? psmouse_attr_set_helper+0x2a0/0x2a0 [psmouse] [ 6.513122] ? phys_pmd_init+0x30e/0x521 [ 6.513137] elantech_init+0x8a/0x200 [psmouse] [ 6.513200] ? elantech_init_ps2+0xf0/0xf0 [psmouse] [ 6.513249] ? elantech_query_info+0x440/0x440 [psmouse] [ 6.513296] ? synaptics_send_cmd+0x60/0x60 [psmouse] [ 6.513342] ? elantech_query_info+0x440/0x440 [psmouse] [ 6.513388] ? psmouse_try_protocol+0x11e/0x170 [psmouse] [ 6.513432] psmouse_extensions+0x65d/0x6e0 [psmouse] [ 6.513476] ? psmouse_try_protocol+0x170/0x170 [psmouse] [ 6.513519] ? mutex_unlock+0x22/0x40 [ 6.513526] ? ps2_command+0x7f/0x90 [ 6.513536] ? psmouse_probe+0xa3/0xf0 [psmouse] [ 6.513580] psmouse_switch_protocol+0x27d/0x2e0 [psmouse] [ 6.513624] psmouse_connect+0x272/0x530 [psmouse] [ 6.513669] serio_driver_probe+0x55/0x70 [ 6.513679] really_probe+0x190/0x720 [ 6.513689] driver_probe_device+0x160/0x1f0 [ 6.513697] device_driver_attach+0x119/0x130 [ 6.513705] ? device_driver_attach+0x130/0x130 [ 6.513713] __driver_attach+0xe7/0x1a0 [ 6.513720] ? device_driver_attach+0x130/0x130 [ 6.513728] bus_for_each_dev+0xfb/0x150 [ 6.513738] ? subsys_dev_iter_exit+0x10/0x10 [ 6.513748] ? _raw_write_unlock_bh+0x30/0x30 [ 6.513757] driver_attach+0x2d/0x40 [ 6.513764] serio_handle_event+0x199/0x3d0 [ 6.513775] process_one_work+0x471/0x740 [ 6.513785] worker_thread+0x2d2/0x790 [ 6.513794] ? process_one_work+0x740/0x740 [ 6.513802] kthread+0x1b4/0x1e0 [ 6.513809] ? set_kthread_struct+0x80/0x80 [ 6.513816] ret_from_fork+0x22/0x30 [ 6.513832] The buggy address belongs to the page: [ 6.513838] page:00000000bc35e189 refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1024d7 [ 6.513847] flags: 0x17ffffc0000000(node=0|zone=2|lastcpupid=0x1fffff) [ 6.513860] raw: 0017ffffc0000000 dead000000000100 dead000000000122 0000000000000000 [ 6.513867] raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000 [ 6.513872] page dumped because: kasan: bad access detected [ 6.513879] addr ffff8881024d77c2 is located in stack of task kworker/2:1/118 at offset 34 in frame: [ 6.513887] elantech_change_report_id+0x0/0x256 [psmouse] [ 6.513941] this frame has 1 object: [ 6.513947] [32, 34) 'param' [ 6.513956] Memory state around the buggy address: [ 6.513962] ffff8881024d7680: f2 f2 f2 f2 f2 00 00 f3 f3 00 00 00 00 00 00 00 [ 6.513969] ffff8881024d7700: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 6.513976] &gt;ffff8881024d7780: 00 00 00 00 f1 f1 f1 f1 02 f3 f3 f3 00 00 00 00 [ 6.513982] ^ [ 6.513988] ffff8881024d7800: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 6.513995] ffff8881024d7880: 00 f1 f1 f1 f1 03 f2 03 f2 03 f3 f3 f3 00 00 00 [ 6.514000] ================================================================== Define param[] in elantech_change_report_id() as an array of 3 bytes to prevent the out-of-bounds access in the stack. Fixes: e4c9062717fe ("Input: elantech - fix protocol errors for some trackpoints in SMBus mode") BugLink: https://bugs.launchpad.net/bugs/1945590 Signed-off-by: Andrea Righi <andrea.righi title="valid: False, node: 159, tag: andrea.righi, level: 159" node_number="159"> Reviewed-by: Wolfram Sang <wsa title="valid: False, node: 160, tag: wsa, level: 160" node_number="160"> Link: https://lore.kernel.org/r/20211116095559.24395-1-andrea.righi@canonical.com Signed-off-by: Dmitry Torokhov <dmitry.torokhov title="valid: False, node: 161, tag: dmitry.torokhov, level: 161" node_number="161"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 162, tag: sashal, level: 162" node_number="162"> commit e12dcd4aa7f41845ecc6c65a57dbfb1d6a3a65c4 Author: Jiasheng Jiang <jiasheng title="valid: False, node: 163, tag: jiasheng, level: 163" node_number="163"> Date: Mon Dec 20 22:03:44 2021 +0800 sfc: falcon: Check null pointer of rx_queue-&gt;page_ring [ Upstream commit 9b8bdd1eb5890aeeab7391dddcf8bd51f7b07216 ] Because of the possible failure of the kcalloc, it should be better to set rx_queue-&gt;page_ptr_mask to 0 when it happens in order to maintain the consistency. Fixes: 5a6681e22c14 ("sfc: separate out SFC4000 ("Falcon") support into new sfc-falcon driver") Signed-off-by: Jiasheng Jiang <jiasheng title="valid: False, node: 164, tag: jiasheng, level: 164" node_number="164"> Acked-by: Martin Habets <habetsm.xilinx title="valid: False, node: 165, tag: habetsm.xilinx, level: 165" node_number="165"> Link: https://lore.kernel.org/r/20211220140344.978408-1-jiasheng@iscas.ac.cn Signed-off-by: Jakub Kicinski <kuba title="valid: False, node: 166, tag: kuba, level: 166" node_number="166"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 167, tag: sashal, level: 167" node_number="167"> commit c11a41e26985eea38ea18df798a9cda8ade4b78e Author: Jiasheng Jiang <jiasheng title="valid: False, node: 168, tag: jiasheng, level: 168" node_number="168"> Date: Wed Dec 22 15:41:12 2021 +0800 drivers: net: smc911x: Check for error irq [ Upstream commit cb93b3e11d405f20a405a07482d01147ef4934a3 ] Because platform_get_irq() could fail and return error irq. Therefore, it might be better to check it if order to avoid the use of error irq. Fixes: ae150435b59e ("smsc: Move the SMC (SMSC) drivers") Signed-off-by: Jiasheng Jiang <jiasheng title="valid: False, node: 169, tag: jiasheng, level: 169" node_number="169"> Signed-off-by: David S. Miller <davem title="valid: False, node: 170, tag: davem, level: 170" node_number="170"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 171, tag: sashal, level: 171" node_number="171"> commit 5d556b1437e1db6e52cda355b2c4cf40212fc72f Author: Jiasheng Jiang <jiasheng title="valid: False, node: 172, tag: jiasheng, level: 172" node_number="172"> Date: Wed Dec 22 15:12:07 2021 +0800 fjes: Check for error irq [ Upstream commit db6d6afe382de5a65d6ccf51253ab48b8e8336c3 ] I find that platform_get_irq() will not always succeed. It will return error irq in case of the failure. Therefore, it might be better to check it if order to avoid the use of error irq. Fixes: 658d439b2292 ("fjes: Introduce FUJITSU Extended Socket Network Device driver") Signed-off-by: Jiasheng Jiang <jiasheng title="valid: False, node: 173, tag: jiasheng, level: 173" node_number="173"> Signed-off-by: David S. Miller <davem title="valid: False, node: 174, tag: davem, level: 174" node_number="174"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 175, tag: sashal, level: 175" node_number="175"> commit d7024080db82ebaddf93c53dea5c861bcdd3aa4f Author: Fernando Fernandez Mancera <ffmancera title="valid: False, node: 176, tag: ffmancera, level: 176" node_number="176"> Date: Tue Dec 21 12:13:45 2021 +0100 bonding: fix ad_actor_system option setting to default [ Upstream commit 1c15b05baea71a5ff98235783e3e4ad227760876 ] When 802.3ad bond mode is configured the ad_actor_system option is set to "00:00:00:00:00:00". But when trying to set the all-zeroes MAC as actors' system address it was failing with EINVAL. An all-zeroes ethernet address is valid, only multicast addresses are not valid values. Fixes: 171a42c38c6e ("bonding: add netlink support for sys prio, actor sys mac, and port key") Signed-off-by: Fernando Fernandez Mancera <ffmancera title="valid: False, node: 177, tag: ffmancera, level: 177" node_number="177"> Acked-by: Jay Vosburgh <jay.vosburgh title="valid: False, node: 178, tag: jay.vosburgh, level: 178" node_number="178"> Link: https://lore.kernel.org/r/20211221111345.2462-1-ffmancera@riseup.net Signed-off-by: Jakub Kicinski <kuba title="valid: False, node: 179, tag: kuba, level: 179" node_number="179"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 180, tag: sashal, level: 180" node_number="180"> commit 992649b8b16843d27eb39ceea5f9cf85ffb50a18 Author: Wu Bo <wubo40 title="valid: False, node: 181, tag: wubo40, level: 181" node_number="181"> Date: Tue Dec 21 15:00:34 2021 +0800 ipmi: Fix UAF when uninstall ipmi_si and ipmi_msghandler module [ Upstream commit ffb76a86f8096a8206be03b14adda6092e18e275 ] Hi, When testing install and uninstall of ipmi_si.ko and ipmi_msghandler.ko, the system crashed. The log as follows: [ 141.087026] BUG: unable to handle kernel paging request at ffffffffc09b3a5a [ 141.087241] PGD 8fe4c0d067 P4D 8fe4c0d067 PUD 8fe4c0f067 PMD 103ad89067 PTE 0 [ 141.087464] Oops: 0010 [#1] SMP NOPTI [ 141.087580] CPU: 67 PID: 668 Comm: kworker/67:1 Kdump: loaded Not tainted 4.18.0.x86_64 #47 [ 141.088009] Workqueue: events 0xffffffffc09b3a40 [ 141.088009] RIP: 0010:0xffffffffc09b3a5a [ 141.088009] Code: Bad RIP value. [ 141.088009] RSP: 0018:ffffb9094e2c3e88 EFLAGS: 00010246 [ 141.088009] RAX: 0000000000000000 RBX: ffff9abfdb1f04a0 RCX: 0000000000000000 [ 141.088009] RDX: 0000000000000000 RSI: 0000000000000246 RDI: 0000000000000246 [ 141.088009] RBP: 0000000000000000 R08: ffff9abfffee3cb8 R09: 00000000000002e1 [ 141.088009] R10: ffffb9094cb73d90 R11: 00000000000f4240 R12: ffff9abfffee8700 [ 141.088009] R13: 0000000000000000 R14: ffff9abfdb1f04a0 R15: ffff9abfdb1f04a8 [ 141.088009] FS: 0000000000000000(0000) GS:ffff9abfffec0000(0000) knlGS:0000000000000000 [ 141.088009] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 141.088009] CR2: ffffffffc09b3a30 CR3: 0000008fe4c0a001 CR4: 00000000007606e0 [ 141.088009] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 141.088009] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [ 141.088009] PKRU: 55555554 [ 141.088009] Call Trace: [ 141.088009] ? process_one_work+0x195/0x390 [ 141.088009] ? worker_thread+0x30/0x390 [ 141.088009] ? process_one_work+0x390/0x390 [ 141.088009] ? kthread+0x10d/0x130 [ 141.088009] ? kthread_flush_work_fn+0x10/0x10 [ 141.088009] ? ret_from_fork+0x35/0x40] BUG: unable to handle kernel paging request at ffffffffc0b28a5a [ 200.223240] PGD 97fe00d067 P4D 97fe00d067 PUD 97fe00f067 PMD a580cbf067 PTE 0 [ 200.223464] Oops: 0010 [#1] SMP NOPTI [ 200.223579] CPU: 63 PID: 664 Comm: kworker/63:1 Kdump: loaded Not tainted 4.18.0.x86_64 #46 [ 200.224008] Workqueue: events 0xffffffffc0b28a40 [ 200.224008] RIP: 0010:0xffffffffc0b28a5a [ 200.224008] Code: Bad RIP value. [ 200.224008] RSP: 0018:ffffbf3c8e2a3e88 EFLAGS: 00010246 [ 200.224008] RAX: 0000000000000000 RBX: ffffa0799ad6bca0 RCX: 0000000000000000 [ 200.224008] RDX: 0000000000000000 RSI: 0000000000000246 RDI: 0000000000000246 [ 200.224008] RBP: 0000000000000000 R08: ffff9fe43fde3cb8 R09: 00000000000000d5 [ 200.224008] R10: ffffbf3c8cb53d90 R11: 00000000000f4240 R12: ffff9fe43fde8700 [ 200.224008] R13: 0000000000000000 R14: ffffa0799ad6bca0 R15: ffffa0799ad6bca8 [ 200.224008] FS: 0000000000000000(0000) GS:ffff9fe43fdc0000(0000) knlGS:0000000000000000 [ 200.224008] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 200.224008] CR2: ffffffffc0b28a30 CR3: 00000097fe00a002 CR4: 00000000007606e0 [ 200.224008] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 200.224008] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [ 200.224008] PKRU: 55555554 [ 200.224008] Call Trace: [ 200.224008] ? process_one_work+0x195/0x390 [ 200.224008] ? worker_thread+0x30/0x390 [ 200.224008] ? process_one_work+0x390/0x390 [ 200.224008] ? kthread+0x10d/0x130 [ 200.224008] ? kthread_flush_work_fn+0x10/0x10 [ 200.224008] ? ret_from_fork+0x35/0x40 [ 200.224008] kernel fault(0x1) notification starting on CPU 63 [ 200.224008] kernel fault(0x1) notification finished on CPU 63 [ 200.224008] CR2: ffffffffc0b28a5a [ 200.224008] ---[ end trace c82a412d93f57412 ]--- The reason is as follows: T1: rmmod ipmi_si. -&gt;ipmi_unregister_smi() -&gt; ipmi_bmc_unregister() -&gt; __ipmi_bmc_unregister() -&gt; kref_put(bmc-&gt;usecount, cleanup_bmc_device); -&gt; schedule_work(bmc-&gt;remove_work); T2: rmmod ipmi_msghandler. ipmi_msghander module uninstalled, and the module space will be freed. T3: bmc-&gt;remove_work doing cleanup the bmc resource. -&gt; cleanup_bmc_work() -&gt; platform_device_unregister(bmc-&gt;pdev); -&gt; platform_device_del(pdev); -&gt; device_del(pdev-&gt;dev); -&gt; kobject_uevent(dev-&gt;kobj, KOBJ_REMOVE); -&gt; kobject_uevent_env() -&gt; dev_uevent() -&gt; if (dev-&gt;type dev-&gt;type-&gt;name) 'dev-&gt;type'(bmc_device_type) pointer space has freed when uninstall ipmi_msghander module, 'dev-&gt;type-&gt;name' cause the system crash. drivers/char/ipmi/ipmi_msghandler.c: 2820 static const struct device_type bmc_device_type = { 2821 .groups = bmc_dev_attr_groups, 2822 }; Steps to reproduce: Add a time delay in cleanup_bmc_work() function, and uninstall ipmi_si and ipmi_msghandler module. 2910 static void cleanup_bmc_work(struct work_struct *work) 2911 { 2912 struct bmc_device *bmc = container_of(work, struct bmc_device, 2913 remove_work); 2914 int id = bmc-&gt;pdev.id; /* Unregister overwrites id */ 2915 2916 msleep(3000); pdev); 2918 ida_simple_remove(ipmi_bmc_ida, id); 2919 } Use 'remove_work_wq' instead of 'system_wq' to solve this issues. Fixes: b2cfd8ab4add ("ipmi: Rework device id and guid handling to catch changing BMCs") Signed-off-by: Wu Bo <wubo40 title="valid: False, node: 182, tag: wubo40, level: 182" node_number="182"> Message-Id: &lt;1640070034-56671-1-git-send-email-wubo40@huawei.com&gt; Signed-off-by: Corey Minyard <cminyard title="valid: False, node: 183, tag: cminyard, level: 183" node_number="183"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 184, tag: sashal, level: 184" node_number="184"> commit 2460d96c19a875745ca328421308ca1f690c923e Author: Willem de Bruijn <willemb title="valid: False, node: 185, tag: willemb, level: 185" node_number="185"> Date: Mon Dec 20 09:50:27 2021 -0500 net: skip virtio_net_hdr_set_proto if protocol already set [ Upstream commit 1ed1d592113959f00cc552c3b9f47ca2d157768f ] virtio_net_hdr_set_proto infers skb-&gt;protocol from the virtio_net_hdr gso_type, to avoid packets getting dropped for lack of a proto type. Its protocol choice is a guess, especially in the case of UFO, where the single VIRTIO_NET_HDR_GSO_UDP label covers both UFOv4 and UFOv6. Skip this best effort if the field is already initialized. Whether explicitly from userspace, or implicitly based on an earlier call to dev_parse_header_protocol (which is more robust, but was introduced after this patch). Fixes: 9d2f67e43b73 ("net/packet: fix packet drop as of virtio gso") Signed-off-by: Willem de Bruijn <willemb title="valid: False, node: 186, tag: willemb, level: 186" node_number="186"> Link: https://lore.kernel.org/r/20211220145027.2784293-1-willemdebruijn.kernel@gmail.com Signed-off-by: Jakub Kicinski <kuba title="valid: False, node: 187, tag: kuba, level: 187" node_number="187"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 188, tag: sashal, level: 188" node_number="188"> commit 621d5536b452c3df2a7d09cdf84793ced5c4756d Author: Willem de Bruijn <willemb title="valid: False, node: 189, tag: willemb, level: 189" node_number="189"> Date: Mon Dec 20 09:49:01 2021 -0500 net: accept UFOv6 packages in virtio_net_hdr_to_skb [ Upstream commit 7e5cced9ca84df52d874aca6b632f930b3dc5bc6 ] Skb with skb-&gt;protocol 0 at the time of virtio_net_hdr_to_skb may have a protocol inferred from virtio_net_hdr with virtio_net_hdr_set_proto. Unlike TCP, UDP does not have separate types for IPv4 and IPv6. Type VIRTIO_NET_HDR_GSO_UDP is guessed to be IPv4/UDP. As of the below commit, UFOv6 packets are dropped due to not matching the protocol as obtained from dev_parse_header_protocol. Invert the test to take that L2 protocol field as starting point and pass both UFOv4 and UFOv6 for VIRTIO_NET_HDR_GSO_UDP. Fixes: 924a9bc362a5 ("net: check if protocol extracted by virtio_net_hdr_set_proto is correct") Link: https://lore.kernel.org/netdev/CABcq3pG9GRCYqFDBAJ48H1vpnnX=41u+MhQnayF1ztLH4WX0Fw@mail.gmail.com/ Reported-by: Andrew Melnichenko <andrew title="valid: False, node: 190, tag: andrew, level: 190" node_number="190"> Signed-off-by: Willem de Bruijn <willemb title="valid: False, node: 191, tag: willemb, level: 191" node_number="191"> Link: https://lore.kernel.org/r/20211220144901.2784030-1-willemdebruijn.kernel@gmail.com Signed-off-by: Jakub Kicinski <kuba title="valid: False, node: 192, tag: kuba, level: 192" node_number="192"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 193, tag: sashal, level: 193" node_number="193"> commit 0b01c51c4f47f59ad7eb1ea5bac47fab14b188a5 Author: Jiasheng Jiang <jiasheng title="valid: False, node: 194, tag: jiasheng, level: 194" node_number="194"> Date: Fri Dec 17 17:39:11 2021 +0800 qlcnic: potential dereference null pointer of rx_queue-&gt;page_ring [ Upstream commit 60ec7fcfe76892a1479afab51ff17a4281923156 ] The return value of kcalloc() needs to be checked. To avoid dereference of null pointer in case of the failure of alloc. Therefore, it might be better to change the return type of qlcnic_sriov_alloc_vlans() and return -ENOMEM when alloc fails and return 0 the others. Also, qlcnic_sriov_set_guest_vlan_mode() and __qlcnic_pci_sriov_enable() should deal with the return value of qlcnic_sriov_alloc_vlans(). Fixes: 154d0c810c53 ("qlcnic: VLAN enhancement for 84XX adapters") Signed-off-by: Jiasheng Jiang <jiasheng title="valid: False, node: 195, tag: jiasheng, level: 195" node_number="195"> Signed-off-by: David S. Miller <davem title="valid: False, node: 196, tag: davem, level: 196" node_number="196"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 197, tag: sashal, level: 197" node_number="197"> commit 685fc8d22489aa319465d0ddf848e6d7210ae17a Author: Ignacy Gaw&#281;dzki <ignacy.gawedzki title="valid: False, node: 198, tag: ignacy.gawedzki, level: 198" node_number="198"> Date: Fri Dec 10 16:31:27 2021 +0100 netfilter: fix regression in looped (broad|multi)cast's MAC handling [ Upstream commit ebb966d3bdfed581ecccbb4a7432341baf7619b4 ] In commit 5648b5e1169f ("netfilter: nfnetlink_queue: fix OOB when mac header was cleared"), the test for non-empty MAC header introduced in commit 2c38de4c1f8da7 ("netfilter: fix looped (broad|multi)cast's MAC handling") has been replaced with a test for a set MAC header. This breaks the case when the MAC header has been reset (using skb_reset_mac_header), as is the case with looped-back multicast packets. As a result, the packets ending up in NFQUEUE get a bogus hwaddr interpreted from the first bytes of the IP header. This patch adds a test for a non-empty MAC header in addition to the test for a set MAC header. The same two tests are also implemented in nfnetlink_log.c, where the initial code of commit 2c38de4c1f8da7 ("netfilter: fix looped (broad|multi)cast's MAC handling") has not been touched, but where supposedly the same situation may happen. Fixes: 5648b5e1169f ("netfilter: nfnetlink_queue: fix OOB when mac header was cleared") Signed-off-by: Ignacy Gaw&#281;dzki <ignacy.gawedzki title="valid: False, node: 199, tag: ignacy.gawedzki, level: 199" node_number="199"> Reviewed-by: Florian Westphal <fw title="valid: False, node: 200, tag: fw, level: 200" node_number="200"> Signed-off-by: Pablo Neira Ayuso <pablo title="valid: False, node: 201, tag: pablo, level: 201" node_number="201"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 202, tag: sashal, level: 202" node_number="202"> commit 79dcbd8176152b860028b62f81a635d987365752 Author: Jos&#233; Exp&#243;sito <jose.exposito89 title="valid: False, node: 203, tag: jose.exposito89, level: 203" node_number="203"> Date: Wed Dec 8 18:52:38 2021 +0100 IB/qib: Fix memory leak in qib_user_sdma_queue_pkts() [ Upstream commit bee90911e0138c76ee67458ac0d58b38a3190f65 ] The wrong goto label was used for the error case and missed cleanup of the pkt allocation. Fixes: d39bf40e55e6 ("IB/qib: Protect from buffer overflow in struct qib_user_sdma_pkt fields") Link: https://lore.kernel.org/r/20211208175238.29983-1-jose.exposito89@gmail.com Addresses-Coverity-ID: 1493352 ("Resource leak") Signed-off-by: Jos&#233; Exp&#243;sito <jose.exposito89 title="valid: False, node: 204, tag: jose.exposito89, level: 204" node_number="204"> Acked-by: Mike Marciniszyn <mike.marciniszyn title="valid: False, node: 205, tag: mike.marciniszyn, level: 205" node_number="205"> Signed-off-by: Jason Gunthorpe <jgg title="valid: False, node: 206, tag: jgg, level: 206" node_number="206"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 207, tag: sashal, level: 207" node_number="207"> commit 78874bca4f271d96cf66bba49a4bc796e780ce89 Author: Dongliang Mu <mudongliangabcd title="valid: False, node: 208, tag: mudongliangabcd, level: 208" node_number="208"> Date: Mon Dec 6 18:19:31 2021 +0800 spi: change clk_disable_unprepare to clk_unprepare [ Upstream commit db6689b643d8653092f5853751ea2cdbc299f8d3 ] The corresponding API for clk_prepare is clk_unprepare, other than clk_disable_unprepare. Fix this by changing clk_disable_unprepare to clk_unprepare. Fixes: 5762ab71eb24 ("spi: Add support for Armada 3700 SPI Controller") Signed-off-by: Dongliang Mu <mudongliangabcd title="valid: False, node: 209, tag: mudongliangabcd, level: 209" node_number="209"> Link: https://lore.kernel.org/r/20211206101931.2816597-1-mudongliangabcd@gmail.com Signed-off-by: Mark Brown Signed-off-by: Sasha Levin <sashal title="valid: False, node: 210, tag: sashal, level: 210" node_number="210"> commit 0c0ac2547c873d2342f60db3a40545f6b3f6d519 Author: Robert Marko <robert.marko title="valid: False, node: 211, tag: robert.marko, level: 211" node_number="211"> Date: Wed Nov 17 15:02:22 2021 +0100 arm64: dts: allwinner: orangepi-zero-plus: fix PHY mode [ Upstream commit 08d2061ff9c5319a07bf9ca6bbf11fdec68f704a ] Orange Pi Zero Plus uses a Realtek RTL8211E RGMII Gigabit PHY, but its currently set to plain RGMII mode meaning that it doesn't introduce delays. With this setup, TX packets are completely lost and changing the mode to RGMII-ID so the PHY will add delays internally fixes the issue. Fixes: a7affb13b271 ("arm64: allwinner: H5: Add Xunlong Orange Pi Zero Plus") Acked-by: Chen-Yu Tsai <wens title="valid: False, node: 212, tag: wens, level: 212" node_number="212"> Tested-by: Ron Goossens <rgoossens title="valid: False, node: 213, tag: rgoossens, level: 213" node_number="213"> Tested-by: Samuel Holland <samuel title="valid: False, node: 214, tag: samuel, level: 214" node_number="214"> Signed-off-by: Robert Marko <robert.marko title="valid: False, node: 215, tag: robert.marko, level: 215" node_number="215"> Signed-off-by: Maxime Ripard <maxime title="valid: False, node: 216, tag: maxime, level: 216" node_number="216"> Link: https://lore.kernel.org/r/20211117140222.43692-1-robert.marko@sartura.hr Signed-off-by: Sasha Levin <sashal title="valid: False, node: 217, tag: sashal, level: 217" node_number="217"> commit 6fa4e2992717c67c3243e88a8342b795b939e5a2 Author: Benjamin Tissoires <benjamin.tissoires title="valid: False, node: 218, tag: benjamin.tissoires, level: 218" node_number="218"> Date: Mon Dec 20 10:51:20 2021 +0100 HID: holtek: fix mouse probing commit 93a2207c254ca102ebbdae47b00f19bbfbfa7ecd upstream. An overlook from the previous commit: we don't even parse or start the device, meaning that the device is not presented to user space. Fixes: 93020953d0fa ("HID: check for valid USB device for many HID drivers") Cc: stable@vger.kernel.org Link: https://bugs.archlinux.org/task/73048 Link: https://bugzilla.kernel.org/show_bug.cgi?id=215341 Link: https://lore.kernel.org/r/e4efbf13-bd8d-0370-629b-6c80c0044b15@leemhuis.info/ Signed-off-by: Benjamin Tissoires <benjamin.tissoires title="valid: False, node: 219, tag: benjamin.tissoires, level: 219" node_number="219"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 220, tag: gregkh, level: 220" node_number="220"> commit 2712816c10b3c59909399f48cce2dc6d2180c7e9 Author: Ji-Ze Hong (Peter Hong) <hpeter title="valid: False, node: 221, tag: hpeter, level: 221" node_number="221"> Date: Wed Dec 15 15:58:35 2021 +0800 serial: 8250_fintek: Fix garbled text for console commit 6c33ff728812aa18792afffaf2c9873b898e7512 upstream. Commit fab8a02b73eb ("serial: 8250_fintek: Enable high speed mode on Fintek F81866") introduced support to use high baudrate with Fintek SuperIO UARTs. It'll change clocksources when the UART probed. But when user add kernel parameter "console=ttyS0,115200 console=tty0" to make the UART as console output, the console will output garbled text after the following kernel message. [ 3.681188] Serial: 8250/16550 driver, 32 ports, IRQ sharing enabled The issue is occurs in following step: probe_setup_port() -&gt; fintek_8250_goto_highspeed() It change clocksource from 115200 to 921600 with wrong time, it should change clocksource in set_termios() not in probed. The following 3 patches are implemented change clocksource in fintek_8250_set_termios(). Commit 58178914ae5b ("serial: 8250_fintek: UART dynamic clocksource on Fintek F81216H") Commit 195638b6d44f ("serial: 8250_fintek: UART dynamic clocksource on Fintek F81866") Commit 423d9118c624 ("serial: 8250_fintek: Add F81966 Support") Due to the high baud rate had implemented above 3 patches and the patch Commit fab8a02b73eb ("serial: 8250_fintek: Enable high speed mode on Fintek F81866") is bugged, So this patch will remove it. Fixes: fab8a02b73eb ("serial: 8250_fintek: Enable high speed mode on Fintek F81866") Signed-off-by: Ji-Ze Hong (Peter Hong) <hpeter title="valid: False, node: 222, tag: hpeter, level: 222" node_number="222"> Link: https://lore.kernel.org/r/20211215075835.2072-1-hpeter+linux_kernel@gmail.com Cc: stable <stable title="valid: False, node: 223, tag: stable, level: 223" node_number="223"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 224, tag: gregkh, level: 224" node_number="224"> commit 51c925a9bcccc642397ad3283c04ccc4e6b13534 Author: Greg Jesionowski <jesionowskigreg title="valid: False, node: 225, tag: jesionowskigreg, level: 225" node_number="225"> Date: Tue Dec 14 15:10:27 2021 -0700 net: usb: lan78xx: add Allied Telesis AT29M2-AF commit ef8a0f6eab1ca5d1a75c242c5c7b9d386735fa0a upstream. This adds the vendor and product IDs for the AT29M2-AF which is a lan7801-based device. Signed-off-by: Greg Jesionowski <jesionowskigreg title="valid: False, node: 226, tag: jesionowskigreg, level: 226" node_number="226"> Link: https://lore.kernel.org/r/20211214221027.305784-1-jesionowskigreg@gmail.com Signed-off-by: Jakub Kicinski <kuba title="valid: False, node: 227, tag: kuba, level: 227" node_number="227"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 228, tag: gregkh, level: 228" node_number="228"/></kuba></jesionowskigreg></jesionowskigreg></gregkh></stable></hpeter></hpeter></gregkh></benjamin.tissoires></benjamin.tissoires></sashal></maxime></robert.marko></samuel></rgoossens></wens></robert.marko></sashal></mudongliangabcd></mudongliangabcd></sashal></jgg></mike.marciniszyn></jose.exposito89></jose.exposito89></sashal></pablo></fw></ignacy.gawedzki></ignacy.gawedzki></sashal></davem></jiasheng></jiasheng></sashal></kuba></willemb></andrew></willemb></sashal></kuba></willemb></willemb></sashal></cminyard></wubo40></wubo40></sashal></kuba></jay.vosburgh></ffmancera></ffmancera></sashal></davem></jiasheng></jiasheng></sashal></davem></jiasheng></jiasheng></sashal></kuba></habetsm.xilinx></jiasheng></jiasheng></sashal></dmitry.torokhov></wsa></andrea.righi></andrea.righi></sashal></linux></linux></sashal></linux></krellan></krellan></sashal></linux></david.wilson></david.wilson></linux></sashal></linux></david.wilson></linux></sashal></linux></krellan></linux></gregkh></tiwai></stable></xkernel.wang></xkernel.wang></gregkh></tiwai></stable></colin.i.king></colin.king></gregkh></tiwai></stable></gregkh></dmitry.torokhov></jose.exposito89></jose.exposito89></gregkh></cminyard></cminyard></cascardo></cascardo></gregkh></cminyard></ykaukab></tiwai></ykaukab></gregkh></cminyard></ioanna-maria.alifieraki></cminyard></cascardo></cascardo></gregkh></dave.anglin></dave.anglin></gregkh></bp></dave.hansen></andrew.cooper3></andrew.cooper3></gregkh></linus.walleij></fabien.dessenne></chf.fritz></fabien.dessenne></gregkh></ulf.hansson></adrian.hunter></pshete></pshete></gregkh></ulf.hansson></adrian.hunter></alcooperx></ulf.hansson></gregkh></rmk></ardb></stable></ardb></gregkh></jens.wiklander></tyhicks></sumit.garg></patrik.lantz></sumit.garg></gregkh></jaegeuk></chao></wenqingliu0120></chao></gregkh></posteuca></posteuca></gregkh></pbonzini></mlevitsk></seanjc></seanjc></gregkh></torvalds></akpm></stable></aarcange></rientjes></mgorman></mhocko></arbn></numaif.h></stdio.h></stdlib.h></assert.h></fcntl.h></sys></sys></unistd.h></arbn></gregkh></linus.walleij></wenst></zhiyong.tao></guodong.liu></guodong.liu></gregkh></linux></linux></gregkh></linux></linux></gregkh></davem></linma></nagi></linma></gregkh></davem></linma></linma></gregkh></davem></linma></linma></gregkh></davem></remi></remi></gregkh></skhan></linux></sudip.mukherjee></lkft></hulkrobot></f.fainelli></gregkh></p></body>
        <style tyle='text/css'>
body{
    position: relative;
    padding-left: 30px;
    top: 60px;
}
* {
    border: 1px solid #eee;
    padding: 5px 12px;
    margin: 3px 0;
    box-sizing: content-box;
    background-color: #fff;
    cursor: no-drop;
}
main:hover > *, section:hover > *, header:hover > *, nav:hover > *, a:hover > *, div:hover > *, p:hover > *, ul:hover > *, h1:hover > *, h2:hover > *, h3:hover > *, li:hover > *, span:hover > *{
    border: 2px solid green;
    background-color: #fffeee;
    padding: 5px 23px !important;
    margin: 1px 0;
    color: green;
}
main:hover, section:hover, header:hover, nav:hover, a:hover, div:hover, p:hover, ul:hover, h1:hover, h2:hover, h3:hover, li:hover, span:hover{
    border: 1px solid #fff;
    background-color: #eee;
}
a, span {
    display: block;
}
.selected {
    border: 2px solid orchid !important;
    opacity: 0.8;
    color: orchid !important;
}
.selected * {
    padding: 2px !important;
    color: orchid !important;
}
.valid {
  cursor: pointer;
}
.btn{
  cursor: pointer;
  font-weight: bolder;
  padding: 8px;
}
</style> 
        <script>function OpenOriginalLink($event){
    $event.stopPropagation();
    console.log(url);
}

function removeItem($event){
    $event.stopPropagation();
    console.log('Remove item: ', url)
    localStorage.removeItem(url)
}

function exportData($event){
    $event.stopPropagation();

    result = []
    for(let i=0; i<localStorage.length; i++) {
        let key = localStorage.key(i);
        result.push(localStorage.getItem(key))
    }
    const _url = URL.createObjectURL(new Blob([result.join("\n")], {type: 'text/plain'}))
    $event.target.href = _url;
    localStorage.clear()
}

var removeItemBtn = document.createElement("BUTTON");   // Create a <button> element
removeItemBtn.innerHTML = "Remove Item";
removeItemBtn.classList.add('btn');
removeItemBtn.style.position = "fixed";
removeItemBtn.style.left = '5px';
removeItemBtn.style.top = 0;
removeItemBtn.style.border = "1px solid";
removeItemBtn.style.boxShadow = "3px 3px #888";
removeItemBtn.onclick = removeItem;
document.body.appendChild(removeItemBtn);

var goToOriginLink = document.createElement("A");   // Create a <button> element
goToOriginLink.innerHTML = "GoToOrigin";
goToOriginLink.classList.add('btn');
goToOriginLink.style.position = "fixed"
goToOriginLink.style.left = '115px'
goToOriginLink.style.top = 0;
goToOriginLink.onclick = OpenOriginalLink;
goToOriginLink.setAttribute('href', decodeURIComponent(url));
goToOriginLink.target = '_blank';
document.body.appendChild(goToOriginLink);

var current = new Date
var exportDataLink = document.createElement("A");   // Create a <button> element
exportDataLink.innerHTML = "Export data";
exportDataLink.classList.add('btn');
exportDataLink.download = current.toISOString() + '.exported.txt';
exportDataLink.style.position = "fixed";
exportDataLink.style.right = '5px';
exportDataLink.style.top = 0;
exportDataLink.style.border = "1px solid #888";
exportDataLink.style.boxShadow = "3px 3px #888";
exportDataLink.onclick = exportData;
document.body.appendChild(exportDataLink);

data = {
    'title': null ,
    'article': null
}

var body = document.getElementsByTagName("body")[0];

body.onclick = function($e){
    var num = $e.target.getAttribute('node_number')
    var valid = $e.target.getAttribute('valid')

    if(!valid){
        console.log("Element is invalid")
        return
    }

    if(data.length > 2){
        data = data.splice(0, 2)
    }

    console.log("node:", $e.target)

    if(!data.title && !data.article){
        data.title = num;
        console.log("data:", data)
        $e.target.classList.add('selected')
    }else if (data.title && !data.article){
        data.article = num;
        console.log("data:", data)
        $e.target.classList.add('selected')
    }else{
        selected = Array.from(document.getElementsByClassName("selected"))
        selected.forEach(function(el){
            el.classList.remove('selected')
        })

        data.title = num;
        data.article = null;
        $e.target.classList.add('selected')

    }

    if(data.title && data.article){
        var obj = {
            url: url,
            text: body_html,
            title: data.title,
            article: data.article,
        }

        var datasetItem = JSON.stringify(obj)
        localStorage.setItem(url, datasetItem)
    }
}
</script> 
      </html>