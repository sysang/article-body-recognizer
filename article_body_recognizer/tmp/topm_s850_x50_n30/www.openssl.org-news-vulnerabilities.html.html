<!DOCTYPE html>
<html>
<head>

      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

        <script> var url = encodeURIComponent('https://www.openssl.org/news/vulnerabilities.html');</script>

        <script> var body_html = 'PGJvZHk+IDxoZWFkZXIgPiA8aGdyb3VwPiA8aDE+IDxhID4gT3BlblNTTCA8L2E+IDwvaDE+IDxoMj4gQ3J5cHRvZ3JhcGh5IGFuZCBTU0wvVExTIFRvb2xraXQgPC9oMj4gPC9oZ3JvdXA+IDwvaGVhZGVyPiAgPGRpdiA+IDxkaXYgPiA8ZGl2ID4gPGFydGljbGU+IDxoZWFkZXI+PGgyPlZ1bG5lcmFiaWxpdGllczwvaDI+PC9oZWFkZXI+IDxkaXYgPiA8cD4gSWYgeW91IHRoaW5rIHlvdSBoYXZlIGZvdW5kIGEgc2VjdXJpdHkgYnVnIGluIE9wZW5TU0wsIHBsZWFzZSA8YSA+cmVwb3J0IGl0IHRvIHVzPC9hPi4gPC9wPiA8cD5TaG93IGlzc3VlcyBmaXhlZCBvbmx5IGluIE9wZW5TU0wgPGEgPjMuMDwvYT4sIDxhID4xLjEuMTwvYT4sIDxhID4xLjEuMDwvYT4sIDxhID4xLjAuMjwvYT4sIDxhID4xLjAuMTwvYT4sIDxhID4xLjAuMDwvYT4sIDxhID4wLjkuODwvYT4sIDxhID4wLjkuNzwvYT4sIDxhID4wLjkuNjwvYT48L3A+PHA+Tm90ZTogQWxsIE9wZW5TU0wgdmVyc2lvbnMgYmVmb3JlIDEuMS4xIGFyZSBvdXQgb2Ygc3VwcG9ydCBhbmQgbm8gbG9uZ2VyIHJlY2VpdmluZyB1cGRhdGVzLiBFeHRlbmRlZCBzdXBwb3J0IGlzIGF2YWlsYWJsZSBmb3IgMS4wLjIgZnJvbSBPcGVuU1NMIFNvZnR3YXJlIFNlcnZpY2VzIGZvciBwcmVtaXVtIHN1cHBvcnQgY3VzdG9tZXJzLjwvcD48cD48YSA+SnVtcCB0byB5ZWFyOiA8L2E+PGEgPjIwMjE8L2E+LCA8YSA+MjAyMDwvYT4sIDxhID4yMDE5PC9hPiwgPGEgPjIwMTg8L2E+LCA8YSA+MjAxNzwvYT4sIDxhID4yMDE2PC9hPiwgPGEgPjIwMTU8L2E+LCA8YSA+MjAxNDwvYT4sIDxhID4yMDEzPC9hPiwgPGEgPjIwMTI8L2E+LCA8YSA+MjAxMTwvYT4sIDxhID4yMDEwPC9hPiwgPGEgPjIwMDk8L2E+LCA8YSA+MjAwODwvYT4sIDxhID4yMDA3PC9hPiwgPGEgPjIwMDY8L2E+LCA8YSA+MjAwNTwvYT4sIDxhID4yMDA0PC9hPiwgPGEgPjIwMDM8L2E+LCA8YSA+MjAwMjwvYT48L3A+PGgzPjxhID4yMDIxPC9hPjwvaDM+PGRsPjxkdD48YSA+Q1ZFLTIwMjEtNDA0NDwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltNb2RlcmF0ZSBzZXZlcml0eV08L2E+IDE0IERlY2VtYmVyIDIwMjE6IDwvZHQ+PGRkPkludGVybmFsbHkgbGlic3NsIGluIE9wZW5TU0wgY2FsbHMgWDUwOV92ZXJpZnlfY2VydCgpIG9uIHRoZSBjbGllbnQgc2lkZSB0byB2ZXJpZnkgYSBjZXJ0aWZpY2F0ZSBzdXBwbGllZCBieSBhIHNlcnZlci4gVGhhdCBmdW5jdGlvbiBtYXkgcmV0dXJuIGEgbmVnYXRpdmUgcmV0dXJuIHZhbHVlIHRvIGluZGljYXRlIGFuIGludGVybmFsIGVycm9yIChmb3IgZXhhbXBsZSBvdXQgb2YgbWVtb3J5KS4gU3VjaCBhIG5lZ2F0aXZlIHJldHVybiB2YWx1ZSBpcyBtaXNoYW5kbGVkIGJ5IE9wZW5TU0wgYW5kIHdpbGwgY2F1c2UgYW4gSU8gZnVuY3Rpb24gKHN1Y2ggYXMgU1NMX2Nvbm5lY3QoKSBvciBTU0xfZG9faGFuZHNoYWtlKCkpIHRvIG5vdCBpbmRpY2F0ZSBzdWNjZXNzIGFuZCBhIHN1YnNlcXVlbnQgY2FsbCB0byBTU0xfZ2V0X2Vycm9yKCkgdG8gcmV0dXJuIHRoZSB2YWx1ZSBTU0xfRVJST1JfV0FOVF9SRVRSWV9WRVJJRlkuIFRoaXMgcmV0dXJuIHZhbHVlIGlzIG9ubHkgc3VwcG9zZWQgdG8gYmUgcmV0dXJuZWQgYnkgT3BlblNTTCBpZiB0aGUgYXBwbGljYXRpb24gaGFzIHByZXZpb3VzbHkgY2FsbGVkIFNTTF9DVFhfc2V0X2NlcnRfdmVyaWZ5X2NhbGxiYWNrKCkuIFNpbmNlIG1vc3QgYXBwbGljYXRpb25zIGRvIG5vdCBkbyB0aGlzIHRoZSBTU0xfRVJST1JfV0FOVF9SRVRSWV9WRVJJRlkgcmV0dXJuIHZhbHVlIGZyb20gU1NMX2dldF9lcnJvcigpIHdpbGwgYmUgdG90YWxseSB1bmV4cGVjdGVkIGFuZCBhcHBsaWNhdGlvbnMgbWF5IG5vdCBiZWhhdmUgY29ycmVjdGx5IGFzIGEgcmVzdWx0LiBUaGUgZXhhY3QgYmVoYXZpb3VyIHdpbGwgZGVwZW5kIG9uIHRoZSBhcHBsaWNhdGlvbiBidXQgaXQgY291bGQgcmVzdWx0IGluIGNyYXNoZXMsIGluZmluaXRlIGxvb3BzIG9yIG90aGVyIHNpbWlsYXIgaW5jb3JyZWN0IHJlc3BvbnNlcy4gVGhpcyBpc3N1ZSBpcyBtYWRlIG1vcmUgc2VyaW91cyBpbiBjb21iaW5hdGlvbiB3aXRoIGEgc2VwYXJhdGUgYnVnIGluIE9wZW5TU0wgMy4wIHRoYXQgd2lsbCBjYXVzZSBYNTA5X3ZlcmlmeV9jZXJ0KCkgdG8gaW5kaWNhdGUgYW4gaW50ZXJuYWwgZXJyb3Igd2hlbiBwcm9jZXNzaW5nIGEgY2VydGlmaWNhdGUgY2hhaW4uIFRoaXMgd2lsbCBvY2N1ciB3aGVyZSBhIGNlcnRpZmljYXRlIGRvZXMgbm90IGluY2x1ZGUgdGhlIFN1YmplY3QgQWx0ZXJuYXRpdmUgTmFtZSBleHRlbnNpb24gYnV0IHdoZXJlIGEgQ2VydGlmaWNhdGUgQXV0aG9yaXR5IGhhcyBlbmZvcmNlZCBuYW1lIGNvbnN0cmFpbnRzLiBUaGlzIGlzc3VlIGNhbiBvY2N1ciBldmVuIHdpdGggdmFsaWQgY2hhaW5zLiBCeSBjb21iaW5pbmcgdGhlIHR3byBpc3N1ZXMgYW4gYXR0YWNrZXIgY291bGQgaW5kdWNlIGluY29ycmVjdCwgYXBwbGljYXRpb24gZGVwZW5kZW50IGJlaGF2aW91ci4gUmVwb3J0ZWQgYnkgVG9iaWFzIE5pZcOfZW4uIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAzLjAuMSA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMy4wLjApPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAyMS0zNzEyPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W01vZGVyYXRlIHNldmVyaXR5XTwvYT4gMjQgQXVndXN0IDIwMjE6IDwvZHQ+PGRkPkFTTi4xIHN0cmluZ3MgYXJlIHJlcHJlc2VudGVkIGludGVybmFsbHkgd2l0aGluIE9wZW5TU0wgYXMgYW4gQVNOMV9TVFJJTkcgc3RydWN0dXJlIHdoaWNoIGNvbnRhaW5zIGEgYnVmZmVyIGhvbGRpbmcgdGhlIHN0cmluZyBkYXRhIGFuZCBhIGZpZWxkIGhvbGRpbmcgdGhlIGJ1ZmZlciBsZW5ndGguIFRoaXMgY29udHJhc3RzIHdpdGggbm9ybWFsIEMgc3RyaW5ncyB3aGljaCBhcmUgcmVwZXNlbnRlZCBhcyBhIGJ1ZmZlciBmb3IgdGhlIHN0cmluZyBkYXRhIHdoaWNoIGlzIHRlcm1pbmF0ZWQgd2l0aCBhIE5VTCAoMCkgYnl0ZS4gQWx0aG91Z2ggbm90IGEgc3RyaWN0IHJlcXVpcmVtZW50LCBBU04uMSBzdHJpbmdzIHRoYXQgYXJlIHBhcnNlZCB1c2luZyBPcGVuU1NMJ3Mgb3duICJkMmkiIGZ1bmN0aW9ucyAoYW5kIG90aGVyIHNpbWlsYXIgcGFyc2luZyBmdW5jdGlvbnMpIGFzIHdlbGwgYXMgYW55IHN0cmluZyB3aG9zZSB2YWx1ZSBoYXMgYmVlbiBzZXQgd2l0aCB0aGUgQVNOMV9TVFJJTkdfc2V0KCkgZnVuY3Rpb24gd2lsbCBhZGRpdGlvbmFsbHkgTlVMIHRlcm1pbmF0ZSB0aGUgYnl0ZSBhcnJheSBpbiB0aGUgQVNOMV9TVFJJTkcgc3RydWN0dXJlLiBIb3dldmVyLCBpdCBpcyBwb3NzaWJsZSBmb3IgYXBwbGljYXRpb25zIHRvIGRpcmVjdGx5IGNvbnN0cnVjdCB2YWxpZCBBU04xX1NUUklORyBzdHJ1Y3R1cmVzIHdoaWNoIGRvIG5vdCBOVUwgdGVybWluYXRlIHRoZSBieXRlIGFycmF5IGJ5IGRpcmVjdGx5IHNldHRpbmcgdGhlICJkYXRhIiBhbmQgImxlbmd0aCIgZmllbGRzIGluIHRoZSBBU04xX1NUUklORyBhcnJheS4gVGhpcyBjYW4gYWxzbyBoYXBwZW4gYnkgdXNpbmcgdGhlIEFTTjFfU1RSSU5HX3NldDAoKSBmdW5jdGlvbi4gTnVtZXJvdXMgT3BlblNTTCBmdW5jdGlvbnMgdGhhdCBwcmludCBBU04uMSBkYXRhIGhhdmUgYmVlbiBmb3VuZCB0byBhc3N1bWUgdGhhdCB0aGUgQVNOMV9TVFJJTkcgYnl0ZSBhcnJheSB3aWxsIGJlIE5VTCB0ZXJtaW5hdGVkLCBldmVuIHRob3VnaCB0aGlzIGlzIG5vdCBndWFyYW50ZWVkIGZvciBzdHJpbmdzIHRoYXQgaGF2ZSBiZWVuIGRpcmVjdGx5IGNvbnN0cnVjdGVkLiBXaGVyZSBhbiBhcHBsaWNhdGlvbiByZXF1ZXN0cyBhbiBBU04uMSBzdHJ1Y3R1cmUgdG8gYmUgcHJpbnRlZCwgYW5kIHdoZXJlIHRoYXQgQVNOLjEgc3RydWN0dXJlIGNvbnRhaW5zIEFTTjFfU1RSSU5HcyB0aGF0IGhhdmUgYmVlbiBkaXJlY3RseSBjb25zdHJ1Y3RlZCBieSB0aGUgYXBwbGljYXRpb24gd2l0aG91dCBOVUwgdGVybWluYXRpbmcgdGhlICJkYXRhIiBmaWVsZCwgdGhlbiBhIHJlYWQgYnVmZmVyIG92ZXJydW4gY2FuIG9jY3VyLiBUaGUgc2FtZSB0aGluZyBjYW4gYWxzbyBvY2N1ciBkdXJpbmcgbmFtZSBjb25zdHJhaW50cyBwcm9jZXNzaW5nIG9mIGNlcnRpZmljYXRlcyAoZm9yIGV4YW1wbGUgaWYgYSBjZXJ0aWZpY2F0ZSBoYXMgYmVlbiBkaXJlY3RseSBjb25zdHJ1Y3RlZCBieSB0aGUgYXBwbGljYXRpb24gaW5zdGVhZCBvZiBsb2FkaW5nIGl0IHZpYSB0aGUgT3BlblNTTCBwYXJzaW5nIGZ1bmN0aW9ucywgYW5kIHRoZSBjZXJ0aWZpY2F0ZSBjb250YWlucyBub24gTlVMIHRlcm1pbmF0ZWQgQVNOMV9TVFJJTkcgc3RydWN0dXJlcykuIEl0IGNhbiBhbHNvIG9jY3VyIGluIHRoZSBYNTA5X2dldDFfZW1haWwoKSwgWDUwOV9SRVFfZ2V0MV9lbWFpbCgpIGFuZCBYNTA5X2dldDFfb2NzcCgpIGZ1bmN0aW9ucy4gSWYgYSBtYWxpY2lvdXMgYWN0b3IgY2FuIGNhdXNlIGFuIGFwcGxpY2F0aW9uIHRvIGRpcmVjdGx5IGNvbnN0cnVjdCBhbiBBU04xX1NUUklORyBhbmQgdGhlbiBwcm9jZXNzIGl0IHRocm91Z2ggb25lIG9mIHRoZSBhZmZlY3RlZCBPcGVuU1NMIGZ1bmN0aW9ucyB0aGVuIHRoaXMgaXNzdWUgY291bGQgYmUgaGl0LiBUaGlzIG1pZ2h0IHJlc3VsdCBpbiBhIGNyYXNoIChjYXVzaW5nIGEgRGVuaWFsIG9mIFNlcnZpY2UgYXR0YWNrKS4gSXQgY291bGQgYWxzbyByZXN1bHQgaW4gdGhlIGRpc2Nsb3N1cmUgb2YgcHJpdmF0ZSBtZW1vcnkgY29udGVudHMgKHN1Y2ggYXMgcHJpdmF0ZSBrZXlzLCBvciBzZW5zaXRpdmUgcGxhaW50ZXh0KS4gUmVwb3J0ZWQgYnkgSW5nbyBTY2h3YXJ6ZS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMS4xbCA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4xLjEtMS4xLjFrKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJ6YSA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4wLjItMS4wLjJ5KTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMjEtMzcxMTwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltIaWdoIHNldmVyaXR5XTwvYT4gMjQgQXVndXN0IDIwMjE6IDwvZHQ+PGRkPkluIG9yZGVyIHRvIGRlY3J5cHQgU00yIGVuY3J5cHRlZCBkYXRhIGFuIGFwcGxpY2F0aW9uIGlzIGV4cGVjdGVkIHRvIGNhbGwgdGhlIEFQSSBmdW5jdGlvbiBFVlBfUEtFWV9kZWNyeXB0KCkuIFR5cGljYWxseSBhbiBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgdGhpcyBmdW5jdGlvbiB0d2ljZS4gVGhlIGZpcnN0IHRpbWUsIG9uIGVudHJ5LCB0aGUgIm91dCIgcGFyYW1ldGVyIGNhbiBiZSBOVUxMIGFuZCwgb24gZXhpdCwgdGhlICJvdXRsZW4iIHBhcmFtZXRlciBpcyBwb3B1bGF0ZWQgd2l0aCB0aGUgYnVmZmVyIHNpemUgcmVxdWlyZWQgdG8gaG9sZCB0aGUgZGVjcnlwdGVkIHBsYWludGV4dC4gVGhlIGFwcGxpY2F0aW9uIGNhbiB0aGVuIGFsbG9jYXRlIGEgc3VmZmljaWVudGx5IHNpemVkIGJ1ZmZlciBhbmQgY2FsbCBFVlBfUEtFWV9kZWNyeXB0KCkgYWdhaW4sIGJ1dCB0aGlzIHRpbWUgcGFzc2luZyBhIG5vbi1OVUxMIHZhbHVlIGZvciB0aGUgIm91dCIgcGFyYW1ldGVyLiBBIGJ1ZyBpbiB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNNMiBkZWNyeXB0aW9uIGNvZGUgbWVhbnMgdGhhdCB0aGUgY2FsY3VsYXRpb24gb2YgdGhlIGJ1ZmZlciBzaXplIHJlcXVpcmVkIHRvIGhvbGQgdGhlIHBsYWludGV4dCByZXR1cm5lZCBieSB0aGUgZmlyc3QgY2FsbCB0byBFVlBfUEtFWV9kZWNyeXB0KCkgY2FuIGJlIHNtYWxsZXIgdGhhbiB0aGUgYWN0dWFsIHNpemUgcmVxdWlyZWQgYnkgdGhlIHNlY29uZCBjYWxsLiBUaGlzIGNhbiBsZWFkIHRvIGEgYnVmZmVyIG92ZXJmbG93IHdoZW4gRVZQX1BLRVlfZGVjcnlwdCgpIGlzIGNhbGxlZCBieSB0aGUgYXBwbGljYXRpb24gYSBzZWNvbmQgdGltZSB3aXRoIGEgYnVmZmVyIHRoYXQgaXMgdG9vIHNtYWxsLiBBIG1hbGljaW91cyBhdHRhY2tlciB3aG8gaXMgYWJsZSBwcmVzZW50IFNNMiBjb250ZW50IGZvciBkZWNyeXB0aW9uIHRvIGFuIGFwcGxpY2F0aW9uIGNvdWxkIGNhdXNlIGF0dGFja2VyIGNob3NlbiBkYXRhIHRvIG92ZXJmbG93IHRoZSBidWZmZXIgYnkgdXAgdG8gYSBtYXhpbXVtIG9mIDYyIGJ5dGVzIGFsdGVyaW5nIHRoZSBjb250ZW50cyBvZiBvdGhlciBkYXRhIGhlbGQgYWZ0ZXIgdGhlIGJ1ZmZlciwgcG9zc2libHkgY2hhbmdpbmcgYXBwbGljYXRpb24gYmVoYXZpb3VyIG9yIGNhdXNpbmcgdGhlIGFwcGxpY2F0aW9uIHRvIGNyYXNoLiBUaGUgbG9jYXRpb24gb2YgdGhlIGJ1ZmZlciBpcyBhcHBsaWNhdGlvbiBkZXBlbmRlbnQgYnV0IGlzIHR5cGljYWxseSBoZWFwIGFsbG9jYXRlZC4gUmVwb3J0ZWQgYnkgSm9obiBPdXlhbmcuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjEuMWwgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMS4xLTEuMS4xayk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDIxLTM0NTA8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bSGlnaCBzZXZlcml0eV08L2E+IDI1IE1hcmNoIDIwMjE6IDwvZHQ+PGRkPlRoZSBYNTA5X1ZfRkxBR19YNTA5X1NUUklDVCBmbGFnIGVuYWJsZXMgYWRkaXRpb25hbCBzZWN1cml0eSBjaGVja3Mgb2YgdGhlIGNlcnRpZmljYXRlcyBwcmVzZW50IGluIGEgY2VydGlmaWNhdGUgY2hhaW4uIEl0IGlzIG5vdCBzZXQgYnkgZGVmYXVsdC4gU3RhcnRpbmcgZnJvbSBPcGVuU1NMIHZlcnNpb24gMS4xLjFoIGEgY2hlY2sgdG8gZGlzYWxsb3cgY2VydGlmaWNhdGVzIGluIHRoZSBjaGFpbiB0aGF0IGhhdmUgZXhwbGljaXRseSBlbmNvZGVkIGVsbGlwdGljIGN1cnZlIHBhcmFtZXRlcnMgd2FzIGFkZGVkIGFzIGFuIGFkZGl0aW9uYWwgc3RyaWN0IGNoZWNrLiBBbiBlcnJvciBpbiB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBjaGVjayBtZWFudCB0aGF0IHRoZSByZXN1bHQgb2YgYSBwcmV2aW91cyBjaGVjayB0byBjb25maXJtIHRoYXQgY2VydGlmaWNhdGVzIGluIHRoZSBjaGFpbiBhcmUgdmFsaWQgQ0EgY2VydGlmaWNhdGVzIHdhcyBvdmVyd3JpdHRlbi4gVGhpcyBlZmZlY3RpdmVseSBieXBhc3NlcyB0aGUgY2hlY2sgdGhhdCBub24tQ0EgY2VydGlmaWNhdGVzIG11c3Qgbm90IGJlIGFibGUgdG8gaXNzdWUgb3RoZXIgY2VydGlmaWNhdGVzLiBJZiBhICJwdXJwb3NlIiBoYXMgYmVlbiBjb25maWd1cmVkIHRoZW4gdGhlcmUgaXMgYSBzdWJzZXF1ZW50IG9wcG9ydHVuaXR5IGZvciBjaGVja3MgdGhhdCB0aGUgY2VydGlmaWNhdGUgaXMgYSB2YWxpZCBDQS4gQWxsIG9mIHRoZSBuYW1lZCAicHVycG9zZSIgdmFsdWVzIGltcGxlbWVudGVkIGluIGxpYmNyeXB0byBwZXJmb3JtIHRoaXMgY2hlY2suIFRoZXJlZm9yZSwgd2hlcmUgYSBwdXJwb3NlIGlzIHNldCB0aGUgY2VydGlmaWNhdGUgY2hhaW4gd2lsbCBzdGlsbCBiZSByZWplY3RlZCBldmVuIHdoZW4gdGhlIHN0cmljdCBmbGFnIGhhcyBiZWVuIHVzZWQuIEEgcHVycG9zZSBpcyBzZXQgYnkgZGVmYXVsdCBpbiBsaWJzc2wgY2xpZW50IGFuZCBzZXJ2ZXIgY2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uIHJvdXRpbmVzLCBidXQgaXQgY2FuIGJlIG92ZXJyaWRkZW4gb3IgcmVtb3ZlZCBieSBhbiBhcHBsaWNhdGlvbi4gSW4gb3JkZXIgdG8gYmUgYWZmZWN0ZWQsIGFuIGFwcGxpY2F0aW9uIG11c3QgZXhwbGljaXRseSBzZXQgdGhlIFg1MDlfVl9GTEFHX1g1MDlfU1RSSUNUIHZlcmlmaWNhdGlvbiBmbGFnIGFuZCBlaXRoZXIgbm90IHNldCBhIHB1cnBvc2UgZm9yIHRoZSBjZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb24gb3IsIGluIHRoZSBjYXNlIG9mIFRMUyBjbGllbnQgb3Igc2VydmVyIGFwcGxpY2F0aW9ucywgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgcHVycG9zZS4gT3BlblNTTCB2ZXJzaW9ucyAxLjEuMWggYW5kIG5ld2VyIGFyZSBhZmZlY3RlZCBieSB0aGlzIGlzc3VlLiBVc2VycyBvZiB0aGVzZSB2ZXJzaW9ucyBzaG91bGQgdXBncmFkZSB0byBPcGVuU1NMIDEuMS4xay4gT3BlblNTTCAxLjAuMiBpcyBub3QgaW1wYWN0ZWQgYnkgdGhpcyBpc3N1ZS4gUmVwb3J0ZWQgYnkgQmVuamFtaW4gS2FkdWsgKEFrYW1haSksIFhpYW5nIERpbmcgKEFrYW1haSksIG90aGVycyBhdCBBa2FtYWkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjEuMWsgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMS4xaC0xLjEuMWopPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAyMS0zNDQ5PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0hpZ2ggc2V2ZXJpdHldPC9hPiAyNSBNYXJjaCAyMDIxOiA8L2R0PjxkZD5BbiBPcGVuU1NMIFRMUyBzZXJ2ZXIgbWF5IGNyYXNoIGlmIHNlbnQgYSBtYWxpY2lvdXNseSBjcmFmdGVkIHJlbmVnb3RpYXRpb24gQ2xpZW50SGVsbG8gbWVzc2FnZSBmcm9tIGEgY2xpZW50LiBJZiBhIFRMU3YxLjIgcmVuZWdvdGlhdGlvbiBDbGllbnRIZWxsbyBvbWl0cyB0aGUgc2lnbmF0dXJlX2FsZ29yaXRobXMgZXh0ZW5zaW9uICh3aGVyZSBpdCB3YXMgcHJlc2VudCBpbiB0aGUgaW5pdGlhbCBDbGllbnRIZWxsbyksIGJ1dCBpbmNsdWRlcyBhIHNpZ25hdHVyZV9hbGdvcml0aG1zX2NlcnQgZXh0ZW5zaW9uIHRoZW4gYSBOVUxMIHBvaW50ZXIgZGVyZWZlcmVuY2Ugd2lsbCByZXN1bHQsIGxlYWRpbmcgdG8gYSBjcmFzaCBhbmQgYSBkZW5pYWwgb2Ygc2VydmljZSBhdHRhY2suIEEgc2VydmVyIGlzIG9ubHkgdnVsbmVyYWJsZSBpZiBpdCBoYXMgVExTdjEuMiBhbmQgcmVuZWdvdGlhdGlvbiBlbmFibGVkICh3aGljaCBpcyB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uKS4gT3BlblNTTCBUTFMgY2xpZW50cyBhcmUgbm90IGltcGFjdGVkIGJ5IHRoaXMgaXNzdWUuIEFsbCBPcGVuU1NMIDEuMS4xIHZlcnNpb25zIGFyZSBhZmZlY3RlZCBieSB0aGlzIGlzc3VlLiBVc2VycyBvZiB0aGVzZSB2ZXJzaW9ucyBzaG91bGQgdXBncmFkZSB0byBPcGVuU1NMIDEuMS4xay4gT3BlblNTTCAxLjAuMiBpcyBub3QgaW1wYWN0ZWQgYnkgdGhpcyBpc3N1ZS4gUmVwb3J0ZWQgYnkgUGV0ZXIgS8Okc3RsZSAoTm9raWEpIGFuZCBTYW11ZWwgU2FwYWxza2kgKE5va2lhKS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMS4xayA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4xLjEtMS4xLjFqKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMjEtMjM4NDE8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTW9kZXJhdGUgc2V2ZXJpdHldPC9hPiAxNiBGZWJydWFyeSAyMDIxOiA8L2R0PjxkZD5UaGUgT3BlblNTTCBwdWJsaWMgQVBJIGZ1bmN0aW9uIFg1MDlfaXNzdWVyX2FuZF9zZXJpYWxfaGFzaCgpIGF0dGVtcHRzIHRvIGNyZWF0ZSBhIHVuaXF1ZSBoYXNoIHZhbHVlIGJhc2VkIG9uIHRoZSBpc3N1ZXIgYW5kIHNlcmlhbCBudW1iZXIgZGF0YSBjb250YWluZWQgd2l0aGluIGFuIFg1MDkgY2VydGlmaWNhdGUuIEhvd2V2ZXIgaXQgZmFpbHMgdG8gY29ycmVjdGx5IGhhbmRsZSBhbnkgZXJyb3JzIHRoYXQgbWF5IG9jY3VyIHdoaWxlIHBhcnNpbmcgdGhlIGlzc3VlciBmaWVsZCAod2hpY2ggbWlnaHQgb2NjdXIgaWYgdGhlIGlzc3VlciBmaWVsZCBpcyBtYWxpY2lvdXNseSBjb25zdHJ1Y3RlZCkuIFRoaXMgbWF5IHN1YnNlcXVlbnRseSByZXN1bHQgaW4gYSBOVUxMIHBvaW50ZXIgZGVyZWYgYW5kIGEgY3Jhc2ggbGVhZGluZyB0byBhIHBvdGVudGlhbCBkZW5pYWwgb2Ygc2VydmljZSBhdHRhY2suIFRoZSBmdW5jdGlvbiBYNTA5X2lzc3Vlcl9hbmRfc2VyaWFsX2hhc2goKSBpcyBuZXZlciBkaXJlY3RseSBjYWxsZWQgYnkgT3BlblNTTCBpdHNlbGYgc28gYXBwbGljYXRpb25zIGFyZSBvbmx5IHZ1bG5lcmFibGUgaWYgdGhleSB1c2UgdGhpcyBmdW5jdGlvbiBkaXJlY3RseSBhbmQgdGhleSB1c2UgaXQgb24gY2VydGlmaWNhdGVzIHRoYXQgbWF5IGhhdmUgYmVlbiBvYnRhaW5lZCBmcm9tIHVudHJ1c3RlZCBzb3VyY2VzLiBPcGVuU1NMIHZlcnNpb25zIDEuMS4xaSBhbmQgYmVsb3cgYXJlIGFmZmVjdGVkIGJ5IHRoaXMgaXNzdWUuIFVzZXJzIG9mIHRoZXNlIHZlcnNpb25zIHNob3VsZCB1cGdyYWRlIHRvIE9wZW5TU0wgMS4xLjFqLiBPcGVuU1NMIHZlcnNpb25zIDEuMC4yeCBhbmQgYmVsb3cgYXJlIGFmZmVjdGVkIGJ5IHRoaXMgaXNzdWUuIEhvd2V2ZXIgT3BlblNTTCAxLjAuMiBpcyBvdXQgb2Ygc3VwcG9ydCBhbmQgbm8gbG9uZ2VyIHJlY2VpdmluZyBwdWJsaWMgdXBkYXRlcy4gUHJlbWl1bSBzdXBwb3J0IGN1c3RvbWVycyBvZiBPcGVuU1NMIDEuMC4yIHNob3VsZCB1cGdyYWRlIHRvIDEuMC4yeS4gT3RoZXIgdXNlcnMgc2hvdWxkIHVwZ3JhZGUgdG8gMS4xLjFqLiBSZXBvcnRlZCBieSBUYXZpcyBPcm1hbmR5IChHb29nbGUpLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4xLjFqIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjEuMS0xLjEuMWkpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMnkgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMC4yLTEuMC4yeCk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDIxLTIzODQwPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0xvdyBzZXZlcml0eV08L2E+IDE2IEZlYnJ1YXJ5IDIwMjE6IDwvZHQ+PGRkPkNhbGxzIHRvIEVWUF9DaXBoZXJVcGRhdGUsIEVWUF9FbmNyeXB0VXBkYXRlIGFuZCBFVlBfRGVjcnlwdFVwZGF0ZSBtYXkgb3ZlcmZsb3cgdGhlIG91dHB1dCBsZW5ndGggYXJndW1lbnQgaW4gc29tZSBjYXNlcyB3aGVyZSB0aGUgaW5wdXQgbGVuZ3RoIGlzIGNsb3NlIHRvIHRoZSBtYXhpbXVtIHBlcm1pc3NhYmxlIGxlbmd0aCBmb3IgYW4gaW50ZWdlciBvbiB0aGUgcGxhdGZvcm0uIEluIHN1Y2ggY2FzZXMgdGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbiBjYWxsIHdpbGwgYmUgMSAoaW5kaWNhdGluZyBzdWNjZXNzKSwgYnV0IHRoZSBvdXRwdXQgbGVuZ3RoIHZhbHVlIHdpbGwgYmUgbmVnYXRpdmUuIFRoaXMgY291bGQgY2F1c2UgYXBwbGljYXRpb25zIHRvIGJlaGF2ZSBpbmNvcnJlY3RseSBvciBjcmFzaC4gT3BlblNTTCB2ZXJzaW9ucyAxLjEuMWkgYW5kIGJlbG93IGFyZSBhZmZlY3RlZCBieSB0aGlzIGlzc3VlLiBVc2VycyBvZiB0aGVzZSB2ZXJzaW9ucyBzaG91bGQgdXBncmFkZSB0byBPcGVuU1NMIDEuMS4xai4gT3BlblNTTCB2ZXJzaW9ucyAxLjAuMnggYW5kIGJlbG93IGFyZSBhZmZlY3RlZCBieSB0aGlzIGlzc3VlLiBIb3dldmVyIE9wZW5TU0wgMS4wLjIgaXMgb3V0IG9mIHN1cHBvcnQgYW5kIG5vIGxvbmdlciByZWNlaXZpbmcgcHVibGljIHVwZGF0ZXMuIFByZW1pdW0gc3VwcG9ydCBjdXN0b21lcnMgb2YgT3BlblNTTCAxLjAuMiBzaG91bGQgdXBncmFkZSB0byAxLjAuMnkuIE90aGVyIHVzZXJzIHNob3VsZCB1cGdyYWRlIHRvIDEuMS4xai4gUmVwb3J0ZWQgYnkgUGF1bCBLZWhyZXIuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjEuMWogPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMS4xLTEuMS4xaSk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yeSA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4wLjItMS4wLjJ4KTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMjEtMjM4Mzk8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMTYgRmVicnVhcnkgMjAyMTogPC9kdD48ZGQ+T3BlblNTTCAxLjAuMiBzdXBwb3J0cyBTU0x2Mi4gSWYgYSBjbGllbnQgYXR0ZW1wdHMgdG8gbmVnb3RpYXRlIFNTTHYyIHdpdGggYSBzZXJ2ZXIgdGhhdCBpcyBjb25maWd1cmVkIHRvIHN1cHBvcnQgYm90aCBTU0x2MiBhbmQgbW9yZSByZWNlbnQgU1NMIGFuZCBUTFMgdmVyc2lvbnMgdGhlbiBhIGNoZWNrIGlzIG1hZGUgZm9yIGEgdmVyc2lvbiByb2xsYmFjayBhdHRhY2sgd2hlbiB1bnBhZGRpbmcgYW4gUlNBIHNpZ25hdHVyZS4gQ2xpZW50cyB0aGF0IHN1cHBvcnQgU1NMIG9yIFRMUyB2ZXJzaW9ucyBncmVhdGVyIHRoYW4gU1NMdjIgYXJlIHN1cHBvc2VkIHRvIHVzZSBhIHNwZWNpYWwgZm9ybSBvZiBwYWRkaW5nLiBBIHNlcnZlciB0aGF0IHN1cHBvcnRzIGdyZWF0ZXIgdGhhbiBTU0x2MiBpcyBzdXBwb3NlZCB0byByZWplY3QgY29ubmVjdGlvbiBhdHRlbXB0cyBmcm9tIGEgY2xpZW50IHdoZXJlIHRoaXMgc3BlY2lhbCBmb3JtIG9mIHBhZGRpbmcgaXMgcHJlc2VudCwgYmVjYXVzZSB0aGlzIGluZGljYXRlcyB0aGF0IGEgdmVyc2lvbiByb2xsYmFjayBoYXMgb2NjdXJyZWQgKGkuZS4gYm90aCBjbGllbnQgYW5kIHNlcnZlciBzdXBwb3J0IGdyZWF0ZXIgdGhhbiBTU0x2MiwgYW5kIHlldCB0aGlzIGlzIHRoZSB2ZXJzaW9uIHRoYXQgaXMgYmVpbmcgcmVxdWVzdGVkKS4gVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgcGFkZGluZyBjaGVjayBpbnZlcnRlZCB0aGUgbG9naWMgc28gdGhhdCB0aGUgY29ubmVjdGlvbiBhdHRlbXB0IGlzIGFjY2VwdGVkIGlmIHRoZSBwYWRkaW5nIGlzIHByZXNlbnQsIGFuZCByZWplY3RlZCBpZiBpdCBpcyBhYnNlbnQuIFRoaXMgbWVhbnMgdGhhdCBzdWNoIGFzIHNlcnZlciB3aWxsIGFjY2VwdCBhIGNvbm5lY3Rpb24gaWYgYSB2ZXJzaW9uIHJvbGxiYWNrIGF0dGFjayBoYXMgb2NjdXJyZWQuIEZ1cnRoZXIgdGhlIHNlcnZlciB3aWxsIGVycm9uZW91c2x5IHJlamVjdCBhIGNvbm5lY3Rpb24gaWYgYSBub3JtYWwgU1NMdjIgY29ubmVjdGlvbiBhdHRlbXB0IGlzIG1hZGUuIE9ubHkgT3BlblNTTCAxLjAuMiBzZXJ2ZXJzIGZyb20gdmVyc2lvbiAxLjAuMnMgdG8gMS4wLjJ4IGFyZSBhZmZlY3RlZCBieSB0aGlzIGlzc3VlLiBJbiBvcmRlciB0byBiZSB2dWxuZXJhYmxlIGEgMS4wLjIgc2VydmVyIG11c3Q6IDEpIGhhdmUgY29uZmlndXJlZCBTU0x2MiBzdXBwb3J0IGF0IGNvbXBpbGUgdGltZSAodGhpcyBpcyBvZmYgYnkgZGVmYXVsdCksIDIpIGhhdmUgY29uZmlndXJlZCBTU0x2MiBzdXBwb3J0IGF0IHJ1bnRpbWUgKHRoaXMgaXMgb2ZmIGJ5IGRlZmF1bHQpLCAzKSBoYXZlIGNvbmZpZ3VyZWQgU1NMdjIgY2lwaGVyc3VpdGVzICh0aGVzZSBhcmUgbm90IGluIHRoZSBkZWZhdWx0IGNpcGhlcnN1aXRlIGxpc3QpIE9wZW5TU0wgMS4xLjEgZG9lcyBub3QgaGF2ZSBTU0x2MiBzdXBwb3J0IGFuZCB0aGVyZWZvcmUgaXMgbm90IHZ1bG5lcmFibGUgdG8gdGhpcyBpc3N1ZS4gVGhlIHVuZGVybHlpbmcgZXJyb3IgaXMgaW4gdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0FfcGFkZGluZ19jaGVja19TU0x2MjMoKSBmdW5jdGlvbi4gVGhpcyBhbHNvIGFmZmVjdHMgdGhlIFJTQV9TU0xWMjNfUEFERElORyBwYWRkaW5nIG1vZGUgdXNlZCBieSB2YXJpb3VzIG90aGVyIGZ1bmN0aW9ucy4gQWx0aG91Z2ggMS4xLjEgZG9lcyBub3Qgc3VwcG9ydCBTU0x2MiB0aGUgUlNBX3BhZGRpbmdfY2hlY2tfU1NMdjIzKCkgZnVuY3Rpb24gc3RpbGwgZXhpc3RzLCBhcyBkb2VzIHRoZSBSU0FfU1NMVjIzX1BBRERJTkcgcGFkZGluZyBtb2RlLiBBcHBsaWNhdGlvbnMgdGhhdCBkaXJlY3RseSBjYWxsIHRoYXQgZnVuY3Rpb24gb3IgdXNlIHRoYXQgcGFkZGluZyBtb2RlIHdpbGwgZW5jb3VudGVyIHRoaXMgaXNzdWUuIEhvd2V2ZXIgc2luY2UgdGhlcmUgaXMgbm8gc3VwcG9ydCBmb3IgdGhlIFNTTHYyIHByb3RvY29sIGluIDEuMS4xIHRoaXMgaXMgY29uc2lkZXJlZCBhIGJ1ZyBhbmQgbm90IGEgc2VjdXJpdHkgaXNzdWUgaW4gdGhhdCB2ZXJzaW9uLiBPcGVuU1NMIDEuMC4yIGlzIG91dCBvZiBzdXBwb3J0IGFuZCBubyBsb25nZXIgcmVjZWl2aW5nIHB1YmxpYyB1cGRhdGVzLiBQcmVtaXVtIHN1cHBvcnQgY3VzdG9tZXJzIG9mIE9wZW5TU0wgMS4wLjIgc2hvdWxkIHVwZ3JhZGUgdG8gMS4wLjJ5LiBPdGhlciB1c2VycyBzaG91bGQgdXBncmFkZSB0byAxLjEuMWouIFJlcG9ydGVkIGJ5IEQuIEthdHogYW5kIEpvZWwgTHVlbGx3aXR6IChUcnVzdHdhdmUpLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJ5IDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjAuMnMtMS4wLjJ4KTwvbGk+PC91bD48L2RkPjwvZGw+PGgzPjxhID4yMDIwPC9hPjwvaDM+PGRsPjxkdD48YSA+Q1ZFLTIwMjAtMTk3MTwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltIaWdoIHNldmVyaXR5XTwvYT4gMDggRGVjZW1iZXIgMjAyMDogPC9kdD48ZGQ+VGhlIFguNTA5IEdlbmVyYWxOYW1lIHR5cGUgaXMgYSBnZW5lcmljIHR5cGUgZm9yIHJlcHJlc2VudGluZyBkaWZmZXJlbnQgdHlwZXMgb2YgbmFtZXMuIE9uZSBvZiB0aG9zZSBuYW1lIHR5cGVzIGlzIGtub3duIGFzIEVESVBhcnR5TmFtZS4gT3BlblNTTCBwcm92aWRlcyBhIGZ1bmN0aW9uIEdFTkVSQUxfTkFNRV9jbXAgd2hpY2ggY29tcGFyZXMgZGlmZmVyZW50IGluc3RhbmNlcyBvZiBhIEdFTkVSQUxfTkFNRSB0byBzZWUgaWYgdGhleSBhcmUgZXF1YWwgb3Igbm90LiBUaGlzIGZ1bmN0aW9uIGJlaGF2ZXMgaW5jb3JyZWN0bHkgd2hlbiBib3RoIEdFTkVSQUxfTkFNRXMgY29udGFpbiBhbiBFRElQQVJUWU5BTUUuIEEgTlVMTCBwb2ludGVyIGRlcmVmZXJlbmNlIGFuZCBhIGNyYXNoIG1heSBvY2N1ciBsZWFkaW5nIHRvIGEgcG9zc2libGUgZGVuaWFsIG9mIHNlcnZpY2UgYXR0YWNrLiBPcGVuU1NMIGl0c2VsZiB1c2VzIHRoZSBHRU5FUkFMX05BTUVfY21wIGZ1bmN0aW9uIGZvciB0d28gcHVycG9zZXM6IDEpIENvbXBhcmluZyBDUkwgZGlzdHJpYnV0aW9uIHBvaW50IG5hbWVzIGJldHdlZW4gYW4gYXZhaWxhYmxlIENSTCBhbmQgYSBDUkwgZGlzdHJpYnV0aW9uIHBvaW50IGVtYmVkZGVkIGluIGFuIFg1MDkgY2VydGlmaWNhdGUgMikgV2hlbiB2ZXJpZnlpbmcgdGhhdCBhIHRpbWVzdGFtcCByZXNwb25zZSB0b2tlbiBzaWduZXIgbWF0Y2hlcyB0aGUgdGltZXN0YW1wIGF1dGhvcml0eSBuYW1lIChleHBvc2VkIHZpYSB0aGUgQVBJIGZ1bmN0aW9ucyBUU19SRVNQX3ZlcmlmeV9yZXNwb25zZSBhbmQgVFNfUkVTUF92ZXJpZnlfdG9rZW4pIElmIGFuIGF0dGFja2VyIGNhbiBjb250cm9sIGJvdGggaXRlbXMgYmVpbmcgY29tcGFyZWQgdGhlbiB0aGF0IGF0dGFja2VyIGNvdWxkIHRyaWdnZXIgYSBjcmFzaC4gRm9yIGV4YW1wbGUgaWYgdGhlIGF0dGFja2VyIGNhbiB0cmljayBhIGNsaWVudCBvciBzZXJ2ZXIgaW50byBjaGVja2luZyBhIG1hbGljaW91cyBjZXJ0aWZpY2F0ZSBhZ2FpbnN0IGEgbWFsaWNpb3VzIENSTCB0aGVuIHRoaXMgbWF5IG9jY3VyLiBOb3RlIHRoYXQgc29tZSBhcHBsaWNhdGlvbnMgYXV0b21hdGljYWxseSBkb3dubG9hZCBDUkxzIGJhc2VkIG9uIGEgVVJMIGVtYmVkZGVkIGluIGEgY2VydGlmaWNhdGUuIFRoaXMgY2hlY2tpbmcgaGFwcGVucyBwcmlvciB0byB0aGUgc2lnbmF0dXJlcyBvbiB0aGUgY2VydGlmaWNhdGUgYW5kIENSTCBiZWluZyB2ZXJpZmllZC4gT3BlblNTTCdzIHNfc2VydmVyLCBzX2NsaWVudCBhbmQgdmVyaWZ5IHRvb2xzIGhhdmUgc3VwcG9ydCBmb3IgdGhlICItY3JsX2Rvd25sb2FkIiBvcHRpb24gd2hpY2ggaW1wbGVtZW50cyBhdXRvbWF0aWMgQ1JMIGRvd25sb2FkaW5nIGFuZCB0aGlzIGF0dGFjayBoYXMgYmVlbiBkZW1vbnN0cmF0ZWQgdG8gd29yayBhZ2FpbnN0IHRob3NlIHRvb2xzLiBOb3RlIHRoYXQgYW4gdW5yZWxhdGVkIGJ1ZyBtZWFucyB0aGF0IGFmZmVjdGVkIHZlcnNpb25zIG9mIE9wZW5TU0wgY2Fubm90IHBhcnNlIG9yIGNvbnN0cnVjdCBjb3JyZWN0IGVuY29kaW5ncyBvZiBFRElQQVJUWU5BTUUuIEhvd2V2ZXIgaXQgaXMgcG9zc2libGUgdG8gY29uc3RydWN0IGEgbWFsZm9ybWVkIEVESVBBUlRZTkFNRSB0aGF0IE9wZW5TU0wncyBwYXJzZXIgd2lsbCBhY2NlcHQgYW5kIGhlbmNlIHRyaWdnZXIgdGhpcyBhdHRhY2suIEFsbCBPcGVuU1NMIDEuMS4xIGFuZCAxLjAuMiB2ZXJzaW9ucyBhcmUgYWZmZWN0ZWQgYnkgdGhpcyBpc3N1ZS4gT3RoZXIgT3BlblNTTCByZWxlYXNlcyBhcmUgb3V0IG9mIHN1cHBvcnQgYW5kIGhhdmUgbm90IGJlZW4gY2hlY2tlZC4gUmVwb3J0ZWQgYnkgRGF2aWQgQmVuamFtaW4gKEdvb2dsZSkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjEuMWkgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMS4xLTEuMS4xaCk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yeCA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4wLjItMS4wLjJ3KTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMjAtMTk2ODwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltMb3cgc2V2ZXJpdHldPC9hPiAwOSBTZXB0ZW1iZXIgMjAyMDogPC9kdD48ZGQ+VGhlIFJhY2Nvb24gYXR0YWNrIGV4cGxvaXRzIGEgZmxhdyBpbiB0aGUgVExTIHNwZWNpZmljYXRpb24gd2hpY2ggY2FuIGxlYWQgdG8gYW4gYXR0YWNrZXIgYmVpbmcgYWJsZSB0byBjb21wdXRlIHRoZSBwcmUtbWFzdGVyIHNlY3JldCBpbiBjb25uZWN0aW9ucyB3aGljaCBoYXZlIHVzZWQgYSBEaWZmaWUtSGVsbG1hbiAoREgpIGJhc2VkIGNpcGhlcnN1aXRlLiBJbiBzdWNoIGEgY2FzZSB0aGlzIHdvdWxkIHJlc3VsdCBpbiB0aGUgYXR0YWNrZXIgYmVpbmcgYWJsZSB0byBlYXZlc2Ryb3Agb24gYWxsIGVuY3J5cHRlZCBjb21tdW5pY2F0aW9ucyBzZW50IG92ZXIgdGhhdCBUTFMgY29ubmVjdGlvbi4gVGhlIGF0dGFjayBjYW4gb25seSBiZSBleHBsb2l0ZWQgaWYgYW4gaW1wbGVtZW50YXRpb24gcmUtdXNlcyBhIERIIHNlY3JldCBhY3Jvc3MgbXVsdGlwbGUgVExTIGNvbm5lY3Rpb25zLiBOb3RlIHRoYXQgdGhpcyBpc3N1ZSBvbmx5IGltcGFjdHMgREggY2lwaGVyc3VpdGVzIGFuZCBub3QgRUNESCBjaXBoZXJzdWl0ZXMuIFRoaXMgaXNzdWUgYWZmZWN0cyBPcGVuU1NMIDEuMC4yIHdoaWNoIGlzIG91dCBvZiBzdXBwb3J0IGFuZCBubyBsb25nZXIgcmVjZWl2aW5nIHB1YmxpYyB1cGRhdGVzLiBPcGVuU1NMIDEuMS4xIGlzIG5vdCB2dWxuZXJhYmxlIHRvIHRoaXMgaXNzdWUuIFJlcG9ydGVkIGJ5IFJvYmVydCBNZXJnZXQsIE1hcmN1cyBCcmlua21hbm4sIE5pbXJvZCBBdmlyYW0sIGFuZCBKdXJhaiBTb21vcm92c2t5LiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJ3IChBZmZlY3RlZCAxLjAuMi0xLjAuMnYpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAyMC0xOTY3PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0hpZ2ggc2V2ZXJpdHldPC9hPiAyMSBBcHJpbCAyMDIwOiA8L2R0PjxkZD5TZXJ2ZXIgb3IgY2xpZW50IGFwcGxpY2F0aW9ucyB0aGF0IGNhbGwgdGhlIFNTTF9jaGVja19jaGFpbigpIGZ1bmN0aW9uIGR1cmluZyBvciBhZnRlciBhIFRMUyAxLjMgaGFuZHNoYWtlIG1heSBjcmFzaCBkdWUgdG8gYSBOVUxMIHBvaW50ZXIgZGVyZWZlcmVuY2UgYXMgYSByZXN1bHQgb2YgaW5jb3JyZWN0IGhhbmRsaW5nIG9mIHRoZSAic2lnbmF0dXJlX2FsZ29yaXRobXNfY2VydCIgVExTIGV4dGVuc2lvbi4gVGhlIGNyYXNoIG9jY3VycyBpZiBhbiBpbnZhbGlkIG9yIHVucmVjb2duaXNlZCBzaWduYXR1cmUgYWxnb3JpdGhtIGlzIHJlY2VpdmVkIGZyb20gdGhlIHBlZXIuIFRoaXMgY291bGQgYmUgZXhwbG9pdGVkIGJ5IGEgbWFsaWNpb3VzIHBlZXIgaW4gYSBEZW5pYWwgb2YgU2VydmljZSBhdHRhY2suIE9wZW5TU0wgdmVyc2lvbiAxLjEuMWQsIDEuMS4xZSwgYW5kIDEuMS4xZiBhcmUgYWZmZWN0ZWQgYnkgdGhpcyBpc3N1ZS4gVGhpcyBpc3N1ZSBkaWQgbm90IGFmZmVjdCBPcGVuU1NMIHZlcnNpb25zIHByaW9yIHRvIDEuMS4xZC4gUmVwb3J0ZWQgYnkgQmVybmQgRWRsaW5nZXIuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjEuMWcgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMS4xZC0xLjEuMWYpPC9saT48L3VsPjwvZGQ+PC9kbD48aDM+PGEgPjIwMTk8L2E+PC9oMz48ZGw+PGR0PjxhID5DVkUtMjAxOS0xNTUxPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0xvdyBzZXZlcml0eV08L2E+IDA2IERlY2VtYmVyIDIwMTk6IDwvZHQ+PGRkPlRoZXJlIGlzIGFuIG92ZXJmbG93IGJ1ZyBpbiB0aGUgeDY0XzY0IE1vbnRnb21lcnkgc3F1YXJpbmcgcHJvY2VkdXJlIHVzZWQgaW4gZXhwb25lbnRpYXRpb24gd2l0aCA1MTItYml0IG1vZHVsaS4gTm8gRUMgYWxnb3JpdGhtcyBhcmUgYWZmZWN0ZWQuIEFuYWx5c2lzIHN1Z2dlc3RzIHRoYXQgYXR0YWNrcyBhZ2FpbnN0IDItcHJpbWUgUlNBMTAyNCwgMy1wcmltZSBSU0ExNTM2LCBhbmQgRFNBMTAyNCBhcyBhIHJlc3VsdCBvZiB0aGlzIGRlZmVjdCB3b3VsZCBiZSB2ZXJ5IGRpZmZpY3VsdCB0byBwZXJmb3JtIGFuZCBhcmUgbm90IGJlbGlldmVkIGxpa2VseS4gQXR0YWNrcyBhZ2FpbnN0IERINTEyIGFyZSBjb25zaWRlcmVkIGp1c3QgZmVhc2libGUuIEhvd2V2ZXIsIGZvciBhbiBhdHRhY2sgdGhlIHRhcmdldCB3b3VsZCBoYXZlIHRvIHJlLXVzZSB0aGUgREg1MTIgcHJpdmF0ZSBrZXksIHdoaWNoIGlzIG5vdCByZWNvbW1lbmRlZCBhbnl3YXkuIEFsc28gYXBwbGljYXRpb25zIGRpcmVjdGx5IHVzaW5nIHRoZSBsb3cgbGV2ZWwgQVBJIEJOX21vZF9leHAgbWF5IGJlIGFmZmVjdGVkIGlmIHRoZXkgdXNlIEJOX0ZMR19DT05TVFRJTUUuIFJlcG9ydGVkIGJ5IE9TUy1GdXp6IGFuZCBHdWlkbyBWcmFua2VuLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4xLjFlIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjEuMS0xLjEuMWQpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMnUgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMC4yLTEuMC4ydCk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE5LTE1NjM8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMTAgU2VwdGVtYmVyIDIwMTk6IDwvZHQ+PGRkPkluIHNpdHVhdGlvbnMgd2hlcmUgYW4gYXR0YWNrZXIgcmVjZWl2ZXMgYXV0b21hdGVkIG5vdGlmaWNhdGlvbiBvZiB0aGUgc3VjY2VzcyBvciBmYWlsdXJlIG9mIGEgZGVjcnlwdGlvbiBhdHRlbXB0IGFuIGF0dGFja2VyLCBhZnRlciBzZW5kaW5nIGEgdmVyeSBsYXJnZSBudW1iZXIgb2YgbWVzc2FnZXMgdG8gYmUgZGVjcnlwdGVkLCBjYW4gcmVjb3ZlciBhIENNUy9QS0NTNyB0cmFuc3BvcnRlZCBlbmNyeXB0aW9uIGtleSBvciBkZWNyeXB0IGFueSBSU0EgZW5jcnlwdGVkIG1lc3NhZ2UgdGhhdCB3YXMgZW5jcnlwdGVkIHdpdGggdGhlIHB1YmxpYyBSU0Ega2V5LCB1c2luZyBhIEJsZWljaGVuYmFjaGVyIHBhZGRpbmcgb3JhY2xlIGF0dGFjay4gQXBwbGljYXRpb25zIGFyZSBub3QgYWZmZWN0ZWQgaWYgdGhleSB1c2UgYSBjZXJ0aWZpY2F0ZSB0b2dldGhlciB3aXRoIHRoZSBwcml2YXRlIFJTQSBrZXkgdG8gdGhlIENNU19kZWNyeXB0IG9yIFBLQ1M3X2RlY3J5cHQgZnVuY3Rpb25zIHRvIHNlbGVjdCB0aGUgY29ycmVjdCByZWNpcGllbnQgaW5mbyB0byBkZWNyeXB0LiBSZXBvcnRlZCBieSBCZXJuZCBFZGxpbmdlci4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMS4xZCA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4xLjEtMS4xLjFjKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4xLjBsIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjEuMC0xLjEuMGspPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMnQgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMC4yLTEuMC4ycyk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE5LTE1NDk8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMTAgU2VwdGVtYmVyIDIwMTk6IDwvZHQ+PGRkPk9wZW5TU0wgMS4xLjEgaW50cm9kdWNlZCBhIHJld3JpdHRlbiByYW5kb20gbnVtYmVyIGdlbmVyYXRvciAoUk5HKS4gVGhpcyB3YXMgaW50ZW5kZWQgdG8gaW5jbHVkZSBwcm90ZWN0aW9uIGluIHRoZSBldmVudCBvZiBhIGZvcmsoKSBzeXN0ZW0gY2FsbCBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCB0aGUgcGFyZW50IGFuZCBjaGlsZCBwcm9jZXNzZXMgZGlkIG5vdCBzaGFyZSB0aGUgc2FtZSBSTkcgc3RhdGUuIEhvd2V2ZXIgdGhpcyBwcm90ZWN0aW9uIHdhcyBub3QgYmVpbmcgdXNlZCBpbiB0aGUgZGVmYXVsdCBjYXNlLiBBIHBhcnRpYWwgbWl0aWdhdGlvbiBmb3IgdGhpcyBpc3N1ZSBpcyB0aGF0IHRoZSBvdXRwdXQgZnJvbSBhIGhpZ2ggcHJlY2lzaW9uIHRpbWVyIGlzIG1peGVkIGludG8gdGhlIFJORyBzdGF0ZSBzbyB0aGUgbGlrZWxpaG9vZCBvZiBhIHBhcmVudCBhbmQgY2hpbGQgcHJvY2VzcyBzaGFyaW5nIHN0YXRlIGlzIHNpZ25pZmljYW50bHkgcmVkdWNlZC4gSWYgYW4gYXBwbGljYXRpb24gYWxyZWFkeSBjYWxscyBPUEVOU1NMX2luaXRfY3J5cHRvKCkgZXhwbGljaXRseSB1c2luZyBPUEVOU1NMX0lOSVRfQVRGT1JLIHRoZW4gdGhpcyBwcm9ibGVtIGRvZXMgbm90IG9jY3VyIGF0IGFsbC4gUmVwb3J0ZWQgYnkgTWF0dCBDYXN3ZWxsLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4xLjFkIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjEuMS0xLjEuMWMpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxOS0xNTQ3PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0xvdyBzZXZlcml0eV08L2E+IDEwIFNlcHRlbWJlciAyMDE5OiA8L2R0PjxkZD5Ob3JtYWxseSBpbiBPcGVuU1NMIEVDIGdyb3VwcyBhbHdheXMgaGF2ZSBhIGNvLWZhY3RvciBwcmVzZW50IGFuZCB0aGlzIGlzIHVzZWQgaW4gc2lkZSBjaGFubmVsIHJlc2lzdGFudCBjb2RlIHBhdGhzLiBIb3dldmVyLCBpbiBzb21lIGNhc2VzLCBpdCBpcyBwb3NzaWJsZSB0byBjb25zdHJ1Y3QgYSBncm91cCB1c2luZyBleHBsaWNpdCBwYXJhbWV0ZXJzIChpbnN0ZWFkIG9mIHVzaW5nIGEgbmFtZWQgY3VydmUpLiBJbiB0aG9zZSBjYXNlcyBpdCBpcyBwb3NzaWJsZSB0aGF0IHN1Y2ggYSBncm91cCBkb2VzIG5vdCBoYXZlIHRoZSBjb2ZhY3RvciBwcmVzZW50LiBUaGlzIGNhbiBvY2N1ciBldmVuIHdoZXJlIGFsbCB0aGUgcGFyYW1ldGVycyBtYXRjaCBhIGtub3duIG5hbWVkIGN1cnZlLiBJZiBzdWNoIGEgY3VydmUgaXMgdXNlZCB0aGVuIE9wZW5TU0wgZmFsbHMgYmFjayB0byBub24tc2lkZSBjaGFubmVsIHJlc2lzdGFudCBjb2RlIHBhdGhzIHdoaWNoIG1heSByZXN1bHQgaW4gZnVsbCBrZXkgcmVjb3ZlcnkgZHVyaW5nIGFuIEVDRFNBIHNpZ25hdHVyZSBvcGVyYXRpb24uIEluIG9yZGVyIHRvIGJlIHZ1bG5lcmFibGUgYW4gYXR0YWNrZXIgd291bGQgaGF2ZSB0byBoYXZlIHRoZSBhYmlsaXR5IHRvIHRpbWUgdGhlIGNyZWF0aW9uIG9mIGEgbGFyZ2UgbnVtYmVyIG9mIHNpZ25hdHVyZXMgd2hlcmUgZXhwbGljaXQgcGFyYW1ldGVycyB3aXRoIG5vIGNvLWZhY3RvciBwcmVzZW50IGFyZSBpbiB1c2UgYnkgYW4gYXBwbGljYXRpb24gdXNpbmcgbGliY3J5cHRvLiBGb3IgdGhlIGF2b2lkYW5jZSBvZiBkb3VidCBsaWJzc2wgaXMgbm90IHZ1bG5lcmFibGUgYmVjYXVzZSBleHBsaWNpdCBwYXJhbWV0ZXJzIGFyZSBuZXZlciB1c2VkLiBSZXBvcnRlZCBieSBDZXNhciBQZXJlaWRhIEdhcmPDrWEsIFNvaGFpYiB1bCBIYXNzYW4sIE5pY29sYSBUdXZlcmksIElhcm9zbGF2IEdyaWRpbiwgQWxlamFuZHJvIENhYnJlcmEgQWxkYXlhLCBhbmQgQmlsbHkgQnJ1bWxleS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMS4xZCA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4xLjEtMS4xLjFjKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4xLjBsIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjEuMC0xLjEuMGspPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMnQgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMC4yLTEuMC4ycyk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE5LTE1NTI8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMzAgSnVseSAyMDE5OiA8L2R0PjxkZD5PcGVuU1NMIGhhcyBpbnRlcm5hbCBkZWZhdWx0cyBmb3IgYSBkaXJlY3RvcnkgdHJlZSB3aGVyZSBpdCBjYW4gZmluZCBhIGNvbmZpZ3VyYXRpb24gZmlsZSBhcyB3ZWxsIGFzIGNlcnRpZmljYXRlcyB1c2VkIGZvciB2ZXJpZmljYXRpb24gaW4gVExTLiBUaGlzIGRpcmVjdG9yeSBpcyBtb3N0IGNvbW1vbmx5IHJlZmVycmVkIHRvIGFzIE9QRU5TU0xESVIsIGFuZCBpcyBjb25maWd1cmFibGUgd2l0aCB0aGUgLS1wcmVmaXggLyAtLW9wZW5zc2xkaXIgY29uZmlndXJhdGlvbiBvcHRpb25zLiBGb3IgT3BlblNTTCB2ZXJzaW9ucyAxLjEuMCBhbmQgMS4xLjEsIHRoZSBtaW5ndyBjb25maWd1cmF0aW9uIHRhcmdldHMgYXNzdW1lIHRoYXQgcmVzdWx0aW5nIHByb2dyYW1zIGFuZCBsaWJyYXJpZXMgYXJlIGluc3RhbGxlZCBpbiBhIFVuaXgtbGlrZSBlbnZpcm9ubWVudCBhbmQgdGhlIGRlZmF1bHQgcHJlZml4IGZvciBwcm9ncmFtIGluc3RhbGxhdGlvbiBhcyB3ZWxsIGFzIGZvciBPUEVOU1NMRElSIHNob3VsZCBiZSAnL3Vzci9sb2NhbCcuIEhvd2V2ZXIsIG1pbmd3IHByb2dyYW1zIGFyZSBXaW5kb3dzIHByb2dyYW1zLCBhbmQgYXMgc3VjaCwgZmluZCB0aGVtc2VsdmVzIGxvb2tpbmcgYXQgc3ViLWRpcmVjdG9yaWVzIG9mICdDOi91c3IvbG9jYWwnLCB3aGljaCBtYXkgYmUgd29ybGQgd3JpdGFibGUsIHdoaWNoIGVuYWJsZXMgdW50cnVzdGVkIHVzZXJzIHRvIG1vZGlmeSBPcGVuU1NMJ3MgZGVmYXVsdCBjb25maWd1cmF0aW9uLCBpbnNlcnQgQ0EgY2VydGlmaWNhdGVzLCBtb2RpZnkgKG9yIGV2ZW4gcmVwbGFjZSkgZXhpc3RpbmcgZW5naW5lIG1vZHVsZXMsIGV0Yy4gRm9yIE9wZW5TU0wgMS4wLjIsICcvdXNyL2xvY2FsL3NzbCcgaXMgdXNlZCBhcyBkZWZhdWx0IGZvciBPUEVOU1NMRElSIG9uIGFsbCBVbml4IGFuZCBXaW5kb3dzIHRhcmdldHMsIGluY2x1ZGluZyBWaXN1YWwgQyBidWlsZHMuIEhvd2V2ZXIsIHNvbWUgYnVpbGQgaW5zdHJ1Y3Rpb25zIGZvciB0aGUgZGl2ZXJzZSBXaW5kb3dzIHRhcmdldHMgb24gMS4wLjIgZW5jb3VyYWdlIHlvdSB0byBzcGVjaWZ5IHlvdXIgb3duIC0tcHJlZml4LiBPcGVuU1NMIHZlcnNpb25zIDEuMS4xLCAxLjEuMCBhbmQgMS4wLjIgYXJlIGFmZmVjdGVkIGJ5IHRoaXMgaXNzdWUuIER1ZSB0byB0aGUgbGltaXRlZCBzY29wZSBvZiBhZmZlY3RlZCBkZXBsb3ltZW50cyB0aGlzIGhhcyBiZWVuIGFzc2Vzc2VkIGFzIGxvdyBzZXZlcml0eSBhbmQgdGhlcmVmb3JlIHdlIGFyZSBub3QgY3JlYXRpbmcgbmV3IHJlbGVhc2VzIGF0IHRoaXMgdGltZS4gUmVwb3J0ZWQgYnkgUmljaCBNaXJjaC4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMS4xZCA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4xLjEtMS4xLjFjKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4xLjBsIDxhID4oZ2l0IGNvbW1pdCk8L2E+IDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjEuMC0xLjEuMGspPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMnQgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMC4yLTEuMC4ycyk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE5LTE1NDM8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMDYgTWFyY2ggMjAxOTogPC9kdD48ZGQ+Q2hhQ2hhMjAtUG9seTEzMDUgaXMgYW4gQUVBRCBjaXBoZXIsIGFuZCByZXF1aXJlcyBhIHVuaXF1ZSBub25jZSBpbnB1dCBmb3IgZXZlcnkgZW5jcnlwdGlvbiBvcGVyYXRpb24uIFJGQyA3NTM5IHNwZWNpZmllcyB0aGF0IHRoZSBub25jZSB2YWx1ZSAoSVYpIHNob3VsZCBiZSA5NiBiaXRzICgxMiBieXRlcykuIE9wZW5TU0wgYWxsb3dzIGEgdmFyaWFibGUgbm9uY2UgbGVuZ3RoIGFuZCBmcm9udCBwYWRzIHRoZSBub25jZSB3aXRoIDAgYnl0ZXMgaWYgaXQgaXMgbGVzcyB0aGFuIDEyIGJ5dGVzLiBIb3dldmVyIGl0IGFsc28gaW5jb3JyZWN0bHkgYWxsb3dzIGEgbm9uY2UgdG8gYmUgc2V0IG9mIHVwIHRvIDE2IGJ5dGVzLiBJbiB0aGlzIGNhc2Ugb25seSB0aGUgbGFzdCAxMiBieXRlcyBhcmUgc2lnbmlmaWNhbnQgYW5kIGFueSBhZGRpdGlvbmFsIGxlYWRpbmcgYnl0ZXMgYXJlIGlnbm9yZWQuIEl0IGlzIGEgcmVxdWlyZW1lbnQgb2YgdXNpbmcgdGhpcyBjaXBoZXIgdGhhdCBub25jZSB2YWx1ZXMgYXJlIHVuaXF1ZS4gTWVzc2FnZXMgZW5jcnlwdGVkIHVzaW5nIGEgcmV1c2VkIG5vbmNlIHZhbHVlIGFyZSBzdXNjZXB0aWJsZSB0byBzZXJpb3VzIGNvbmZpZGVudGlhbGl0eSBhbmQgaW50ZWdyaXR5IGF0dGFja3MuIElmIGFuIGFwcGxpY2F0aW9uIGNoYW5nZXMgdGhlIGRlZmF1bHQgbm9uY2UgbGVuZ3RoIHRvIGJlIGxvbmdlciB0aGFuIDEyIGJ5dGVzIGFuZCB0aGVuIG1ha2VzIGEgY2hhbmdlIHRvIHRoZSBsZWFkaW5nIGJ5dGVzIG9mIHRoZSBub25jZSBleHBlY3RpbmcgdGhlIG5ldyB2YWx1ZSB0byBiZSBhIG5ldyB1bmlxdWUgbm9uY2UgdGhlbiBzdWNoIGFuIGFwcGxpY2F0aW9uIGNvdWxkIGluYWR2ZXJ0ZW50bHkgZW5jcnlwdCBtZXNzYWdlcyB3aXRoIGEgcmV1c2VkIG5vbmNlLiBBZGRpdGlvbmFsbHkgdGhlIGlnbm9yZWQgYnl0ZXMgaW4gYSBsb25nIG5vbmNlIGFyZSBub3QgY292ZXJlZCBieSB0aGUgaW50ZWdyaXR5IGd1YXJhbnRlZSBvZiB0aGlzIGNpcGhlci4gQW55IGFwcGxpY2F0aW9uIHRoYXQgcmVsaWVzIG9uIHRoZSBpbnRlZ3JpdHkgb2YgdGhlc2UgaWdub3JlZCBsZWFkaW5nIGJ5dGVzIG9mIGEgbG9uZyBub25jZSBtYXkgYmUgZnVydGhlciBhZmZlY3RlZC4gQW55IE9wZW5TU0wgaW50ZXJuYWwgdXNlIG9mIHRoaXMgY2lwaGVyLCBpbmNsdWRpbmcgaW4gU1NML1RMUywgaXMgc2FmZSBiZWNhdXNlIG5vIHN1Y2ggdXNlIHNldHMgc3VjaCBhIGxvbmcgbm9uY2UgdmFsdWUuIEhvd2V2ZXIgdXNlciBhcHBsaWNhdGlvbnMgdGhhdCB1c2UgdGhpcyBjaXBoZXIgZGlyZWN0bHkgYW5kIHNldCBhIG5vbi1kZWZhdWx0IG5vbmNlIGxlbmd0aCB0byBiZSBsb25nZXIgdGhhbiAxMiBieXRlcyBtYXkgYmUgdnVsbmVyYWJsZS4gT3BlblNTTCB2ZXJzaW9ucyAxLjEuMSBhbmQgMS4xLjAgYXJlIGFmZmVjdGVkIGJ5IHRoaXMgaXNzdWUuIER1ZSB0byB0aGUgbGltaXRlZCBzY29wZSBvZiBhZmZlY3RlZCBkZXBsb3ltZW50cyB0aGlzIGhhcyBiZWVuIGFzc2Vzc2VkIGFzIGxvdyBzZXZlcml0eSBhbmQgdGhlcmVmb3JlIHdlIGFyZSBub3QgY3JlYXRpbmcgbmV3IHJlbGVhc2VzIGF0IHRoaXMgdGltZS4gUmVwb3J0ZWQgYnkgSm9yYW4gRGlyayBHcmVlZiBvZiBSb25vbW9uLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4xLjFjIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjEuMS0xLjEuMWIpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjEuMGsgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMS4wLTEuMS4waik8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE5LTE1NTk8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTW9kZXJhdGUgc2V2ZXJpdHldPC9hPiAyNiBGZWJydWFyeSAyMDE5OiA8L2R0PjxkZD5JZiBhbiBhcHBsaWNhdGlvbiBlbmNvdW50ZXJzIGEgZmF0YWwgcHJvdG9jb2wgZXJyb3IgYW5kIHRoZW4gY2FsbHMgU1NMX3NodXRkb3duKCkgdHdpY2UgKG9uY2UgdG8gc2VuZCBhIGNsb3NlX25vdGlmeSwgYW5kIG9uY2UgdG8gcmVjZWl2ZSBvbmUpIHRoZW4gT3BlblNTTCBjYW4gcmVzcG9uZCBkaWZmZXJlbnRseSB0byB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBpZiBhIDAgYnl0ZSByZWNvcmQgaXMgcmVjZWl2ZWQgd2l0aCBpbnZhbGlkIHBhZGRpbmcgY29tcGFyZWQgdG8gaWYgYSAwIGJ5dGUgcmVjb3JkIGlzIHJlY2VpdmVkIHdpdGggYW4gaW52YWxpZCBNQUMuIElmIHRoZSBhcHBsaWNhdGlvbiB0aGVuIGJlaGF2ZXMgZGlmZmVyZW50bHkgYmFzZWQgb24gdGhhdCBpbiBhIHdheSB0aGF0IGlzIGRldGVjdGFibGUgdG8gdGhlIHJlbW90ZSBwZWVyLCB0aGVuIHRoaXMgYW1vdW50cyB0byBhIHBhZGRpbmcgb3JhY2xlIHRoYXQgY291bGQgYmUgdXNlZCB0byBkZWNyeXB0IGRhdGEuIEluIG9yZGVyIGZvciB0aGlzIHRvIGJlIGV4cGxvaXRhYmxlICJub24tc3RpdGNoZWQiIGNpcGhlcnN1aXRlcyBtdXN0IGJlIGluIHVzZS4gU3RpdGNoZWQgY2lwaGVyc3VpdGVzIGFyZSBvcHRpbWlzZWQgaW1wbGVtZW50YXRpb25zIG9mIGNlcnRhaW4gY29tbW9ubHkgdXNlZCBjaXBoZXJzdWl0ZXMuIEFsc28gdGhlIGFwcGxpY2F0aW9uIG11c3QgY2FsbCBTU0xfc2h1dGRvd24oKSB0d2ljZSBldmVuIGlmIGEgcHJvdG9jb2wgZXJyb3IgaGFzIG9jY3VycmVkIChhcHBsaWNhdGlvbnMgc2hvdWxkIG5vdCBkbyB0aGlzIGJ1dCBzb21lIGRvIGFueXdheSkuIEFFQUQgY2lwaGVyc3VpdGVzIGFyZSBub3QgaW1wYWN0ZWQuIFJlcG9ydGVkIGJ5IEp1cmFqIFNvbW9yb3Zza3ksIFJvYmVydCBNZXJnZXQgYW5kIE5pbXJvZCBBdmlyYW0sIHdpdGggYWRkaXRpb25hbCBpbnZlc3RpZ2F0aW9uIGJ5IFN0ZXZlbiBDb2xsaXNvbiBhbmQgQW5kcmV3IEhvdXJzZWx0LiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJyIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjAuMi0xLjAuMnEpPC9saT48L3VsPjwvZGQ+PC9kbD48aDM+PGEgPjIwMTg8L2E+PC9oMz48ZGw+PGR0PjxhID5DVkUtMjAxOC01NDA3PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0xvdyBzZXZlcml0eV08L2E+IDAyIE5vdmVtYmVyIDIwMTg6IDwvZHQ+PGRkPk9wZW5TU0wgRUNDIHNjYWxhciBtdWx0aXBsaWNhdGlvbiwgdXNlZCBpbiBlLmcuIEVDRFNBIGFuZCBFQ0RILCBoYXMgYmVlbiBzaG93biB0byBiZSB2dWxuZXJhYmxlIHRvIGEgbWljcm9hcmNoaXRlY3R1cmUgdGltaW5nIHNpZGUgY2hhbm5lbCBhdHRhY2suIEFuIGF0dGFja2VyIHdpdGggc3VmZmljaWVudCBhY2Nlc3MgdG8gbW91bnQgbG9jYWwgdGltaW5nIGF0dGFja3MgZHVyaW5nIEVDRFNBIHNpZ25hdHVyZSBnZW5lcmF0aW9uIGNvdWxkIHJlY292ZXIgdGhlIHByaXZhdGUga2V5LiBSZXBvcnRlZCBieSBBbGVqYW5kcm8gQ2FicmVyYSBBbGRheWEsIEJpbGx5IEJydW1sZXksIFNvaGFpYiB1bCBIYXNzYW4sIENlc2FyIFBlcmVpZGEgR2FyY2lhIGFuZCBOaWNvbGEgVHV2ZXJpLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4xLjBpIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjEuMC0xLjEuMGgpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMnEgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMC4yLTEuMC4ycCk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE4LTA3MzQ8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMzAgT2N0b2JlciAyMDE4OiA8L2R0PjxkZD5UaGUgT3BlblNTTCBEU0Egc2lnbmF0dXJlIGFsZ29yaXRobSBoYXMgYmVlbiBzaG93biB0byBiZSB2dWxuZXJhYmxlIHRvIGEgdGltaW5nIHNpZGUgY2hhbm5lbCBhdHRhY2suIEFuIGF0dGFja2VyIGNvdWxkIHVzZSB2YXJpYXRpb25zIGluIHRoZSBzaWduaW5nIGFsZ29yaXRobSB0byByZWNvdmVyIHRoZSBwcml2YXRlIGtleS4gUmVwb3J0ZWQgYnkgU2FtdWVsIFdlaXNlci4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMS4xYSA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4xLjEpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjEuMGogPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMS4wLTEuMS4waSk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4ycSA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4wLjItMS4wLjJwKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTgtMDczNTwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltMb3cgc2V2ZXJpdHldPC9hPiAyOSBPY3RvYmVyIDIwMTg6IDwvZHQ+PGRkPlRoZSBPcGVuU1NMIEVDRFNBIHNpZ25hdHVyZSBhbGdvcml0aG0gaGFzIGJlZW4gc2hvd24gdG8gYmUgdnVsbmVyYWJsZSB0byBhIHRpbWluZyBzaWRlIGNoYW5uZWwgYXR0YWNrLiBBbiBhdHRhY2tlciBjb3VsZCB1c2UgdmFyaWF0aW9ucyBpbiB0aGUgc2lnbmluZyBhbGdvcml0aG0gdG8gcmVjb3ZlciB0aGUgcHJpdmF0ZSBrZXkuIFJlcG9ydGVkIGJ5IFNhbXVlbCBXZWlzZXIuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjEuMWEgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMS4xKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4xLjBqIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjEuMC0xLjEuMGkpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxOC0wNzMyPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0xvdyBzZXZlcml0eV08L2E+IDEyIEp1bmUgMjAxODogPC9kdD48ZGQ+RHVyaW5nIGtleSBhZ3JlZW1lbnQgaW4gYSBUTFMgaGFuZHNoYWtlIHVzaW5nIGEgREgoRSkgYmFzZWQgY2lwaGVyc3VpdGUgYSBtYWxpY2lvdXMgc2VydmVyIGNhbiBzZW5kIGEgdmVyeSBsYXJnZSBwcmltZSB2YWx1ZSB0byB0aGUgY2xpZW50LiBUaGlzIHdpbGwgY2F1c2UgdGhlIGNsaWVudCB0byBzcGVuZCBhbiB1bnJlYXNvbmFibHkgbG9uZyBwZXJpb2Qgb2YgdGltZSBnZW5lcmF0aW5nIGEga2V5IGZvciB0aGlzIHByaW1lIHJlc3VsdGluZyBpbiBhIGhhbmcgdW50aWwgdGhlIGNsaWVudCBoYXMgZmluaXNoZWQuIFRoaXMgY291bGQgYmUgZXhwbG9pdGVkIGluIGEgRGVuaWFsIE9mIFNlcnZpY2UgYXR0YWNrLiBSZXBvcnRlZCBieSBHdWlkbyBWcmFua2VuLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4xLjBpIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjEuMC0xLjEuMGgpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMnAgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMC4yLTEuMC4ybyk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE4LTA3Mzc8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMTYgQXByaWwgMjAxODogPC9kdD48ZGQ+VGhlIE9wZW5TU0wgUlNBIEtleSBnZW5lcmF0aW9uIGFsZ29yaXRobSBoYXMgYmVlbiBzaG93biB0byBiZSB2dWxuZXJhYmxlIHRvIGEgY2FjaGUgdGltaW5nIHNpZGUgY2hhbm5lbCBhdHRhY2suIEFuIGF0dGFja2VyIHdpdGggc3VmZmljaWVudCBhY2Nlc3MgdG8gbW91bnQgY2FjaGUgdGltaW5nIGF0dGFja3MgZHVyaW5nIHRoZSBSU0Ega2V5IGdlbmVyYXRpb24gcHJvY2VzcyBjb3VsZCByZWNvdmVyIHRoZSBwcml2YXRlIGtleS4gUmVwb3J0ZWQgYnkgQWxlamFuZHJvIENhYnJlcmEgQWxkYXlhLCBCaWxseSBCcnVtbGV5LCBDZXNhciBQZXJlaWRhIEdhcmNpYSBhbmQgTHVpcyBNYW51ZWwgQWx2YXJleiBUYXBpYS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMS4waSA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4xLjAtMS4xLjBoKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJwIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjAuMi0xLjAuMm8pPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxOC0wNzM5PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W01vZGVyYXRlIHNldmVyaXR5XTwvYT4gMjcgTWFyY2ggMjAxODogPC9kdD48ZGQ+Q29uc3RydWN0ZWQgQVNOLjEgdHlwZXMgd2l0aCBhIHJlY3Vyc2l2ZSBkZWZpbml0aW9uIChzdWNoIGFzIGNhbiBiZSBmb3VuZCBpbiBQS0NTNykgY291bGQgZXZlbnR1YWxseSBleGNlZWQgdGhlIHN0YWNrIGdpdmVuIG1hbGljaW91cyBpbnB1dCB3aXRoIGV4Y2Vzc2l2ZSByZWN1cnNpb24uIFRoaXMgY291bGQgcmVzdWx0IGluIGEgRGVuaWFsIE9mIFNlcnZpY2UgYXR0YWNrLiBUaGVyZSBhcmUgbm8gc3VjaCBzdHJ1Y3R1cmVzIHVzZWQgd2l0aGluIFNTTC9UTFMgdGhhdCBjb21lIGZyb20gdW50cnVzdGVkIHNvdXJjZXMgc28gdGhpcyBpcyBjb25zaWRlcmVkIHNhZmUuIFJlcG9ydGVkIGJ5IE9TUy1mdXp6LiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4xLjBoIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjEuMC0xLjEuMGcpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMm8gPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMC4yYi0xLjAuMm4pPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxOC0wNzMzPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W01vZGVyYXRlIHNldmVyaXR5XTwvYT4gMjcgTWFyY2ggMjAxODogPC9kdD48ZGQ+QmVjYXVzZSBvZiBhbiBpbXBsZW1lbnRhdGlvbiBidWcgdGhlIFBBLVJJU0MgQ1JZUFRPX21lbWNtcCBmdW5jdGlvbiBpcyBlZmZlY3RpdmVseSByZWR1Y2VkIHRvIG9ubHkgY29tcGFyaW5nIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2YgZWFjaCBieXRlLiBUaGlzIGFsbG93cyBhbiBhdHRhY2tlciB0byBmb3JnZSBtZXNzYWdlcyB0aGF0IHdvdWxkIGJlIGNvbnNpZGVyZWQgYXMgYXV0aGVudGljYXRlZCBpbiBhbiBhbW91bnQgb2YgdHJpZXMgbG93ZXIgdGhhbiB0aGF0IGd1YXJhbnRlZWQgYnkgdGhlIHNlY3VyaXR5IGNsYWltcyBvZiB0aGUgc2NoZW1lLiBUaGUgbW9kdWxlIGNhbiBvbmx5IGJlIGNvbXBpbGVkIGJ5IHRoZSBIUC1VWCBhc3NlbWJsZXIsIHNvIHRoYXQgb25seSBIUC1VWCBQQS1SSVNDIHRhcmdldHMgYXJlIGFmZmVjdGVkLiBSZXBvcnRlZCBieSBQZXRlciBXYWx0ZW5iZXJnIChJQk0pLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4xLjBoIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjEuMC0xLjEuMGcpPC9saT48L3VsPjwvZGQ+PC9kbD48aDM+PGEgPjIwMTc8L2E+PC9oMz48ZGw+PGR0PjxhID5DVkUtMjAxNy0zNzM4PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0xvdyBzZXZlcml0eV08L2E+IDA3IERlY2VtYmVyIDIwMTc6IDwvZHQ+PGRkPlRoZXJlIGlzIGFuIG92ZXJmbG93IGJ1ZyBpbiB0aGUgQVZYMiBNb250Z29tZXJ5IG11bHRpcGxpY2F0aW9uIHByb2NlZHVyZSB1c2VkIGluIGV4cG9uZW50aWF0aW9uIHdpdGggMTAyNC1iaXQgbW9kdWxpLiBObyBFQyBhbGdvcml0aG1zIGFyZSBhZmZlY3RlZC4gQW5hbHlzaXMgc3VnZ2VzdHMgdGhhdCBhdHRhY2tzIGFnYWluc3QgUlNBIGFuZCBEU0EgYXMgYSByZXN1bHQgb2YgdGhpcyBkZWZlY3Qgd291bGQgYmUgdmVyeSBkaWZmaWN1bHQgdG8gcGVyZm9ybSBhbmQgYXJlIG5vdCBiZWxpZXZlZCBsaWtlbHkuIEF0dGFja3MgYWdhaW5zdCBESDEwMjQgYXJlIGNvbnNpZGVyZWQganVzdCBmZWFzaWJsZSwgYmVjYXVzZSBtb3N0IG9mIHRoZSB3b3JrIG5lY2Vzc2FyeSB0byBkZWR1Y2UgaW5mb3JtYXRpb24gYWJvdXQgYSBwcml2YXRlIGtleSBtYXkgYmUgcGVyZm9ybWVkIG9mZmxpbmUuIFRoZSBhbW91bnQgb2YgcmVzb3VyY2VzIHJlcXVpcmVkIGZvciBzdWNoIGFuIGF0dGFjayB3b3VsZCBiZSBzaWduaWZpY2FudC4gSG93ZXZlciwgZm9yIGFuIGF0dGFjayBvbiBUTFMgdG8gYmUgbWVhbmluZ2Z1bCwgdGhlIHNlcnZlciB3b3VsZCBoYXZlIHRvIHNoYXJlIHRoZSBESDEwMjQgcHJpdmF0ZSBrZXkgYW1vbmcgbXVsdGlwbGUgY2xpZW50cywgd2hpY2ggaXMgbm8gbG9uZ2VyIGFuIG9wdGlvbiBzaW5jZSBDVkUtMjAxNi0wNzAxLiBUaGlzIG9ubHkgYWZmZWN0cyBwcm9jZXNzb3JzIHRoYXQgc3VwcG9ydCB0aGUgQVZYMiBidXQgbm90IEFEWCBleHRlbnNpb25zIGxpa2UgSW50ZWwgSGFzd2VsbCAoNHRoIGdlbmVyYXRpb24pLiBOb3RlOiBUaGUgaW1wYWN0IGZyb20gdGhpcyBpc3N1ZSBpcyBzaW1pbGFyIHRvIENWRS0yMDE3LTM3MzYsIENWRS0yMDE3LTM3MzIgYW5kIENWRS0yMDE1LTMxOTMuIER1ZSB0byB0aGUgbG93IHNldmVyaXR5IG9mIHRoaXMgaXNzdWUgd2UgYXJlIG5vdCBpc3N1aW5nIGEgbmV3IHJlbGVhc2Ugb2YgT3BlblNTTCAxLjEuMCBhdCB0aGlzIHRpbWUuIFRoZSBmaXggd2lsbCBiZSBpbmNsdWRlZCBpbiBPcGVuU1NMIDEuMS4waCB3aGVuIGl0IGJlY29tZXMgYXZhaWxhYmxlLiBUaGUgZml4IGlzIGFsc28gYXZhaWxhYmxlIGluIGNvbW1pdCBlNTAyY2M4NmQgaW4gdGhlIE9wZW5TU0wgZ2l0IHJlcG9zaXRvcnkuIFJlcG9ydGVkIGJ5IERhdmlkIEJlbmphbWluIChHb29nbGUpL0dvb2dsZSBPU1MtRnV6ei4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMS4waCA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4xLjAtMS4xLjBnKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJuIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjAuMi0xLjAuMm0pPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNy0zNzM3PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W01vZGVyYXRlIHNldmVyaXR5XTwvYT4gMDcgRGVjZW1iZXIgMjAxNzogPC9kdD48ZGQ+T3BlblNTTCAxLjAuMiAoc3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDEuMC4yYikgaW50cm9kdWNlZCBhbiAiZXJyb3Igc3RhdGUiIG1lY2hhbmlzbS4gVGhlIGludGVudCB3YXMgdGhhdCBpZiBhIGZhdGFsIGVycm9yIG9jY3VycmVkIGR1cmluZyBhIGhhbmRzaGFrZSB0aGVuIE9wZW5TU0wgd291bGQgbW92ZSBpbnRvIHRoZSBlcnJvciBzdGF0ZSBhbmQgd291bGQgaW1tZWRpYXRlbHkgZmFpbCBpZiB5b3UgYXR0ZW1wdGVkIHRvIGNvbnRpbnVlIHRoZSBoYW5kc2hha2UuIFRoaXMgd29ya3MgYXMgZGVzaWduZWQgZm9yIHRoZSBleHBsaWNpdCBoYW5kc2hha2UgZnVuY3Rpb25zIChTU0xfZG9faGFuZHNoYWtlKCksIFNTTF9hY2NlcHQoKSBhbmQgU1NMX2Nvbm5lY3QoKSksIGhvd2V2ZXIgZHVlIHRvIGEgYnVnIGl0IGRvZXMgbm90IHdvcmsgY29ycmVjdGx5IGlmIFNTTF9yZWFkKCkgb3IgU1NMX3dyaXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5LiBJbiB0aGF0IHNjZW5hcmlvLCBpZiB0aGUgaGFuZHNoYWtlIGZhaWxzIHRoZW4gYSBmYXRhbCBlcnJvciB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBpbml0aWFsIGZ1bmN0aW9uIGNhbGwuIElmIFNTTF9yZWFkKCkvU1NMX3dyaXRlKCkgaXMgc3Vic2VxdWVudGx5IGNhbGxlZCBieSB0aGUgYXBwbGljYXRpb24gZm9yIHRoZSBzYW1lIFNTTCBvYmplY3QgdGhlbiBpdCB3aWxsIHN1Y2NlZWQgYW5kIHRoZSBkYXRhIGlzIHBhc3NlZCB3aXRob3V0IGJlaW5nIGRlY3J5cHRlZC9lbmNyeXB0ZWQgZGlyZWN0bHkgZnJvbSB0aGUgU1NML1RMUyByZWNvcmQgbGF5ZXIuIEluIG9yZGVyIHRvIGV4cGxvaXQgdGhpcyBpc3N1ZSBhbiBhcHBsaWNhdGlvbiBidWcgd291bGQgaGF2ZSB0byBiZSBwcmVzZW50IHRoYXQgcmVzdWx0ZWQgaW4gYSBjYWxsIHRvIFNTTF9yZWFkKCkvU1NMX3dyaXRlKCkgYmVpbmcgaXNzdWVkIGFmdGVyIGhhdmluZyBhbHJlYWR5IHJlY2VpdmVkIGEgZmF0YWwgZXJyb3IuIFJlcG9ydGVkIGJ5IERhdmlkIEJlbmphbWluIChHb29nbGUpLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJuIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjAuMmItMS4wLjJtKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTctMzczNjwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltNb2RlcmF0ZSBzZXZlcml0eV08L2E+IDAyIE5vdmVtYmVyIDIwMTc6IDwvZHQ+PGRkPlRoZXJlIGlzIGEgY2FycnkgcHJvcGFnYXRpbmcgYnVnIGluIHRoZSB4ODZfNjQgTW9udGdvbWVyeSBzcXVhcmluZyBwcm9jZWR1cmUuIE5vIEVDIGFsZ29yaXRobXMgYXJlIGFmZmVjdGVkLiBBbmFseXNpcyBzdWdnZXN0cyB0aGF0IGF0dGFja3MgYWdhaW5zdCBSU0EgYW5kIERTQSBhcyBhIHJlc3VsdCBvZiB0aGlzIGRlZmVjdCB3b3VsZCBiZSB2ZXJ5IGRpZmZpY3VsdCB0byBwZXJmb3JtIGFuZCBhcmUgbm90IGJlbGlldmVkIGxpa2VseS4gQXR0YWNrcyBhZ2FpbnN0IERIIGFyZSBjb25zaWRlcmVkIGp1c3QgZmVhc2libGUgKGFsdGhvdWdoIHZlcnkgZGlmZmljdWx0KSBiZWNhdXNlIG1vc3Qgb2YgdGhlIHdvcmsgbmVjZXNzYXJ5IHRvIGRlZHVjZSBpbmZvcm1hdGlvbiBhYm91dCBhIHByaXZhdGUga2V5IG1heSBiZSBwZXJmb3JtZWQgb2ZmbGluZS4gVGhlIGFtb3VudCBvZiByZXNvdXJjZXMgcmVxdWlyZWQgZm9yIHN1Y2ggYW4gYXR0YWNrIHdvdWxkIGJlIHZlcnkgc2lnbmlmaWNhbnQgYW5kIGxpa2VseSBvbmx5IGFjY2Vzc2libGUgdG8gYSBsaW1pdGVkIG51bWJlciBvZiBhdHRhY2tlcnMuIEFuIGF0dGFja2VyIHdvdWxkIGFkZGl0aW9uYWxseSBuZWVkIG9ubGluZSBhY2Nlc3MgdG8gYW4gdW5wYXRjaGVkIHN5c3RlbSB1c2luZyB0aGUgdGFyZ2V0IHByaXZhdGUga2V5IGluIGEgc2NlbmFyaW8gd2l0aCBwZXJzaXN0ZW50IERIIHBhcmFtZXRlcnMgYW5kIGEgcHJpdmF0ZSBrZXkgdGhhdCBpcyBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBjbGllbnRzLiBUaGlzIG9ubHkgYWZmZWN0cyBwcm9jZXNzb3JzIHRoYXQgc3VwcG9ydCB0aGUgQk1JMSwgQk1JMiBhbmQgQURYIGV4dGVuc2lvbnMgbGlrZSBJbnRlbCBCcm9hZHdlbGwgKDV0aCBnZW5lcmF0aW9uKSBhbmQgbGF0ZXIgb3IgQU1EIFJ5emVuLiBSZXBvcnRlZCBieSBHb29nbGUgT1NTLUZ1enouIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjEuMGcgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMS4wLTEuMS4wZik8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4ybSA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4wLjItMS4wLjJsKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTctMzczNTwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltMb3cgc2V2ZXJpdHldPC9hPiAyOCBBdWd1c3QgMjAxNzogPC9kdD48ZGQ+V2hpbGUgcGFyc2luZyBhbiBJUEFkcmVzc0ZhbWlseSBleHRlbnNpb24gaW4gYW4gWC41MDkgY2VydGlmaWNhdGUsIGl0IGlzIHBvc3NpYmxlIHRvIGRvIGEgb25lLWJ5dGUgb3ZlcnJlYWQuIFRoaXMgd291bGQgcmVzdWx0IGluIGFuIGluY29ycmVjdCB0ZXh0IGRpc3BsYXkgb2YgdGhlIGNlcnRpZmljYXRlLiBSZXBvcnRlZCBieSBHb29nbGUgT1NTLUZ1enouIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjEuMGcgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMS4wLTEuMS4wZik8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4ybSA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4wLjItMS4wLjJsKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTctMzczMzwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltIaWdoIHNldmVyaXR5XTwvYT4gMTYgRmVicnVhcnkgMjAxNzogPC9kdD48ZGQ+RHVyaW5nIGEgcmVuZWdvdGlhdGlvbiBoYW5kc2hha2UgaWYgdGhlIEVuY3J5cHQtVGhlbi1NYWMgZXh0ZW5zaW9uIGlzIG5lZ290aWF0ZWQgd2hlcmUgaXQgd2FzIG5vdCBpbiB0aGUgb3JpZ2luYWwgaGFuZHNoYWtlIChvciB2aWNlLXZlcnNhKSB0aGVuIHRoaXMgY2FuIGNhdXNlIE9wZW5TU0wgdG8gY3Jhc2ggKGRlcGVuZGVudCBvbiBjaXBoZXJzdWl0ZSkuIEJvdGggY2xpZW50cyBhbmQgc2VydmVycyBhcmUgYWZmZWN0ZWQuIFJlcG9ydGVkIGJ5IEpvZSBPcnRvbiAoUmVkIEhhdCkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjEuMGUgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMS4wLTEuMS4wZCk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE3LTM3MzI8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTW9kZXJhdGUgc2V2ZXJpdHldPC9hPiAyNiBKYW51YXJ5IDIwMTc6IDwvZHQ+PGRkPlRoZXJlIGlzIGEgY2FycnkgcHJvcGFnYXRpbmcgYnVnIGluIHRoZSB4ODZfNjQgTW9udGdvbWVyeSBzcXVhcmluZyBwcm9jZWR1cmUuIE5vIEVDIGFsZ29yaXRobXMgYXJlIGFmZmVjdGVkLiBBbmFseXNpcyBzdWdnZXN0cyB0aGF0IGF0dGFja3MgYWdhaW5zdCBSU0EgYW5kIERTQSBhcyBhIHJlc3VsdCBvZiB0aGlzIGRlZmVjdCB3b3VsZCBiZSB2ZXJ5IGRpZmZpY3VsdCB0byBwZXJmb3JtIGFuZCBhcmUgbm90IGJlbGlldmVkIGxpa2VseS4gQXR0YWNrcyBhZ2FpbnN0IERIIGFyZSBjb25zaWRlcmVkIGp1c3QgZmVhc2libGUgKGFsdGhvdWdoIHZlcnkgZGlmZmljdWx0KSBiZWNhdXNlIG1vc3Qgb2YgdGhlIHdvcmsgbmVjZXNzYXJ5IHRvIGRlZHVjZSBpbmZvcm1hdGlvbiBhYm91dCBhIHByaXZhdGUga2V5IG1heSBiZSBwZXJmb3JtZWQgb2ZmbGluZS4gVGhlIGFtb3VudCBvZiByZXNvdXJjZXMgcmVxdWlyZWQgZm9yIHN1Y2ggYW4gYXR0YWNrIHdvdWxkIGJlIHZlcnkgc2lnbmlmaWNhbnQgYW5kIGxpa2VseSBvbmx5IGFjY2Vzc2libGUgdG8gYSBsaW1pdGVkIG51bWJlciBvZiBhdHRhY2tlcnMuIEFuIGF0dGFja2VyIHdvdWxkIGFkZGl0aW9uYWxseSBuZWVkIG9ubGluZSBhY2Nlc3MgdG8gYW4gdW5wYXRjaGVkIHN5c3RlbSB1c2luZyB0aGUgdGFyZ2V0IHByaXZhdGUga2V5IGluIGEgc2NlbmFyaW8gd2l0aCBwZXJzaXN0ZW50IERIIHBhcmFtZXRlcnMgYW5kIGEgcHJpdmF0ZSBrZXkgdGhhdCBpcyBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBjbGllbnRzLiBGb3IgZXhhbXBsZSB0aGlzIGNhbiBvY2N1ciBieSBkZWZhdWx0IGluIE9wZW5TU0wgREhFIGJhc2VkIFNTTC9UTFMgY2lwaGVyc3VpdGVzLiBOb3RlOiBUaGlzIGlzc3VlIGlzIHZlcnkgc2ltaWxhciB0byBDVkUtMjAxNS0zMTkzIGJ1dCBtdXN0IGJlIHRyZWF0ZWQgYXMgYSBzZXBhcmF0ZSBwcm9ibGVtLiBSZXBvcnRlZCBieSBPU1MtRnV6eiBwcm9qZWN0LiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4xLjBkIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjEuMC0xLjEuMGMpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMmsgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMC4yLTEuMC4yaik8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE3LTM3MzE8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTW9kZXJhdGUgc2V2ZXJpdHldPC9hPiAyNiBKYW51YXJ5IDIwMTc6IDwvZHQ+PGRkPklmIGFuIFNTTC9UTFMgc2VydmVyIG9yIGNsaWVudCBpcyBydW5uaW5nIG9uIGEgMzItYml0IGhvc3QsIGFuZCBhIHNwZWNpZmljIGNpcGhlciBpcyBiZWluZyB1c2VkLCB0aGVuIGEgdHJ1bmNhdGVkIHBhY2tldCBjYW4gY2F1c2UgdGhhdCBzZXJ2ZXIgb3IgY2xpZW50IHRvIHBlcmZvcm0gYW4gb3V0LW9mLWJvdW5kcyByZWFkLCB1c3VhbGx5IHJlc3VsdGluZyBpbiBhIGNyYXNoLiBGb3IgT3BlblNTTCAxLjEuMCwgdGhlIGNyYXNoIGNhbiBiZSB0cmlnZ2VyZWQgd2hlbiB1c2luZyBDSEFDSEEyMC9QT0xZMTMwNTsgdXNlcnMgc2hvdWxkIHVwZ3JhZGUgdG8gMS4xLjBkLiBGb3IgT3BlbnNzbCAxLjAuMiwgdGhlIGNyYXNoIGNhbiBiZSB0cmlnZ2VyZWQgd2hlbiB1c2luZyBSQzQtTUQ1OyB1c2VycyB3aG8gaGF2ZSBub3QgZGlzYWJsZWQgdGhhdCBhbGdvcml0aG0gc2hvdWxkIHVwZGF0ZSB0byAxLjAuMmsgUmVwb3J0ZWQgYnkgUm9iZXJ0IMWad2nEmWNraSBvZiBHb29nbGUuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjEuMGQgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMS4wLTEuMS4wYyk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yayA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4wLjItMS4wLjJqKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTctMzczMDwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltNb2RlcmF0ZSBzZXZlcml0eV08L2E+IDI2IEphbnVhcnkgMjAxNzogPC9kdD48ZGQ+SWYgYSBtYWxpY2lvdXMgc2VydmVyIHN1cHBsaWVzIGJhZCBwYXJhbWV0ZXJzIGZvciBhIERIRSBvciBFQ0RIRSBrZXkgZXhjaGFuZ2UgdGhlbiB0aGlzIGNhbiByZXN1bHQgaW4gdGhlIGNsaWVudCBhdHRlbXB0aW5nIHRvIGRlcmVmZXJlbmNlIGEgTlVMTCBwb2ludGVyIGxlYWRpbmcgdG8gYSBjbGllbnQgY3Jhc2guIFRoaXMgY291bGQgYmUgZXhwbG9pdGVkIGluIGEgRGVuaWFsIG9mIFNlcnZpY2UgYXR0YWNrLiBSZXBvcnRlZCBieSBHdWlkbyBWcmFua2VuLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4xLjBkIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjEuMC0xLjEuMGMpPC9saT48L3VsPjwvZGQ+PC9kbD48aDM+PGEgPjIwMTY8L2E+PC9oMz48ZGw+PGR0PjxhID5DVkUtMjAxNi03MDU1PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0xvdyBzZXZlcml0eV08L2E+IDEwIE5vdmVtYmVyIDIwMTY6IDwvZHQ+PGRkPlRoZXJlIGlzIGEgY2FycnkgcHJvcGFnYXRpbmcgYnVnIGluIHRoZSBCcm9hZHdlbGwtc3BlY2lmaWMgTW9udGdvbWVyeSBtdWx0aXBsaWNhdGlvbiBwcm9jZWR1cmUgdGhhdCBoYW5kbGVzIGlucHV0IGxlbmd0aHMgZGl2aXNpYmxlIGJ5LCBidXQgbG9uZ2VyIHRoYW4gMjU2IGJpdHMuIEFuYWx5c2lzIHN1Z2dlc3RzIHRoYXQgYXR0YWNrcyBhZ2FpbnN0IFJTQSwgRFNBIGFuZCBESCBwcml2YXRlIGtleXMgYXJlIGltcG9zc2libGUuIFRoaXMgaXMgYmVjYXVzZSB0aGUgc3Vicm91dGluZSBpbiBxdWVzdGlvbiBpcyBub3QgdXNlZCBpbiBvcGVyYXRpb25zIHdpdGggdGhlIHByaXZhdGUga2V5IGl0c2VsZiBhbmQgYW4gaW5wdXQgb2YgdGhlIGF0dGFja2VyJ3MgZGlyZWN0IGNob2ljZS4gT3RoZXJ3aXNlIHRoZSBidWcgY2FuIG1hbmlmZXN0IGl0c2VsZiBhcyB0cmFuc2llbnQgYXV0aGVudGljYXRpb24gYW5kIGtleSBuZWdvdGlhdGlvbiBmYWlsdXJlcyBvciByZXByb2R1Y2libGUgZXJyb25lb3VzIG91dGNvbWUgb2YgcHVibGljLWtleSBvcGVyYXRpb25zIHdpdGggc3BlY2lhbGx5IGNyYWZ0ZWQgaW5wdXQuIEFtb25nIEVDIGFsZ29yaXRobXMgb25seSBCcmFpbnBvb2wgUC01MTIgY3VydmVzIGFyZSBhZmZlY3RlZCBhbmQgb25lIHByZXN1bWFibHkgY2FuIGF0dGFjayBFQ0RIIGtleSBuZWdvdGlhdGlvbi4gSW1wYWN0IHdhcyBub3QgYW5hbHl6ZWQgaW4gZGV0YWlsLCBiZWNhdXNlIHByZS1yZXF1aXNpdGVzIGZvciBhdHRhY2sgYXJlIGNvbnNpZGVyZWQgdW5saWtlbHkuIE5hbWVseSBtdWx0aXBsZSBjbGllbnRzIGhhdmUgdG8gY2hvb3NlIHRoZSBjdXJ2ZSBpbiBxdWVzdGlvbiBhbmQgdGhlIHNlcnZlciBoYXMgdG8gc2hhcmUgdGhlIHByaXZhdGUga2V5IGFtb25nIHRoZW0sIG5laXRoZXIgb2Ygd2hpY2ggaXMgZGVmYXVsdCBiZWhhdmlvdXIuIEV2ZW4gdGhlbiBvbmx5IGNsaWVudHMgdGhhdCBjaG9zZSB0aGUgY3VydmUgd2lsbCBiZSBhZmZlY3RlZC4gUmVwb3J0ZWQgYnkgUHVibGljbHkgcmVwb3J0ZWQuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjEuMGMgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMS4wLTEuMS4wYik8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yayA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4wLjItMS4wLjJqKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTYtNzA1NDwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltIaWdoIHNldmVyaXR5XTwvYT4gMTAgTm92ZW1iZXIgMjAxNjogPC9kdD48ZGQ+VExTIGNvbm5lY3Rpb25zIHVzaW5nICotQ0hBQ0hBMjAtUE9MWTEzMDUgY2lwaGVyc3VpdGVzIGFyZSBzdXNjZXB0aWJsZSB0byBhIERvUyBhdHRhY2sgYnkgY29ycnVwdGluZyBsYXJnZXIgcGF5bG9hZHMuIFRoaXMgY2FuIHJlc3VsdCBpbiBhbiBPcGVuU1NMIGNyYXNoLiBUaGlzIGlzc3VlIGlzIG5vdCBjb25zaWRlcmVkIHRvIGJlIGV4cGxvaXRhYmxlIGJleW9uZCBhIERvUy4gUmVwb3J0ZWQgYnkgUm9iZXJ0IMWad2nEmWNraSAoR29vZ2xlIFNlY3VyaXR5IFRlYW0pLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4xLjBjIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjEuMC0xLjEuMGIpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNi03MDUzPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W01vZGVyYXRlIHNldmVyaXR5XTwvYT4gMTAgTm92ZW1iZXIgMjAxNjogPC9kdD48ZGQ+QXBwbGljYXRpb25zIHBhcnNpbmcgaW52YWxpZCBDTVMgc3RydWN0dXJlcyBjYW4gY3Jhc2ggd2l0aCBhIE5VTEwgcG9pbnRlciBkZXJlZmVyZW5jZS4gVGhpcyBpcyBjYXVzZWQgYnkgYSBidWcgaW4gdGhlIGhhbmRsaW5nIG9mIHRoZSBBU04uMSBDSE9JQ0UgdHlwZSBpbiBPcGVuU1NMIDEuMS4wIHdoaWNoIGNhbiByZXN1bHQgaW4gYSBOVUxMIHZhbHVlIGJlaW5nIHBhc3NlZCB0byB0aGUgc3RydWN0dXJlIGNhbGxiYWNrIGlmIGFuIGF0dGVtcHQgaXMgbWFkZSB0byBmcmVlIGNlcnRhaW4gaW52YWxpZCBlbmNvZGluZ3MuIE9ubHkgQ0hPSUNFIHN0cnVjdHVyZXMgdXNpbmcgYSBjYWxsYmFjayB3aGljaCBkbyBub3QgaGFuZGxlIE5VTEwgdmFsdWUgYXJlIGFmZmVjdGVkLiBSZXBvcnRlZCBieSBUeWxlciBOaWdoc3dhbmRlciAoRm9yQWxsU2VjdXJlKS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMS4wYyA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4xLjAtMS4xLjBiKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTYtNzA1MjwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltNb2RlcmF0ZSBzZXZlcml0eV08L2E+IDI2IFNlcHRlbWJlciAyMDE2OiA8L2R0PjxkZD5UaGlzIGlzc3VlIG9ubHkgYWZmZWN0cyBPcGVuU1NMIDEuMC4yaSwgcmVsZWFzZWQgb24gMjJuZCBTZXB0ZW1iZXIgMjAxNi4gQSBidWcgZml4IHdoaWNoIGluY2x1ZGVkIGEgQ1JMIHNhbml0eSBjaGVjayB3YXMgYWRkZWQgdG8gT3BlblNTTCAxLjEuMCBidXQgd2FzIG9taXR0ZWQgZnJvbSBPcGVuU1NMIDEuMC4yaS4gQXMgYSByZXN1bHQgYW55IGF0dGVtcHQgdG8gdXNlIENSTHMgaW4gT3BlblNTTCAxLjAuMmkgd2lsbCBjcmFzaCB3aXRoIGEgbnVsbCBwb2ludGVyIGV4Y2VwdGlvbi4gUmVwb3J0ZWQgYnkgQnJ1Y2UgU3RlcGhlbnMgYW5kIFRob21hcyBKYWtvYmkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMmogPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMC4yaSk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE2LTYzMDk8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bQ3JpdGljYWwgc2V2ZXJpdHldPC9hPiAyNiBTZXB0ZW1iZXIgMjAxNjogPC9kdD48ZGQ+VGhpcyBpc3N1ZSBvbmx5IGFmZmVjdHMgT3BlblNTTCAxLjEuMGEsIHJlbGVhc2VkIG9uIDIybmQgU2VwdGVtYmVyIDIwMTYuIFRoZSBwYXRjaCBhcHBsaWVkIHRvIGFkZHJlc3MgQ1ZFLTIwMTYtNjMwNyByZXN1bHRlZCBpbiBhbiBpc3N1ZSB3aGVyZSBpZiBhIG1lc3NhZ2UgbGFyZ2VyIHRoYW4gYXBwcm94IDE2ayBpcyByZWNlaXZlZCB0aGVuIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciB0byBzdG9yZSB0aGUgaW5jb21pbmcgbWVzc2FnZSBpcyByZWFsbG9jYXRlZCBhbmQgbW92ZWQuIFVuZm9ydHVuYXRlbHkgYSBkYW5nbGluZyBwb2ludGVyIHRvIHRoZSBvbGQgbG9jYXRpb24gaXMgbGVmdCB3aGljaCByZXN1bHRzIGluIGFuIGF0dGVtcHQgdG8gd3JpdGUgdG8gdGhlIHByZXZpb3VzbHkgZnJlZWQgbG9jYXRpb24uIFRoaXMgaXMgbGlrZWx5IHRvIHJlc3VsdCBpbiBhIGNyYXNoLCBob3dldmVyIGl0IGNvdWxkIHBvdGVudGlhbGx5IGxlYWQgdG8gZXhlY3V0aW9uIG9mIGFyYml0cmFyeSBjb2RlLiBSZXBvcnRlZCBieSBSb2JlcnQgxZp3acSZY2tpIChHb29nbGUgU2VjdXJpdHkgVGVhbSkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjEuMGIgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMS4wYSk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE2LTYzMDU8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTW9kZXJhdGUgc2V2ZXJpdHldPC9hPiAyMiBTZXB0ZW1iZXIgMjAxNjogPC9kdD48ZGQ+T3BlblNTTCAxLjEuMCBTU0wvVExTIHdpbGwgaGFuZyBkdXJpbmcgYSBjYWxsIHRvIFNTTF9wZWVrKCkgaWYgdGhlIHBlZXIgc2VuZHMgYW4gZW1wdHkgcmVjb3JkLiBUaGlzIGNvdWxkIGJlIGV4cGxvaXRlZCBieSBhIG1hbGljaW91cyBwZWVyIGluIGEgRGVuaWFsIE9mIFNlcnZpY2UgYXR0YWNrLiBSZXBvcnRlZCBieSBBbGV4IEdheW5vci4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMS4wYSA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4xLjApPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNi02MzA0PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0hpZ2ggc2V2ZXJpdHldPC9hPiAyMiBTZXB0ZW1iZXIgMjAxNjogPC9kdD48ZGQ+QSBtYWxpY2lvdXMgY2xpZW50IGNhbiBzZW5kIGFuIGV4Y2Vzc2l2ZWx5IGxhcmdlIE9DU1AgU3RhdHVzIFJlcXVlc3QgZXh0ZW5zaW9uLiBJZiB0aGF0IGNsaWVudCBjb250aW51YWxseSByZXF1ZXN0cyByZW5lZ290aWF0aW9uLCBzZW5kaW5nIGEgbGFyZ2UgT0NTUCBTdGF0dXMgUmVxdWVzdCBleHRlbnNpb24gZWFjaCB0aW1lLCB0aGVuIHRoZXJlIHdpbGwgYmUgdW5ib3VuZGVkIG1lbW9yeSBncm93dGggb24gdGhlIHNlcnZlci4gVGhpcyB3aWxsIGV2ZW50dWFsbHkgbGVhZCB0byBhIERlbmlhbCBPZiBTZXJ2aWNlIGF0dGFjayB0aHJvdWdoIG1lbW9yeSBleGhhdXN0aW9uLiBTZXJ2ZXJzIHdpdGggYSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gYXJlIHZ1bG5lcmFibGUgZXZlbiBpZiB0aGV5IGRvIG5vdCBzdXBwb3J0IE9DU1AuIEJ1aWxkcyB1c2luZyB0aGUgIm5vLW9jc3AiIGJ1aWxkIHRpbWUgb3B0aW9uIGFyZSBub3QgYWZmZWN0ZWQuIFNlcnZlcnMgdXNpbmcgT3BlblNTTCB2ZXJzaW9ucyBwcmlvciB0byAxLjAuMWcgYXJlIG5vdCB2dWxuZXJhYmxlIGluIGEgZGVmYXVsdCBjb25maWd1cmF0aW9uLCBpbnN0ZWFkIG9ubHkgaWYgYW4gYXBwbGljYXRpb24gZXhwbGljaXRseSBlbmFibGVzIE9DU1Agc3RhcGxpbmcgc3VwcG9ydC4gUmVwb3J0ZWQgYnkgU2hpIExlaSAoR2VhciBUZWFtLCBRaWhvbyAzNjAgSW5jLikuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjEuMGEgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMS4wKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJpIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjAuMi0xLjAuMmgpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMXUgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMC4xLTEuMC4xdCk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE2LTYzMDg8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMjEgU2VwdGVtYmVyIDIwMTY6IDwvZHQ+PGRkPkEgRFRMUyBtZXNzYWdlIGluY2x1ZGVzIDMgYnl0ZXMgZm9yIGl0cyBsZW5ndGggaW4gdGhlIGhlYWRlciBmb3IgdGhlIG1lc3NhZ2UuIFRoaXMgd291bGQgYWxsb3cgZm9yIG1lc3NhZ2VzIHVwIHRvIDE2TWIgaW4gbGVuZ3RoLiBNZXNzYWdlcyBvZiB0aGlzIGxlbmd0aCBhcmUgZXhjZXNzaXZlIGFuZCBPcGVuU1NMIGluY2x1ZGVzIGEgY2hlY2sgdG8gZW5zdXJlIHRoYXQgYSBwZWVyIGlzIHNlbmRpbmcgcmVhc29uYWJseSBzaXplZCBtZXNzYWdlcyBpbiBvcmRlciB0byBhdm9pZCB0b28gbXVjaCBtZW1vcnkgYmVpbmcgY29uc3VtZWQgdG8gc2VydmljZSBhIGNvbm5lY3Rpb24uIEEgZmxhdyBpbiB0aGUgbG9naWMgb2YgdmVyc2lvbiAxLjEuMCBtZWFucyB0aGF0IG1lbW9yeSBmb3IgdGhlIG1lc3NhZ2UgaXMgYWxsb2NhdGVkIHRvbyBlYXJseSwgcHJpb3IgdG8gdGhlIGV4Y2Vzc2l2ZSBtZXNzYWdlIGxlbmd0aCBjaGVjay4gRHVlIHRvIHdheSBtZW1vcnkgaXMgYWxsb2NhdGVkIGluIE9wZW5TU0wgdGhpcyBjb3VsZCBtZWFuIGFuIGF0dGFja2VyIGNvdWxkIGZvcmNlIHVwIHRvIDIxTWIgdG8gYmUgYWxsb2NhdGVkIHRvIHNlcnZpY2UgYSBjb25uZWN0aW9uLiBUaGlzIGNvdWxkIGxlYWQgdG8gYSBEZW5pYWwgb2YgU2VydmljZSB0aHJvdWdoIG1lbW9yeSBleGhhdXN0aW9uLiBIb3dldmVyLCB0aGUgZXhjZXNzaXZlIG1lc3NhZ2UgbGVuZ3RoIGNoZWNrIHN0aWxsIHRha2VzIHBsYWNlLCBhbmQgdGhpcyB3b3VsZCBjYXVzZSB0aGUgY29ubmVjdGlvbiB0byBpbW1lZGlhdGVseSBmYWlsLiBBc3N1bWluZyB0aGF0IHRoZSBhcHBsaWNhdGlvbiBjYWxscyBTU0xfZnJlZSgpIG9uIHRoZSBmYWlsZWQgY29ubmVjaXRvbiBpbiBhIHRpbWVseSBtYW5uZXIgdGhlbiB0aGUgMjFNYiBvZiBhbGxvY2F0ZWQgbWVtb3J5IHdpbGwgdGhlbiBiZSBpbW1lZGlhdGVseSBmcmVlZCBhZ2Fpbi4gVGhlcmVmb3JlIHRoZSBleGNlc3NpdmUgbWVtb3J5IGFsbG9jYXRpb24gd2lsbCBiZSB0cmFuc2l0b3J5IGluIG5hdHVyZS4gVGhpcyB0aGVuIG1lYW5zIHRoYXQgdGhlcmUgaXMgb25seSBhIHNlY3VyaXR5IGltcGFjdCBpZjogMSkgVGhlIGFwcGxpY2F0aW9uIGRvZXMgbm90IGNhbGwgU1NMX2ZyZWUoKSBpbiBhIHRpbWVseSBtYW5uZXIgaW4gdGhlIGV2ZW50IHRoYXQgdGhlIGNvbm5lY3Rpb24gZmFpbHMgb3IgMikgVGhlIGFwcGxpY2F0aW9uIGlzIHdvcmtpbmcgaW4gYSBjb25zdHJhaW5lZCBlbnZpcm9ubWVudCB3aGVyZSB0aGVyZSBpcyB2ZXJ5IGxpdHRsZSBmcmVlIG1lbW9yeSBvciAzKSBUaGUgYXR0YWNrZXIgaW5pdGlhdGVzIG11bHRpcGxlIGNvbm5lY3Rpb24gYXR0ZW1wdHMgc3VjaCB0aGF0IHRoZXJlIGFyZSBtdWx0aXBsZSBjb25uZWN0aW9ucyBpbiBhIHN0YXRlIHdoZXJlIG1lbW9yeSBoYXMgYmVlbiBhbGxvY2F0ZWQgZm9yIHRoZSBjb25uZWN0aW9uOyBTU0xfZnJlZSgpIGhhcyBub3QgeWV0IGJlZW4gY2FsbGVkOyBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50IG1lbW9yeSB0byBzZXJ2aWNlIHRoZSBtdWx0aXBsZSByZXF1ZXN0cy4gRXhjZXB0IGluIHRoZSBpbnN0YW5jZSBvZiAoMSkgYWJvdmUgYW55IERlbmlhbCBPZiBTZXJ2aWNlIGlzIGxpa2VseSB0byBiZSB0cmFuc2l0b3J5IGJlY2F1c2UgYXMgc29vbiBhcyB0aGUgY29ubmVjdGlvbiBmYWlscyB0aGUgbWVtb3J5IGlzIHN1YnNlcXVlbnRseSBmcmVlZCBhZ2FpbiBpbiB0aGUgU1NMX2ZyZWUoKSBjYWxsLiBIb3dldmVyIHRoZXJlIGlzIGFuIGluY3JlYXNlZCByaXNrIGR1cmluZyB0aGlzIHBlcmlvZCBvZiBhcHBsaWNhdGlvbiBjcmFzaGVzIGR1ZSB0byB0aGUgbGFjayBvZiBtZW1vcnkgLSB3aGljaCB3b3VsZCB0aGVuIG1lYW4gYSBtb3JlIHNlcmlvdXMgRGVuaWFsIG9mIFNlcnZpY2UuIFJlcG9ydGVkIGJ5IFNoaSBMZWkgKEdlYXIgVGVhbSwgUWlob28gMzYwIEluYy4pLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4xLjBhIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjEuMCk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE2LTYzMDc8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMjEgU2VwdGVtYmVyIDIwMTY6IDwvZHQ+PGRkPkEgVExTIG1lc3NhZ2UgaW5jbHVkZXMgMyBieXRlcyBmb3IgaXRzIGxlbmd0aCBpbiB0aGUgaGVhZGVyIGZvciB0aGUgbWVzc2FnZS4gVGhpcyB3b3VsZCBhbGxvdyBmb3IgbWVzc2FnZXMgdXAgdG8gMTZNYiBpbiBsZW5ndGguIE1lc3NhZ2VzIG9mIHRoaXMgbGVuZ3RoIGFyZSBleGNlc3NpdmUgYW5kIE9wZW5TU0wgaW5jbHVkZXMgYSBjaGVjayB0byBlbnN1cmUgdGhhdCBhIHBlZXIgaXMgc2VuZGluZyByZWFzb25hYmx5IHNpemVkIG1lc3NhZ2VzIGluIG9yZGVyIHRvIGF2b2lkIHRvbyBtdWNoIG1lbW9yeSBiZWluZyBjb25zdW1lZCB0byBzZXJ2aWNlIGEgY29ubmVjdGlvbi4gQSBmbGF3IGluIHRoZSBsb2dpYyBvZiB2ZXJzaW9uIDEuMS4wIG1lYW5zIHRoYXQgbWVtb3J5IGZvciB0aGUgbWVzc2FnZSBpcyBhbGxvY2F0ZWQgdG9vIGVhcmx5LCBwcmlvciB0byB0aGUgZXhjZXNzaXZlIG1lc3NhZ2UgbGVuZ3RoIGNoZWNrLiBEdWUgdG8gd2F5IG1lbW9yeSBpcyBhbGxvY2F0ZWQgaW4gT3BlblNTTCB0aGlzIGNvdWxkIG1lYW4gYW4gYXR0YWNrZXIgY291bGQgZm9yY2UgdXAgdG8gMjFNYiB0byBiZSBhbGxvY2F0ZWQgdG8gc2VydmljZSBhIGNvbm5lY3Rpb24uIFRoaXMgY291bGQgbGVhZCB0byBhIERlbmlhbCBvZiBTZXJ2aWNlIHRocm91Z2ggbWVtb3J5IGV4aGF1c3Rpb24uIEhvd2V2ZXIsIHRoZSBleGNlc3NpdmUgbWVzc2FnZSBsZW5ndGggY2hlY2sgc3RpbGwgdGFrZXMgcGxhY2UsIGFuZCB0aGlzIHdvdWxkIGNhdXNlIHRoZSBjb25uZWN0aW9uIHRvIGltbWVkaWF0ZWx5IGZhaWwuIEFzc3VtaW5nIHRoYXQgdGhlIGFwcGxpY2F0aW9uIGNhbGxzIFNTTF9mcmVlKCkgb24gdGhlIGZhaWxlZCBjb25uZWNpdG9uIGluIGEgdGltZWx5IG1hbm5lciB0aGVuIHRoZSAyMU1iIG9mIGFsbG9jYXRlZCBtZW1vcnkgd2lsbCB0aGVuIGJlIGltbWVkaWF0ZWx5IGZyZWVkIGFnYWluLiBUaGVyZWZvcmUgdGhlIGV4Y2Vzc2l2ZSBtZW1vcnkgYWxsb2NhdGlvbiB3aWxsIGJlIHRyYW5zaXRvcnkgaW4gbmF0dXJlLiBUaGlzIHRoZW4gbWVhbnMgdGhhdCB0aGVyZSBpcyBvbmx5IGEgc2VjdXJpdHkgaW1wYWN0IGlmOiAxKSBUaGUgYXBwbGljYXRpb24gZG9lcyBub3QgY2FsbCBTU0xfZnJlZSgpIGluIGEgdGltZWx5IG1hbm5lciBpbiB0aGUgZXZlbnQgdGhhdCB0aGUgY29ubmVjdGlvbiBmYWlscyBvciAyKSBUaGUgYXBwbGljYXRpb24gaXMgd29ya2luZyBpbiBhIGNvbnN0cmFpbmVkIGVudmlyb25tZW50IHdoZXJlIHRoZXJlIGlzIHZlcnkgbGl0dGxlIGZyZWUgbWVtb3J5IG9yIDMpIFRoZSBhdHRhY2tlciBpbml0aWF0ZXMgbXVsdGlwbGUgY29ubmVjdGlvbiBhdHRlbXB0cyBzdWNoIHRoYXQgdGhlcmUgYXJlIG11bHRpcGxlIGNvbm5lY3Rpb25zIGluIGEgc3RhdGUgd2hlcmUgbWVtb3J5IGhhcyBiZWVuIGFsbG9jYXRlZCBmb3IgdGhlIGNvbm5lY3Rpb247IFNTTF9mcmVlKCkgaGFzIG5vdCB5ZXQgYmVlbiBjYWxsZWQ7IGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbWVtb3J5IHRvIHNlcnZpY2UgdGhlIG11bHRpcGxlIHJlcXVlc3RzLiBFeGNlcHQgaW4gdGhlIGluc3RhbmNlIG9mICgxKSBhYm92ZSBhbnkgRGVuaWFsIE9mIFNlcnZpY2UgaXMgbGlrZWx5IHRvIGJlIHRyYW5zaXRvcnkgYmVjYXVzZSBhcyBzb29uIGFzIHRoZSBjb25uZWN0aW9uIGZhaWxzIHRoZSBtZW1vcnkgaXMgc3Vic2VxdWVudGx5IGZyZWVkIGFnYWluIGluIHRoZSBTU0xfZnJlZSgpIGNhbGwuIEhvd2V2ZXIgdGhlcmUgaXMgYW4gaW5jcmVhc2VkIHJpc2sgZHVyaW5nIHRoaXMgcGVyaW9kIG9mIGFwcGxpY2F0aW9uIGNyYXNoZXMgZHVlIHRvIHRoZSBsYWNrIG9mIG1lbW9yeSAtIHdoaWNoIHdvdWxkIHRoZW4gbWVhbiBhIG1vcmUgc2VyaW91cyBEZW5pYWwgb2YgU2VydmljZS4gUmVwb3J0ZWQgYnkgU2hpIExlaSAoR2VhciBUZWFtLCBRaWhvbyAzNjAgSW5jLikuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjEuMGEgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMS4wKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTYtNjMwNjwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltMb3cgc2V2ZXJpdHldPC9hPiAyMSBTZXB0ZW1iZXIgMjAxNjogPC9kdD48ZGQ+SW4gT3BlblNTTCAxLjAuMiBhbmQgZWFybGllciBzb21lIG1pc3NpbmcgbWVzc2FnZSBsZW5ndGggY2hlY2tzIGNhbiByZXN1bHQgaW4gT09CIHJlYWRzIG9mIHVwIHRvIDIgYnl0ZXMgYmV5b25kIGFuIGFsbG9jYXRlZCBidWZmZXIuIFRoZXJlIGlzIGEgdGhlb3JldGljYWwgRG9TIHJpc2sgYnV0IHRoaXMgaGFzIG5vdCBiZWVuIG9ic2VydmVkIGluIHByYWN0aWNlIG9uIGNvbW1vbiBwbGF0Zm9ybXMuIFRoZSBtZXNzYWdlcyBhZmZlY3RlZCBhcmUgY2xpZW50IGNlcnRpZmljYXRlLCBjbGllbnQgY2VydGlmaWNhdGUgcmVxdWVzdCBhbmQgc2VydmVyIGNlcnRpZmljYXRlLiBBcyBhIHJlc3VsdCB0aGUgYXR0YWNrIGNhbiBvbmx5IGJlIHBlcmZvcm1lZCBhZ2FpbnN0IGEgY2xpZW50IG9yIGEgc2VydmVyIHdoaWNoIGVuYWJsZXMgY2xpZW50IGF1dGhlbnRpY2F0aW9uLiBSZXBvcnRlZCBieSBTaGkgTGVpIChHZWFyIFRlYW0sIFFpaG9vIDM2MCBJbmMuKS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yaSA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4wLjItMS4wLjJoKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjF1IDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjAuMS0xLjAuMXQpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNi02MzAzPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0xvdyBzZXZlcml0eV08L2E+IDI0IEF1Z3VzdCAyMDE2OiA8L2R0PjxkZD5BbiBvdmVyZmxvdyBjYW4gb2NjdXIgaW4gTURDMl9VcGRhdGUoKSBlaXRoZXIgaWYgY2FsbGVkIGRpcmVjdGx5IG9yIHRocm91Z2ggdGhlIEVWUF9EaWdlc3RVcGRhdGUoKSBmdW5jdGlvbiB1c2luZyBNREMyLiBJZiBhbiBhdHRhY2tlciBpcyBhYmxlIHRvIHN1cHBseSB2ZXJ5IGxhcmdlIGFtb3VudHMgb2YgaW5wdXQgZGF0YSBhZnRlciBhIHByZXZpb3VzIGNhbGwgdG8gRVZQX0VuY3J5cHRVcGRhdGUoKSB3aXRoIGEgcGFydGlhbCBibG9jayB0aGVuIGEgbGVuZ3RoIGNoZWNrIGNhbiBvdmVyZmxvdyByZXN1bHRpbmcgaW4gYSBoZWFwIGNvcnJ1cHRpb24uIFRoZSBhbW91bnQgb2YgZGF0YSBuZWVkZWQgaXMgY29tcGFyYWJsZSB0byBTSVpFX01BWCB3aGljaCBpcyBpbXByYWN0aWNhbCBvbiBtb3N0IHBsYXRmb3Jtcy4gUmVwb3J0ZWQgYnkgU2hpIExlaSAoR2VhciBUZWFtLCBRaWhvbyAzNjAgSW5jLikuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMmkgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMC4yLTEuMC4yaCk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4xdSA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4wLjEtMS4wLjF0KTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTYtNjMwMjwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltMb3cgc2V2ZXJpdHldPC9hPiAyMyBBdWd1c3QgMjAxNjogPC9kdD48ZGQ+SWYgYSBzZXJ2ZXIgdXNlcyBTSEE1MTIgZm9yIFRMUyBzZXNzaW9uIHRpY2tldCBITUFDIGl0IGlzIHZ1bG5lcmFibGUgdG8gYSBEb1MgYXR0YWNrIHdoZXJlIGEgbWFsZm9ybWVkIHRpY2tldCB3aWxsIHJlc3VsdCBpbiBhbiBPT0IgcmVhZCB3aGljaCB3aWxsIHVsdGltYXRlbHkgY3Jhc2guIFRoZSB1c2Ugb2YgU0hBNTEyIGluIFRMUyBzZXNzaW9uIHRpY2tldHMgaXMgY29tcGFyYXRpdmVseSByYXJlIGFzIGl0IHJlcXVpcmVzIGEgY3VzdG9tIHNlcnZlciBjYWxsYmFjayBhbmQgdGlja2V0IGxvb2t1cCBtZWNoYW5pc20uIFJlcG9ydGVkIGJ5IFNoaSBMZWkgKEdlYXIgVGVhbSwgUWlob28gMzYwIEluYy4pLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJpIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjAuMi0xLjAuMmgpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMXUgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMC4xLTEuMC4xdCk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE2LTIxNzk8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMjIgQXVndXN0IDIwMTY6IDwvZHQ+PGRkPkluIGEgRFRMUyBjb25uZWN0aW9uIHdoZXJlIGhhbmRzaGFrZSBtZXNzYWdlcyBhcmUgZGVsaXZlcmVkIG91dC1vZi1vcmRlciB0aG9zZSBtZXNzYWdlcyB0aGF0IE9wZW5TU0wgaXMgbm90IHlldCByZWFkeSB0byBwcm9jZXNzIHdpbGwgYmUgYnVmZmVyZWQgZm9yIGxhdGVyIHVzZS4gVW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCBhIGZsYXcgaW4gdGhlIGxvZ2ljIG1lYW5zIHRoYXQgdGhvc2UgbWVzc2FnZXMgZG8gbm90IGdldCByZW1vdmVkIGZyb20gdGhlIGJ1ZmZlciBldmVuIHRob3VnaCB0aGUgaGFuZHNoYWtlIGhhcyBiZWVuIGNvbXBsZXRlZC4gQW4gYXR0YWNrZXIgY291bGQgZm9yY2UgdXAgdG8gYXBwcm94LiAxNSBtZXNzYWdlcyB0byByZW1haW4gaW4gdGhlIGJ1ZmZlciB3aGVuIHRoZXkgYXJlIG5vIGxvbmdlciByZXF1aXJlZC4gVGhlc2UgbWVzc2FnZXMgd2lsbCBiZSBjbGVhcmVkIHdoZW4gdGhlIERUTFMgY29ubmVjdGlvbiBpcyBjbG9zZWQuIFRoZSBkZWZhdWx0IG1heGltdW0gc2l6ZSBmb3IgYSBtZXNzYWdlIGlzIDEwMGsuIFRoZXJlZm9yZSB0aGUgYXR0YWNrZXIgY291bGQgZm9yY2UgYW4gYWRkaXRpb25hbCAxNTAwayB0byBiZSBjb25zdW1lZCBwZXIgY29ubmVjdGlvbi4gQnkgb3BlbmluZyBtYW55IHNpbXVsYXRhbmVvdXMgY29ubmVjdGlvbnMgYW4gYXR0YWNrZXIgY291bGQgY2F1c2UgYSBEb1MgYXR0YWNrIHRocm91Z2ggbWVtb3J5IGV4aGF1c3Rpb24uIFJlcG9ydGVkIGJ5IFF1YW4gTHVvLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJpIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjAuMi0xLjAuMmgpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMXUgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMC4xLTEuMC4xdCk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE2LTIxODE8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMTkgQXVndXN0IDIwMTY6IDwvZHQ+PGRkPkEgZmxhdyBpbiB0aGUgRFRMUyByZXBsYXkgYXR0YWNrIHByb3RlY3Rpb24gbWVjaGFuaXNtIG1lYW5zIHRoYXQgcmVjb3JkcyB0aGF0IGFycml2ZSBmb3IgZnV0dXJlIGVwb2NocyB1cGRhdGUgdGhlIHJlcGxheSBwcm90ZWN0aW9uICJ3aW5kb3ciIGJlZm9yZSB0aGUgTUFDIGZvciB0aGUgcmVjb3JkIGhhcyBiZWVuIHZhbGlkYXRlZC4gVGhpcyBjb3VsZCBiZSBleHBsb2l0ZWQgYnkgYW4gYXR0YWNrZXIgYnkgc2VuZGluZyBhIHJlY29yZCBmb3IgdGhlIG5leHQgZXBvY2ggKHdoaWNoIGRvZXMgbm90IGhhdmUgdG8gZGVjcnlwdCBvciBoYXZlIGEgdmFsaWQgTUFDKSwgd2l0aCBhIHZlcnkgbGFyZ2Ugc2VxdWVuY2UgbnVtYmVyLiBUaGlzIG1lYW5zIHRoYXQgYWxsIHN1YnNlcXVlbnQgbGVnaXRpbWF0ZSBwYWNrZXRzIGFyZSBkcm9wcGVkIGNhdXNpbmcgYSBkZW5pYWwgb2Ygc2VydmljZSBmb3IgYSBzcGVjaWZpYyBEVExTIGNvbm5lY3Rpb24uIFJlcG9ydGVkIGJ5IE9DQVAgYXVkaXQgdGVhbS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yaSA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4wLjItMS4wLjJoKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjF1IDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjAuMS0xLjAuMXQpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNi0yMTgyPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0xvdyBzZXZlcml0eV08L2E+IDE2IEF1Z3VzdCAyMDE2OiA8L2R0PjxkZD5UaGUgZnVuY3Rpb24gQk5fYm4yZGVjKCkgZG9lcyBub3QgY2hlY2sgdGhlIHJldHVybiB2YWx1ZSBvZiBCTl9kaXZfd29yZCgpLiBUaGlzIGNhbiBjYXVzZSBhbiBPT0Igd3JpdGUgaWYgYW4gYXBwbGljYXRpb24gdXNlcyB0aGlzIGZ1bmN0aW9uIHdpdGggYW4gb3Zlcmx5IGxhcmdlIEJJR05VTS4gVGhpcyBjb3VsZCBiZSBhIHByb2JsZW0gaWYgYW4gb3Zlcmx5IGxhcmdlIGNlcnRpZmljYXRlIG9yIENSTCBpcyBwcmludGVkIG91dCBmcm9tIGFuIHVudHJ1c3RlZCBzb3VyY2UuIFRMUyBpcyBub3QgYWZmZWN0ZWQgYmVjYXVzZSByZWNvcmQgbGltaXRzIHdpbGwgcmVqZWN0IGFuIG92ZXJzaXplZCBjZXJ0aWZpY2F0ZSBiZWZvcmUgaXQgaXMgcGFyc2VkLiBSZXBvcnRlZCBieSBTaGkgTGVpIChHZWFyIFRlYW0sIFFpaG9vIDM2MCBJbmMuKS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yaSAoQWZmZWN0ZWQgMS4wLjItMS4wLjJoKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjF1IChBZmZlY3RlZCAxLjAuMS0xLjAuMXQpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNi0yMTgwPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0xvdyBzZXZlcml0eV08L2E+IDIyIEp1bHkgMjAxNjogPC9kdD48ZGQ+VGhlIGZ1bmN0aW9uIFRTX09CSl9wcmludF9iaW8oKSBtaXN1c2VzIE9CSl9vYmoydHh0KCk6IHRoZSByZXR1cm4gdmFsdWUgaXMgdGhlIHRvdGFsIGxlbmd0aCB0aGUgT0lEIHRleHQgcmVwcmVzZW50YXRpb24gd291bGQgdXNlIGFuZCBub3QgdGhlIGFtb3VudCBvZiBkYXRhIHdyaXR0ZW4uIFRoaXMgd2lsbCByZXN1bHQgaW4gT09CIHJlYWRzIHdoZW4gbGFyZ2UgT0lEcyBhcmUgcHJlc2VudGVkLiBSZXBvcnRlZCBieSBTaGkgTGVpIChHZWFyIFRlYW0sIFFpaG9vIDM2MCBJbmMuKS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yaSAoQWZmZWN0ZWQgMS4wLjItMS4wLjJoKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjF1IChBZmZlY3RlZCAxLjAuMS0xLjAuMXQpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNi0yMTc4PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0xvdyBzZXZlcml0eV08L2E+IDA3IEp1bmUgMjAxNjogPC9kdD48ZGQ+T3BlcmF0aW9ucyBpbiB0aGUgRFNBIHNpZ25pbmcgYWxnb3JpdGhtIHNob3VsZCBydW4gaW4gY29uc3RhbnQgdGltZSBpbiBvcmRlciB0byBhdm9pZCBzaWRlIGNoYW5uZWwgYXR0YWNrcy4gQSBmbGF3IGluIHRoZSBPcGVuU1NMIERTQSBpbXBsZW1lbnRhdGlvbiBtZWFucyB0aGF0IGEgbm9uLWNvbnN0YW50IHRpbWUgY29kZXBhdGggaXMgZm9sbG93ZWQgZm9yIGNlcnRhaW4gb3BlcmF0aW9ucy4gVGhpcyBoYXMgYmVlbiBkZW1vbnN0cmF0ZWQgdGhyb3VnaCBhIGNhY2hlLXRpbWluZyBhdHRhY2sgdG8gYmUgc3VmZmljaWVudCBmb3IgYW4gYXR0YWNrZXIgdG8gcmVjb3ZlciB0aGUgcHJpdmF0ZSBEU0Ega2V5LiBSZXBvcnRlZCBieSBDw6lzYXIgUGVyZWlkYSAoQWFsdG8gVW5pdmVyc2l0eSksIEJpbGx5IEJydW1sZXkgKFRhbXBlcmUgVW5pdmVyc2l0eSBvZiBUZWNobm9sb2d5KSwgYW5kIFl1dmFsIFlhcm9tIChUaGUgVW5pdmVyc2l0eSBvZiBBZGVsYWlkZSBhbmQgTklDVEEpLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJpIChBZmZlY3RlZCAxLjAuMi0xLjAuMmgpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMXUgKEFmZmVjdGVkIDEuMC4xLTEuMC4xdCk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE2LTIxNzc8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMDEgSnVuZSAyMDE2OiA8L2R0PjxkZD5Bdm9pZCBzb21lIHVuZGVmaW5lZCBwb2ludGVyIGFyaXRobWV0aWMgQSBjb21tb24gaWRpb20gaW4gdGhlIGNvZGViYXNlIGlzIHRvIGNoZWNrIGxpbWl0cyBpbiB0aGUgZm9sbG93aW5nIG1hbm5lcjogInAgKyBsZW4gJmd0OyBsaW1pdCIgV2hlcmUgInAiIHBvaW50cyB0byBzb21lIG1hbGxvYydkIGRhdGEgb2YgU0laRSBieXRlcyBhbmQgbGltaXQgPT0gcCArIFNJWkUgImxlbiIgaGVyZSBjb3VsZCBiZSBmcm9tIHNvbWUgZXh0ZXJuYWxseSBzdXBwbGllZCBkYXRhIChlLmcuIGZyb20gYSBUTFMgbWVzc2FnZSkuIFRoZSBydWxlcyBvZiBDIHBvaW50ZXIgYXJpdGhtZXRpYyBhcmUgc3VjaCB0aGF0ICJwICsgbGVuIiBpcyBvbmx5IHdlbGwgZGVmaW5lZCB3aGVyZSBsZW4gJmx0Oz0gU0laRS4gVGhlcmVmb3JlIHRoZSBhYm92ZSBpZGlvbSBpcyBhY3R1YWxseSB1bmRlZmluZWQgYmVoYXZpb3VyLiBGb3IgZXhhbXBsZSB0aGlzIGNvdWxkIGNhdXNlIHByb2JsZW1zIGlmIHNvbWUgbWFsbG9jIGltcGxlbWVudGF0aW9uIHByb3ZpZGVzIGFuIGFkZHJlc3MgZm9yICJwIiBzdWNoIHRoYXQgInAgKyBsZW4iIGFjdHVhbGx5IG92ZXJmbG93cyBmb3IgdmFsdWVzIG9mIGxlbiB0aGF0IGFyZSB0b28gYmlnIGFuZCB0aGVyZWZvcmUgcCArIGxlbiAmbHQ7IGxpbWl0LiBSZXBvcnRlZCBieSBHdWlkbyBWcmFua2VuLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJpIChBZmZlY3RlZCAxLjAuMi0xLjAuMmgpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMXUgKEFmZmVjdGVkIDEuMC4xLTEuMC4xdCk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE2LTIxNzY8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMDMgTWF5IDIwMTY6IDwvZHQ+PGRkPkFTTjEgU3RyaW5ncyB0aGF0IGFyZSBvdmVyIDEwMjQgYnl0ZXMgY2FuIGNhdXNlIGFuIG92ZXJyZWFkIGluIGFwcGxpY2F0aW9ucyB1c2luZyB0aGUgWDUwOV9OQU1FX29uZWxpbmUoKSBmdW5jdGlvbiBvbiBFQkNESUMgc3lzdGVtcy4gVGhpcyBjb3VsZCByZXN1bHQgaW4gYXJiaXRyYXJ5IHN0YWNrIGRhdGEgYmVpbmcgcmV0dXJuZWQgaW4gdGhlIGJ1ZmZlci4gUmVwb3J0ZWQgYnkgR3VpZG8gVnJhbmtlbi4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yaCAoQWZmZWN0ZWQgMS4wLjItMS4wLjJnKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjF0IChBZmZlY3RlZCAxLjAuMS0xLjAuMXMpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNi0yMTA5PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0xvdyBzZXZlcml0eV08L2E+IDAzIE1heSAyMDE2OiA8L2R0PjxkZD5XaGVuIEFTTi4xIGRhdGEgaXMgcmVhZCBmcm9tIGEgQklPIHVzaW5nIGZ1bmN0aW9ucyBzdWNoIGFzIGQyaV9DTVNfYmlvKCkgYSBzaG9ydCBpbnZhbGlkIGVuY29kaW5nIGNhbiBjYXN1c2UgYWxsb2NhdGlvbiBvZiBsYXJnZSBhbW91bnRzIG9mIG1lbW9yeSBwb3RlbnRpYWxseSBjb25zdW1pbmcgZXhjZXNzaXZlIHJlc291cmNlcyBvciBleGhhdXN0aW5nIG1lbW9yeS4gQW55IGFwcGxpY2F0aW9uIHBhcnNpbmcgdW50cnVzdGVkIGRhdGEgdGhyb3VnaCBkMmkgQklPIGZ1bmN0aW9ucyBpcyBhZmZlY3RlZC4gVGhlIG1lbW9yeSBiYXNlZCBmdW5jdGlvbnMgc3VjaCBhcyBkMmlfWDUwOSgpIGFyZSAqbm90KiBhZmZlY3RlZC4gU2luY2UgdGhlIG1lbW9yeSBiYXNlZCBmdW5jdGlvbnMgYXJlIHVzZWQgYnkgdGhlIFRMUyBsaWJyYXJ5LCBUTFMgYXBwbGljYXRpb25zIGFyZSBub3QgYWZmZWN0ZWQuIFJlcG9ydGVkIGJ5IEJyaWFuIENhcnBlbnRlci4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yaCAoQWZmZWN0ZWQgMS4wLjItMS4wLjJnKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjF0IChBZmZlY3RlZCAxLjAuMS0xLjAuMXMpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNi0yMTA4PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0hpZ2ggc2V2ZXJpdHldPC9hPiAwMyBNYXkgMjAxNjogPC9kdD48ZGQ+VGhpcyBpc3N1ZSBhZmZlY3RlZCB2ZXJzaW9ucyBvZiBPcGVuU1NMIHByaW9yIHRvIEFwcmlsIDIwMTUuIFRoZSBidWcgY2F1c2luZyB0aGUgdnVsbmVyYWJpbGl0eSB3YXMgZml4ZWQgb24gQXByaWwgMTh0aCAyMDE1LCBhbmQgcmVsZWFzZWQgYXMgcGFydCBvZiB0aGUgSnVuZSAxMXRoIDIwMTUgc2VjdXJpdHkgcmVsZWFzZXMuIFRoZSBzZWN1cml0eSBpbXBhY3Qgb2YgdGhlIGJ1ZyB3YXMgbm90IGtub3duIGF0IHRoZSB0aW1lLiBJbiBwcmV2aW91cyB2ZXJzaW9ucyBvZiBPcGVuU1NMLCBBU04uMSBlbmNvZGluZyB0aGUgdmFsdWUgemVybyByZXByZXNlbnRlZCBhcyBhIG5lZ2F0aXZlIGludGVnZXIgY2FuIGNhdXNlIGEgYnVmZmVyIHVuZGVyZmxvdyB3aXRoIGFuIG91dC1vZi1ib3VuZHMgd3JpdGUgaW4gaTJjX0FTTjFfSU5URUdFUi4gVGhlIEFTTi4xIHBhcnNlciBkb2VzIG5vdCBub3JtYWxseSBjcmVhdGUgIm5lZ2F0aXZlIHplcm9lcyIgd2hlbiBwYXJzaW5nIEFTTi4xIGlucHV0LCBhbmQgdGhlcmVmb3JlLCBhbiBhdHRhY2tlciBjYW5ub3QgdHJpZ2dlciB0aGlzIGJ1Zy4gSG93ZXZlciwgYSBzZWNvbmQsIGluZGVwZW5kZW50IGJ1ZyByZXZlYWxlZCB0aGF0IHRoZSBBU04uMSBwYXJzZXIgKHNwZWNpZmljYWxseSwgZDJpX0FTTjFfVFlQRSkgY2FuIG1pc2ludGVycHJldCBhIGxhcmdlIHVuaXZlcnNhbCB0YWcgYXMgYSBuZWdhdGl2ZSB6ZXJvIHZhbHVlLiBMYXJnZSB1bml2ZXJzYWwgdGFncyBhcmUgbm90IHByZXNlbnQgaW4gYW55IGNvbW1vbiBBU04uMSBzdHJ1Y3R1cmVzIChzdWNoIGFzIFg1MDkpIGJ1dCBhcmUgYWNjZXB0ZWQgYXMgcGFydCBvZiBBTlkgc3RydWN0dXJlcy4gVGhlcmVmb3JlLCBpZiBhbiBhcHBsaWNhdGlvbiBkZXNlcmlhbGl6ZXMgdW50cnVzdGVkIEFTTi4xIHN0cnVjdHVyZXMgY29udGFpbmluZyBhbiBBTlkgZmllbGQsIGFuZCBsYXRlciByZXNlcmlhbGl6ZXMgdGhlbSwgYW4gYXR0YWNrZXIgbWF5IGJlIGFibGUgdG8gdHJpZ2dlciBhbiBvdXQtb2YtYm91bmRzIHdyaXRlLiBUaGlzIGhhcyBiZWVuIHNob3duIHRvIGNhdXNlIG1lbW9yeSBjb3JydXB0aW9uIHRoYXQgaXMgcG90ZW50aWFsbHkgZXhwbG9pdGFibGUgd2l0aCBzb21lIG1hbGxvYyBpbXBsZW1lbnRhdGlvbnMuIEFwcGxpY2F0aW9ucyB0aGF0IHBhcnNlIGFuZCByZS1lbmNvZGUgWDUwOSBjZXJ0aWZpY2F0ZXMgYXJlIGtub3duIHRvIGJlIHZ1bG5lcmFibGUuIEFwcGxpY2F0aW9ucyB0aGF0IHZlcmlmeSBSU0Egc2lnbmF0dXJlcyBvbiBYNTA5IGNlcnRpZmljYXRlcyBtYXkgYWxzbyBiZSB2dWxuZXJhYmxlOyBob3dldmVyLCBvbmx5IGNlcnRpZmljYXRlcyB3aXRoIHZhbGlkIHNpZ25hdHVyZXMgdHJpZ2dlciBBU04uMSByZS1lbmNvZGluZyBhbmQgaGVuY2UgdGhlIGJ1Zy4gU3BlY2lmaWNhbGx5LCBzaW5jZSBPcGVuU1NMJ3MgZGVmYXVsdCBUTFMgWDUwOSBjaGFpbiB2ZXJpZmljYXRpb24gY29kZSB2ZXJpZmllcyB0aGUgY2VydGlmaWNhdGUgY2hhaW4gZnJvbSByb290IHRvIGxlYWYsIFRMUyBoYW5kc2hha2VzIGNvdWxkIG9ubHkgYmUgdGFyZ2V0ZWQgd2l0aCB2YWxpZCBjZXJ0aWZpY2F0ZXMgaXNzdWVkIGJ5IHRydXN0ZWQgQ2VydGlmaWNhdGlvbiBBdXRob3JpdGllcy4gUmVwb3J0ZWQgYnkgSHV6YWlmYSBTaWRocHVyd2FsYSAoUmVkIEhhdCksIEhhbm5vIELDtmNrLCBEYXZpZCBCZW5qYW1pbiAoR29vZ2xlKS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yYyAoQWZmZWN0ZWQgMS4wLjItMS4wLjJiKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFvIChBZmZlY3RlZCAxLjAuMS0xLjAuMW4pPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNi0yMTA3PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0hpZ2ggc2V2ZXJpdHldPC9hPiAwMyBNYXkgMjAxNjogPC9kdD48ZGQ+QSBNSVRNIGF0dGFja2VyIGNhbiB1c2UgYSBwYWRkaW5nIG9yYWNsZSBhdHRhY2sgdG8gZGVjcnlwdCB0cmFmZmljIHdoZW4gdGhlIGNvbm5lY3Rpb24gdXNlcyBhbiBBRVMgQ0JDIGNpcGhlciBhbmQgdGhlIHNlcnZlciBzdXBwb3J0IEFFUy1OSS4gVGhpcyBpc3N1ZSB3YXMgaW50cm9kdWNlZCBhcyBwYXJ0IG9mIHRoZSBmaXggZm9yIEx1Y2t5IDEzIHBhZGRpbmcgYXR0YWNrIChDVkUtMjAxMy0wMTY5KS4gVGhlIHBhZGRpbmcgY2hlY2sgd2FzIHJld3JpdHRlbiB0byBiZSBpbiBjb25zdGFudCB0aW1lIGJ5IG1ha2luZyBzdXJlIHRoYXQgYWx3YXlzIHRoZSBzYW1lIGJ5dGVzIGFyZSByZWFkIGFuZCBjb21wYXJlZCBhZ2FpbnN0IGVpdGhlciB0aGUgTUFDIG9yIHBhZGRpbmcgYnl0ZXMuIEJ1dCBpdCBubyBsb25nZXIgY2hlY2tlZCB0aGF0IHRoZXJlIHdhcyBlbm91Z2ggZGF0YSB0byBoYXZlIGJvdGggdGhlIE1BQyBhbmQgcGFkZGluZyBieXRlcy4gUmVwb3J0ZWQgYnkgSnVyYWogU29tb3JvdnNreS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yaCA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4wLjItMS4wLjJnKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjF0IChBZmZlY3RlZCAxLjAuMS0xLjAuMXMpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNi0yMTA2PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0xvdyBzZXZlcml0eV08L2E+IDAzIE1heSAyMDE2OiA8L2R0PjxkZD5BbiBvdmVyZmxvdyBjYW4gb2NjdXIgaW4gdGhlIEVWUF9FbmNyeXB0VXBkYXRlKCkgZnVuY3Rpb24uIElmIGFuIGF0dGFja2VyIGlzIGFibGUgdG8gc3VwcGx5IHZlcnkgbGFyZ2UgYW1vdW50cyBvZiBpbnB1dCBkYXRhIGFmdGVyIGEgcHJldmlvdXMgY2FsbCB0byBFVlBfRW5jcnlwdFVwZGF0ZSgpIHdpdGggYSBwYXJ0aWFsIGJsb2NrIHRoZW4gYSBsZW5ndGggY2hlY2sgY2FuIG92ZXJmbG93IHJlc3VsdGluZyBpbiBhIGhlYXAgY29ycnVwdGlvbi4gRm9sbG93aW5nIGFuIGFuYWx5c2lzIG9mIGFsbCBPcGVuU1NMIGludGVybmFsIHVzYWdlIG9mIHRoZSBFVlBfRW5jcnlwdFVwZGF0ZSgpIGZ1bmN0aW9uIGFsbCB1c2FnZSBpcyBvbmUgb2YgdHdvIGZvcm1zLiBUaGUgZmlyc3QgZm9ybSBpcyB3aGVyZSB0aGUgRVZQX0VuY3J5cHRVcGRhdGUoKSBjYWxsIGlzIGtub3duIHRvIGJlIHRoZSBmaXJzdCBjYWxsZWQgZnVuY3Rpb24gYWZ0ZXIgYW4gRVZQX0VuY3J5cHRJbml0KCksIGFuZCB0aGVyZWZvcmUgdGhhdCBzcGVjaWZpYyBjYWxsIG11c3QgYmUgc2FmZS4gVGhlIHNlY29uZCBmb3JtIGlzIHdoZXJlIHRoZSBsZW5ndGggcGFzc2VkIHRvIEVWUF9FbmNyeXB0VXBkYXRlKCkgY2FuIGJlIHNlZW4gZnJvbSB0aGUgY29kZSB0byBiZSBzb21lIHNtYWxsIHZhbHVlIGFuZCB0aGVyZWZvcmUgdGhlcmUgaXMgbm8gcG9zc2liaWxpdHkgb2YgYW4gb3ZlcmZsb3cuIFNpbmNlIGFsbCBpbnN0YW5jZXMgYXJlIG9uZSBvZiB0aGVzZSB0d28gZm9ybXMsIGl0IGlzIGJlbGlldmVkIHRoYXQgdGhlcmUgY2FuIGJlIG5vIG92ZXJmbG93cyBpbiBpbnRlcm5hbCBjb2RlIGR1ZSB0byB0aGlzIHByb2JsZW0uIEl0IHNob3VsZCBiZSBub3RlZCB0aGF0IEVWUF9EZWNyeXB0VXBkYXRlKCkgY2FuIGNhbGwgRVZQX0VuY3J5cHRVcGRhdGUoKSBpbiBjZXJ0YWluIGNvZGUgcGF0aHMuIEFsc28gRVZQX0NpcGhlclVwZGF0ZSgpIGlzIGEgc3lub255bSBmb3IgRVZQX0VuY3J5cHRVcGRhdGUoKS4gQWxsIGluc3RhbmNlcyBvZiB0aGVzZSBjYWxscyBoYXZlIGFsc28gYmVlbiBhbmFseXNlZCB0b28gYW5kIGl0IGlzIGJlbGlldmVkIHRoZXJlIGFyZSBubyBpbnN0YW5jZXMgaW4gaW50ZXJuYWwgdXNhZ2Ugd2hlcmUgYW4gb3ZlcmZsb3cgY291bGQgb2NjdXIuIFRoaXMgY291bGQgc3RpbGwgcmVwcmVzZW50IGEgc2VjdXJpdHkgaXNzdWUgZm9yIGVuZCB1c2VyIGNvZGUgdGhhdCBjYWxscyB0aGlzIGZ1bmN0aW9uIGRpcmVjdGx5LiBSZXBvcnRlZCBieSBHdWlkbyBWcmFua2VuLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJoIChBZmZlY3RlZCAxLjAuMi0xLjAuMmcpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMXQgKEFmZmVjdGVkIDEuMC4xLTEuMC4xcyk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE2LTIxMDU8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMDMgTWF5IDIwMTY6IDwvZHQ+PGRkPkFuIG92ZXJmbG93IGNhbiBvY2N1ciBpbiB0aGUgRVZQX0VuY29kZVVwZGF0ZSgpIGZ1bmN0aW9uIHdoaWNoIGlzIHVzZWQgZm9yIEJhc2U2NCBlbmNvZGluZyBvZiBiaW5hcnkgZGF0YS4gSWYgYW4gYXR0YWNrZXIgaXMgYWJsZSB0byBzdXBwbHkgdmVyeSBsYXJnZSBhbW91bnRzIG9mIGlucHV0IGRhdGEgdGhlbiBhIGxlbmd0aCBjaGVjayBjYW4gb3ZlcmZsb3cgcmVzdWx0aW5nIGluIGEgaGVhcCBjb3JydXB0aW9uLiBJbnRlcm5hbGx5IHRvIE9wZW5TU0wgdGhlIEVWUF9FbmNvZGVVcGRhdGUoKSBmdW5jdGlvbiBpcyBwcmltYXJseSB1c2VkIGJ5IHRoZSBQRU1fd3JpdGVfYmlvKiBmYW1pbHkgb2YgZnVuY3Rpb25zLiBUaGVzZSBhcmUgbWFpbmx5IHVzZWQgd2l0aGluIHRoZSBPcGVuU1NMIGNvbW1hbmQgbGluZSBhcHBsaWNhdGlvbnMuIFRoZXNlIGludGVybmFsIHVzZXMgYXJlIG5vdCBjb25zaWRlcmVkIHZ1bG5lcmFibGUgYmVjYXVzZSBhbGwgY2FsbHMgYXJlIGJvdW5kZWQgd2l0aCBsZW5ndGggY2hlY2tzIHNvIG5vIG92ZXJmbG93IGlzIHBvc3NpYmxlLiBVc2VyIGFwcGxpY2F0aW9ucyB0aGF0IGNhbGwgdGhlc2UgQVBJcyBkaXJlY3RseSB3aXRoIGxhcmdlIGFtb3VudHMgb2YgdW50cnVzdGVkIGRhdGEgbWF5IGJlIHZ1bG5lcmFibGUuIChOb3RlOiBJbml0aWFsIGFuYWx5c2lzIHN1Z2dlc3RlZCB0aGF0IHRoZSBQRU1fd3JpdGVfYmlvKiB3ZXJlIHZ1bG5lcmFibGUsIGFuZCB0aGlzIGlzIHJlZmxlY3RlZCBpbiB0aGUgcGF0Y2ggY29tbWl0IG1lc3NhZ2UuIFRoaXMgaXMgbm8gbG9uZ2VyIGJlbGlldmVkIHRvIGJlIHRoZSBjYXNlKS4gUmVwb3J0ZWQgYnkgR3VpZG8gVnJhbmtlbi4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yaCAoQWZmZWN0ZWQgMS4wLjItMS4wLjJnKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjF0IChBZmZlY3RlZCAxLjAuMS0xLjAuMXMpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNi0wODAwPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0hpZ2ggc2V2ZXJpdHldPC9hPiAwMSBNYXJjaCAyMDE2OiA8L2R0PjxkZD5BIGNyb3NzLXByb3RvY29sIGF0dGFjayB3YXMgZGlzY292ZXJlZCB0aGF0IGNvdWxkIGxlYWQgdG8gZGVjcnlwdGlvbiBvZiBUTFMgc2Vzc2lvbnMgYnkgdXNpbmcgYSBzZXJ2ZXIgc3VwcG9ydGluZyBTU0x2MiBhbmQgRVhQT1JUIGNpcGhlciBzdWl0ZXMgYXMgYSBCbGVpY2hlbmJhY2hlciBSU0EgcGFkZGluZyBvcmFjbGUuIE5vdGUgdGhhdCB0cmFmZmljIGJldHdlZW4gY2xpZW50cyBhbmQgbm9uLXZ1bG5lcmFibGUgc2VydmVycyBjYW4gYmUgZGVjcnlwdGVkIHByb3ZpZGVkIGFub3RoZXIgc2VydmVyIHN1cHBvcnRpbmcgU1NMdjIgYW5kIEVYUE9SVCBjaXBoZXJzIChldmVuIHdpdGggYSBkaWZmZXJlbnQgcHJvdG9jb2wgc3VjaCBhcyBTTVRQLCBJTUFQIG9yIFBPUCkgc2hhcmVzIHRoZSBSU0Ega2V5cyBvZiB0aGUgbm9uLXZ1bG5lcmFibGUgc2VydmVyLiBUaGlzIHZ1bG5lcmFiaWxpdHkgaXMga25vd24gYXMgRFJPV04gKENWRS0yMDE2LTA4MDApLiBSZWNvdmVyaW5nIG9uZSBzZXNzaW9uIGtleSByZXF1aXJlcyB0aGUgYXR0YWNrZXIgdG8gcGVyZm9ybSBhcHByb3hpbWF0ZWx5IDJeNTAgY29tcHV0YXRpb24sIGFzIHdlbGwgYXMgdGhvdXNhbmRzIG9mIGNvbm5lY3Rpb25zIHRvIHRoZSBhZmZlY3RlZCBzZXJ2ZXIuIEEgbW9yZSBlZmZpY2llbnQgdmFyaWFudCBvZiB0aGUgRFJPV04gYXR0YWNrIGV4aXN0cyBhZ2FpbnN0IHVucGF0Y2hlZCBPcGVuU1NMIHNlcnZlcnMgdXNpbmcgdmVyc2lvbnMgdGhhdCBwcmVkYXRlIDEuMC4yYSwgMS4wLjFtLCAxLjAuMHIgYW5kIDAuOS44emYgcmVsZWFzZWQgb24gMTkvTWFyLzIwMTUgKHNlZSBDVkUtMjAxNi0wNzAzIGJlbG93KS4gVXNlcnMgY2FuIGF2b2lkIHRoaXMgaXNzdWUgYnkgZGlzYWJsaW5nIHRoZSBTU0x2MiBwcm90b2NvbCBpbiBhbGwgdGhlaXIgU1NML1RMUyBzZXJ2ZXJzLCBpZiB0aGV5J3ZlIG5vdCBkb25lIHNvIGFscmVhZHkuIERpc2FibGluZyBhbGwgU1NMdjIgY2lwaGVycyBpcyBhbHNvIHN1ZmZpY2llbnQsIHByb3ZpZGVkIHRoZSBwYXRjaGVzIGZvciBDVkUtMjAxNS0zMTk3IChmaXhlZCBpbiBPcGVuU1NMIDEuMC4xciBhbmQgMS4wLjJmKSBoYXZlIGJlZW4gZGVwbG95ZWQuIFNlcnZlcnMgdGhhdCBoYXZlIG5vdCBkaXNhYmxlZCB0aGUgU1NMdjIgcHJvdG9jb2wsIGFuZCBhcmUgbm90IHBhdGNoZWQgZm9yIENWRS0yMDE1LTMxOTcgYXJlIHZ1bG5lcmFibGUgdG8gRFJPV04gZXZlbiBpZiBhbGwgU1NMdjIgY2lwaGVycyBhcmUgbm9taW5hbGx5IGRpc2FibGVkLCBiZWNhdXNlIG1hbGljaW91cyBjbGllbnRzIGNhbiBmb3JjZSB0aGUgdXNlIG9mIFNTTHYyIHdpdGggRVhQT1JUIGNpcGhlcnMuIE9wZW5TU0wgMS4wLjJnIGFuZCAxLjAuMXMgZGVwbG95IHRoZSBmb2xsb3dpbmcgbWl0aWdhdGlvbiBhZ2FpbnN0IERST1dOOiBTU0x2MiBpcyBub3cgYnkgZGVmYXVsdCBkaXNhYmxlZCBhdCBidWlsZC10aW1lLiBCdWlsZHMgdGhhdCBhcmUgbm90IGNvbmZpZ3VyZWQgd2l0aCAiZW5hYmxlLXNzbDIiIHdpbGwgbm90IHN1cHBvcnQgU1NMdjIuIEV2ZW4gaWYgImVuYWJsZS1zc2wyIiBpcyB1c2VkLCB1c2VycyB3aG8gd2FudCB0byBuZWdvdGlhdGUgU1NMdjIgdmlhIHRoZSB2ZXJzaW9uLWZsZXhpYmxlIFNTTHYyM19tZXRob2QoKSB3aWxsIG5lZWQgdG8gZXhwbGljaXRseSBjYWxsIGVpdGhlciBvZjogU1NMX0NUWF9jbGVhcl9vcHRpb25zKGN0eCwgU1NMX09QX05PX1NTTHYyKTsgb3IgU1NMX2NsZWFyX29wdGlvbnMoc3NsLCBTU0xfT1BfTk9fU1NMdjIpOyBhcyBhcHByb3ByaWF0ZS4gRXZlbiBpZiBlaXRoZXIgb2YgdGhvc2UgaXMgdXNlZCwgb3IgdGhlIGFwcGxpY2F0aW9uIGV4cGxpY2l0bHkgdXNlcyB0aGUgdmVyc2lvbi1zcGVjaWZpYyBTU0x2Ml9tZXRob2QoKSBvciBpdHMgY2xpZW50IG9yIHNlcnZlciB2YXJpYW50cywgU1NMdjIgY2lwaGVycyB2dWxuZXJhYmxlIHRvIGV4aGF1c3RpdmUgc2VhcmNoIGtleSByZWNvdmVyeSBoYXZlIGJlZW4gcmVtb3ZlZC4gU3BlY2lmaWNhbGx5LCB0aGUgU1NMdjIgNDAtYml0IEVYUE9SVCBjaXBoZXJzLCBhbmQgU1NMdjIgNTYtYml0IERFUyBhcmUgbm8gbG9uZ2VyIGF2YWlsYWJsZS4gSW4gYWRkaXRpb24sIHdlYWsgY2lwaGVycyBpbiBTU0x2MyBhbmQgdXAgYXJlIG5vdyBkaXNhYmxlZCBpbiBkZWZhdWx0IGJ1aWxkcyBvZiBPcGVuU1NMLiBCdWlsZHMgdGhhdCBhcmUgbm90IGNvbmZpZ3VyZWQgd2l0aCAiZW5hYmxlLXdlYWstc3NsLWNpcGhlcnMiIHdpbGwgbm90IHByb3ZpZGUgYW55ICJFWFBPUlQiIG9yICJMT1ciIHN0cmVuZ3RoIGNpcGhlcnMuIFJlcG9ydGVkIGJ5IE5pbXJvZCBBdmlyYW0gYW5kIFNlYmFzdGlhbiBTY2hpbnplbC4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yZyAoQWZmZWN0ZWQgMS4wLjItMS4wLjJmKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFzIChBZmZlY3RlZCAxLjAuMS0xLjAuMXIpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNi0wNzk5PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0xvdyBzZXZlcml0eV08L2E+IDAxIE1hcmNoIDIwMTY6IDwvZHQ+PGRkPlRoZSBpbnRlcm5hbCB8Zm10c3RyfCBmdW5jdGlvbiB1c2VkIGluIHByb2Nlc3NpbmcgYSAiJXMiIGZvcm1hdCBzdHJpbmcgaW4gdGhlIEJJT18qcHJpbnRmIGZ1bmN0aW9ucyBjb3VsZCBvdmVyZmxvdyB3aGlsZSBjYWxjdWxhdGluZyB0aGUgbGVuZ3RoIG9mIGEgc3RyaW5nIGFuZCBjYXVzZSBhbiBPT0IgcmVhZCB3aGVuIHByaW50aW5nIHZlcnkgbG9uZyBzdHJpbmdzLiBBZGRpdGlvbmFsbHkgdGhlIGludGVybmFsIHxkb2Fwcl9vdXRjaHwgZnVuY3Rpb24gY2FuIGF0dGVtcHQgdG8gd3JpdGUgdG8gYW4gT09CIG1lbW9yeSBsb2NhdGlvbiAoYXQgYW4gb2Zmc2V0IGZyb20gdGhlIE5VTEwgcG9pbnRlcikgaW4gdGhlIGV2ZW50IG9mIGEgbWVtb3J5IGFsbG9jYXRpb24gZmFpbHVyZS4gSW4gMS4wLjIgYW5kIGJlbG93IHRoaXMgY291bGQgYmUgY2F1c2VkIHdoZXJlIHRoZSBzaXplIG9mIGEgYnVmZmVyIHRvIGJlIGFsbG9jYXRlZCBpcyBncmVhdGVyIHRoYW4gSU5UX01BWC4gRS5nLiB0aGlzIGNvdWxkIGJlIGluIHByb2Nlc3NpbmcgYSB2ZXJ5IGxvbmcgIiVzIiBmb3JtYXQgc3RyaW5nLiBNZW1vcnkgbGVha3MgY2FuIGFsc28gb2NjdXIuIFRoZSBmaXJzdCBpc3N1ZSBtYXkgbWFzayB0aGUgc2Vjb25kIGlzc3VlIGRlcGVuZGVudCBvbiBjb21waWxlciBiZWhhdmlvdXIuIFRoZXNlIHByb2JsZW1zIGNvdWxkIGVuYWJsZSBhdHRhY2tzIHdoZXJlIGxhcmdlIGFtb3VudHMgb2YgdW50cnVzdGVkIGRhdGEgaXMgcGFzc2VkIHRvIHRoZSBCSU9fKnByaW50ZiBmdW5jdGlvbnMuIElmIGFwcGxpY2F0aW9ucyB1c2UgdGhlc2UgZnVuY3Rpb25zIGluIHRoaXMgd2F5IHRoZW4gdGhleSBjb3VsZCBiZSB2dWxuZXJhYmxlLiBPcGVuU1NMIGl0c2VsZiB1c2VzIHRoZXNlIGZ1bmN0aW9ucyB3aGVuIHByaW50aW5nIG91dCBodW1hbi1yZWFkYWJsZSBkdW1wcyBvZiBBU04uMSBkYXRhLiBUaGVyZWZvcmUgYXBwbGljYXRpb25zIHRoYXQgcHJpbnQgdGhpcyBkYXRhIGNvdWxkIGJlIHZ1bG5lcmFibGUgaWYgdGhlIGRhdGEgaXMgZnJvbSB1bnRydXN0ZWQgc291cmNlcy4gT3BlblNTTCBjb21tYW5kIGxpbmUgYXBwbGljYXRpb25zIGNvdWxkIGFsc28gYmUgdnVsbmVyYWJsZSB3aGVyZSB0aGV5IHByaW50IG91dCBBU04uMSBkYXRhLCBvciBpZiB1bnRydXN0ZWQgZGF0YSBpcyBwYXNzZWQgYXMgY29tbWFuZCBsaW5lIGFyZ3VtZW50cy4gTGlic3NsIGlzIG5vdCBjb25zaWRlcmVkIGRpcmVjdGx5IHZ1bG5lcmFibGUuIEFkZGl0aW9uYWxseSBjZXJ0aWZpY2F0ZXMgZXRjIHJlY2VpdmVkIHZpYSByZW1vdGUgY29ubmVjdGlvbnMgdmlhIGxpYnNzbCBhcmUgYWxzbyB1bmxpa2VseSB0byBiZSBhYmxlIHRvIHRyaWdnZXIgdGhlc2UgaXNzdWVzIGJlY2F1c2Ugb2YgbWVzc2FnZSBzaXplIGxpbWl0cyBlbmZvcmNlZCB3aXRoaW4gbGlic3NsLiBSZXBvcnRlZCBieSBHdWlkbyBWcmFua2VuLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJnIChBZmZlY3RlZCAxLjAuMi0xLjAuMmYpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMXMgKEFmZmVjdGVkIDEuMC4xLTEuMC4xcik8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE2LTA3OTg8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMDEgTWFyY2ggMjAxNjogPC9kdD48ZGQ+VGhlIFNSUCB1c2VyIGRhdGFiYXNlIGxvb2t1cCBtZXRob2QgU1JQX1ZCQVNFX2dldF9ieV91c2VyIGhhZCBjb25mdXNpbmcgbWVtb3J5IG1hbmFnZW1lbnQgc2VtYW50aWNzOyB0aGUgcmV0dXJuZWQgcG9pbnRlciB3YXMgc29tZXRpbWVzIG5ld2x5IGFsbG9jYXRlZCwgYW5kIHNvbWV0aW1lcyBvd25lZCBieSB0aGUgY2FsbGVlLiBUaGUgY2FsbGluZyBjb2RlIGhhcyBubyB3YXkgb2YgZGlzdGluZ3Vpc2hpbmcgdGhlc2UgdHdvIGNhc2VzLiBTcGVjaWZpY2FsbHksIFNSUCBzZXJ2ZXJzIHRoYXQgY29uZmlndXJlIGEgc2VjcmV0IHNlZWQgdG8gaGlkZSB2YWxpZCBsb2dpbiBpbmZvcm1hdGlvbiBhcmUgdnVsbmVyYWJsZSB0byBhIG1lbW9yeSBsZWFrOiBhbiBhdHRhY2tlciBjb25uZWN0aW5nIHdpdGggYW4gaW52YWxpZCB1c2VybmFtZSBjYW4gY2F1c2UgYSBtZW1vcnkgbGVhayBvZiBhcm91bmQgMzAwIGJ5dGVzIHBlciBjb25uZWN0aW9uLiBTZXJ2ZXJzIHRoYXQgZG8gbm90IGNvbmZpZ3VyZSBTUlAsIG9yIGNvbmZpZ3VyZSBTUlAgYnV0IGRvIG5vdCBjb25maWd1cmUgYSBzZWVkIGFyZSBub3QgdnVsbmVyYWJsZS4gSW4gQXBhY2hlLCB0aGUgc2VlZCBkaXJlY3RpdmUgaXMga25vd24gYXMgU1NMU1JQVW5rbm93blVzZXJTZWVkLiBUbyBtaXRpZ2F0ZSB0aGUgbWVtb3J5IGxlYWssIHRoZSBzZWVkIGhhbmRsaW5nIGluIFNSUF9WQkFTRV9nZXRfYnlfdXNlciBpcyBub3cgZGlzYWJsZWQgZXZlbiBpZiB0aGUgdXNlciBoYXMgY29uZmlndXJlZCBhIHNlZWQuIEFwcGxpY2F0aW9ucyBhcmUgYWR2aXNlZCB0byBtaWdyYXRlIHRvIFNSUF9WQkFTRV9nZXQxX2J5X3VzZXIuIEhvd2V2ZXIsIG5vdGUgdGhhdCBPcGVuU1NMIG1ha2VzIG5vIHN0cm9uZyBndWFyYW50ZWVzIGFib3V0IHRoZSBpbmRpc3Rpbmd1aXNoYWJpbGl0eSBvZiB2YWxpZCBhbmQgaW52YWxpZCBsb2dpbnMuIEluIHBhcnRpY3VsYXIsIGNvbXB1dGF0aW9ucyBhcmUgY3VycmVudGx5IG5vdCBjYXJyaWVkIG91dCBpbiBjb25zdGFudCB0aW1lLiBSZXBvcnRlZCBieSBFbWlsaWEgS8Okc3BlciAoT3BlblNTTCkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMmcgKEFmZmVjdGVkIDEuMC4yLTEuMC4yZik8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4xcyAoQWZmZWN0ZWQgMS4wLjEtMS4wLjFyKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTYtMDc5NzwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltMb3cgc2V2ZXJpdHldPC9hPiAwMSBNYXJjaCAyMDE2OiA8L2R0PjxkZD5JbiB0aGUgQk5faGV4MmJuIGZ1bmN0aW9uIHRoZSBudW1iZXIgb2YgaGV4IGRpZ2l0cyBpcyBjYWxjdWxhdGVkIHVzaW5nIGFuIGludCB2YWx1ZSB8aXwuIExhdGVyIHxibl9leHBhbmR8IGlzIGNhbGxlZCB3aXRoIGEgdmFsdWUgb2YgfGkgKiA0fC4gRm9yIGxhcmdlIHZhbHVlcyBvZiB8aXwgdGhpcyBjYW4gcmVzdWx0IGluIHxibl9leHBhbmR8IG5vdCBhbGxvY2F0aW5nIGFueSBtZW1vcnkgYmVjYXVzZSB8aSAqIDR8IGlzIG5lZ2F0aXZlLiBUaGlzIGNhbiBsZWF2ZSB0aGUgaW50ZXJuYWwgQklHTlVNIGRhdGEgZmllbGQgYXMgTlVMTCBsZWFkaW5nIHRvIGEgc3Vic2VxdWVudCBOVUxMIHB0ciBkZXJlZi4gRm9yIHZlcnkgbGFyZ2UgdmFsdWVzIG9mIHxpfCwgdGhlIGNhbGN1bGF0aW9uIHxpICogNHwgY291bGQgYmUgYSBwb3NpdGl2ZSB2YWx1ZSBzbWFsbGVyIHRoYW4gfGl8LiBJbiB0aGlzIGNhc2UgbWVtb3J5IGlzIGFsbG9jYXRlZCB0byB0aGUgaW50ZXJuYWwgQklHTlVNIGRhdGEgZmllbGQsIGJ1dCBpdCBpcyBpbnN1ZmZpY2llbnRseSBzaXplZCBsZWFkaW5nIHRvIGhlYXAgY29ycnVwdGlvbi4gQSBzaW1pbGFyIGlzc3VlIGV4aXN0cyBpbiBCTl9kZWMyYm4uIFRoaXMgY291bGQgaGF2ZSBzZWN1cml0eSBjb25zZXF1ZW5jZXMgaWYgQk5faGV4MmJuL0JOX2RlYzJibiBpcyBldmVyIGNhbGxlZCBieSB1c2VyIGFwcGxpY2F0aW9ucyB3aXRoIHZlcnkgbGFyZ2UgdW50cnVzdGVkIGhleC9kZWMgZGF0YS4gVGhpcyBpcyBhbnRpY2lwYXRlZCB0byBiZSBhIHJhcmUgb2NjdXJyZW5jZS4gQWxsIE9wZW5TU0wgaW50ZXJuYWwgdXNhZ2Ugb2YgdGhlc2UgZnVuY3Rpb25zIHVzZSBkYXRhIHRoYXQgaXMgbm90IGV4cGVjdGVkIHRvIGJlIHVudHJ1c3RlZCwgZS5nLiBjb25maWcgZmlsZSBkYXRhIG9yIGFwcGxpY2F0aW9uIGNvbW1hbmQgbGluZSBhcmd1bWVudHMuIElmIHVzZXIgZGV2ZWxvcGVkIGFwcGxpY2F0aW9ucyBnZW5lcmF0ZSBjb25maWcgZmlsZSBkYXRhIGJhc2VkIG9uIHVudHJ1c3RlZCBkYXRhIHRoZW4gaXQgaXMgcG9zc2libGUgdGhhdCB0aGlzIGNvdWxkIGFsc28gbGVhZCB0byBzZWN1cml0eSBjb25zZXF1ZW5jZXMuIFRoaXMgaXMgYWxzbyBhbnRpY2lwYXRlZCB0byBiZSByYXJlLiBSZXBvcnRlZCBieSBHdWlkbyBWcmFua2VuLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJnIChBZmZlY3RlZCAxLjAuMi0xLjAuMmYpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMXMgKEFmZmVjdGVkIDEuMC4xLTEuMC4xcik8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE2LTA3MDU8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMDEgTWFyY2ggMjAxNjogPC9kdD48ZGQ+QSBkb3VibGUgZnJlZSBidWcgd2FzIGRpc2NvdmVyZWQgd2hlbiBPcGVuU1NMIHBhcnNlcyBtYWxmb3JtZWQgRFNBIHByaXZhdGUga2V5cyBhbmQgY291bGQgbGVhZCB0byBhIERvUyBhdHRhY2sgb3IgbWVtb3J5IGNvcnJ1cHRpb24gZm9yIGFwcGxpY2F0aW9ucyB0aGF0IHJlY2VpdmUgRFNBIHByaXZhdGUga2V5cyBmcm9tIHVudHJ1c3RlZCBzb3VyY2VzLiBUaGlzIHNjZW5hcmlvIGlzIGNvbnNpZGVyZWQgcmFyZS4gUmVwb3J0ZWQgYnkgQWRhbSBMYW5nbGV5IChHb29nbGUvQm9yaW5nU1NMKS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yZyAoQWZmZWN0ZWQgMS4wLjItMS4wLjJmKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFzIChBZmZlY3RlZCAxLjAuMS0xLjAuMXIpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNi0wNzA0PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W01vZGVyYXRlIHNldmVyaXR5XTwvYT4gMDEgTWFyY2ggMjAxNjogPC9kdD48ZGQ+VGhpcyBpc3N1ZSBvbmx5IGFmZmVjdGVkIHZlcnNpb25zIG9mIE9wZW5TU0wgcHJpb3IgdG8gTWFyY2ggMTl0aCAyMDE1IGF0IHdoaWNoIHRpbWUgdGhlIGNvZGUgd2FzIHJlZmFjdG9yZWQgdG8gYWRkcmVzcyB0aGUgdnVsbmVyYWJpbGl0eSBDVkUtMjAxNS0wMjkzLiBzMl9zcnZyLmMgb3ZlcndyaXRlIHRoZSB3cm9uZyBieXRlcyBpbiB0aGUgbWFzdGVyLWtleSB3aGVuIGFwcGx5aW5nIEJsZWljaGVuYmFjaGVyIHByb3RlY3Rpb24gZm9yIGV4cG9ydCBjaXBoZXIgc3VpdGVzLiBUaGlzIHByb3ZpZGVzIGEgQmxlaWNoZW5iYWNoZXIgb3JhY2xlLCBhbmQgY291bGQgcG90ZW50aWFsbHkgYWxsb3cgbW9yZSBlZmZpY2llbnQgdmFyaWFudHMgb2YgdGhlIERST1dOIGF0dGFjay4gUmVwb3J0ZWQgYnkgRGF2aWQgQWRyaWFuIGFuZCBKLkFsZXggSGFsZGVybWFuIChVbml2ZXJzaXR5IG9mIE1pY2hpZ2FuKS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yYSAoQWZmZWN0ZWQgMS4wLjIpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMW0gKEFmZmVjdGVkIDEuMC4xLTEuMC4xbCk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wciAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBxKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45Ljh6ZiAoQWZmZWN0ZWQgMC45LjgtMC45Ljh6ZSk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE2LTA3MDM8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bSGlnaCBzZXZlcml0eV08L2E+IDAxIE1hcmNoIDIwMTY6IDwvZHQ+PGRkPlRoaXMgaXNzdWUgb25seSBhZmZlY3RlZCB2ZXJzaW9ucyBvZiBPcGVuU1NMIHByaW9yIHRvIE1hcmNoIDE5dGggMjAxNSBhdCB3aGljaCB0aW1lIHRoZSBjb2RlIHdhcyByZWZhY3RvcmVkIHRvIGFkZHJlc3MgdnVsbmVyYWJpbGl0eSBDVkUtMjAxNS0wMjkzLiBzMl9zcnZyLmMgZGlkIG5vdCBlbmZvcmNlIHRoYXQgY2xlYXIta2V5LWxlbmd0aCBpcyAwIGZvciBub24tZXhwb3J0IGNpcGhlcnMuIElmIGNsZWFyLWtleSBieXRlcyBhcmUgcHJlc2VudCBmb3IgdGhlc2UgY2lwaGVycywgdGhleSAqZGlzcGxhY2UqIGVuY3J5cHRlZC1rZXkgYnl0ZXMuIFRoaXMgbGVhZHMgdG8gYW4gZWZmaWNpZW50IGRpdmlkZS1hbmQtY29ucXVlciBrZXkgcmVjb3ZlcnkgYXR0YWNrOiBpZiBhbiBlYXZlc2Ryb3BwZXIgaGFzIGludGVyY2VwdGVkIGFuIFNTTHYyIGhhbmRzaGFrZSwgdGhleSBjYW4gdXNlIHRoZSBzZXJ2ZXIgYXMgYW4gb3JhY2xlIHRvIGRldGVybWluZSB0aGUgU1NMdjIgbWFzdGVyLWtleSwgdXNpbmcgb25seSAxNiBjb25uZWN0aW9ucyB0byB0aGUgc2VydmVyIGFuZCBuZWdsaWdpYmxlIGNvbXB1dGF0aW9uLiBNb3JlIGltcG9ydGFudGx5LCB0aGlzIGxlYWRzIHRvIGEgbW9yZSBlZmZpY2llbnQgdmVyc2lvbiBvZiBEUk9XTiB0aGF0IGlzIGVmZmVjdGl2ZSBhZ2FpbnN0IG5vbi1leHBvcnQgY2lwaGVyc3VpdGVzLCBhbmQgcmVxdWlyZXMgbm8gc2lnbmlmaWNhbnQgY29tcHV0YXRpb24uIFJlcG9ydGVkIGJ5IERhdmlkIEFkcmlhbiBhbmQgSi5BbGV4IEhhbGRlcm1hbiAoVW5pdmVyc2l0eSBvZiBNaWNoaWdhbikuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMmEgKEFmZmVjdGVkIDEuMC4yKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFtIChBZmZlY3RlZCAxLjAuMS0xLjAuMWwpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMHIgKEFmZmVjdGVkIDEuMC4wLTEuMC4wcSk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44emYgKEFmZmVjdGVkIDAuOS44LTAuOS44emUpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNi0wNzAyPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0xvdyBzZXZlcml0eV08L2E+IDAxIE1hcmNoIDIwMTY6IDwvZHQ+PGRkPkEgc2lkZS1jaGFubmVsIGF0dGFjayB3YXMgZm91bmQgd2hpY2ggbWFrZXMgdXNlIG9mIGNhY2hlLWJhbmsgY29uZmxpY3RzIG9uIHRoZSBJbnRlbCBTYW5keS1CcmlkZ2UgbWljcm9hcmNoaXRlY3R1cmUgd2hpY2ggY291bGQgbGVhZCB0byB0aGUgcmVjb3Zlcnkgb2YgUlNBIGtleXMuIFRoZSBhYmlsaXR5IHRvIGV4cGxvaXQgdGhpcyBpc3N1ZSBpcyBsaW1pdGVkIGFzIGl0IHJlbGllcyBvbiBhbiBhdHRhY2tlciB3aG8gaGFzIGNvbnRyb2wgb2YgY29kZSBpbiBhIHRocmVhZCBydW5uaW5nIG9uIHRoZSBzYW1lIGh5cGVyLXRocmVhZGVkIGNvcmUgYXMgdGhlIHZpY3RpbSB0aHJlYWQgd2hpY2ggaXMgcGVyZm9ybWluZyBkZWNyeXB0aW9ucy4gUmVwb3J0ZWQgYnkgWXV2YWwgWWFyb20sIFRoZSBVbml2ZXJzaXR5IG9mIEFkZWxhaWRlIGFuZCBOSUNUQSwgRGFuaWVsIEdlbmtpbiwgVGVjaG5pb24gYW5kIFRlbCBBdml2IFVuaXZlcnNpdHksIGFuZCBOYWRpYSBIZW5pbmdlciwgVW5pdmVyc2l0eSBvZiBQZW5uc3lsdmFuaWEuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMmcgKEFmZmVjdGVkIDEuMC4yLTEuMC4yZik8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4xcyAoQWZmZWN0ZWQgMS4wLjEtMS4wLjFyKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTYtMDcwMTwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltIaWdoIHNldmVyaXR5XTwvYT4gMjggSmFudWFyeSAyMDE2OiA8L2R0PjxkZD5IaXN0b3JpY2FsbHkgT3BlblNTTCB1c3VhbGx5IG9ubHkgZXZlciBnZW5lcmF0ZWQgREggcGFyYW1ldGVycyBiYXNlZCBvbiAic2FmZSIgcHJpbWVzLiBNb3JlIHJlY2VudGx5IChpbiB2ZXJzaW9uIDEuMC4yKSBzdXBwb3J0IHdhcyBwcm92aWRlZCBmb3IgZ2VuZXJhdGluZyBYOS40MiBzdHlsZSBwYXJhbWV0ZXIgZmlsZXMgc3VjaCBhcyB0aG9zZSByZXF1aXJlZCBmb3IgUkZDIDUxMTQgc3VwcG9ydC4gVGhlIHByaW1lcyB1c2VkIGluIHN1Y2ggZmlsZXMgbWF5IG5vdCBiZSAic2FmZSIuIFdoZXJlIGFuIGFwcGxpY2F0aW9uIGlzIHVzaW5nIERIIGNvbmZpZ3VyZWQgd2l0aCBwYXJhbWV0ZXJzIGJhc2VkIG9uIHByaW1lcyB0aGF0IGFyZSBub3QgInNhZmUiIHRoZW4gYW4gYXR0YWNrZXIgY291bGQgdXNlIHRoaXMgZmFjdCB0byBmaW5kIGEgcGVlcidzIHByaXZhdGUgREggZXhwb25lbnQuIFRoaXMgYXR0YWNrIHJlcXVpcmVzIHRoYXQgdGhlIGF0dGFja2VyIGNvbXBsZXRlIG11bHRpcGxlIGhhbmRzaGFrZXMgaW4gd2hpY2ggdGhlIHBlZXIgdXNlcyB0aGUgc2FtZSBwcml2YXRlIERIIGV4cG9uZW50LiBGb3IgZXhhbXBsZSB0aGlzIGNvdWxkIGJlIHVzZWQgdG8gZGlzY292ZXIgYSBUTFMgc2VydmVyJ3MgcHJpdmF0ZSBESCBleHBvbmVudCBpZiBpdCdzIHJldXNpbmcgdGhlIHByaXZhdGUgREggZXhwb25lbnQgb3IgaXQncyB1c2luZyBhIHN0YXRpYyBESCBjaXBoZXJzdWl0ZS4gT3BlblNTTCBwcm92aWRlcyB0aGUgb3B0aW9uIFNTTF9PUF9TSU5HTEVfREhfVVNFIGZvciBlcGhlbWVyYWwgREggKERIRSkgaW4gVExTLiBJdCBpcyBub3Qgb24gYnkgZGVmYXVsdC4gSWYgdGhlIG9wdGlvbiBpcyBub3Qgc2V0IHRoZW4gdGhlIHNlcnZlciByZXVzZXMgdGhlIHNhbWUgcHJpdmF0ZSBESCBleHBvbmVudCBmb3IgdGhlIGxpZmUgb2YgdGhlIHNlcnZlciBwcm9jZXNzIGFuZCB3b3VsZCBiZSB2dWxuZXJhYmxlIHRvIHRoaXMgYXR0YWNrLiBJdCBpcyBiZWxpZXZlZCB0aGF0IG1hbnkgcG9wdWxhciBhcHBsaWNhdGlvbnMgZG8gc2V0IHRoaXMgb3B0aW9uIGFuZCB3b3VsZCB0aGVyZWZvcmUgbm90IGJlIGF0IHJpc2suIE9wZW5TU0wgYmVmb3JlIDEuMC4yZiB3aWxsIHJldXNlIHRoZSBrZXkgaWY6IC0gU1NMX0NUWF9zZXRfdG1wX2RoKCkvU1NMX3NldF90bXBfZGgoKSBpcyB1c2VkIGFuZCBTU0xfT1BfU0lOR0xFX0RIX1VTRSBpcyBub3Qgc2V0LiAtIFNTTF9DVFhfc2V0X3RtcF9kaF9jYWxsYmFjaygpL1NTTF9zZXRfdG1wX2RoX2NhbGxiYWNrKCkgaXMgdXNlZCwgYW5kIGJvdGggdGhlIHBhcmFtZXRlcnMgYW5kIHRoZSBrZXkgYXJlIHNldCBhbmQgU1NMX09QX1NJTkdMRV9ESF9VU0UgaXMgbm90IHVzZWQuIFRoaXMgaXMgYW4gdW5kb2N1bXRlZCBmZWF0dXJlIGFuZCBwYXJhbWV0ZXIgZmlsZXMgZG9uJ3QgY29udGFpbiB0aGUga2V5LiAtIFN0YXRpYyBESCBjaXBoZXJzdWl0ZXMgYXJlIHVzZWQuIFRoZSBrZXkgaXMgcGFydCBvZiB0aGUgY2VydGlmaWNhdGUgYW5kIHNvIGl0IHdpbGwgYWx3YXlzIHJldXNlIGl0LiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGluIDEuMC4yLiBJdCB3aWxsIG5vdCByZXVzZSB0aGUga2V5IGZvciBESEUgY2lwaGVycyBzdWl0ZXMgaWY6IC0gU1NMX09QX1NJTkdMRV9ESF9VU0UgaXMgc2V0IC0gU1NMX0NUWF9zZXRfdG1wX2RoX2NhbGxiYWNrKCkvU1NMX3NldF90bXBfZGhfY2FsbGJhY2soKSBpcyB1c2VkIGFuZCB0aGUgY2FsbGJhY2sgZG9lcyBub3QgcHJvdmlkZSB0aGUga2V5LCBvbmx5IHRoZSBwYXJhbWV0ZXJzLiBUaGUgY2FsbGJhY2sgaXMgYWxtb3N0IGFsd2F5cyB1c2VkIGxpa2UgdGhpcy4gTm9uLXNhZmUgcHJpbWVzIGFyZSBnZW5lcmF0ZWQgYnkgT3BlblNTTCB3aGVuIHVzaW5nOiAtIGdlbnBrZXkgd2l0aCB0aGUgZGhfcmZjNTExNCBvcHRpb24uIFRoaXMgd2lsbCB3cml0ZSBhbiBYOS40MiBzdHlsZSBmaWxlIGluY2x1ZGluZyB0aGUgcHJpbWUtb3JkZXIgc3ViZ3JvdXAgc2l6ZSAicSIuIFRoaXMgaXMgc3VwcG9ydGVkIHNpbmNlIHRoZSAxLjAuMiB2ZXJzaW9uLiBPbGRlciB2ZXJzaW9ucyBjYW4ndCByZWFkIGZpbGVzIGdlbmVyYXRlZCBpbiB0aGlzIHdheS4gLSBkaHBhcmFtIHdpdGggdGhlIC1kc2FwYXJhbSBvcHRpb24uIFRoaXMgaGFzIGFsd2F5cyBiZWVuIGRvY3VtZW50ZWQgYXMgcmVxdWlyaW5nIHRoZSBzaW5nbGUgdXNlLiBUaGUgZml4IGZvciB0aGlzIGlzc3VlIGFkZHMgYW4gYWRkaXRpb25hbCBjaGVjayB3aGVyZSBhICJxIiBwYXJhbWV0ZXIgaXMgYXZhaWxhYmxlIChhcyBpcyB0aGUgY2FzZSBpbiBYOS40MiBiYXNlZCBwYXJhbWV0ZXJzKS4gVGhpcyBkZXRlY3RzIHRoZSBvbmx5IGtub3duIGF0dGFjaywgYW5kIGlzIHRoZSBvbmx5IHBvc3NpYmxlIGRlZmVuc2UgZm9yIHN0YXRpYyBESCBjaXBoZXJzdWl0ZXMuIFRoaXMgY291bGQgaGF2ZSBzb21lIHBlcmZvcm1hbmNlIGltcGFjdC4gQWRkaXRpb25hbGx5IHRoZSBTU0xfT1BfU0lOR0xFX0RIX1VTRSBvcHRpb24gaGFzIGJlZW4gc3dpdGNoZWQgb24gYnkgZGVmYXVsdCBhbmQgY2Fubm90IGJlIGRpc2FibGVkLiBUaGlzIGNvdWxkIGhhdmUgc29tZSBwZXJmb3JtYW5jZSBpbXBhY3QuIFJlcG9ydGVkIGJ5IEFudG9uaW8gU2Fuc28gKEFkb2JlKS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yZiAoQWZmZWN0ZWQgMS4wLjItMS4wLjJlKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTUtMzE5NzwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltMb3cgc2V2ZXJpdHldPC9hPiAyOCBKYW51YXJ5IDIwMTY6IDwvZHQ+PGRkPkEgbWFsaWNpb3VzIGNsaWVudCBjYW4gbmVnb3RpYXRlIFNTTHYyIGNpcGhlcnMgdGhhdCBoYXZlIGJlZW4gZGlzYWJsZWQgb24gdGhlIHNlcnZlciBhbmQgY29tcGxldGUgU1NMdjIgaGFuZHNoYWtlcyBldmVuIGlmIGFsbCBTU0x2MiBjaXBoZXJzIGhhdmUgYmVlbiBkaXNhYmxlZCwgcHJvdmlkZWQgdGhhdCB0aGUgU1NMdjIgcHJvdG9jb2wgd2FzIG5vdCBhbHNvIGRpc2FibGVkIHZpYSBTU0xfT1BfTk9fU1NMdjIuIFJlcG9ydGVkIGJ5IE5pbXJvZCBBdmlyYW0gYW5kIFNlYmFzdGlhbiBTY2hpbnplbC4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yZiAoQWZmZWN0ZWQgMS4wLjItMS4wLjJlKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFyIChBZmZlY3RlZCAxLjAuMS0xLjAuMXEpPC9saT48L3VsPjwvZGQ+PC9kbD48aDM+PGEgPjIwMTU8L2E+PC9oMz48ZGw+PGR0PjxhID5DVkUtMjAxNS0zMTk2PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0xvdyBzZXZlcml0eV08L2E+IDAzIERlY2VtYmVyIDIwMTU6IDwvZHQ+PGRkPklmIFBTSyBpZGVudGl0eSBoaW50cyBhcmUgcmVjZWl2ZWQgYnkgYSBtdWx0aS10aHJlYWRlZCBjbGllbnQgdGhlbiB0aGUgdmFsdWVzIGFyZSB3cm9uZ2x5IHVwZGF0ZWQgaW4gdGhlIHBhcmVudCBTU0xfQ1RYIHN0cnVjdHVyZS4gVGhpcyBjYW4gcmVzdWx0IGluIGEgcmFjZSBjb25kaXRpb24gcG90ZW50aWFsbHkgbGVhZGluZyB0byBhIGRvdWJsZSBmcmVlIG9mIHRoZSBpZGVudGlmeSBoaW50IGRhdGEuIFJlcG9ydGVkIGJ5IFN0ZXBoZW4gSGVuc29uIChPcGVuU1NMKS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yZCAoQWZmZWN0ZWQgMS4wLjItMS4wLjJjKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFwIChBZmZlY3RlZCAxLjAuMS0xLjAuMW8pPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMHQgKEFmZmVjdGVkIDEuMC4wLTEuMC4wZywxLjAuMGgtMS4wLjBzKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTUtMzE5NTwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltNb2RlcmF0ZSBzZXZlcml0eV08L2E+IDAzIERlY2VtYmVyIDIwMTU6IDwvZHQ+PGRkPldoZW4gcHJlc2VudGVkIHdpdGggYSBtYWxmb3JtZWQgWDUwOV9BVFRSSUJVVEUgc3RydWN0dXJlIE9wZW5TU0wgd2lsbCBsZWFrIG1lbW9yeS4gVGhpcyBzdHJ1Y3R1cmUgaXMgdXNlZCBieSB0aGUgUEtDUyM3IGFuZCBDTVMgcm91dGluZXMgc28gYW55IGFwcGxpY2F0aW9uIHdoaWNoIHJlYWRzIFBLQ1MjNyBvciBDTVMgZGF0YSBmcm9tIHVudHJ1c3RlZCBzb3VyY2VzIGlzIGFmZmVjdGVkLiBTU0wvVExTIGlzIG5vdCBhZmZlY3RlZC4gUmVwb3J0ZWQgYnkgQWRhbSBMYW5nbGV5IChHb29nbGUvQm9yaW5nU1NMKSB1c2luZyBsaWJGdXp6ZXIuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMmUgKEFmZmVjdGVkIDEuMC4yLTEuMC4yZCk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4xcSAoQWZmZWN0ZWQgMS4wLjEtMS4wLjFwKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjB0IChBZmZlY3RlZCAxLjAuMC0xLjAuMGcsMS4wLjBoLTEuMC4wcyk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44emggKEFmZmVjdGVkIDAuOS44LTAuOS44emcpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNS0zMTk0PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W01vZGVyYXRlIHNldmVyaXR5XTwvYT4gMDMgRGVjZW1iZXIgMjAxNTogPC9kdD48ZGQ+VGhlIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gcm91dGluZXMgd2lsbCBjcmFzaCB3aXRoIGEgTlVMTCBwb2ludGVyIGRlcmVmZXJlbmNlIGlmIHByZXNlbnRlZCB3aXRoIGFuIEFTTi4xIHNpZ25hdHVyZSB1c2luZyB0aGUgUlNBIFBTUyBhbGdvcml0aG0gYW5kIGFic2VudCBtYXNrIGdlbmVyYXRpb24gZnVuY3Rpb24gcGFyYW1ldGVyLiBTaW5jZSB0aGVzZSByb3V0aW5lcyBhcmUgdXNlZCB0byB2ZXJpZnkgY2VydGlmaWNhdGUgc2lnbmF0dXJlIGFsZ29yaXRobXMgdGhpcyBjYW4gYmUgdXNlZCB0byBjcmFzaCBhbnkgY2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uIG9wZXJhdGlvbiBhbmQgZXhwbG9pdGVkIGluIGEgRG9TIGF0dGFjay4gQW55IGFwcGxpY2F0aW9uIHdoaWNoIHBlcmZvcm1zIGNlcnRpZmljYXRlIHZlcmlmaWNhdGlvbiBpcyB2dWxuZXJhYmxlIGluY2x1ZGluZyBPcGVuU1NMIGNsaWVudHMgYW5kIHNlcnZlcnMgd2hpY2ggZW5hYmxlIGNsaWVudCBhdXRoZW50aWNhdGlvbi4gUmVwb3J0ZWQgYnkgTG/Dr2MgSm9uYXMgRXRpZW5uZSAoUW5lY3RpdmUgQUcpLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJlIChBZmZlY3RlZCAxLjAuMi0xLjAuMmQpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMXEgKEFmZmVjdGVkIDEuMC4xLTEuMC4xcCk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE1LTMxOTM8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTW9kZXJhdGUgc2V2ZXJpdHldPC9hPiAwMyBEZWNlbWJlciAyMDE1OiA8L2R0PjxkZD5UaGVyZSBpcyBhIGNhcnJ5IHByb3BhZ2F0aW5nIGJ1ZyBpbiB0aGUgeDg2XzY0IE1vbnRnb21lcnkgc3F1YXJpbmcgcHJvY2VkdXJlLiBObyBFQyBhbGdvcml0aG1zIGFyZSBhZmZlY3RlZC4gQW5hbHlzaXMgc3VnZ2VzdHMgdGhhdCBhdHRhY2tzIGFnYWluc3QgUlNBIGFuZCBEU0EgYXMgYSByZXN1bHQgb2YgdGhpcyBkZWZlY3Qgd291bGQgYmUgdmVyeSBkaWZmaWN1bHQgdG8gcGVyZm9ybSBhbmQgYXJlIG5vdCBiZWxpZXZlZCBsaWtlbHkuIEF0dGFja3MgYWdhaW5zdCBESCBhcmUgY29uc2lkZXJlZCBqdXN0IGZlYXNpYmxlIChhbHRob3VnaCB2ZXJ5IGRpZmZpY3VsdCkgYmVjYXVzZSBtb3N0IG9mIHRoZSB3b3JrIG5lY2Vzc2FyeSB0byBkZWR1Y2UgaW5mb3JtYXRpb24gYWJvdXQgYSBwcml2YXRlIGtleSBtYXkgYmUgcGVyZm9ybWVkIG9mZmxpbmUuIFRoZSBhbW91bnQgb2YgcmVzb3VyY2VzIHJlcXVpcmVkIGZvciBzdWNoIGFuIGF0dGFjayB3b3VsZCBiZSB2ZXJ5IHNpZ25pZmljYW50IGFuZCBsaWtlbHkgb25seSBhY2Nlc3NpYmxlIHRvIGEgbGltaXRlZCBudW1iZXIgb2YgYXR0YWNrZXJzLiBBbiBhdHRhY2tlciB3b3VsZCBhZGRpdGlvbmFsbHkgbmVlZCBvbmxpbmUgYWNjZXNzIHRvIGFuIHVucGF0Y2hlZCBzeXN0ZW0gdXNpbmcgdGhlIHRhcmdldCBwcml2YXRlIGtleSBpbiBhIHNjZW5hcmlvIHdpdGggcGVyc2lzdGVudCBESCBwYXJhbWV0ZXJzIGFuZCBhIHByaXZhdGUga2V5IHRoYXQgaXMgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgY2xpZW50cy4gRm9yIGV4YW1wbGUgdGhpcyBjYW4gb2NjdXIgYnkgZGVmYXVsdCBpbiBPcGVuU1NMIERIRSBiYXNlZCBTU0wvVExTIGNpcGhlcnN1aXRlcy4gUmVwb3J0ZWQgYnkgSGFubm8gQsO2Y2suIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMmUgKEFmZmVjdGVkIDEuMC4yLTEuMC4yZCk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE1LTE3OTQ8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMTEgQXVndXN0IDIwMTU6IDwvZHQ+PGRkPklmIGEgY2xpZW50IHJlY2VpdmVzIGEgU2VydmVyS2V5RXhjaGFuZ2UgZm9yIGFuIGFub255bW91cyBESCBjaXBoZXJzdWl0ZSB3aXRoIHRoZSB2YWx1ZSBvZiBwIHNldCB0byAwIHRoZW4gYSBzZWcgZmF1bHQgY2FuIG9jY3VyIGxlYWRpbmcgdG8gYSBwb3NzaWJsZSBkZW5pYWwgb2Ygc2VydmljZSBhdHRhY2suIFJlcG9ydGVkIGJ5IEd1eSBMZWF2ZXIgKENpc2NvKS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yZSAoQWZmZWN0ZWQgMS4wLjItMS4wLjJkKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTUtMTc5MzwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltIaWdoIHNldmVyaXR5XTwvYT4gMDkgSnVseSAyMDE1OiA8L2R0PjxkZD5BbiBlcnJvciBpbiB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIGFsdGVybmF0aXZlIGNlcnRpZmljYXRlIGNoYWluIGxvZ2ljIGNvdWxkIGFsbG93IGFuIGF0dGFja2VyIHRvIGNhdXNlIGNlcnRhaW4gY2hlY2tzIG9uIHVudHJ1c3RlZCBjZXJ0aWZpY2F0ZXMgdG8gYmUgYnlwYXNzZWQsIHN1Y2ggYXMgdGhlIENBIGZsYWcsIGVuYWJsaW5nIHRoZW0gdG8gdXNlIGEgdmFsaWQgbGVhZiBjZXJ0aWZpY2F0ZSB0byBhY3QgYXMgYSBDQSBhbmQgImlzc3VlIiBhbiBpbnZhbGlkIGNlcnRpZmljYXRlLiBSZXBvcnRlZCBieSBBZGFtIExhbmdsZXkgYW5kIERhdmlkIEJlbmphbWluIChHb29nbGUvQm9yaW5nU1NMKS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yZCAoQWZmZWN0ZWQgMS4wLjJiLTEuMC4yYyk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4xcCAoQWZmZWN0ZWQgMS4wLjFuLTEuMC4xbyk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE1LTE3OTI8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTW9kZXJhdGUgc2V2ZXJpdHldPC9hPiAxMSBKdW5lIDIwMTU6IDwvZHQ+PGRkPldoZW4gdmVyaWZ5aW5nIGEgc2lnbmVkRGF0YSBtZXNzYWdlIHRoZSBDTVMgY29kZSBjYW4gZW50ZXIgYW4gaW5maW5pdGUgbG9vcCBpZiBwcmVzZW50ZWQgd2l0aCBhbiB1bmtub3duIGhhc2ggZnVuY3Rpb24gT0lELiBUaGlzIGNhbiBiZSB1c2VkIHRvIHBlcmZvcm0gZGVuaWFsIG9mIHNlcnZpY2UgYWdhaW5zdCBhbnkgc3lzdGVtIHdoaWNoIHZlcmlmaWVzIHNpZ25lZERhdGEgbWVzc2FnZXMgdXNpbmcgdGhlIENNUyBjb2RlLiBSZXBvcnRlZCBieSBKb2hhbm5lcyBCYXVlci4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yYiAoQWZmZWN0ZWQgMS4wLjItMS4wLjJhKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFuIChBZmZlY3RlZCAxLjAuMS0xLjAuMW0pPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMHMgKEFmZmVjdGVkIDEuMC4wLTEuMC4wcik8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44emcgKEFmZmVjdGVkIDAuOS44LTAuOS44emYpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNS0xNzkwPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W01vZGVyYXRlIHNldmVyaXR5XTwvYT4gMTEgSnVuZSAyMDE1OiA8L2R0PjxkZD5UaGUgUEtDUyM3IHBhcnNpbmcgY29kZSBkb2VzIG5vdCBoYW5kbGUgbWlzc2luZyBpbm5lciBFbmNyeXB0ZWRDb250ZW50IGNvcnJlY3RseS4gQW4gYXR0YWNrZXIgY2FuIGNyYWZ0IG1hbGZvcm1lZCBBU04uMS1lbmNvZGVkIFBLQ1MjNyBibG9icyB3aXRoIG1pc3NpbmcgY29udGVudCBhbmQgdHJpZ2dlciBhIE5VTEwgcG9pbnRlciBkZXJlZmVyZW5jZSBvbiBwYXJzaW5nLiBBcHBsaWNhdGlvbnMgdGhhdCBkZWNyeXB0IFBLQ1MjNyBkYXRhIG9yIG90aGVyd2lzZSBwYXJzZSBQS0NTIzcgc3RydWN0dXJlcyBmcm9tIHVudHJ1c3RlZCBzb3VyY2VzIGFyZSBhZmZlY3RlZC4gT3BlblNTTCBjbGllbnRzIGFuZCBzZXJ2ZXJzIGFyZSBub3QgYWZmZWN0ZWQuIFJlcG9ydGVkIGJ5IE1pY2hhbCBaYWxld3NraSAoR29vZ2xlKS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yYiAoQWZmZWN0ZWQgMS4wLjItMS4wLjJhKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFuIChBZmZlY3RlZCAxLjAuMS0xLjAuMW0pPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMHMgKEFmZmVjdGVkIDEuMC4wLTEuMC4wcik8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44emcgKEFmZmVjdGVkIDAuOS44LTAuOS44emYpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNS0xNzg5PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W01vZGVyYXRlIHNldmVyaXR5XTwvYT4gMTEgSnVuZSAyMDE1OiA8L2R0PjxkZD5YNTA5X2NtcF90aW1lIGRvZXMgbm90IHByb3Blcmx5IGNoZWNrIHRoZSBsZW5ndGggb2YgdGhlIEFTTjFfVElNRSBzdHJpbmcgYW5kIGNhbiByZWFkIGEgZmV3IGJ5dGVzIG91dCBvZiBib3VuZHMuIEluIGFkZGl0aW9uLCBYNTA5X2NtcF90aW1lIGFjY2VwdHMgYW4gYXJiaXRyYXJ5IG51bWJlciBvZiBmcmFjdGlvbmFsIHNlY29uZHMgaW4gdGhlIHRpbWUgc3RyaW5nLiBBbiBhdHRhY2tlciBjYW4gdXNlIHRoaXMgdG8gY3JhZnQgbWFsZm9ybWVkIGNlcnRpZmljYXRlcyBhbmQgQ1JMcyBvZiB2YXJpb3VzIHNpemVzIGFuZCBwb3RlbnRpYWxseSBjYXVzZSBhIHNlZ21lbnRhdGlvbiBmYXVsdCwgcmVzdWx0aW5nIGluIGEgRG9TIG9uIGFwcGxpY2F0aW9ucyB0aGF0IHZlcmlmeSBjZXJ0aWZpY2F0ZXMgb3IgQ1JMcy4gVExTIGNsaWVudHMgdGhhdCB2ZXJpZnkgQ1JMcyBhcmUgYWZmZWN0ZWQuIFRMUyBjbGllbnRzIGFuZCBzZXJ2ZXJzIHdpdGggY2xpZW50IGF1dGhlbnRpY2F0aW9uIGVuYWJsZWQgbWF5IGJlIGFmZmVjdGVkIGlmIHRoZXkgdXNlIGN1c3RvbSB2ZXJpZmljYXRpb24gY2FsbGJhY2tzLiBSZXBvcnRlZCBieSBSb2JlcnQgxZp3acSZY2tpIChHb29nbGUgU2VjdXJpdHkgVGVhbSkuIFJlcG9ydGVkIGJ5IEhhbm5vIELDtmNrLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJiIChBZmZlY3RlZCAxLjAuMi0xLjAuMmEpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMW4gKEFmZmVjdGVkIDEuMC4xLTEuMC4xbSk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wcyAoQWZmZWN0ZWQgMS4wLjAtMS4wLjByKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45Ljh6ZyAoQWZmZWN0ZWQgMC45LjgtMC45Ljh6Zik8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE1LTE3ODg8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTW9kZXJhdGUgc2V2ZXJpdHldPC9hPiAxMSBKdW5lIDIwMTU6IDwvZHQ+PGRkPldoZW4gcHJvY2Vzc2luZyBhbiBFQ1BhcmFtZXRlcnMgc3RydWN0dXJlIE9wZW5TU0wgZW50ZXJzIGFuIGluZmluaXRlIGxvb3AgaWYgdGhlIGN1cnZlIHNwZWNpZmllZCBpcyBvdmVyIGEgc3BlY2lhbGx5IG1hbGZvcm1lZCBiaW5hcnkgcG9seW5vbWlhbCBmaWVsZC4gVGhpcyBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIGRlbmlhbCBvZiBzZXJ2aWNlIGFnYWluc3QgYW55IHN5c3RlbSB3aGljaCBwcm9jZXNzZXMgcHVibGljIGtleXMsIGNlcnRpZmljYXRlIHJlcXVlc3RzIG9yIGNlcnRpZmljYXRlcy4gVGhpcyBpbmNsdWRlcyBUTFMgY2xpZW50cyBhbmQgVExTIHNlcnZlcnMgd2l0aCBjbGllbnQgYXV0aGVudGljYXRpb24gZW5hYmxlZC4gUmVwb3J0ZWQgYnkgSm9zZXBoIEJpcnItUGl4dG9uLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJiIChBZmZlY3RlZCAxLjAuMi0xLjAuMmEpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMW4gKEFmZmVjdGVkIDEuMC4xLTEuMC4xbSk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wZSAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBkKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45LjhzIChBZmZlY3RlZCAwLjkuOC0wLjkuOHIpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNC04MTc2PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W01vZGVyYXRlIHNldmVyaXR5XTwvYT4gMTEgSnVuZSAyMDE1OiA8L2R0PjxkZD5UaGlzIHZ1bG5lcmFiaWxpdHkgZG9lcyBub3QgYWZmZWN0IGN1cnJlbnQgdmVyc2lvbnMgb2YgT3BlblNTTC4gSXQgZXhpc3RlZCBpbiBwcmV2aW91cyBPcGVuU1NMIHZlcnNpb25zIGFuZCB3YXMgZml4ZWQgaW4gSnVuZSAyMDE0LiBJZiBhIERUTFMgcGVlciByZWNlaXZlcyBhcHBsaWNhdGlvbiBkYXRhIGJldHdlZW4gdGhlIENoYW5nZUNpcGhlclNwZWMgYW5kIEZpbmlzaGVkIG1lc3NhZ2VzLCBidWZmZXJpbmcgb2Ygc3VjaCBkYXRhIG1heSBjYXVzZSBhbiBpbnZhbGlkIGZyZWUsIHJlc3VsdGluZyBpbiBhIHNlZ21lbnRhdGlvbiBmYXVsdCBvciBwb3RlbnRpYWxseSwgbWVtb3J5IGNvcnJ1cHRpb24uIFJlcG9ydGVkIGJ5IFByYXZlZW4gS2FyaXlhbmFoYWxsaSwgYW5kIHN1YnNlcXVlbnRseSBieSBJdmFuIEZyYXRyaWMgYW5kIEZlbGl4IEdyb2ViZXJ0IChHb29nbGUpLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFoIChBZmZlY3RlZCAxLjAuMS0xLjAuMWcpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMG0gKEFmZmVjdGVkIDEuMC4wLTEuMC4wbCk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44emEgKEFmZmVjdGVkIDAuOS44LTAuOS44eSk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE1LTE3OTE8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMDIgSnVuZSAyMDE1OiA8L2R0PjxkZD5JZiBhIE5ld1Nlc3Npb25UaWNrZXQgaXMgcmVjZWl2ZWQgYnkgYSBtdWx0aS10aHJlYWRlZCBjbGllbnQgd2hlbiBhdHRlbXB0aW5nIHRvIHJldXNlIGEgcHJldmlvdXMgdGlja2V0IHRoZW4gYSByYWNlIGNvbmRpdGlvbiBjYW4gb2NjdXIgcG90ZW50aWFsbHkgbGVhZGluZyB0byBhIGRvdWJsZSBmcmVlIG9mIHRoZSB0aWNrZXQgZGF0YS4gUmVwb3J0ZWQgYnkgRW1pbGlhIEvDpHNwZXIgKE9wZW5TU0wpLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJiIChBZmZlY3RlZCAxLjAuMi0xLjAuMmEpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMW4gKEFmZmVjdGVkIDEuMC4xLTEuMC4xbSk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wcyAoQWZmZWN0ZWQgMS4wLjAtMS4wLjByKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45Ljh6ZyAoQWZmZWN0ZWQgMC45LjgtMC45Ljh6Zik8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE1LTE3ODc8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTW9kZXJhdGUgc2V2ZXJpdHldPC9hPiAxOSBNYXJjaCAyMDE1OiA8L2R0PjxkZD5FbXB0eSBDS0Ugd2l0aCBjbGllbnQgYXV0aCBhbmQgREhFLiBJZiBjbGllbnQgYXV0aCBpcyB1c2VkIHRoZW4gYSBzZXJ2ZXIgY2FuIHNlZyBmYXVsdCBpbiB0aGUgZXZlbnQgb2YgYSBESEUgY2lwaGVyc3VpdGUgYmVpbmcgc2VsZWN0ZWQgYW5kIGEgemVybyBsZW5ndGggQ2xpZW50S2V5RXhjaGFuZ2UgbWVzc2FnZSBiZWluZyBzZW50IGJ5IHRoZSBjbGllbnQuIFRoaXMgY291bGQgYmUgZXhwbG9pdGVkIGluIGEgRG9TIGF0dGFjay4gUmVwb3J0ZWQgYnkgTWF0dCBDYXN3ZWxsIChPcGVuU1NMIGRldmVsb3BtZW50IHRlYW0pLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJhIChBZmZlY3RlZCAxLjAuMik8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE1LTAyOTM8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTW9kZXJhdGUgc2V2ZXJpdHldPC9hPiAxOSBNYXJjaCAyMDE1OiA8L2R0PjxkZD5Eb1MgdmlhIHJlYWNoYWJsZSBhc3NlcnQgaW4gU1NMdjIgc2VydmVycy4gQSBtYWxpY2lvdXMgY2xpZW50IGNhbiB0cmlnZ2VyIGFuIE9QRU5TU0xfYXNzZXJ0IGluIHNlcnZlcnMgdGhhdCBib3RoIHN1cHBvcnQgU1NMdjIgYW5kIGVuYWJsZSBleHBvcnQgY2lwaGVyIHN1aXRlcyBieSBzZW5kaW5nIGEgc3BlY2lhbGx5IGNyYWZ0ZWQgU1NMdjIgQ0xJRU5ULU1BU1RFUi1LRVkgbWVzc2FnZS4gUmVwb3J0ZWQgYnkgU2VhbiBCdXJmb3JkIChHb29nbGUpIGFuZCBFbWlsaWEgS8Okc3BlciAoT3BlblNTTCBkZXZlbG9wbWVudCB0ZWFtKS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yYSAoQWZmZWN0ZWQgMS4wLjIpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMW0gKEFmZmVjdGVkIDEuMC4xLTEuMC4xbCk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wciAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBxKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45Ljh6ZiAoQWZmZWN0ZWQgMC45LjgtMC45Ljh6ZSk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE1LTAyOTI8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTW9kZXJhdGUgc2V2ZXJpdHldPC9hPiAxOSBNYXJjaCAyMDE1OiA8L2R0PjxkZD5BIHZ1bG5lcmFiaWxpdHkgZXhpc3RlZCBpbiBwcmV2aW91cyB2ZXJzaW9ucyBvZiBPcGVuU1NMIHJlbGF0ZWQgdG8gdGhlIHByb2Nlc3Npbmcgb2YgYmFzZTY0IGVuY29kZWQgZGF0YS4gQW55IGNvZGUgcGF0aCB0aGF0IHJlYWRzIGJhc2U2NCBkYXRhIGZyb20gYW4gdW50cnVzdGVkIHNvdXJjZSBjb3VsZCBiZSBhZmZlY3RlZCAoc3VjaCBhcyB0aGUgUEVNIHByb2Nlc3Npbmcgcm91dGluZXMpLiBNYWxpY2lvdXNseSBjcmFmdGVkIGJhc2UgNjQgZGF0YSBjb3VsZCB0cmlnZ2VyIGEgc2VnbWVuYXRpb24gZmF1bHQgb3IgbWVtb3J5IGNvcnJ1cHRpb24uIFJlcG9ydGVkIGJ5IFJvYmVydCBEdWdhbCwgYWxzbyBEYXZpZCBSYW1vcywgYWxzbyBIdXphaWZhIFNpZGhwdXJ3YWxhIChSZWQgSGF0KS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4xaCAoQWZmZWN0ZWQgMS4wLjEtMS4wLjFnKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjBtIChBZmZlY3RlZCAxLjAuMC0xLjAuMGwpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOHphIChBZmZlY3RlZCAwLjkuOC0wLjkuOHkpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNS0wMjkxPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0hpZ2ggc2V2ZXJpdHldPC9hPiAxOSBNYXJjaCAyMDE1OiA8L2R0PjxkZD5DbGllbnRIZWxsbyBzaWdhbGdzIERvUy4gSWYgYSBjbGllbnQgY29ubmVjdHMgdG8gYW4gT3BlblNTTCAxLjAuMiBzZXJ2ZXIgYW5kIHJlbmVnb3RpYXRlcyB3aXRoIGFuIGludmFsaWQgc2lnbmF0dXJlIGFsZ29yaXRobXMgZXh0ZW5zaW9uIGEgTlVMTCBwb2ludGVyIGRlcmVmZXJlbmNlIHdpbGwgb2NjdXIuIFRoaXMgY2FuIGJlIGV4cGxvaXRlZCBpbiBhIERvUyBhdHRhY2sgYWdhaW5zdCB0aGUgc2VydmVyLiBSZXBvcnRlZCBieSBEYXZpZCBSYW1vcyAoU3RhbmZvcmQgVW5pdmVyc2l0eSkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMmEgKEFmZmVjdGVkIDEuMC4yKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTUtMDI5MDwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltNb2RlcmF0ZSBzZXZlcml0eV08L2E+IDE5IE1hcmNoIDIwMTU6IDwvZHQ+PGRkPk11bHRpYmxvY2sgY29ycnVwdGVkIHBvaW50ZXIuIE9wZW5TU0wgMS4wLjIgaW50cm9kdWNlZCB0aGUgIm11bHRpYmxvY2siIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50LiBUaGlzIGZlYXR1cmUgb25seSBhcHBsaWVzIG9uIDY0IGJpdCB4ODYgYXJjaGl0ZWN0dXJlIHBsYXRmb3JtcyB0aGF0IHN1cHBvcnQgQUVTIE5JIGluc3RydWN0aW9ucy4gQSBkZWZlY3QgaW4gdGhlIGltcGxlbWVudGF0aW9uIG9mICJtdWx0aWJsb2NrIiBjYW4gY2F1c2UgT3BlblNTTCdzIGludGVybmFsIHdyaXRlIGJ1ZmZlciB0byBiZWNvbWUgaW5jb3JyZWN0bHkgc2V0IHRvIE5VTEwgd2hlbiB1c2luZyBub24tYmxvY2tpbmcgSU8uIFR5cGljYWxseSwgd2hlbiB0aGUgdXNlciBhcHBsaWNhdGlvbiBpcyB1c2luZyBhIHNvY2tldCBCSU8gZm9yIHdyaXRpbmcsIHRoaXMgd2lsbCBvbmx5IHJlc3VsdCBpbiBhIGZhaWxlZCBjb25uZWN0aW9uLiBIb3dldmVyIGlmIHNvbWUgb3RoZXIgQklPIGlzIHVzZWQgdGhlbiBpdCBpcyBsaWtlbHkgdGhhdCBhIHNlZ21lbnRhdGlvbiBmYXVsdCB3aWxsIGJlIHRyaWdnZXJlZCwgdGh1cyBlbmFibGluZyBhIHBvdGVudGlhbCBEb1MgYXR0YWNrLiBSZXBvcnRlZCBieSBEYW5pZWwgRGFubmVyIGFuZCBSYWluZXIgTXVlbGxlci4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yYSAoQWZmZWN0ZWQgMS4wLjIpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNS0wMjg5PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W01vZGVyYXRlIHNldmVyaXR5XTwvYT4gMTkgTWFyY2ggMjAxNTogPC9kdD48ZGQ+UEtDUyM3IE5VTEwgcG9pbnRlciBkZXJlZmVyZW5jZS4gVGhlIFBLQ1MjNyBwYXJzaW5nIGNvZGUgZG9lcyBub3QgaGFuZGxlIG1pc3Npbmcgb3V0ZXIgQ29udGVudEluZm8gY29ycmVjdGx5LiBBbiBhdHRhY2tlciBjYW4gY3JhZnQgbWFsZm9ybWVkIEFTTi4xLWVuY29kZWQgUEtDUyM3IGJsb2JzIHdpdGggbWlzc2luZyBjb250ZW50IGFuZCB0cmlnZ2VyIGEgTlVMTCBwb2ludGVyIGRlcmVmZXJlbmNlIG9uIHBhcnNpbmcuIEFwcGxpY2F0aW9ucyB0aGF0IHZlcmlmeSBQS0NTIzcgc2lnbmF0dXJlcywgZGVjcnlwdCBQS0NTIzcgZGF0YSBvciBvdGhlcndpc2UgcGFyc2UgUEtDUyM3IHN0cnVjdHVyZXMgZnJvbSB1bnRydXN0ZWQgc291cmNlcyBhcmUgYWZmZWN0ZWQuIE9wZW5TU0wgY2xpZW50cyBhbmQgc2VydmVycyBhcmUgbm90IGFmZmVjdGVkLiBSZXBvcnRlZCBieSBNaWNoYWwgWmFsZXdza2kgKEdvb2dsZSkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMmEgKEFmZmVjdGVkIDEuMC4yKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFtIChBZmZlY3RlZCAxLjAuMS0xLjAuMWwpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMHIgKEFmZmVjdGVkIDEuMC4wLTEuMC4wcSk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44emYgKEFmZmVjdGVkIDAuOS44LTAuOS44emUpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNS0wMjg3PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W01vZGVyYXRlIHNldmVyaXR5XTwvYT4gMTkgTWFyY2ggMjAxNTogPC9kdD48ZGQ+QVNOLjEgc3RydWN0dXJlIHJldXNlIG1lbW9yeSBjb3JydXB0aW9uLiBSZXVzaW5nIGEgc3RydWN0dXJlIGluIEFTTi4xIHBhcnNpbmcgbWF5IGFsbG93IGFuIGF0dGFja2VyIHRvIGNhdXNlIG1lbW9yeSBjb3JydXB0aW9uIHZpYSBhbiBpbnZhbGlkIHdyaXRlLiBTdWNoIHJldXNlIGlzIGFuZCBoYXMgYmVlbiBzdHJvbmdseSBkaXNjb3VyYWdlZCBhbmQgaXMgYmVsaWV2ZWQgdG8gYmUgcmFyZS4gUmVwb3J0ZWQgYnkgRW1pbGlhIEvDpHNwZXIgKE9wZW5TU0wgZGV2ZWxvcG1lbnQgdGVhbSkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMmEgKEFmZmVjdGVkIDEuMC4yKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFtIChBZmZlY3RlZCAxLjAuMS0xLjAuMWwpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMHIgKEFmZmVjdGVkIDEuMC4wLTEuMC4wcSk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44emYgKEFmZmVjdGVkIDAuOS44LTAuOS44emUpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNS0wMjg2PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W01vZGVyYXRlIHNldmVyaXR5XTwvYT4gMTkgTWFyY2ggMjAxNTogPC9kdD48ZGQ+U2VnbWVudGF0aW9uIGZhdWx0IGluIEFTTjFfVFlQRV9jbXAuIFRoZSBmdW5jdGlvbiBBU04xX1RZUEVfY21wIHdpbGwgY3Jhc2ggd2l0aCBhbiBpbnZhbGlkIHJlYWQgaWYgYW4gYXR0ZW1wdCBpcyBtYWRlIHRvIGNvbXBhcmUgQVNOLjEgYm9vbGVhbiB0eXBlcy4gU2luY2UgQVNOMV9UWVBFX2NtcCBpcyB1c2VkIHRvIGNoZWNrIGNlcnRpZmljYXRlIHNpZ25hdHVyZSBhbGdvcml0aG0gY29uc2lzdGVuY3kgdGhpcyBjYW4gYmUgdXNlZCB0byBjcmFzaCBhbnkgY2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uIG9wZXJhdGlvbiBhbmQgZXhwbG9pdGVkIGluIGEgRG9TIGF0dGFjay4gQW55IGFwcGxpY2F0aW9uIHdoaWNoIHBlcmZvcm1zIGNlcnRpZmljYXRlIHZlcmlmaWNhdGlvbiBpcyB2dWxuZXJhYmxlIGluY2x1ZGluZyBPcGVuU1NMIGNsaWVudHMgYW5kIHNlcnZlcnMgd2hpY2ggZW5hYmxlIGNsaWVudCBhdXRoZW50aWNhdGlvbi4gUmVwb3J0ZWQgYnkgU3RlcGhlbiBIZW5zb24gKE9wZW5TU0wgZGV2ZWxvcG1lbnQgdGVhbSkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMmEgKEFmZmVjdGVkIDEuMC4yKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFtIChBZmZlY3RlZCAxLjAuMS0xLjAuMWwpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMHIgKEFmZmVjdGVkIDEuMC4wLTEuMC4wcSk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44emYgKEFmZmVjdGVkIDAuOS44emQtMC45Ljh6ZSk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE1LTAyMDk8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMTkgTWFyY2ggMjAxNTogPC9kdD48ZGQ+VXNlIEFmdGVyIEZyZWUgZm9sbG93aW5nIGQyaV9FQ1ByaXZhdGVrZXkgZXJyb3IuIEEgbWFsZm9ybWVkIEVDIHByaXZhdGUga2V5IGZpbGUgY29uc3VtZWQgdmlhIHRoZSBkMmlfRUNQcml2YXRlS2V5IGZ1bmN0aW9uIGNvdWxkIGNhdXNlIGEgdXNlIGFmdGVyIGZyZWUgY29uZGl0aW9uLiBUaGlzLCBpbiB0dXJuLCBjb3VsZCBjYXVzZSBhIGRvdWJsZSBmcmVlIGluIHNldmVyYWwgcHJpdmF0ZSBrZXkgcGFyc2luZyBmdW5jdGlvbnMgKHN1Y2ggYXMgZDJpX1ByaXZhdGVLZXkgb3IgRVZQX1BLQ1M4MlBLRVkpIGFuZCBjb3VsZCBsZWFkIHRvIGEgRG9TIGF0dGFjayBvciBtZW1vcnkgY29ycnVwdGlvbiBmb3IgYXBwbGljYXRpb25zIHRoYXQgcmVjZWl2ZSBFQyBwcml2YXRlIGtleXMgZnJvbSB1bnRydXN0ZWQgc291cmNlcy4gVGhpcyBzY2VuYXJpbyBpcyBjb25zaWRlcmVkIHJhcmUuIFJlcG9ydGVkIGJ5IFRoZSBCb3JpbmdTU0wgcHJvamVjdC4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yYSAoQWZmZWN0ZWQgMS4wLjIpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMW0gKEFmZmVjdGVkIDEuMC4xLTEuMC4xbCk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wciAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBxKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45Ljh6ZiAoQWZmZWN0ZWQgMC45LjgtMC45Ljh6ZSk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE1LTAyMDg8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTW9kZXJhdGUgc2V2ZXJpdHldPC9hPiAxOSBNYXJjaCAyMDE1OiA8L2R0PjxkZD5TZWdtZW50YXRpb24gZmF1bHQgZm9yIGludmFsaWQgUFNTIHBhcmFtZXRlcnMuIFRoZSBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIHJvdXRpbmVzIHdpbGwgY3Jhc2ggd2l0aCBhIE5VTEwgcG9pbnRlciBkZXJlZmVyZW5jZSBpZiBwcmVzZW50ZWQgd2l0aCBhbiBBU04uMSBzaWduYXR1cmUgdXNpbmcgdGhlIFJTQSBQU1MgYWxnb3JpdGhtIGFuZCBpbnZhbGlkIHBhcmFtZXRlcnMuIFNpbmNlIHRoZXNlIHJvdXRpbmVzIGFyZSB1c2VkIHRvIHZlcmlmeSBjZXJ0aWZpY2F0ZSBzaWduYXR1cmUgYWxnb3JpdGhtcyB0aGlzIGNhbiBiZSB1c2VkIHRvIGNyYXNoIGFueSBjZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb24gb3BlcmF0aW9uIGFuZCBleHBsb2l0ZWQgaW4gYSBEb1MgYXR0YWNrLiBBbnkgYXBwbGljYXRpb24gd2hpY2ggcGVyZm9ybXMgY2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uIGlzIHZ1bG5lcmFibGUgaW5jbHVkaW5nIE9wZW5TU0wgY2xpZW50cyBhbmQgc2VydmVycyB3aGljaCBlbmFibGUgY2xpZW50IGF1dGhlbnRpY2F0aW9uLiBSZXBvcnRlZCBieSBCcmlhbiBDYXJwZW50ZXIuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMmEgKEFmZmVjdGVkIDEuMC4yKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTUtMDIwNzwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltNb2RlcmF0ZSBzZXZlcml0eV08L2E+IDE5IE1hcmNoIDIwMTU6IDwvZHQ+PGRkPlNlZ21lbnRhdGlvbiBmYXVsdCBpbiBEVExTdjFfbGlzdGVuLiBBIGRlZmVjdCBpbiB0aGUgaW1wbGVtZW50YXRpb24gb2YgRFRMU3YxX2xpc3RlbiBtZWFucyB0aGF0IHN0YXRlIGlzIHByZXNlcnZlZCBpbiB0aGUgU1NMIG9iamVjdCBmcm9tIG9uZSBpbnZvY2F0aW9uIHRvIHRoZSBuZXh0IHRoYXQgY2FuIGxlYWQgdG8gYSBzZWdtZW50YXRpb24gZmF1bHQuIEVycm9ycyBwcm9jZXNzaW5nIHRoZSBpbml0aWFsIENsaWVudEhlbGxvIGNhbiB0cmlnZ2VyIHRoaXMgc2NlbmFyaW8uIEFuIGV4YW1wbGUgb2Ygc3VjaCBhbiBlcnJvciBjb3VsZCBiZSB0aGF0IGEgRFRMUzEuMCBvbmx5IGNsaWVudCBpcyBhdHRlbXB0aW5nIHRvIGNvbm5lY3QgdG8gYSBEVExTMS4yIG9ubHkgc2VydmVyLiBSZXBvcnRlZCBieSBQZXIgQWxsYW5zc29uLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJhIChBZmZlY3RlZCAxLjAuMik8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE1LTAyODU8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMTAgTWFyY2ggMjAxNTogPC9kdD48ZGQ+VW5kZXIgY2VydGFpbiBjb25kaXRpb25zIGFuIE9wZW5TU0wgMS4wLjIgY2xpZW50IGNhbiBjb21wbGV0ZSBhIGhhbmRzaGFrZSB3aXRoIGFuIHVuc2VlZGVkIFBSTkcuIElmIHRoZSBoYW5kc2hha2Ugc3VjY2VlZHMgdGhlbiB0aGUgY2xpZW50IHJhbmRvbSB0aGF0IGhhcyBiZWVuIHVzZWQgd2lsbCBoYXZlIGJlZW4gZ2VuZXJhdGVkIGZyb20gYSBQUk5HIHdpdGggaW5zdWZmaWNpZW50IGVudHJvcHkgYW5kIHRoZXJlZm9yZSB0aGUgb3V0cHV0IG1heSBiZSBwcmVkaWN0YWJsZS4gUmVwb3J0ZWQgYnkgTWF0dCBDYXN3ZWxsIChPcGVuU1NMIGRldmVsb3BtZW50IHRlYW0pLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjJhIChBZmZlY3RlZCAxLjAuMik8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE1LTAyODg8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMDIgTWFyY2ggMjAxNTogPC9kdD48ZGQ+WDUwOV90b19YNTA5X1JFUSBOVUxMIHBvaW50ZXIgZGVyZWYuIFRoZSBmdW5jdGlvbiBYNTA5X3RvX1g1MDlfUkVRIHdpbGwgY3Jhc2ggd2l0aCBhIE5VTEwgcG9pbnRlciBkZXJlZmVyZW5jZSBpZiB0aGUgY2VydGlmaWNhdGUga2V5IGlzIGludmFsaWQuIFRoaXMgZnVuY3Rpb24gaXMgcmFyZWx5IHVzZWQgaW4gcHJhY3RpY2UuIFJlcG9ydGVkIGJ5IEJyaWFuIENhcnBlbnRlci4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4yYSAoQWZmZWN0ZWQgMS4wLjIpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMW0gKEFmZmVjdGVkIDEuMC4xLTEuMC4xbCk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wciAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBxKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45Ljh6ZiAoQWZmZWN0ZWQgMC45LjgtMC45Ljh6ZSk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE1LTAyMDY8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTW9kZXJhdGUgc2V2ZXJpdHldPC9hPiAwOCBKYW51YXJ5IDIwMTU6IDwvZHQ+PGRkPkEgbWVtb3J5IGxlYWsgY2FuIG9jY3VyIGluIHRoZSBkdGxzMV9idWZmZXJfcmVjb3JkIGZ1bmN0aW9uIHVuZGVyIGNlcnRhaW4gY29uZGl0aW9ucy4gSW4gcGFydGljdWxhciB0aGlzIGNvdWxkIG9jY3VyIGlmIGFuIGF0dGFja2VyIHNlbnQgcmVwZWF0ZWQgRFRMUyByZWNvcmRzIHdpdGggdGhlIHNhbWUgc2VxdWVuY2UgbnVtYmVyIGJ1dCBmb3IgdGhlIG5leHQgZXBvY2guIFRoZSBtZW1vcnkgbGVhayBjb3VsZCBiZSBleHBsb2l0ZWQgYnkgYW4gYXR0YWNrZXIgaW4gYSBEZW5pYWwgb2YgU2VydmljZSBhdHRhY2sgdGhyb3VnaCBtZW1vcnkgZXhoYXVzdGlvbi4gUmVwb3J0ZWQgYnkgQ2hyaXMgTXVlbGxlci4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4xayAoQWZmZWN0ZWQgMS4wLjEtMS4wLjFqKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjBwIChBZmZlY3RlZCAxLjAuMC0xLjAuMG8pPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNS0wMjA1PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0xvdyBzZXZlcml0eV08L2E+IDA4IEphbnVhcnkgMjAxNTogPC9kdD48ZGQ+QW4gT3BlblNTTCBzZXJ2ZXIgd2lsbCBhY2NlcHQgYSBESCBjZXJ0aWZpY2F0ZSBmb3IgY2xpZW50IGF1dGhlbnRpY2F0aW9uIHdpdGhvdXQgdGhlIGNlcnRpZmljYXRlIHZlcmlmeSBtZXNzYWdlLiBUaGlzIGVmZmVjdGl2ZWx5IGFsbG93cyBhIGNsaWVudCB0byBhdXRoZW50aWNhdGUgd2l0aG91dCB0aGUgdXNlIG9mIGEgcHJpdmF0ZSBrZXkuIFRoaXMgb25seSBhZmZlY3RzIHNlcnZlcnMgd2hpY2ggdHJ1c3QgYSBjbGllbnQgY2VydGlmaWNhdGUgYXV0aG9yaXR5IHdoaWNoIGlzc3VlcyBjZXJ0aWZpY2F0ZXMgY29udGFpbmluZyBESCBrZXlzOiB0aGVzZSBhcmUgZXh0cmVtZWx5IHJhcmUgYW5kIGhhcmRseSBldmVyIGVuY291bnRlcmVkLiBSZXBvcnRlZCBieSBLYXJ0aGlrZXlhbiBCaGFyZ2F2YW4gb2YgdGhlIFBST1NFQ0NPIHRlYW0gYXQgSU5SSUEuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMWsgKEFmZmVjdGVkIDEuMC4xLTEuMC4xaik8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wcCAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBvKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTQtMzU3MDwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltMb3cgc2V2ZXJpdHldPC9hPiAwOCBKYW51YXJ5IDIwMTU6IDwvZHQ+PGRkPkJpZ251bSBzcXVhcmluZyAoQk5fc3FyKSBtYXkgcHJvZHVjZSBpbmNvcnJlY3QgcmVzdWx0cyBvbiBzb21lIHBsYXRmb3JtcywgaW5jbHVkaW5nIHg4Nl82NC4gVGhpcyBidWcgb2NjdXJzIGF0IHJhbmRvbSB3aXRoIGEgdmVyeSBsb3cgcHJvYmFiaWxpdHksIGFuZCBpcyBub3Qga25vd24gdG8gYmUgZXhwbG9pdGFibGUgaW4gYW55IHdheSwgdGhvdWdoIGl0cyBleGFjdCBpbXBhY3QgaXMgZGlmZmljdWx0IHRvIGRldGVybWluZS4gVGhlIGZvbGxvd2luZyBoYXMgYmVlbiBkZXRlcm1pbmVkOiAqKSBUaGUgcHJvYmFiaWxpdHkgb2YgQk5fc3FyIHByb2R1Y2luZyBhbiBpbmNvcnJlY3QgcmVzdWx0IGF0IHJhbmRvbSBpcyB2ZXJ5IGxvdzogMS8yXjY0IG9uIHRoZSBzaW5nbGUgYWZmZWN0ZWQgMzItYml0IHBsYXRmb3JtIChNSVBTKSBhbmQgMS8yXjEyOCBvbiBhZmZlY3RlZCA2NC1iaXQgcGxhdGZvcm1zLiAqKSBPbiBtb3N0IHBsYXRmb3JtcywgUlNBIGZvbGxvd3MgYSBkaWZmZXJlbnQgY29kZSBwYXRoIGFuZCBSU0Egb3BlcmF0aW9ucyBhcmUgbm90IGFmZmVjdGVkIGF0IGFsbC4gRm9yIHRoZSByZW1haW5pbmcgcGxhdGZvcm1zIChlLmcuIE9wZW5TU0wgYnVpbHQgd2l0aG91dCBhc3NlbWJseSBzdXBwb3J0KSwgcHJlLWV4aXN0aW5nIGNvdW50ZXJtZWFzdXJlcyB0aHdhcnQgYnVnIGF0dGFja3MgWzFdLiAqKSBTdGF0aWMgRUNESCBpcyB0aGVvcmV0aWNhbGx5IGFmZmVjdGVkOiBpdCBpcyBwb3NzaWJsZSB0byBjb25zdHJ1Y3QgZWxsaXB0aWMgY3VydmUgcG9pbnRzIHRoYXQgd291bGQgZmFsc2VseSBhcHBlYXIgdG8gYmUgb24gdGhlIGdpdmVuIGN1cnZlLiBIb3dldmVyLCB0aGVyZSBpcyBubyBrbm93biBjb21wdXRhdGlvbmFsbHkgZmVhc2libGUgd2F5IHRvIGNvbnN0cnVjdCBzdWNoIHBvaW50cyB3aXRoIGxvdyBvcmRlciwgYW5kIHNvIHRoZSBzZWN1cml0eSBvZiBzdGF0aWMgRUNESCBwcml2YXRlIGtleXMgaXMgYmVsaWV2ZWQgdG8gYmUgdW5hZmZlY3RlZC4gKikgT3RoZXIgcm91dGluZXMga25vd24gdG8gYmUgdGhlb3JldGljYWxseSBhZmZlY3RlZCBhcmUgbW9kdWxhciBleHBvbmVudGlhdGlvbiwgcHJpbWFsaXR5IHRlc3RpbmcsIERTQSwgUlNBIGJsaW5kaW5nLCBKUEFLRSBhbmQgU1JQLiBObyBleHBsb2l0cyBhcmUga25vd24gYW5kIHN0cmFpZ2h0Zm9yd2FyZCBidWcgYXR0YWNrcyBmYWlsIC0gZWl0aGVyIHRoZSBhdHRhY2tlciBjYW5ub3QgY29udHJvbCB3aGVuIHRoZSBidWcgdHJpZ2dlcnMsIG9yIG5vIHByaXZhdGUga2V5IG1hdGVyaWFsIGlzIGludm9sdmVkLiBSZXBvcnRlZCBieSBQaWV0ZXIgV3VpbGxlIChCbG9ja3N0cmVhbSkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMWsgKEFmZmVjdGVkIDEuMC4xLTEuMC4xaik8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wcCAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBvKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45Ljh6ZCAoQWZmZWN0ZWQgMC45LjgtMC45Ljh6Yyk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE1LTAyMDQ8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMDYgSmFudWFyeSAyMDE1OiA8L2R0PjxkZD5BbiBPcGVuU1NMIGNsaWVudCB3aWxsIGFjY2VwdCB0aGUgdXNlIG9mIGFuIFJTQSB0ZW1wb3Jhcnkga2V5IGluIGEgbm9uLWV4cG9ydCBSU0Ega2V5IGV4Y2hhbmdlIGNpcGhlcnN1aXRlLiBBIHNlcnZlciBjb3VsZCBwcmVzZW50IGEgd2VhayB0ZW1wb3Jhcnkga2V5IGFuZCBkb3duZ3JhZGUgdGhlIHNlY3VyaXR5IG9mIHRoZSBzZXNzaW9uLiBSZXBvcnRlZCBieSBLYXJ0aGlrZXlhbiBCaGFyZ2F2YW4gb2YgdGhlIFBST1NFQ0NPIHRlYW0gYXQgSU5SSUEuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMWsgKEFmZmVjdGVkIDEuMC4xLTEuMC4xaik8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wcCAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBvKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45Ljh6ZCAoQWZmZWN0ZWQgMC45LjgtMC45Ljh6Yyk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE0LTgyNzU8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMDUgSmFudWFyeSAyMDE1OiA8L2R0PjxkZD5PcGVuU1NMIGFjY2VwdHMgc2V2ZXJhbCBub24tREVSLXZhcmlhdGlvbnMgb2YgY2VydGlmaWNhdGUgc2lnbmF0dXJlIGFsZ29yaXRobSBhbmQgc2lnbmF0dXJlIGVuY29kaW5ncy4gT3BlblNTTCBhbHNvIGRvZXMgbm90IGVuZm9yY2UgYSBtYXRjaCBiZXR3ZWVuIHRoZSBzaWduYXR1cmUgYWxnb3JpdGhtIGJldHdlZW4gdGhlIHNpZ25lZCBhbmQgdW5zaWduZWQgcG9ydGlvbnMgb2YgdGhlIGNlcnRpZmljYXRlLiBCeSBtb2RpZnlpbmcgdGhlIGNvbnRlbnRzIG9mIHRoZSBzaWduYXR1cmUgYWxnb3JpdGhtIG9yIHRoZSBlbmNvZGluZyBvZiB0aGUgc2lnbmF0dXJlLCBpdCBpcyBwb3NzaWJsZSB0byBjaGFuZ2UgdGhlIGNlcnRpZmljYXRlJ3MgZmluZ2VycHJpbnQuIFRoaXMgZG9lcyBub3QgYWxsb3cgYW4gYXR0YWNrZXIgdG8gZm9yZ2UgY2VydGlmaWNhdGVzLCBhbmQgZG9lcyBub3QgYWZmZWN0IGNlcnRpZmljYXRlIHZlcmlmaWNhdGlvbiBvciBPcGVuU1NMIHNlcnZlcnMvY2xpZW50cyBpbiBhbnkgb3RoZXIgd2F5LiBJdCBhbHNvIGRvZXMgbm90IGFmZmVjdCBjb21tb24gcmV2b2NhdGlvbiBtZWNoYW5pc21zLiBPbmx5IGN1c3RvbSBhcHBsaWNhdGlvbnMgdGhhdCByZWx5IG9uIHRoZSB1bmlxdWVuZXNzIG9mIHRoZSBmaW5nZXJwcmludCAoZS5nLiBjZXJ0aWZpY2F0ZSBibGFja2xpc3RzKSBtYXkgYmUgYWZmZWN0ZWQuIFJlcG9ydGVkIGJ5IEFudHRpIEthcmphbGFpbmVuIGFuZCBUdW9tbyBVbnRpbmVuIGZyb20gdGhlIENvZGVub21pY29uIENST1NTIHByb2dyYW0vS29ucmFkIEtyYXN6ZXdza2kgZnJvbSBHb29nbGUuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMWsgKEFmZmVjdGVkIDEuMC4xLTEuMC4xaik8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wcCAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBvKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45Ljh6ZCAoQWZmZWN0ZWQgMC45LjgtMC45Ljh6Yyk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE0LTM1NzI8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMDUgSmFudWFyeSAyMDE1OiA8L2R0PjxkZD5BbiBPcGVuU1NMIGNsaWVudCB3aWxsIGFjY2VwdCBhIGhhbmRzaGFrZSB1c2luZyBhbiBlcGhlbWVyYWwgRUNESCBjaXBoZXJzdWl0ZSB1c2luZyBhbiBFQ0RTQSBjZXJ0aWZpY2F0ZSBpZiB0aGUgc2VydmVyIGtleSBleGNoYW5nZSBtZXNzYWdlIGlzIG9taXR0ZWQuIFRoaXMgZWZmZWN0aXZlbHkgcmVtb3ZlcyBmb3J3YXJkIHNlY3JlY3kgZnJvbSB0aGUgY2lwaGVyc3VpdGUuIFJlcG9ydGVkIGJ5IEthcnRoaWtleWFuIEJoYXJnYXZhbiBvZiB0aGUgUFJPU0VDQ08gdGVhbSBhdCBJTlJJQS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4xayAoQWZmZWN0ZWQgMS4wLjEtMS4wLjFqKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjBwIChBZmZlY3RlZCAxLjAuMC0xLjAuMG8pPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOHpkIChBZmZlY3RlZCAwLjkuOC0wLjkuOHpjKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTQtMzU3MTwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltNb2RlcmF0ZSBzZXZlcml0eV08L2E+IDA1IEphbnVhcnkgMjAxNTogPC9kdD48ZGQ+QSBjYXJlZnVsbHkgY3JhZnRlZCBEVExTIG1lc3NhZ2UgY2FuIGNhdXNlIGEgc2VnbWVudGF0aW9uIGZhdWx0IGluIE9wZW5TU0wgZHVlIHRvIGEgTlVMTCBwb2ludGVyIGRlcmVmZXJlbmNlLiBUaGlzIGNvdWxkIGxlYWQgdG8gYSBEZW5pYWwgT2YgU2VydmljZSBhdHRhY2suIFJlcG9ydGVkIGJ5IE1hcmt1cyBTdGVuYmVyZyBvZiBDaXNjbyBTeXN0ZW1zLCBJbmMuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMWsgKEFmZmVjdGVkIDEuMC4xLTEuMC4xaik8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wcCAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBvKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45Ljh6ZCAoQWZmZWN0ZWQgMC45LjgtMC45Ljh6Yyk8L2xpPjwvdWw+PC9kZD48L2RsPjxoMz48YSA+MjAxNDwvYT48L2gzPjxkbD48ZHQ+PGEgPkNWRS0yMDE0LTM1Njk8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDxhID5bTG93IHNldmVyaXR5XTwvYT4gMjEgT2N0b2JlciAyMDE0OiA8L2R0PjxkZD5XaGVuIG9wZW5zc2wgaXMgYnVpbHQgd2l0aCB0aGUgbm8tc3NsMyBvcHRpb24gYW5kIGEgU1NMIHYzIENsaWVudEhlbGxvIGlzIHJlY2VpdmVkIHRoZSBzc2wgbWV0aG9kIHdvdWxkIGJlIHNldCB0byBOVUxMIHdoaWNoIGNvdWxkIGxhdGVyIHJlc3VsdCBpbiBhIE5VTEwgcG9pbnRlciBkZXJlZmVyZW5jZS4gUmVwb3J0ZWQgYnkgRnJhbmsgU2NobWlybGVyLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFrIChBZmZlY3RlZCAxLjAuMWopPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMHAgKEFmZmVjdGVkIDEuMC4wbyk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44emQgKEFmZmVjdGVkIDAuOS44emMpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNC0zNTY4PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiA8YSA+W0xvdyBzZXZlcml0eV08L2E+IDE1IE9jdG9iZXIgMjAxNDogPC9kdD48ZGQ+V2hlbiBPcGVuU1NMIGlzIGNvbmZpZ3VyZWQgd2l0aCAibm8tc3NsMyIgYXMgYSBidWlsZCBvcHRpb24sIHNlcnZlcnMgY291bGQgYWNjZXB0IGFuZCBjb21wbGV0ZSBhIFNTTCAzLjAgaGFuZHNoYWtlLCBhbmQgY2xpZW50cyBjb3VsZCBiZSBjb25maWd1cmVkIHRvIHNlbmQgdGhlbS4gUmVwb3J0ZWQgYnkgQWthbWFpIFRlY2hub2xvZ2llcy4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4xaiAoQWZmZWN0ZWQgMS4wLjEtMS4wLjFpKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjBvIChBZmZlY3RlZCAxLjAuMC0xLjAuMG4pPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOHpjIChBZmZlY3RlZCAwLjkuOC0wLjkuOHpiKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTQtMzU2NzwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltNb2RlcmF0ZSBzZXZlcml0eV08L2E+IDE1IE9jdG9iZXIgMjAxNDogPC9kdD48ZGQ+V2hlbiBhbiBPcGVuU1NMIFNTTC9UTFMvRFRMUyBzZXJ2ZXIgcmVjZWl2ZXMgYSBzZXNzaW9uIHRpY2tldCB0aGUgaW50ZWdyaXR5IG9mIHRoYXQgdGlja2V0IGlzIGZpcnN0IHZlcmlmaWVkLiBJbiB0aGUgZXZlbnQgb2YgYSBzZXNzaW9uIHRpY2tldCBpbnRlZ3JpdHkgY2hlY2sgZmFpbGluZywgT3BlblNTTCB3aWxsIGZhaWwgdG8gZnJlZSBtZW1vcnkgY2F1c2luZyBhIG1lbW9yeSBsZWFrLiBCeSBzZW5kaW5nIGEgbGFyZ2UgbnVtYmVyIG9mIGludmFsaWQgc2Vzc2lvbiB0aWNrZXRzIGFuIGF0dGFja2VyIGNvdWxkIGV4cGxvaXQgdGhpcyBpc3N1ZSBpbiBhIERlbmlhbCBPZiBTZXJ2aWNlIGF0dGFjay48dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFqIChBZmZlY3RlZCAxLjAuMS0xLjAuMWkpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMG8gKEFmZmVjdGVkIDEuMC4wLTEuMC4wbik8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44emMgKEFmZmVjdGVkIDAuOS44Zy0wLjkuOHpiKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTQtMzUxMzwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gPGEgPltIaWdoIHNldmVyaXR5XTwvYT4gMTUgT2N0b2JlciAyMDE0OiA8L2R0PjxkZD5BIGZsYXcgaW4gdGhlIERUTFMgU1JUUCBleHRlbnNpb24gcGFyc2luZyBjb2RlIGFsbG93cyBhbiBhdHRhY2tlciwgd2hvIHNlbmRzIGEgY2FyZWZ1bGx5IGNyYWZ0ZWQgaGFuZHNoYWtlIG1lc3NhZ2UsIHRvIGNhdXNlIE9wZW5TU0wgdG8gZmFpbCB0byBmcmVlIHVwIHRvIDY0ayBvZiBtZW1vcnkgY2F1c2luZyBhIG1lbW9yeSBsZWFrLiBUaGlzIGNvdWxkIGJlIGV4cGxvaXRlZCBpbiBhIERlbmlhbCBPZiBTZXJ2aWNlIGF0dGFjay4gVGhpcyBpc3N1ZSBhZmZlY3RzIE9wZW5TU0wgMS4wLjEgc2VydmVyIGltcGxlbWVudGF0aW9ucyBmb3IgYm90aCBTU0wvVExTIGFuZCBEVExTIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBTUlRQIGlzIHVzZWQgb3IgY29uZmlndXJlZC4gSW1wbGVtZW50YXRpb25zIG9mIE9wZW5TU0wgdGhhdCBoYXZlIGJlZW4gY29tcGlsZWQgd2l0aCBPUEVOU1NMX05PX1NSVFAgZGVmaW5lZCBhcmUgbm90IGFmZmVjdGVkLiBSZXBvcnRlZCBieSBMaWJyZVNTTCBwcm9qZWN0LiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFqIChBZmZlY3RlZCAxLjAuMS0xLjAuMWkpPC9saT48L3VsPjwvZGQ+PGR0PjE1IE9jdG9iZXIgMjAxNDogPC9kdD48ZGQ+T3BlblNTTCBoYXMgYWRkZWQgc3VwcG9ydCBmb3IgVExTX0ZBTExCQUNLX1NDU1YgdG8gYWxsb3cgYXBwbGljYXRpb25zIHRvIGJsb2NrIHRoZSBhYmlsaXR5IGZvciBhIE1JVE0gYXR0YWNrZXIgdG8gZm9yY2UgYSBwcm90b2NvbCBkb3duZ3JhZGUuIFNvbWUgY2xpZW50IGFwcGxpY2F0aW9ucyAoc3VjaCBhcyBicm93c2Vycykgd2lsbCByZWNvbm5lY3QgdXNpbmcgYSBkb3duZ3JhZGVkIHByb3RvY29sIHRvIHdvcmsgYXJvdW5kIGludGVyb3BlcmFiaWxpdHkgYnVncyBpbiBvbGRlciBzZXJ2ZXJzLiBUaGlzIGNvdWxkIGJlIGV4cGxvaXRlZCBieSBhbiBhY3RpdmUgbWFuLWluLXRoZS1taWRkbGUgdG8gZG93bmdyYWRlIGNvbm5lY3Rpb25zIHRvIFNTTCAzLjAgZXZlbiBpZiBib3RoIHNpZGVzIG9mIHRoZSBjb25uZWN0aW9uIHN1cHBvcnQgaGlnaGVyIHByb3RvY29scy4gU1NMIDMuMCBjb250YWlucyBhIG51bWJlciBvZiB3ZWFrbmVzc2VzIGluY2x1ZGluZyBQT09ETEUgKENWRS0yMDE0LTM1NjYpLiBTZWUgYWxzbyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi10bHMtZG93bmdyYWRlLXNjc3YtMDAgYW5kIGh0dHBzOi8vd3d3Lm9wZW5zc2wub3JnL35ib2RvL3NzbC1wb29kbGUucGRmPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4xaiAoQWZmZWN0ZWQgMS4wLjEtMS4wLjFpKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjBvIChBZmZlY3RlZCAxLjAuMC0xLjAuMG4pPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOHpjIChBZmZlY3RlZCAwLjkuOC0wLjkuOHpiKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTQtNTEzOTwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMDYgQXVndXN0IDIwMTQ6IDwvZHQ+PGRkPkEgY3Jhc2ggd2FzIGZvdW5kIGFmZmVjdGluZyBTUlAgY2lwaGVyc3VpdGVzIHVzZWQgaW4gYSBTZXJ2ZXIgSGVsbG8gbWVzc2FnZS4gVGhlIGlzc3VlIGFmZmVjdHMgT3BlblNTTCBjbGllbnRzIGFuZCBhbGxvd3MgYSBtYWxpY2lvdXMgc2VydmVyIHRvIGNyYXNoIHRoZSBjbGllbnQgd2l0aCBhIG51bGwgcG9pbnRlciBkZXJlZmVyZW5jZSAocmVhZCkgYnkgc3BlY2lmeWluZyBhbiBTUlAgY2lwaGVyc3VpdGUgZXZlbiB0aG91Z2ggaXQgd2FzIG5vdCBwcm9wZXJseSBuZWdvdGlhdGVkIHdpdGggdGhlIGNsaWVudC4gVGhpcyBjb3VsZCBsZWFkIHRvIGEgRGVuaWFsIG9mIFNlcnZpY2UuIFJlcG9ydGVkIGJ5IEpvb25hcyBLdW9yaWxlaHRvIGFuZCBSaWt1IEhpZXRhbcOka2kgKENvZGVub21pY29uKS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4xaSAoQWZmZWN0ZWQgMS4wLjEtMS4wLjFoKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTQtMzUxMjwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMDYgQXVndXN0IDIwMTQ6IDwvZHQ+PGRkPkEgU1JQIGJ1ZmZlciBvdmVycnVuIHdhcyBmb3VuZC4gQSBtYWxpY2lvdXMgY2xpZW50IG9yIHNlcnZlciBjYW4gc2VuZCBpbnZhbGlkIFNSUCBwYXJhbWV0ZXJzIGFuZCBvdmVycnVuIGFuIGludGVybmFsIGJ1ZmZlci4gT25seSBhcHBsaWNhdGlvbnMgd2hpY2ggYXJlIGV4cGxpY2l0bHkgc2V0IHVwIGZvciBTUlAgdXNlIGFyZSBhZmZlY3RlZC4gUmVwb3J0ZWQgYnkgU2VhbiBEZXZsaW4gYW5kIFdhdHNvbiBMYWRkIChDcnlwdG9ncmFwaHkgU2VydmljZXMsIE5DQyBHcm91cCkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMWkgKEFmZmVjdGVkIDEuMC4xLTEuMC4xaCk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE0LTM1MTE8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDA2IEF1Z3VzdCAyMDE0OiA8L2R0PjxkZD5BIGZsYXcgaW4gdGhlIE9wZW5TU0wgU1NML1RMUyBzZXJ2ZXIgY29kZSBjYXVzZXMgdGhlIHNlcnZlciB0byBuZWdvdGlhdGUgVExTIDEuMCBpbnN0ZWFkIG9mIGhpZ2hlciBwcm90b2NvbCB2ZXJzaW9ucyB3aGVuIHRoZSBDbGllbnRIZWxsbyBtZXNzYWdlIGlzIGJhZGx5IGZyYWdtZW50ZWQuIFRoaXMgYWxsb3dzIGEgbWFuLWluLXRoZS1taWRkbGUgYXR0YWNrZXIgdG8gZm9yY2UgYSBkb3duZ3JhZGUgdG8gVExTIDEuMCBldmVuIGlmIGJvdGggdGhlIHNlcnZlciBhbmQgdGhlIGNsaWVudCBzdXBwb3J0IGEgaGlnaGVyIHByb3RvY29sIHZlcnNpb24sIGJ5IG1vZGlmeWluZyB0aGUgY2xpZW50J3MgVExTIHJlY29yZHMuIFJlcG9ydGVkIGJ5IERhdmlkIEJlbmphbWluIGFuZCBBZGFtIExhbmdsZXkgKEdvb2dsZSkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMWkgKEFmZmVjdGVkIDEuMC4xLTEuMC4xaCk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE0LTM1MTA8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDA2IEF1Z3VzdCAyMDE0OiA8L2R0PjxkZD5BIGZsYXcgaW4gaGFuZGxpbmcgRFRMUyBhbm9ueW1vdXMgRUMoREgpIGNpcGhlcnN1aXRlcyB3YXMgZm91bmQuIE9wZW5TU0wgRFRMUyBjbGllbnRzIGVuYWJsaW5nIGFub255bW91cyAoRUMpREggY2lwaGVyc3VpdGVzIGFyZSBzdWJqZWN0IHRvIGEgZGVuaWFsIG9mIHNlcnZpY2UgYXR0YWNrLiBBIG1hbGljaW91cyBzZXJ2ZXIgY2FuIGNyYXNoIHRoZSBjbGllbnQgd2l0aCBhIG51bGwgcG9pbnRlciBkZXJlZmVyZW5jZSAocmVhZCkgYnkgc3BlY2lmeWluZyBhbiBhbm9ueW1vdXMgKEVDKURIIGNpcGhlcnN1aXRlIGFuZCBzZW5kaW5nIGNhcmVmdWxseSBjcmFmdGVkIGhhbmRzaGFrZSBtZXNzYWdlcy4gUmVwb3J0ZWQgYnkgRmVsaXggR3LDtmJlcnQgKEdvb2dsZSkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMWkgKEFmZmVjdGVkIDEuMC4xLTEuMC4xaCk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wbiAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBtKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45Ljh6YiAoQWZmZWN0ZWQgMC45LjgtMC45Ljh6YSk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE0LTM1MDk8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDA2IEF1Z3VzdCAyMDE0OiA8L2R0PjxkZD5BIHJhY2UgY29uZGl0aW9uIHdhcyBmb3VuZCBpbiBzc2xfcGFyc2Vfc2VydmVyaGVsbG9fdGxzZXh0LiBJZiBhIG11bHRpdGhyZWFkZWQgY2xpZW50IGNvbm5lY3RzIHRvIGEgbWFsaWNpb3VzIHNlcnZlciB1c2luZyBhIHJlc3VtZWQgc2Vzc2lvbiBhbmQgdGhlIHNlcnZlciBzZW5kcyBhbiBlYyBwb2ludCBmb3JtYXQgZXh0ZW5zaW9uLCBpdCBjb3VsZCB3cml0ZSB1cCB0byAyNTUgYnl0ZXMgdG8gZnJlZWQgbWVtb3J5LiBSZXBvcnRlZCBieSBHYWJvciBUeXVrYXN6IChMb2dNZUluIEluYykuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMWkgKEFmZmVjdGVkIDEuMC4xLTEuMC4xaCk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wbiAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBtKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTQtMzUwODwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMDYgQXVndXN0IDIwMTQ6IDwvZHQ+PGRkPkEgZmxhdyBpbiBPQkpfb2JqMnR4dCBtYXkgY2F1c2UgcHJldHR5IHByaW50aW5nIGZ1bmN0aW9ucyBzdWNoIGFzIFg1MDlfbmFtZV9vbmVsaW5lLCBYNTA5X25hbWVfcHJpbnRfZXgsIHRvIGxlYWsgc29tZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzdGFjay4gQXBwbGljYXRpb25zIG1heSBiZSBhZmZlY3RlZCBpZiB0aGV5IGVjaG8gcHJldHR5IHByaW50aW5nIG91dHB1dCB0byB0aGUgYXR0YWNrZXIuIE9wZW5TU0wgU1NML1RMUyBjbGllbnRzIGFuZCBzZXJ2ZXJzIHRoZW1zZWx2ZXMgYXJlIG5vdCBhZmZlY3RlZC4gUmVwb3J0ZWQgYnkgSXZhbiBGcmF0cmljIChHb29nbGUpLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFpIChBZmZlY3RlZCAxLjAuMS0xLjAuMWgpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMG4gKEFmZmVjdGVkIDEuMC4wLTEuMC4wbSk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44emIgKEFmZmVjdGVkIDAuOS44LTAuOS44emEpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNC0zNTA3PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAwNiBBdWd1c3QgMjAxNDogPC9kdD48ZGQ+QSBEVExTIG1lbW9yeSBsZWFrIGZyb20gemVyby1sZW5ndGggZnJhZ21lbnRzIHdhcyBmb3VuZC4gQnkgc2VuZGluZyBjYXJlZnVsbHkgY3JhZnRlZCBEVExTIHBhY2tldHMgYW4gYXR0YWNrZXIgY291bGQgY2F1c2UgT3BlblNTTCB0byBsZWFrIG1lbW9yeS4gVGhpcyBjb3VsZCBsZWFkIHRvIGEgRGVuaWFsIG9mIFNlcnZpY2UgYXR0YWNrLiBSZXBvcnRlZCBieSBBZGFtIExhbmdsZXkgKEdvb2dsZSkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMWkgKEFmZmVjdGVkIDEuMC4xLTEuMC4xaCk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wbiAoQWZmZWN0ZWQgMS4wLjBhLTEuMC4wbSk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44emIgKEFmZmVjdGVkIDAuOS44by0wLjkuOHphKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTQtMzUwNjwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMDYgQXVndXN0IDIwMTQ6IDwvZHQ+PGRkPkEgRFRMUyBmbGF3IGxlYWRpbmcgdG8gbWVtb3J5IGV4aGF1c3Rpb24gd2FzIGZvdW5kLiBBbiBhdHRhY2tlciBjYW4gZm9yY2Ugb3BlbnNzbCB0byBjb25zdW1lIGxhcmdlIGFtb3VudHMgb2YgbWVtb3J5IHdoaWxzdCBwcm9jZXNzaW5nIERUTFMgaGFuZHNoYWtlIG1lc3NhZ2VzLiBUaGlzIGNvdWxkIGxlYWQgdG8gYSBEZW5pYWwgb2YgU2VydmljZSBhdHRhY2suIFJlcG9ydGVkIGJ5IEFkYW0gTGFuZ2xleSAoR29vZ2xlKS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4xaSAoQWZmZWN0ZWQgMS4wLjEtMS4wLjFoKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjBuIChBZmZlY3RlZCAxLjAuMC0xLjAuMG0pPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOHpiIChBZmZlY3RlZCAwLjkuOC0wLjkuOHphKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTQtMzUwNTwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMDYgQXVndXN0IDIwMTQ6IDwvZHQ+PGRkPkEgRG91YmxlIEZyZWUgd2FzIGZvdW5kIHdoZW4gcHJvY2Vzc2luZyBEVExTIHBhY2tldHMuIEFuIGF0dGFja2VyIGNhbiBmb3JjZSBhbiBlcnJvciBjb25kaXRpb24gd2hpY2ggY2F1c2VzIG9wZW5zc2wgdG8gY3Jhc2ggd2hpbHN0IHByb2Nlc3NpbmcgRFRMUyBwYWNrZXRzIGR1ZSB0byBtZW1vcnkgYmVpbmcgZnJlZWQgdHdpY2UuIFRoaXMgY291bGQgbGVhZCB0byBhIERlbmlhbCBvZiBTZXJ2aWNlIGF0dGFjay4gUmVwb3J0ZWQgYnkgQWRhbSBMYW5nbGV5IGFuZCBXYW4tVGVoIENoYW5nIChHb29nbGUpLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFpIChBZmZlY3RlZCAxLjAuMS0xLjAuMWgpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMG4gKEFmZmVjdGVkIDEuMC4wLTEuMC4wbSk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44emIgKEFmZmVjdGVkIDAuOS44bS0wLjkuOHphKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTQtMDIyNDwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMDUgSnVuZSAyMDE0OiA8L2R0PjxkZD5BbiBhdHRhY2tlciBjYW4gZm9yY2UgdGhlIHVzZSBvZiB3ZWFrIGtleWluZyBtYXRlcmlhbCBpbiBPcGVuU1NMIFNTTC9UTFMgY2xpZW50cyBhbmQgc2VydmVycy4gVGhpcyBjYW4gYmUgZXhwbG9pdGVkIGJ5IGEgTWFuLWluLXRoZS1taWRkbGUgKE1JVE0pIGF0dGFjayB3aGVyZSB0aGUgYXR0YWNrZXIgY2FuIGRlY3J5cHQgYW5kIG1vZGlmeSB0cmFmZmljIGZyb20gdGhlIGF0dGFja2VkIGNsaWVudCBhbmQgc2VydmVyLiBSZXBvcnRlZCBieSBLSUtVQ0hJIE1hc2FzaGkgKExlcGlkdW0gQ28uIEx0ZC4pLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFoIChBZmZlY3RlZCAxLjAuMS0xLjAuMWcpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMG0gKEFmZmVjdGVkIDEuMC4wLTEuMC4wbCk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44emEgKEFmZmVjdGVkIDAuOS44LTAuOS44eSk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE0LTAyMjE8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDA1IEp1bmUgMjAxNDogPC9kdD48ZGQ+Qnkgc2VuZGluZyBhbiBpbnZhbGlkIERUTFMgaGFuZHNoYWtlIHRvIGFuIE9wZW5TU0wgRFRMUyBjbGllbnQgdGhlIGNvZGUgY2FuIGJlIG1hZGUgdG8gcmVjdXJzZSBldmVudHVhbGx5IGNyYXNoaW5nIGluIGEgRG9TIGF0dGFjay4gT25seSBhcHBsaWNhdGlvbnMgdXNpbmcgT3BlblNTTCBhcyBhIERUTFMgY2xpZW50IGFyZSBhZmZlY3RlZC4gUmVwb3J0ZWQgYnkgSW1yZSBSYWQgKFNlYXJjaC1MYWIgTHRkLikuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMWggKEFmZmVjdGVkIDEuMC4xLTEuMC4xZyk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wbSAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBsKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45Ljh6YSAoQWZmZWN0ZWQgMC45LjgtMC45Ljh5KTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTQtMDE5NTwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMDUgSnVuZSAyMDE0OiA8L2R0PjxkZD5BIGJ1ZmZlciBvdmVycnVuIGF0dGFjayBjYW4gYmUgdHJpZ2dlcmVkIGJ5IHNlbmRpbmcgaW52YWxpZCBEVExTIGZyYWdtZW50cyB0byBhbiBPcGVuU1NMIERUTFMgY2xpZW50IG9yIHNlcnZlci4gVGhpcyBpcyBwb3RlbnRpYWxseSBleHBsb2l0YWJsZSB0byBydW4gYXJiaXRyYXJ5IGNvZGUgb24gYSB2dWxuZXJhYmxlIGNsaWVudCBvciBzZXJ2ZXIuIE9ubHkgYXBwbGljYXRpb25zIHVzaW5nIE9wZW5TU0wgYXMgYSBEVExTIGNsaWVudCBvciBzZXJ2ZXIgYWZmZWN0ZWQuIFJlcG9ydGVkIGJ5IErDvHJpIEFlZGxhLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFoIChBZmZlY3RlZCAxLjAuMS0xLjAuMWcpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMG0gKEFmZmVjdGVkIDEuMC4wLTEuMC4wbCk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44emEgKEFmZmVjdGVkIDAuOS44by0wLjkuOHkpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxNC0zNDcwPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAzMCBNYXkgMjAxNDogPC9kdD48ZGQ+T3BlblNTTCBUTFMgY2xpZW50cyBlbmFibGluZyBhbm9ueW1vdXMgRUNESCBjaXBoZXJzdWl0ZXMgYXJlIHN1YmplY3QgdG8gYSBkZW5pYWwgb2Ygc2VydmljZSBhdHRhY2suIFJlcG9ydGVkIGJ5IEZlbGl4IEdyw7ZiZXJ0IGFuZCBJdmFuIEZyYXRyacSHIChHb29nbGUpLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFoIChBZmZlY3RlZCAxLjAuMS0xLjAuMWcpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMG0gKEFmZmVjdGVkIDEuMC4wLTEuMC4wbCk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44emEgKEFmZmVjdGVkIDAuOS44LTAuOS44eSk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDE0LTAxOTg8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDIxIEFwcmlsIDIwMTQ6IDwvZHQ+PGRkPkEgZmxhdyBpbiB0aGUgZG9fc3NsM193cml0ZSBmdW5jdGlvbiBjYW4gYWxsb3cgcmVtb3RlIGF0dGFja2VycyB0byBjYXVzZSBhIGRlbmlhbCBvZiBzZXJ2aWNlIHZpYSBhIE5VTEwgcG9pbnRlciBkZXJlZmVyZW5jZS4gVGhpcyBmbGF3IG9ubHkgYWZmZWN0cyBPcGVuU1NMIDEuMC4wIGFuZCAxLjAuMSB3aGVyZSBTU0xfTU9ERV9SRUxFQVNFX0JVRkZFUlMgaXMgZW5hYmxlZCwgd2hpY2ggaXMgbm90IHRoZSBkZWZhdWx0IGFuZCBub3QgY29tbW9uLjx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMWggKEFmZmVjdGVkIDEuMC4xLTEuMC4xZyk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wbSAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBsKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTAtNTI5ODwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMDggQXByaWwgMjAxNDogPC9kdD48ZGQ+QSByYWNlIGNvbmRpdGlvbiBpbiB0aGUgc3NsM19yZWFkX2J5dGVzIGZ1bmN0aW9uIGNhbiBhbGxvdyByZW1vdGUgYXR0YWNrZXJzIHRvIGluamVjdCBkYXRhIGFjcm9zcyBzZXNzaW9ucyBvciBjYXVzZSBhIGRlbmlhbCBvZiBzZXJ2aWNlLiBUaGlzIGZsYXcgb25seSBhZmZlY3RzIG11bHRpdGhyZWFkZWQgYXBwbGljYXRpb25zIHVzaW5nIE9wZW5TU0wgMS4wLjAgYW5kIDEuMC4xLCB3aGVyZSBTU0xfTU9ERV9SRUxFQVNFX0JVRkZFUlMgaXMgZW5hYmxlZCwgd2hpY2ggaXMgbm90IHRoZSBkZWZhdWx0IGFuZCBub3QgY29tbW9uLjx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMWggKEFmZmVjdGVkIDEuMC4xLTEuMC4xZyk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wbSAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBsKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTQtMDE2MDwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMDcgQXByaWwgMjAxNDogPC9kdD48ZGQ+QSBtaXNzaW5nIGJvdW5kcyBjaGVjayBpbiB0aGUgaGFuZGxpbmcgb2YgdGhlIFRMUyBoZWFydGJlYXQgZXh0ZW5zaW9uIGNhbiBiZSB1c2VkIHRvIHJldmVhbCB1cCB0byA2NGtCIG9mIG1lbW9yeSB0byBhIGNvbm5lY3RlZCBjbGllbnQgb3Igc2VydmVyIChhLmsuYS4gSGVhcnRibGVlZCkuIFRoaXMgaXNzdWUgZGlkIG5vdCBhZmZlY3QgdmVyc2lvbnMgb2YgT3BlblNTTCBwcmlvciB0byAxLjAuMS4gUmVwb3J0ZWQgYnkgTmVlbCBNZWh0YS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4xZyAoQWZmZWN0ZWQgMS4wLjEtMS4wLjFmKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTQtMDA3NjwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMTQgRmVicnVhcnkgMjAxNDogPC9kdD48ZGQ+Rml4IGZvciB0aGUgYXR0YWNrIGRlc2NyaWJlZCBpbiB0aGUgcGFwZXIgIlJlY292ZXJpbmcgT3BlblNTTCBFQ0RTQSBOb25jZXMgVXNpbmcgdGhlIEZMVVNIK1JFTE9BRCBDYWNoZSBTaWRlLWNoYW5uZWwgQXR0YWNrIiBSZXBvcnRlZCBieSBZdXZhbCBZYXJvbSBhbmQgTmFvbWkgQmVuZ2VyLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFnIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjAuMS0xLjAuMWYpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMG0gPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDEuMC4wLTEuMC4wbCk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44emEgKEFmZmVjdGVkIDAuOS44LTAuOS44eSk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDEzLTQzNTM8L2E+IDA2IEphbnVhcnkgMjAxNDogPC9kdD48ZGQ+QSBjYXJlZnVsbHkgY3JhZnRlZCBpbnZhbGlkIFRMUyBoYW5kc2hha2UgY291bGQgY3Jhc2ggT3BlblNTTCB3aXRoIGEgTlVMTCBwb2ludGVyIGV4Y2VwdGlvbi4gQSBtYWxpY2lvdXMgc2VydmVyIGNvdWxkIHVzZSB0aGlzIGZsYXcgdG8gY3Jhc2ggYSBjb25uZWN0aW5nIGNsaWVudC4gVGhpcyBpc3N1ZSBvbmx5IGFmZmVjdGVkIE9wZW5TU0wgMS4wLjEgdmVyc2lvbnMuIFJlcG9ydGVkIGJ5IEFudG9uIEpvaGFuc3Nvbi4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4xZiA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4wLjEtMS4wLjFlKTwvbGk+PC91bD48L2RkPjwvZGw+PGgzPjxhID4yMDEzPC9hPjwvaDM+PGRsPjxkdD48YSA+Q1ZFLTIwMTMtNjQ0OTwvYT4gMTQgRGVjZW1iZXIgMjAxMzogPC9kdD48ZGQ+QSBmbGF3IGluIE9wZW5TU0wgY2FuIGNhdXNlIGFuIGFwcGxpY2F0aW9uIHVzaW5nIE9wZW5TU0wgdG8gY3Jhc2ggd2hlbiB1c2luZyBUTFMgdmVyc2lvbiAxLjIuIFRoaXMgaXNzdWUgb25seSBhZmZlY3RlZCBPcGVuU1NMIDEuMC4xIHZlcnNpb25zLiBSZXBvcnRlZCBieSBSb24gQmFyYmVyLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFmIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAxLjAuMS0xLjAuMWUpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxMy02NDUwPC9hPiAxMyBEZWNlbWJlciAyMDEzOiA8L2R0PjxkZD5BIGZsYXcgaW4gRFRMUyBoYW5kbGluZyBjYW4gY2F1c2UgYW4gYXBwbGljYXRpb24gdXNpbmcgT3BlblNTTCBhbmQgRFRMUyB0byBjcmFzaC4gVGhpcyBpcyBub3QgYSB2dWxuZXJhYmlsaXR5IGZvciBPcGVuU1NMIHByaW9yIHRvIDEuMC4wLiBSZXBvcnRlZCBieSBEbWl0cnkgU29iaW5vdi4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4xZiA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMS4wLjEtMS4wLjFlKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjBsIChBZmZlY3RlZCAxLjAuMC0xLjAuMGspPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxMy0wMTY2PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAwNSBGZWJydWFyeSAyMDEzOiA8L2R0PjxkZD5BIGZsYXcgaW4gdGhlIE9wZW5TU0wgaGFuZGxpbmcgb2YgT0NTUCByZXNwb25zZSB2ZXJpZmljYXRpb24gY2FuIGJlIGV4cGxvaXRlZCBpbiBhIGRlbmlhbCBvZiBzZXJ2aWNlIGF0dGFjay4gUmVwb3J0ZWQgYnkgU3RlcGhlbiBIZW5zb24uIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMWQgKEFmZmVjdGVkIDEuMC4xLTEuMC4xYyk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wayAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBqKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45Ljh5IChBZmZlY3RlZCAwLjkuOC0wLjkuOHgpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxMi0yNjg2PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAwNSBGZWJydWFyeSAyMDEzOiA8L2R0PjxkZD5BIGZsYXcgaW4gdGhlIE9wZW5TU0wgaGFuZGxpbmcgb2YgQ0JDIGNpcGhlcnN1aXRlcyBpbiBUTFMgMS4xIGFuZCBUTFMgMS4yIG9uIEFFUy1OSSBzdXBwb3J0aW5nIHBsYXRmb3JtcyBjYW4gYmUgZXhwbG9pdGVkIGluIGEgRG9TIGF0dGFjay4gUmVwb3J0ZWQgYnkgQWRhbSBMYW5nbGV5IGFuZCBXb2xmZ2FuZyBFdHRsaW5nZXIuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMWQgKEFmZmVjdGVkIDEuMC4xLTEuMC4xYyk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDEzLTAxNjk8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDA0IEZlYnJ1YXJ5IDIwMTM6IDwvZHQ+PGRkPkEgd2Vha25lc3MgaW4gdGhlIGhhbmRsaW5nIG9mIENCQyBjaXBoZXJzdWl0ZXMgaW4gU1NMLCBUTFMgYW5kIERUTFMgd2hpY2ggY291bGQgbGVhZCB0byBwbGFpbnRleHQgcmVjb3ZlcnkgYnkgZXhwbG9pdGluZyB0aW1pbmcgZGlmZmVyZW5jZXMgYXJpc2luZyBkdXJpbmcgTUFDIHByb2Nlc3NpbmcuIFJlcG9ydGVkIGJ5IE5hZGhlbSBKLiBBbEZhcmRhbiBhbmQgS2VubmV0aCBHLiBQYXRlcnNvbiBvZiB0aGUgSW5mb3JtYXRpb24gU2VjdXJpdHkgR3JvdXAgUm95YWwgSG9sbG93YXksIFVuaXZlcnNpdHkgb2YgTG9uZG9uLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjFkIChBZmZlY3RlZCAxLjAuMS0xLjAuMWMpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMGsgKEFmZmVjdGVkIDEuMC4wLTEuMC4waik8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44eSAoQWZmZWN0ZWQgMC45LjgtMC45Ljh4KTwvbGk+PC91bD48L2RkPjwvZGw+PGgzPjxhID4yMDEyPC9hPjwvaDM+PGRsPjxkdD48YSA+Q1ZFLTIwMTItMjMzMzwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMTAgTWF5IDIwMTI6IDwvZHQ+PGRkPkFuIGludGVnZXIgdW5kZXJmbG93IGZsYXcsIGxlYWRpbmcgdG8gYSBidWZmZXIgb3Zlci1yZWFkLCB3YXMgZm91bmQgaW4gdGhlIHdheSBPcGVuU1NMIGhhbmRsZWQgVExTIDEuMSwgVExTIDEuMiwgYW5kIERUTFMgKERhdGFncmFtIFRyYW5zcG9ydCBMYXllciBTZWN1cml0eSkgYXBwbGljYXRpb24gZGF0YSByZWNvcmQgbGVuZ3RocyB3aGVuIHVzaW5nIGEgYmxvY2sgY2lwaGVyIGluIENCQyAoY2lwaGVyLWJsb2NrIGNoYWluaW5nKSBtb2RlLiBBIG1hbGljaW91cyBUTFMgMS4xLCBUTFMgMS4yLCBvciBEVExTIGNsaWVudCBvciBzZXJ2ZXIgY291bGQgdXNlIHRoaXMgZmxhdyB0byBjcmFzaCBpdHMgY29ubmVjdGlvbiBwZWVyLiBSZXBvcnRlZCBieSBDb2Rlbm9taWNvbi4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4xYyAoQWZmZWN0ZWQgMS4wLjEtMS4wLjFiKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjBqIChBZmZlY3RlZCAxLjAuMC0xLjAuMGkpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOHggKEFmZmVjdGVkIDAuOS44LTAuOS44dyk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDEyLTIxMzE8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDI0IEFwcmlsIDIwMTI6IDwvZHQ+PGRkPkl0IHdhcyBkaXNjb3ZlcmVkIHRoYXQgdGhlIGZpeCBmb3IgQ1ZFLTIwMTItMjExMCByZWxlYXNlZCBvbiAxOSBBcHIgMjAxMiB3YXMgbm90IHN1ZmZpY2llbnQgdG8gY29ycmVjdCB0aGUgaXNzdWUgZm9yIE9wZW5TU0wgMC45LjguIFRoaXMgaXNzdWUgb25seSBhZmZlY3RzIE9wZW5TU0wgMC45Ljh2LiBPcGVuU1NMIDEuMC4xYSBhbmQgMS4wLjBpIGFscmVhZHkgY29udGFpbiBhIHBhdGNoIHN1ZmZpY2llbnQgdG8gY29ycmVjdCBDVkUtMjAxMi0yMTEwLiBSZXBvcnRlZCBieSBSZWQgSGF0LiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45Ljh3IChBZmZlY3RlZCAwLjkuOHYpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxMi0yMTEwPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAxOSBBcHJpbCAyMDEyOiA8L2R0PjxkZD5NdWx0aXBsZSBudW1lcmljIGNvbnZlcnNpb24gZXJyb3JzLCBsZWFkaW5nIHRvIGEgYnVmZmVyIG92ZXJmbG93LCB3ZXJlIGZvdW5kIGluIHRoZSB3YXkgT3BlblNTTCBwYXJzZWQgQVNOLjEgKEFic3RyYWN0IFN5bnRheCBOb3RhdGlvbiBPbmUpIGRhdGEgZnJvbSBCSU8gKE9wZW5TU0wncyBJL08gYWJzdHJhY3Rpb24pIGlucHV0cy4gU3BlY2lhbGx5LWNyYWZ0ZWQgREVSIChEaXN0aW5ndWlzaGVkIEVuY29kaW5nIFJ1bGVzKSBlbmNvZGVkIGRhdGEgcmVhZCBmcm9tIGEgZmlsZSBvciBvdGhlciBCSU8gaW5wdXQgY291bGQgY2F1c2UgYW4gYXBwbGljYXRpb24gdXNpbmcgdGhlIE9wZW5TU0wgbGlicmFyeSB0byBjcmFzaCBvciwgcG90ZW50aWFsbHksIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUuIFJlcG9ydGVkIGJ5IFRhdmlzIE9ybWFuZHkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMWEgKEFmZmVjdGVkIDEuMC4xKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjBpIChBZmZlY3RlZCAxLjAuMC0xLjAuMGcpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOHYgKEFmZmVjdGVkIDAuOS44LTAuOS44dSk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDEyLTA4ODQ8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDEyIE1hcmNoIDIwMTI6IDwvZHQ+PGRkPkEgd2Vha25lc3MgaW4gdGhlIE9wZW5TU0wgQ01TIGFuZCBQS0NTICM3IGNvZGUgY2FuIGJlIGV4cGxvaXRlZCB1c2luZyBCbGVpY2hlbmJhY2hlcidzIGF0dGFjayBvbiBQS0NTICMxIHYxLjUgUlNBIHBhZGRpbmcgYWxzbyBrbm93biBhcyB0aGUgbWlsbGlvbiBtZXNzYWdlIGF0dGFjayAoTU1BKS4gT25seSB1c2VycyBvZiBDTVMsIFBLQ1MgIzcsIG9yIFMvTUlNRSBkZWNyeXB0aW9uIG9wZXJhdGlvbnMgYXJlIGFmZmVjdGVkLCBTU0wvVExTIGFwcGxpY2F0aW9ucyBhcmUgbm90IGFmZmVjdGVkIGJ5IHRoaXMgaXNzdWUuIFJlcG9ydGVkIGJ5IEl2YW4gTmVzdGxlcm9kZS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4waCAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBnKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45Ljh1IChBZmZlY3RlZCAwLjkuOC0wLjkuOHQpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxMi0wMDUwPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAwNCBKYW51YXJ5IDIwMTI6IDwvZHQ+PGRkPkEgZmxhdyBpbiB0aGUgZml4IHRvIENWRS0yMDExLTQxMDggY2FuIGJlIGV4cGxvaXRlZCBpbiBhIGRlbmlhbCBvZiBzZXJ2aWNlIGF0dGFjay4gT25seSBEVExTIGFwcGxpY2F0aW9ucyBhcmUgYWZmZWN0ZWQuIFJlcG9ydGVkIGJ5IEFudG9uaW8gTWFydGluLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjBnIChBZmZlY3RlZCAxLjAuMGYpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOHQgKEFmZmVjdGVkIDAuOS44cyk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDEyLTAwMjc8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDA0IEphbnVhcnkgMjAxMjogPC9kdD48ZGQ+QSBtYWxpY2lvdXMgVExTIGNsaWVudCBjYW4gc2VuZCBhbiBpbnZhbGlkIHNldCBvZiBHT1NUIHBhcmFtZXRlcnMgd2hpY2ggd2lsbCBjYXVzZSB0aGUgc2VydmVyIHRvIGNyYXNoIGR1ZSB0byBsYWNrIG9mIGVycm9yIGNoZWNraW5nLiBUaGlzIGNvdWxkIGJlIHVzZWQgaW4gYSBkZW5pYWwtb2Ytc2VydmljZSBhdHRhY2suIE9ubHkgdXNlcnMgb2YgdGhlIE9wZW5TU0wgR09TVCBFTkdJTkUgYXJlIGFmZmVjdGVkIGJ5IHRoaXMgYnVnLiBSZXBvcnRlZCBieSBBbmRyZXkgS3VsaWtvdi4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wZiAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBlKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTEtNDYxOTwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMDQgSmFudWFyeSAyMDEyOiA8L2R0PjxkZD5TdXBwb3J0IGZvciBoYW5kc2hha2UgcmVzdGFydHMgZm9yIHNlcnZlciBnYXRlZCBjcnlwdG9ncmFweSAoU0dDKSBjYW4gYmUgdXNlZCBpbiBhIGRlbmlhbC1vZi1zZXJ2aWNlIGF0dGFjay4gUmVwb3J0ZWQgYnkgR2VvcmdlIEthZGlhbmFraXMuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMGYgKEFmZmVjdGVkIDEuMC4wLTEuMC4wZSk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44cyAoQWZmZWN0ZWQgMC45LjgtMC45LjhyKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTEtNDU3NzwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMDQgSmFudWFyeSAyMDEyOiA8L2R0PjxkZD5SRkMgMzc3OSBkYXRhIGNhbiBiZSBpbmNsdWRlZCBpbiBjZXJ0aWZpY2F0ZXMsIGFuZCBpZiBpdCBpcyBtYWxmb3JtZWQsIG1heSB0cmlnZ2VyIGFuIGFzc2VydGlvbiBmYWlsdXJlLiBUaGlzIGNvdWxkIGJlIHVzZWQgaW4gYSBkZW5pYWwtb2Ytc2VydmljZSBhdHRhY2suIEJ1aWxkcyBvZiBPcGVuU1NMIGFyZSBvbmx5IHZ1bG5lcmFibGUgaWYgY29uZmlndXJlZCB3aXRoICJlbmFibGUtcmZjMzc3OSIsIHdoaWNoIGlzIG5vdCBhIGRlZmF1bHQuIFJlcG9ydGVkIGJ5IEFuZHJldyBDaGkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMGYgKEFmZmVjdGVkIDEuMC4wLTEuMC4wZSk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44cyAoQWZmZWN0ZWQgMC45LjgtMC45LjhyKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTEtNDU3NjwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMDQgSmFudWFyeSAyMDEyOiA8L2R0PjxkZD5PcGVuU1NMIGZhaWxlZCB0byBjbGVhciB0aGUgYnl0ZXMgdXNlZCBhcyBibG9jayBjaXBoZXIgcGFkZGluZyBpbiBTU0wgMy4wIHJlY29yZHMgd2hpY2ggY291bGQgbGVhayB0aGUgY29udGVudHMgb2YgbWVtb3J5IGluIHNvbWUgY2lyY3Vtc3RhbmNlcy4gUmVwb3J0ZWQgYnkgQWRhbSBMYW5nbGV5LiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjBmIChBZmZlY3RlZCAxLjAuMC0xLjAuMGUpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOHMgKEFmZmVjdGVkIDAuOS44LTAuOS44cik8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDExLTQxMDk8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDA0IEphbnVhcnkgMjAxMjogPC9kdD48ZGQ+SWYgWDUwOV9WX0ZMQUdfUE9MSUNZX0NIRUNLIGlzIHNldCBpbiBPcGVuU1NMIDAuOS44LCB0aGVuIGEgcG9saWN5IGNoZWNrIGZhaWx1cmUgY2FuIGxlYWQgdG8gYSBkb3VibGUtZnJlZS4gVGhlIGJ1ZyBkb2VzIG5vdCBvY2N1ciB1bmxlc3MgdGhpcyBmbGFnIGlzIHNldC4gVXNlcnMgb2YgT3BlblNTTCAxLjAuMCBhcmUgbm90IGFmZmVjdGVkIFJlcG9ydGVkIGJ5IEJlbiBMYXVyaWUuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOHMgKEFmZmVjdGVkIDAuOS44LTAuOS44cik8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDExLTQxMDg8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDA0IEphbnVhcnkgMjAxMjogPC9kdD48ZGQ+T3BlblNTTCB3YXMgc3VzY2VwdGFibGUgYW4gZXh0ZW5zaW9uIG9mIHRoZSBWYXVkZW5heSBwYWRkaW5nIG9yYWNsZSBhdHRhY2sgb24gQ0JDIG1vZGUgZW5jcnlwdGlvbiB3aGljaCBlbmFibGVzIGFuIGVmZmljaWVudCBwbGFpbnRleHQgcmVjb3ZlcnkgYXR0YWNrIGFnYWluc3QgdGhlIE9wZW5TU0wgaW1wbGVtZW50YXRpb24gb2YgRFRMUyBieSBleHBsb2l0aW5nIHRpbWluZyBkaWZmZXJlbmNlcyBhcmlzaW5nIGR1cmluZyBkZWNyeXB0aW9uIHByb2Nlc3NpbmcuIFJlcG9ydGVkIGJ5IE5hZGhlbSBBbGZhcmRhbiBhbmQgS2VubnkgUGF0ZXJzb24uIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAxLjAuMGYgKEFmZmVjdGVkIDEuMC4wLTEuMC4wZSk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44cyAoQWZmZWN0ZWQgMC45LjgtMC45LjhyKTwvbGk+PC91bD48L2RkPjwvZGw+PGgzPjxhID4yMDExPC9hPjwvaDM+PGRsPjxkdD48YSA+Q1ZFLTIwMTEtMzIxMDwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMDYgU2VwdGVtYmVyIDIwMTE6IDwvZHQ+PGRkPk9wZW5TU0wgc2VydmVyIGNvZGUgZm9yIGVwaGVtZXJhbCBFQ0RIIGNpcGhlcnN1aXRlcyBpcyBub3QgdGhyZWFkLXNhZmUsIGFuZCBmdXJ0aGVybW9yZSBjYW4gY3Jhc2ggaWYgYSBjbGllbnQgdmlvbGF0ZXMgdGhlIHByb3RvY29sIGJ5IHNlbmRpbmcgaGFuZHNoYWtlIG1lc3NhZ2VzIGluIGluY29ycmVjdCBvcmRlci4gT25seSBzZXJ2ZXItc2lkZSBhcHBsaWNhdGlvbnMgdGhhdCBzcGVjaWZpY2FsbHkgc3VwcG9ydCBlcGhlbWVyYWwgRUNESCBjaXBoZXJzdWl0ZXMgYXJlIGFmZmVjdGVkLCBhbmQgb25seSBpZiBlcGhlbWVyYWwgRUNESCBjaXBoZXJzdWl0ZXMgYXJlIGVuYWJsZWQgaW4gdGhlIGNvbmZpZ3VyYXRpb24uIFJlcG9ydGVkIGJ5IEFkYW0gTGFuZ2xleS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wZSAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBkKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTEtMzIwNzwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMDYgU2VwdGVtYmVyIDIwMTE6IDwvZHQ+PGRkPlVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcyBPcGVuU1NMJ3MgaW50ZXJuYWwgY2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uIHJvdXRpbmVzIGNhbiBpbmNvcnJlY3RseSBhY2NlcHQgYSBDUkwgd2hvc2UgbmV4dFVwZGF0ZSBmaWVsZCBpcyBpbiB0aGUgcGFzdC4gQXBwbGljYXRpb25zIGFyZSBvbmx5IGFmZmVjdGVkIGJ5IHRoZSBDUkwgY2hlY2tpbmcgdnVsbmVyYWJpbGl0eSBpZiB0aGV5IGVuYWJsZSBPcGVuU1NMJ3MgaW50ZXJuYWwgQ1JMIGNoZWNraW5nIHdoaWNoIGlzIG9mZiBieSBkZWZhdWx0LiBBcHBsaWNhdGlvbnMgd2hpY2ggdXNlIHRoZWlyIG93biBjdXN0b20gQ1JMIGNoZWNraW5nIChzdWNoIGFzIEFwYWNoZSkgYXJlIG5vdCBhZmZlY3RlZC4gUmVwb3J0ZWQgYnkgS2FzcGFyIEJyYW5kLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjBlIChBZmZlY3RlZCAxLjAuMC0xLjAuMGQpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxMS0wMDE0PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAwOCBGZWJydWFyeSAyMDExOiA8L2R0PjxkZD5BIGJ1ZmZlciBvdmVyLXJlYWQgZmxhdyB3YXMgZGlzY292ZXJlZCBpbiB0aGUgd2F5IE9wZW5TU0wgcGFyc2VkIHRoZSBDZXJ0aWZpY2F0ZSBTdGF0dXMgUmVxdWVzdCBUTFMgZXh0ZW5zaW9ucyBpbiBDbGllbnRIZWxsbyBUTFMgaGFuZHNoYWtlIG1lc3NhZ2VzLiBBIHJlbW90ZSBhdHRhY2tlciBjb3VsZCBwb3NzaWJseSB1c2UgdGhpcyBmbGF3IHRvIGNyYXNoIGFuIFNTTCBzZXJ2ZXIgdXNpbmcgdGhlIGFmZmVjdGVkIE9wZW5TU0wgZnVuY3Rpb25hbGl0eS4gUmVwb3J0ZWQgYnkgTmVlbCBNZWh0YS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wZCAoQWZmZWN0ZWQgMS4wLjAtMS4wLjBjKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45LjhyIChBZmZlY3RlZCAwLjkuOGgtMC45LjhxKTwvbGk+PC91bD48L2RkPjwvZGw+PGgzPjxhID4yMDEwPC9hPjwvaDM+PGRsPjxkdD48YSA+Q1ZFLTIwMTAtNDI1MjwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMDIgRGVjZW1iZXIgMjAxMDogPC9kdD48ZGQ+QW4gZXJyb3IgaW4gT3BlblNTTCdzIGV4cGVyaW1lbnRhbCBKLVBBS0UgaW1wbGVtZW50YXRpb24gd2hpY2ggY291bGQgbGVhZCB0byBzdWNjZXNzZnVsIHZhbGlkYXRpb24gYnkgc29tZW9uZSB3aXRoIG5vIGtub3dsZWRnZSBvZiB0aGUgc2hhcmVkIHNlY3JldC4gVGhlIE9wZW5TU0wgVGVhbSBzdGlsbCBjb25zaWRlciB0aGUgaW1wbGVtZW50YXRpb24gb2YgSi1QQUtFIHRvIGJlIGV4cGVyaW1lbnRhbCBhbmQgaXMgbm90IGNvbXBpbGVkIGJ5IGRlZmF1bHQuIFJlcG9ydGVkIGJ5IFNlYmFzdGlhbiBNYXJ0aW5pLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjBjIChBZmZlY3RlZCAxLjAuMC0xLjAuMGIpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxMC00MTgwPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAwMiBEZWNlbWJlciAyMDEwOiA8L2R0PjxkZD5BIGZsYXcgaW4gdGhlIE9wZW5TU0wgU1NML1RMUyBzZXJ2ZXIgY29kZSB3aGVyZSBhbiBvbGQgYnVnIHdvcmthcm91bmQgYWxsb3dzIG1hbGljaW91cyBjbGllbnRzIHRvIG1vZGlmeSB0aGUgc3RvcmVkIHNlc3Npb24gY2FjaGUgY2lwaGVyc3VpdGUuIEluIHNvbWUgY2FzZXMgdGhlIGNpcGhlcnN1aXRlIGNhbiBiZSBkb3duZ3JhZGVkIHRvIGEgd2Vha2VyIG9uZSBvbiBzdWJzZXF1ZW50IGNvbm5lY3Rpb25zLiBUaGlzIGlzc3VlIG9ubHkgYWZmZWN0cyBPcGVuU1NMIGJhc2VkIFNTTC9UTFMgc2VydmVyIGlmIGl0IHVzZXMgT3BlblNTTCdzIGludGVybmFsIGNhY2hpbmcgbWVjaGFuaXNtcyBhbmQgdGhlIFNTTF9PUF9ORVRTQ0FQRV9SRVVTRV9DSVBIRVJfQ0hBTkdFX0JVRyBmbGFnIChtYW55IGFwcGxpY2F0aW9ucyBlbmFibGUgdGhpcyBieSB1c2luZyB0aGUgU1NMX09QX0FMTCBvcHRpb24pLiBSZXBvcnRlZCBieSBNYXJ0aW4gUmV4LiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjBjIChBZmZlY3RlZCAxLjAuMC0xLjAuMGIpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOHEgKEFmZmVjdGVkIDAuOS44LTAuOS44cCk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDEwLTM4NjQ8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDE2IE5vdmVtYmVyIDIwMTA6IDwvZHQ+PGRkPkEgZmxhdyBpbiB0aGUgT3BlblNTTCBUTFMgc2VydmVyIGV4dGVuc2lvbiBjb2RlIHBhcnNpbmcgd2hpY2ggb24gYWZmZWN0ZWQgc2VydmVycyBjYW4gYmUgZXhwbG9pdGVkIGluIGEgYnVmZmVyIG92ZXJydW4gYXR0YWNrLiBBbnkgT3BlblNTTCBiYXNlZCBUTFMgc2VydmVyIGlzIHZ1bG5lcmFibGUgaWYgaXQgaXMgbXVsdGktdGhyZWFkZWQgYW5kIHVzZXMgT3BlblNTTCdzIGludGVybmFsIGNhY2hpbmcgbWVjaGFuaXNtLiBTZXJ2ZXJzIHRoYXQgYXJlIG11bHRpLXByb2Nlc3MgYW5kL29yIGRpc2FibGUgaW50ZXJuYWwgc2Vzc2lvbiBjYWNoaW5nIGFyZSBOT1QgYWZmZWN0ZWQuIFJlcG9ydGVkIGJ5IFJvYiBIdWxzd2l0LiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjBiIChBZmZlY3RlZCAxLjAuMC0xLjAuMGEpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOHAgKEFmZmVjdGVkIDAuOS44LTAuOS44byk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDEwLTE2MzM8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDAxIEp1bmUgMjAxMDogPC9kdD48ZGQ+QW4gaW52YWxpZCBSZXR1cm4gdmFsdWUgY2hlY2sgaW4gcGtleV9yc2FfdmVyaWZ5cmVjb3ZlciB3YXMgZGlzY292ZXJlZC4gV2hlbiB2ZXJpZmljYXRpb24gcmVjb3ZlcnkgZmFpbHMgZm9yIFJTQSBrZXlzIGFuIHVuaW5pdGlhbGlzZWQgYnVmZmVyIHdpdGggYW4gdW5kZWZpbmVkIGxlbmd0aCBpcyByZXR1cm5lZCBpbnN0ZWFkIG9mIGFuIGVycm9yIGNvZGUuIFRoaXMgY291bGQgbGVhZCB0byBhbiBpbmZvcm1hdGlvbiBsZWFrLiBSZXBvcnRlZCBieSBQZXRlci1NaWNoYWVsIEhhZ2VyLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMS4wLjBhIChBZmZlY3RlZCAxLjAuMCk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDEwLTA3NDI8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDAxIEp1bmUgMjAxMDogPC9kdD48ZGQ+QSBmbGF3IGluIHRoZSBoYW5kbGluZyBvZiBDTVMgc3RydWN0dXJlcyBjb250YWluaW5nIE9yaWdpbmF0b3JJbmZvIHdhcyBmb3VuZCB3aGljaCBjb3VsZCBsZWFkIHRvIGEgd3JpdGUgdG8gaW52YWxpZCBtZW1vcnkgYWRkcmVzcyBvciBkb3VibGUgZnJlZS4gQ01TIHN1cHBvcnQgaXMgZGlzYWJsZWQgYnkgZGVmYXVsdCBpbiBPcGVuU1NMIDAuOS44IHZlcnNpb25zLiBSZXBvcnRlZCBieSBSb25hbGQgTW9lc2Jlcmdlbi4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDEuMC4wYSAoQWZmZWN0ZWQgMS4wLjApPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOG8gKEFmZmVjdGVkIDAuOS44aC0wLjkuOG4pPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAxMC0wNzQwPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAyNCBNYXJjaCAyMDEwOiA8L2R0PjxkZD5JbiBUTFMgY29ubmVjdGlvbnMsIGNlcnRhaW4gaW5jb3JyZWN0bHkgZm9ybWF0dGVkIHJlY29yZHMgY2FuIGNhdXNlIGFuIE9wZW5TU0wgY2xpZW50IG9yIHNlcnZlciB0byBjcmFzaCBkdWUgdG8gYSByZWFkIGF0dGVtcHQgYXQgTlVMTC4gUmVwb3J0ZWQgYnkgQm9kbyBNb2VsbGVyIGFuZCBBZGFtIExhbmdsZXkgKEdvb2dsZSkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOG4gKEFmZmVjdGVkIDAuOS44Zi0wLjkuOG0pPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAwOS0zMjQ1PC9hPiAyMyBGZWJydWFyeSAyMDEwOiA8L2R0PjxkZD5JdCB3YXMgZGlzY292ZXJlZCB0aGF0IE9wZW5TU0wgZGlkIG5vdCBhbHdheXMgY2hlY2sgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgYm5fd2V4cGFuZCgpIGZ1bmN0aW9uLiBBbiBhdHRhY2tlciBhYmxlIHRvIHRyaWdnZXIgYSBtZW1vcnkgYWxsb2NhdGlvbiBmYWlsdXJlIGluIHRoYXQgZnVuY3Rpb24gY291bGQgY2F1c2UgYW4gYXBwbGljYXRpb24gdXNpbmcgdGhlIE9wZW5TU0wgbGlicmFyeSB0byBjcmFzaCBvciwgcG9zc2libHksIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgUmVwb3J0ZWQgYnkgTWFydGluIE9sc3NvbiwgTmVlbCBNZWh0YS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44bSA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMC45LjgtMC45LjhsKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMTAtMDQzMzwvYT4gMTkgSmFudWFyeSAyMDEwOiA8L2R0PjxkZD5BIG1pc3NpbmcgcmV0dXJuIHZhbHVlIGNoZWNrIGZsYXcgd2FzIGRpc2NvdmVyZWQgaW4gT3BlblNTTCwgdGhhdCBjb3VsZCBwb3NzaWJseSBjYXVzZSBPcGVuU1NMIHRvIGNhbGwgYSBLZXJiZXJvcyBsaWJyYXJ5IGZ1bmN0aW9uIHdpdGggaW52YWxpZCBhcmd1bWVudHMsIHJlc3VsdGluZyBpbiBhIE5VTEwgcG9pbnRlciBkZXJlZmVyZW5jZSBjcmFzaCBpbiB0aGUgTUlUIEtlcmJlcm9zIGxpYnJhcnkuIEluIGNlcnRhaW4gY29uZmlndXJhdGlvbnMsIGEgcmVtb3RlIGF0dGFja2VyIGNvdWxkIHVzZSB0aGlzIGZsYXcgdG8gY3Jhc2ggYSBUTFMvU1NMIHNlcnZlciB1c2luZyBPcGVuU1NMIGJ5IHJlcXVlc3RpbmcgS2VyYmVyb3MgY2lwaGVyIHN1aXRlcyBkdXJpbmcgdGhlIFRMUyBoYW5kc2hha2UgUmVwb3J0ZWQgYnkgVG9kZCBSaW5hbGRvLCBUb21hcyBIb2dlciAoUmVkIEhhdCkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOG4gPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDAuOS44LTAuOS44bSk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDA5LTQzNTU8L2E+IDEzIEphbnVhcnkgMjAxMDogPC9kdD48ZGQ+QSBtZW1vcnkgbGVhayBpbiB0aGUgemxpYl9zdGF0ZWZ1bF9maW5pc2ggZnVuY3Rpb24gaW4gY3J5cHRvL2NvbXAvY196bGliLmMgYWxsb3dzIHJlbW90ZSBhdHRhY2tlcnMgdG8gY2F1c2UgYSBkZW5pYWwgb2Ygc2VydmljZSB2aWEgdmVjdG9ycyB0aGF0IHRyaWdnZXIgaW5jb3JyZWN0IGNhbGxzIHRvIHRoZSBDUllQVE9fY2xlYW51cF9hbGxfZXhfZGF0YSBmdW5jdGlvbi4gUmVwb3J0ZWQgYnkgTWljaGFlbCBLIEpvaG5zb24gYW5kIEFuZHkgR3JpbW0gKHJQYXRoKS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44bSA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMC45LjgtMC45LjhsKTwvbGk+PC91bD48L2RkPjwvZGw+PGgzPjxhID4yMDA5PC9hPjwvaDM+PGRsPjxkdD48YSA+Q1ZFLTIwMDktMzU1NTwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMDUgTm92ZW1iZXIgMjAwOTogPC9kdD48ZGQ+SW1wbGVtZW50IFJGQzU3NDYgdG8gYWRkcmVzcyB2dWxuZXJhYmlsaXRpZXMgaW4gU1NML1RMUyByZW5lZ290aWF0aW9uLjx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOG0gKEFmZmVjdGVkIDAuOS44LTAuOS44bCk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDA5LTEzODY8L2E+IDAyIEp1bmUgMjAwOTogPC9kdD48ZGQ+Rml4IGEgTlVMTCBwb2ludGVyIGRlcmVmZXJlbmNlIGlmIGEgRFRMUyBzZXJ2ZXIgcmVjaWV2ZWQgQ2hhbmdlQ2lwaGVyU3BlYyBhcyBmaXJzdCByZWNvcmQuIEEgcmVtb3RlIGF0dGFja2VyIGNvdWxkIHVzZSB0aGlzIGZsYXcgdG8gY2F1c2UgYSBEVExTIHNlcnZlciB0byBjcmFzaCBSZXBvcnRlZCBieSBBbGV4IExhbS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44aSA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMC45LjgtMC45LjhoKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMDktMTM3OTwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMTIgTWF5IDIwMDk6IDwvZHQ+PGRkPlVzZS1hZnRlci1mcmVlIHZ1bG5lcmFiaWxpdHkgaW4gdGhlIGR0bHMxX3JldHJpZXZlX2J1ZmZlcmVkX2ZyYWdtZW50IGZ1bmN0aW9uIGNvdWxkIGNhdXNlIGEgY2xpZW50IGFjY2Vzc2luZyBhIG1hbGljaW91cyBEVExTIHNlcnZlciB0byBjcmFzaC4gUmVwb3J0ZWQgYnkgRGFuaWVsIE1lbnR6LCBSb2JpbiBTZWdnZWxtYW5uLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45LjhtIDxhID4oZ2l0IGNvbW1pdCk8L2E+IChBZmZlY3RlZCAwLjkuOC0wLjkuOGwpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAwOS0xMzc4PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAxMiBNYXkgMjAwOTogPC9kdD48ZGQ+Rml4IGEgZGVuaWFsIG9mIHNlcnZpY2UgZmxhdyBpbiB0aGUgRFRMUyBpbXBsZW1lbnRhdGlvbi4gSW4gZHRsczFfcHJvY2Vzc19vdXRfb2Zfc2VxX21lc3NhZ2UoKSB0aGUgY2hlY2sgaWYgdGhlIGN1cnJlbnQgbWVzc2FnZSBpcyBhbHJlYWR5IGJ1ZmZlcmVkIHdhcyBtaXNzaW5nLiBGb3IgZXZlcnkgbmV3IG1lc3NhZ2Ugd2FzIG1lbW9yeSBhbGxvY2F0ZWQsIGFsbG93aW5nIGFuIGF0dGFja2VyIHRvIHBlcmZvcm0gYW4gZGVuaWFsIG9mIHNlcnZpY2UgYXR0YWNrIGFnYWluc3QgYSBEVExTIHNlcnZlciBieSBzZW5kaW5nIG91dCBvZiBzZXEgaGFuZHNoYWtlIG1lc3NhZ2VzIHVudGlsIHRoZXJlIGlzIG5vIG1lbW9yeSBsZWZ0LiBSZXBvcnRlZCBieSBEYW5pZWwgTWVudHosIFJvYmluIFNlZ2dlbG1hbm4uIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOG0gPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDAuOS44LTAuOS44bCk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDA5LTEzNzc8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDEyIE1heSAyMDA5OiA8L2R0PjxkZD5GaXggYSBkZW5pYWwgb2Ygc2VydmljZSBmbGF3IGluIHRoZSBEVExTIGltcGxlbWVudGF0aW9uLiBSZWNvcmRzIGFyZSBidWZmZXJlZCBpZiB0aGV5IGFycml2ZSB3aXRoIGEgZnV0dXJlIGVwb2NoIHRvIGJlIHByb2Nlc3NlZCBhZnRlciBmaW5pc2hpbmcgdGhlIGNvcnJlc3BvbmRpbmcgaGFuZHNoYWtlLiBUaGVyZSBpcyBjdXJyZW50bHkgbm8gbGltaXRhdGlvbiB0byB0aGlzIGJ1ZmZlciBhbGxvd2luZyBhbiBhdHRhY2tlciB0byBwZXJmb3JtIGEgRE9TIGF0dGFjayB0byBhIERUTFMgc2VydmVyIGJ5IHNlbmRpbmcgcmVjb3JkcyB3aXRoIGZ1dHVyZSBlcG9jaHMgdW50aWwgdGhlcmUgaXMgbm8gbWVtb3J5IGxlZnQuIFJlcG9ydGVkIGJ5IERhbmllbCBNZW50eiwgUm9iaW4gU2VnZ2VsbWFubi4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44bSA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMC45LjgtMC45LjhsKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMDktMDc4OTwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMjUgTWFyY2ggMjAwOTogPC9kdD48ZGQ+V2hlbiBhIG1hbGZvcm1lZCBBU04xIHN0cnVjdHVyZSBpcyByZWNlaXZlZCBpdCdzIGNvbnRlbnRzIGFyZSBmcmVlZCB1cCBhbmQgemVyb2VkIGFuZCBhbiBlcnJvciBjb25kaXRpb24gcmV0dXJuZWQuIE9uIGEgc21hbGwgbnVtYmVyIG9mIHBsYXRmb3JtcyB3aGVyZSBzaXplb2YobG9uZykgJmx0OyBzaXplb2Yodm9pZCAqKSAoZm9yIGV4YW1wbGUgV0lONjQpIHRoaXMgY2FuIGNhdXNlIGFuIGludmFsaWQgbWVtb3J5IGFjY2VzcyBsYXRlciByZXN1bHRpbmcgaW4gYSBjcmFzaCB3aGVuIHNvbWUgaW52YWxpZCBzdHJ1Y3R1cmVzIGFyZSByZWFkLCBmb3IgZXhhbXBsZSBSU0EgcHVibGljIGtleXMuIFJlcG9ydGVkIGJ5IFBhb2xvIEdhbmNpLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45LjhrIChBZmZlY3RlZCAwLjkuOC0wLjkuOGopPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAwOS0wNTkxPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAyNSBNYXJjaCAyMDA5OiA8L2R0PjxkZD5UaGUgZnVuY3Rpb24gQ01TX3ZlcmlmeSgpIGRvZXMgbm90IGNvcnJlY3RseSBoYW5kbGUgYW4gZXJyb3IgY29uZGl0aW9uIGludm9sdmluZyBtYWxmb3JtZWQgc2lnbmVkIGF0dHJpYnV0ZXMuIFRoaXMgd2lsbCBjYXVzZSBhbiBpbnZhbGlkIHNldCBvZiBzaWduZWQgYXR0cmlidXRlcyB0byBhcHBlYXIgdmFsaWQgYW5kIGNvbnRlbnQgZGlnZXN0cyB3aWxsIG5vdCBiZSBjaGVja2VkLiBSZXBvcnRlZCBieSBJdmFuIE5lc3RsZXJvZGUsIElCTS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44ayAoQWZmZWN0ZWQgMC45LjhoLTAuOS44aik8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDA5LTA1OTA8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDI1IE1hcmNoIDIwMDk6IDwvZHQ+PGRkPlRoZSBmdW5jdGlvbiBBU04xX1NUUklOR19wcmludF9leCgpIHdoZW4gdXNlZCB0byBwcmludCBhIEJNUFN0cmluZyBvciBVbml2ZXJzYWxTdHJpbmcgd2lsbCBjcmFzaCB3aXRoIGFuIGludmFsaWQgbWVtb3J5IGFjY2VzcyBpZiB0aGUgZW5jb2RlZCBsZW5ndGggb2YgdGhlIHN0cmluZyBpcyBpbGxlZ2FsLiBBbnkgT3BlblNTTCBhcHBsaWNhdGlvbiB3aGljaCBwcmludHMgb3V0IHRoZSBjb250ZW50cyBvZiBhIGNlcnRpZmljYXRlIGNvdWxkIGJlIGFmZmVjdGVkIGJ5IHRoaXMgYnVnLCBpbmNsdWRpbmcgU1NMIHNlcnZlcnMsIGNsaWVudHMgYW5kIFMvTUlNRSBzb2Z0d2FyZS48dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45LjhrIChBZmZlY3RlZCAwLjkuOC0wLjkuOGopPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAwOS0xMzg3PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAwNSBGZWJydWFyeSAyMDA5OiA8L2R0PjxkZD5GaXggZGVuaWFsIG9mIHNlcnZpY2UgZmxhdyBkdWUgaW4gdGhlIERUTFMgaW1wbGVtZW50YXRpb24uIEEgcmVtb3RlIGF0dGFja2VyIGNvdWxkIHVzZSB0aGlzIGZsYXcgdG8gY2F1c2UgYSBEVExTIHNlcnZlciB0byBjcmFzaC4gUmVwb3J0ZWQgYnkgUm9iaW4gU2VnZ2VsbWFubi4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44bSAoQWZmZWN0ZWQgMC45LjgtMC45LjhsKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMDgtNTA3NzwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMDcgSmFudWFyeSAyMDA5OiA8L2R0PjxkZD5UaGUgR29vZ2xlIFNlY3VyaXR5IFRlYW0gZGlzY292ZXJlZCBzZXZlcmFsIGZ1bmN0aW9ucyBpbnNpZGUgT3BlblNTTCBpbmNvcnJlY3RseSBjaGVja2VkIHRoZSByZXN1bHQgYWZ0ZXIgY2FsbGluZyB0aGUgRVZQX1ZlcmlmeUZpbmFsIGZ1bmN0aW9uLCBhbGxvd2luZyBhIG1hbGZvcm1lZCBzaWduYXR1cmUgdG8gYmUgdHJlYXRlZCBhcyBhIGdvb2Qgc2lnbmF0dXJlIHJhdGhlciB0aGFuIGFzIGFuIGVycm9yLiBUaGlzIGlzc3VlIGFmZmVjdGVkIHRoZSBzaWduYXR1cmUgY2hlY2tzIG9uIERTQSBhbmQgRUNEU0Ega2V5cyB1c2VkIHdpdGggU1NML1RMUy4gT25lIHdheSB0byBleHBsb2l0IHRoaXMgZmxhdyB3b3VsZCBiZSBmb3IgYSByZW1vdGUgYXR0YWNrZXIgd2hvIGlzIGluIGNvbnRyb2wgb2YgYSBtYWxpY2lvdXMgc2VydmVyIG9yIHdobyBjYW4gdXNlIGEgJ21hbiBpbiB0aGUgbWlkZGxlJyBhdHRhY2sgdG8gcHJlc2VudCBhIG1hbGZvcm1lZCBTU0wvVExTIHNpZ25hdHVyZSBmcm9tIGEgY2VydGlmaWNhdGUgY2hhaW4gdG8gYSB2dWxuZXJhYmxlIGNsaWVudCwgYnlwYXNzaW5nIHZhbGlkYXRpb24uIFJlcG9ydGVkIGJ5IGdvb2dsZS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44aiAoQWZmZWN0ZWQgMC45LjgtMC45LjhpKTwvbGk+PC91bD48L2RkPjwvZGw+PGgzPjxhID4yMDA4PC9hPjwvaDM+PGRsPjxkdD48YSA+Q1ZFLTIwMDgtMTY3MjwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMjggTWF5IDIwMDg6IDwvZHQ+PGRkPlRlc3RpbmcgdXNpbmcgdGhlIENvZGVub21pY29uIFRMUyB0ZXN0IHN1aXRlIGRpc2NvdmVyZWQgYSBmbGF3IGlmIHRoZSAnU2VydmVyIEtleSBleGNoYW5nZSBtZXNzYWdlJyBpcyBvbWl0dGVkIGZyb20gYSBUTFMgaGFuZHNoYWtlIGluIE9wZW5TU0wgMC45LjhmIGFuZCBPcGVuU1NMIDAuOS44Zy4gSWYgYSBjbGllbnQgY29ubmVjdHMgdG8gYSBtYWxpY2lvdXMgc2VydmVyIHdpdGggcGFydGljdWxhciBjaXBoZXIgc3VpdGVzLCB0aGUgc2VydmVyIGNvdWxkIGNhdXNlIHRoZSBjbGllbnQgdG8gY3Jhc2guIFJlcG9ydGVkIGJ5IGNvZGVub21pY29uLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45LjhoIChBZmZlY3RlZCAwLjkuOGYtMC45LjhnKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMDgtMDg5MTwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMjggTWF5IDIwMDg6IDwvZHQ+PGRkPlRlc3RpbmcgdXNpbmcgdGhlIENvZGVub21pY29uIFRMUyB0ZXN0IHN1aXRlIGRpc2NvdmVyZWQgYSBmbGF3IGluIHRoZSBoYW5kbGluZyBvZiBzZXJ2ZXIgbmFtZSBleHRlbnNpb24gZGF0YSBpbiBPcGVuU1NMIDAuOS44ZiBhbmQgT3BlblNTTCAwLjkuOGcuIElmIE9wZW5TU0wgaGFzIGJlZW4gY29tcGlsZWQgdXNpbmcgdGhlIG5vbi1kZWZhdWx0IFRMUyBzZXJ2ZXIgbmFtZSBleHRlbnNpb25zLCBhIHJlbW90ZSBhdHRhY2tlciBjb3VsZCBzZW5kIGEgY2FyZWZ1bGx5IGNyYWZ0ZWQgcGFja2V0IHRvIGEgc2VydmVyIGFwcGxpY2F0aW9uIHVzaW5nIE9wZW5TU0wgYW5kIGNhdXNlIGl0IHRvIGNyYXNoLiBSZXBvcnRlZCBieSBjb2Rlbm9taWNvbi4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44aCAoQWZmZWN0ZWQgMC45LjhmLTAuOS44Zyk8L2xpPjwvdWw+PC9kZD48L2RsPjxoMz48YSA+MjAwNzwvYT48L2gzPjxkbD48ZHQ+PGEgPkNWRS0yMDA3LTU1MDI8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDI5IE5vdmVtYmVyIDIwMDc6IDwvZHQ+PGRkPlRoZSBQUk5HIGltcGxlbWVudGF0aW9uIGZvciB0aGUgT3BlblNTTCBGSVBTIE9iamVjdCBNb2R1bGUgMS4xLjEgZG9lcyBub3QgcGVyZm9ybSBhdXRvLXNlZWRpbmcgZHVyaW5nIHRoZSBGSVBTIHNlbGYtdGVzdCwgd2hpY2ggZ2VuZXJhdGVzIHJhbmRvbSBkYXRhIHRoYXQgaXMgbW9yZSBwcmVkaWN0YWJsZSB0aGFuIGV4cGVjdGVkIGFuZCBtYWtlcyBpdCBlYXNpZXIgZm9yIGF0dGFja2VycyB0byBieXBhc3MgcHJvdGVjdGlvbiBtZWNoYW5pc21zIHRoYXQgcmVseSBvbiB0aGUgcmFuZG9tbmVzcy4gUmVwb3J0ZWQgYnkgR2VvZmYgTG93ZS4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIGZpcHMtMS4xLjIgKEFmZmVjdGVkIGZpcHMtMS4xLjEpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAwNy01MTM1PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAxMiBPY3RvYmVyIDIwMDc6IDwvZHQ+PGRkPkEgZmxhdyB3YXMgZm91bmQgaW4gdGhlIFNTTF9nZXRfc2hhcmVkX2NpcGhlcnMoKSB1dGlsaXR5IGZ1bmN0aW9uLiBBbiBhdHRhY2tlciBjb3VsZCBzZW5kIGEgbGlzdCBvZiBjaXBoZXJzIHRvIGFuIGFwcGxpY2F0aW9uIHRoYXQgdXNlZCB0aGlzIGZ1bmN0aW9uIGFuZCBvdmVycnVuIGEgYnVmZmVyIHdpdGggYSBzaW5nbGUgYnl0ZS4gRmV3IGFwcGxpY2F0aW9ucyBtYWtlIHVzZSBvZiB0aGlzIHZ1bG5lcmFibGUgZnVuY3Rpb24gYW5kIGdlbmVyYWxseSBpdCBpcyB1c2VkIG9ubHkgd2hlbiBhcHBsaWNhdGlvbnMgYXJlIGNvbXBpbGVkIGZvciBkZWJ1Z2dpbmcuIFJlcG9ydGVkIGJ5IE1vcml0eiBKb2RlaXQuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOGYgKEFmZmVjdGVkIDAuOS44LTAuOS44ZSk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDA3LTQ5OTU8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDEyIE9jdG9iZXIgMjAwNzogPC9kdD48ZGQ+QSBmbGF3IGluIERUTFMgc3VwcG9ydC4gQW4gYXR0YWNrZXIgY291bGQgY3JlYXRlIGEgbWFsaWNpb3VzIGNsaWVudCBvciBzZXJ2ZXIgdGhhdCBjb3VsZCB0cmlnZ2VyIGEgaGVhcCBvdmVyZmxvdy4gVGhpcyBpcyBwb3NzaWJseSBleHBsb2l0YWJsZSB0byBydW4gYXJiaXRyYXJ5IGNvZGUsIGJ1dCBpdCBoYXMgbm90IGJlZW4gdmVyaWZpZWQuIFJlcG9ydGVkIGJ5IEFuZHkgUG9seWFrb3YuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOGYgKEFmZmVjdGVkIDAuOS44LTAuOS44ZSk8L2xpPjwvdWw+PC9kZD48L2RsPjxoMz48YSA+MjAwNjwvYT48L2gzPjxkbD48ZHQ+PGEgPkNWRS0yMDA2LTQzNDM8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDI4IFNlcHRlbWJlciAyMDA2OiA8L2R0PjxkZD5BIGZsYXcgaW4gdGhlIFNTTHYyIGNsaWVudCBjb2RlIHdhcyBkaXNjb3ZlcmVkLiBXaGVuIGEgY2xpZW50IGFwcGxpY2F0aW9uIHVzZWQgT3BlblNTTCB0byBjcmVhdGUgYW4gU1NMdjIgY29ubmVjdGlvbiB0byBhIG1hbGljaW91cyBzZXJ2ZXIsIHRoYXQgc2VydmVyIGNvdWxkIGNhdXNlIHRoZSBjbGllbnQgdG8gY3Jhc2guIFJlcG9ydGVkIGJ5IG9wZW5zc2wuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOGQgKEFmZmVjdGVkIDAuOS44LTAuOS44Yyk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS43bCAoQWZmZWN0ZWQgMC45LjctMC45LjdrKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMDYtMzczODwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMjggU2VwdGVtYmVyIDIwMDY6IDwvZHQ+PGRkPkEgYnVmZmVyIG92ZXJmbG93IHdhcyBkaXNjb3ZlcmVkIGluIHRoZSBTU0xfZ2V0X3NoYXJlZF9jaXBoZXJzKCkgdXRpbGl0eSBmdW5jdGlvbi4gQW4gYXR0YWNrZXIgY291bGQgc2VuZCBhIGxpc3Qgb2YgY2lwaGVycyB0byBhbiBhcHBsaWNhdGlvbiB0aGF0IHVzZXMgdGhpcyBmdW5jdGlvbiBhbmQgb3ZlcnJ1biBhIGJ1ZmZlci4gUmVwb3J0ZWQgYnkgb3BlbnNzbC4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44ZCAoQWZmZWN0ZWQgMC45LjgtMC45LjhjKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45LjdsIChBZmZlY3RlZCAwLjkuNy0wLjkuN2spPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAwNi0yOTQwPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAyOCBTZXB0ZW1iZXIgMjAwNjogPC9kdD48ZGQ+Q2VydGFpbiB0eXBlcyBvZiBwdWJsaWMga2V5IGNhbiB0YWtlIGRpc3Byb3BvcnRpb25hdGUgYW1vdW50cyBvZiB0aW1lIHRvIHByb2Nlc3MuIFRoaXMgY291bGQgYmUgdXNlZCBieSBhbiBhdHRhY2tlciBpbiBhIGRlbmlhbCBvZiBzZXJ2aWNlIGF0dGFjay4gUmVwb3J0ZWQgYnkgb3BlbnNzbC4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44ZCAoQWZmZWN0ZWQgMC45LjgtMC45LjhjKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45LjdsIChBZmZlY3RlZCAwLjkuNy0wLjkuN2spPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAwNi0yOTM3PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAyOCBTZXB0ZW1iZXIgMjAwNjogPC9kdD48ZGQ+RHVyaW5nIHRoZSBwYXJzaW5nIG9mIGNlcnRhaW4gaW52YWxpZCBBU04uMSBzdHJ1Y3R1cmVzIGFuIGVycm9yIGNvbmRpdGlvbiBpcyBtaXNoYW5kbGVkLiBUaGlzIGNhbiByZXN1bHQgaW4gYW4gaW5maW5pdGUgbG9vcCB3aGljaCBjb25zdW1lcyBzeXN0ZW0gbWVtb3J5IFJlcG9ydGVkIGJ5IG9wZW5zc2wuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuOGQgKEFmZmVjdGVkIDAuOS44LTAuOS44Yyk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS43bCAoQWZmZWN0ZWQgMC45LjctMC45LjdrKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMDYtNDMzOTwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMDUgU2VwdGVtYmVyIDIwMDY6IDwvZHQ+PGRkPkRhbmllbCBCbGVpY2hlbmJhY2hlciBkaXNjb3ZlcmVkIGFuIGF0dGFjayBvbiBQS0NTICMxIHYxLjUgc2lnbmF0dXJlcyB3aGVyZSB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMgaXQgbWF5IGJlIHBvc3NpYmxlIGZvciBhbiBhdHRhY2tlciB0byBmb3JnZSBhIFBLQ1MgIzEgdjEuNSBzaWduYXR1cmUgdGhhdCB3b3VsZCBiZSBpbmNvcnJlY3RseSB2ZXJpZmllZCBieSBPcGVuU1NMLiBSZXBvcnRlZCBieSBvcGVuc3NsLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45LjhjIChBZmZlY3RlZCAwLjkuOC0wLjkuOGIpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuN2sgKEFmZmVjdGVkIDAuOS43LTAuOS43aik8L2xpPjwvdWw+PC9kZD48L2RsPjxoMz48YSA+MjAwNTwvYT48L2gzPjxkbD48ZHQ+PGEgPkNWRS0yMDA1LTI5Njk8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDExIE9jdG9iZXIgMjAwNTogPC9kdD48ZGQ+QSBkZXByZWNhdGVkIG9wdGlvbiwgU1NMX09QX01JU0VfU1NMVjJfUlNBX1BBRERJTkcsIGNvdWxkIGFsbG93IGFuIGF0dGFja2VyIGFjdGluZyBhcyBhICJtYW4gaW4gdGhlIG1pZGRsZSIgdG8gZm9yY2UgYSBjb25uZWN0aW9uIHRvIGRvd25ncmFkZSB0byBTU0wgMi4wIGV2ZW4gaWYgYm90aCBwYXJ0aWVzIHN1cHBvcnQgYmV0dGVyIHByb3RvY29scy4gUmVwb3J0ZWQgYnkgcmVzZWFyY2hlci4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS44YSAoQWZmZWN0ZWQgMC45LjgpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuN2ggKEFmZmVjdGVkIDAuOS43LTAuOS43Zyk8L2xpPjwvdWw+PC9kZD48L2RsPjxoMz48YSA+MjAwNDwvYT48L2gzPjxkbD48ZHQ+PGEgPkNWRS0yMDA0LTA5NzU8L2E+IDMwIFNlcHRlbWJlciAyMDA0OiA8L2R0PjxkZD5UaGUgZGVyX2Nob3Agc2NyaXB0IGNyZWF0ZWQgdGVtcG9yYXJ5IGZpbGVzIGluc2VjdXJlbHkgd2hpY2ggY291bGQgYWxsb3cgbG9jYWwgdXNlcnMgdG8gb3ZlcndyaXRlIGZpbGVzIHZpYSBhIHN5bWxpbmsgYXR0YWNrIG9uIHRlbXBvcmFyeSBmaWxlcy4gTm90ZSB0aGF0IGl0IGlzIHF1aXRlIHVubGlrZWx5IHRoYXQgYSB1c2VyIHdvdWxkIGJlIHVzaW5nIHRoZSByZWR1bmRhbnQgZGVyX2Nob3Agc2NyaXB0LCBhbmQgdGhpcyBzY3JpcHQgd2FzIHJlbW92ZWQgZnJvbSB0aGUgT3BlblNTTCBkaXN0cmlidXRpb24uPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS43ZiA8YSA+KGdpdCBjb21taXQpPC9hPiAoQWZmZWN0ZWQgMC45LjctMC45LjdlKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45LjYtY3ZzIChBZmZlY3RlZCAwLjkuNi0wLjkuNm0pPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAwNC0wMTEyPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAxNyBNYXJjaCAyMDA0OiA8L2R0PjxkZD5BIGZsYXcgaW4gU1NML1RMUyBoYW5kc2hha2luZyBjb2RlIHdoZW4gdXNpbmcgS2VyYmVyb3MgY2lwaGVyc3VpdGVzLiBBIHJlbW90ZSBhdHRhY2tlciBjb3VsZCBwZXJmb3JtIGEgY2FyZWZ1bGx5IGNyYWZ0ZWQgU1NML1RMUyBoYW5kc2hha2UgYWdhaW5zdCBhIHNlcnZlciBjb25maWd1cmVkIHRvIHVzZSBLZXJiZXJvcyBjaXBoZXJzdWl0ZXMgaW4gc3VjaCBhIHdheSBhcyB0byBjYXVzZSBPcGVuU1NMIHRvIGNyYXNoLiBNb3N0IGFwcGxpY2F0aW9ucyBoYXZlIG5vIGFiaWxpdHkgdG8gdXNlIEtlcmJlcm9zIGNpcGhlcnN1aXRlcyBhbmQgd2lsbCB0aGVyZWZvcmUgYmUgdW5hZmZlY3RlZC4gUmVwb3J0ZWQgYnkgT3BlblNTTCBncm91cCAoU3RlcGhlbiBIZW5zb24pLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45LjdkIChBZmZlY3RlZCAwLjkuN2EtMC45LjdjKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMDQtMDA4MTwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMTcgTWFyY2ggMjAwNDogPC9kdD48ZGQ+VGhlIENvZGVub21pY29uIFRMUyBUZXN0IFRvb2wgZm91bmQgdGhhdCBzb21lIHVua25vd24gbWVzc2FnZSB0eXBlcyB3ZXJlIGhhbmRsZWQgaW5jb3JyZWN0bHksIGFsbG93aW5nIGEgcmVtb3RlIGF0dGFja2VyIHRvIGNhdXNlIGEgZGVuaWFsIG9mIHNlcnZpY2UgKGluZmluaXRlIGxvb3ApLiBSZXBvcnRlZCBieSBPcGVuU1NMIGdyb3VwLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45LjZkIChBZmZlY3RlZCAwLjkuNi0wLjkuNmMpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAwNC0wMDc5PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAxNyBNYXJjaCAyMDA0OiA8L2R0PjxkZD5UaGUgQ29kZW5vbWljb24gVExTIFRlc3QgVG9vbCB1bmNvdmVyZWQgYSBudWxsLXBvaW50ZXIgYXNzaWdubWVudCBpbiB0aGUgZG9fY2hhbmdlX2NpcGhlcl9zcGVjKCkgZnVuY3Rpb24uIEEgcmVtb3RlIGF0dGFja2VyIGNvdWxkIHBlcmZvcm0gYSBjYXJlZnVsbHkgY3JhZnRlZCBTU0wvVExTIGhhbmRzaGFrZSBhZ2FpbnN0IGEgc2VydmVyIHRoYXQgdXNlZCB0aGUgT3BlblNTTCBsaWJyYXJ5IGluIHN1Y2ggYSB3YXkgYXMgdG8gY2F1c2UgYSBjcmFzaC4gUmVwb3J0ZWQgYnkgT3BlblNTTCBncm91cC4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS43ZCAoQWZmZWN0ZWQgMC45LjctMC45LjdjKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45LjZtIChBZmZlY3RlZCAwLjkuNmMtMC45LjZsKTwvbGk+PC91bD48L2RkPjwvZGw+PGgzPjxhID4yMDAzPC9hPjwvaDM+PGRsPjxkdD48YSA+Q1ZFLTIwMDMtMDg1MTwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMDQgTm92ZW1iZXIgMjAwMzogPC9kdD48ZGQ+QSBmbGF3IGluIE9wZW5TU0wgMC45LjZrIChvbmx5KSB3b3VsZCBjYXVzZSBjZXJ0YWluIEFTTi4xIHNlcXVlbmNlcyB0byB0cmlnZ2VyIGEgbGFyZ2UgcmVjdXJzaW9uLiBPbiBwbGF0Zm9ybXMgc3VjaCBhcyBXaW5kb3dzIHRoaXMgbGFyZ2UgcmVjdXJzaW9uIGNhbm5vdCBiZSBoYW5kbGVkIGNvcnJlY3RseSBhbmQgc28gdGhlIGJ1ZyBjYXVzZXMgT3BlblNTTCB0byBjcmFzaC4gQSByZW1vdGUgYXR0YWNrZXIgY291bGQgZXhwbG9pdCB0aGlzIGZsYXcgaWYgdGhleSBjYW4gc2VuZCBhcmJpdHJhcnkgQVNOLjEgc2VxdWVuY2VzIHdoaWNoIHdvdWxkIGNhdXNlIE9wZW5TU0wgdG8gY3Jhc2guIFRoaXMgY291bGQgYmUgcGVyZm9ybWVkIGZvciBleGFtcGxlIGJ5IHNlbmRpbmcgYSBjbGllbnQgY2VydGlmaWNhdGUgdG8gYSBTU0wvVExTIGVuYWJsZWQgc2VydmVyIHdoaWNoIGlzIGNvbmZpZ3VyZWQgdG8gYWNjZXB0IHRoZW0uIFJlcG9ydGVkIGJ5IE5vdmVsbC4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS42bCAoQWZmZWN0ZWQgMC45LjZrKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMDMtMDU0NTwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMzAgU2VwdGVtYmVyIDIwMDM6IDwvZHQ+PGRkPkNlcnRhaW4gQVNOLjEgZW5jb2RpbmdzIHRoYXQgd2VyZSByZWplY3RlZCBhcyBpbnZhbGlkIGJ5IHRoZSBwYXJzZXIgY291bGQgdHJpZ2dlciBhIGJ1ZyBpbiB0aGUgZGVhbGxvY2F0aW9uIG9mIHRoZSBjb3JyZXNwb25kaW5nIGRhdGEgc3RydWN0dXJlLCBjb3JydXB0aW5nIHRoZSBzdGFjaywgbGVhZGluZyB0byBhIGNyYXNoLiBSZXBvcnRlZCBieSBOSVNDQy4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS43YyAoQWZmZWN0ZWQgMC45LjctMC45LjdiKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMDMtMDU0NDwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMzAgU2VwdGVtYmVyIDIwMDM6IDwvZHQ+PGRkPkluY29ycmVjdCB0cmFja2luZyBvZiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gY2VydGFpbiBBU04uMSBpbnB1dHMgY291bGQgYWxsb3cgcmVtb3RlIGF0dGFja2VycyB0byBjYXVzZSBhIGRlbmlhbCBvZiBzZXJ2aWNlIChjcmFzaCkgYnkgc2VuZGluZyBhbiBTU0wgY2xpZW50IGNlcnRpZmljYXRlIHRoYXQgY2F1c2VzIE9wZW5TU0wgdG8gcmVhZCBwYXN0IHRoZSBlbmQgb2YgYSBidWZmZXIgd2hlbiB0aGUgbG9uZyBmb3JtIGlzIHVzZWQuIFJlcG9ydGVkIGJ5IE5JU0NDLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45LjdjIChBZmZlY3RlZCAwLjkuNy0wLjkuN2IpPC9saT48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuNmsgKEFmZmVjdGVkIDAuOS42LTAuOS42aik8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDAzLTA1NDM8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDMwIFNlcHRlbWJlciAyMDAzOiA8L2R0PjxkZD5BbiBpbnRlZ2VyIG92ZXJmbG93IGNvdWxkIGFsbG93IHJlbW90ZSBhdHRhY2tlcnMgdG8gY2F1c2UgYSBkZW5pYWwgb2Ygc2VydmljZSAoY3Jhc2gpIHZpYSBhbiBTU0wgY2xpZW50IGNlcnRpZmljYXRlIHdpdGggY2VydGFpbiBBU04uMSB0YWcgdmFsdWVzLiBSZXBvcnRlZCBieSBOSVNDQy4gPHVsPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS43YyAoQWZmZWN0ZWQgMC45LjctMC45LjdiKTwvbGk+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45LjZrIChBZmZlY3RlZCAwLjkuNi0wLjkuNmopPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAwMy0wMTMxPC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAxOSBNYXJjaCAyMDAzOiA8L2R0PjxkZD5UaGUgU1NMIGFuZCBUTFMgY29tcG9uZW50cyBhbGxvd2VkIHJlbW90ZSBhdHRhY2tlcnMgdG8gcGVyZm9ybSBhbiB1bmF1dGhvcml6ZWQgUlNBIHByaXZhdGUga2V5IG9wZXJhdGlvbiB2aWEgYSBtb2RpZmllZCBCbGVpY2hlbmJhY2hlciBhdHRhY2sgdGhhdCB1c2VzIGEgbGFyZ2UgbnVtYmVyIG9mIFNTTCBvciBUTFMgY29ubmVjdGlvbnMgdXNpbmcgUEtDUyAjMSB2MS41IHBhZGRpbmcgdGhhdCBjYXVzZWQgT3BlblNTTCB0byBsZWFrIGluZm9ybWF0aW9uIHJlZ2FyZGluZyB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gY2lwaGVydGV4dCBhbmQgdGhlIGFzc29jaWF0ZWQgcGxhaW50ZXh0LCBha2EgdGhlICJLbGltYS1Qb2tvcm55LVJvc2EgYXR0YWNrIjx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuN2IgKEFmZmVjdGVkIDAuOS43LTAuOS43YSk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS42aiAoQWZmZWN0ZWQgMC45LjYtMC45LjZpKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMDMtMDE0NzwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMTQgTWFyY2ggMjAwMzogPC9kdD48ZGQ+UlNBIGJsaW5kaW5nIHdhcyBub3QgZW5hYmxlZCBieSBkZWZhdWx0LCB3aGljaCBjb3VsZCBhbGxvdyBsb2NhbCBhbmQgcmVtb3RlIGF0dGFja2VycyB0byBvYnRhaW4gYSBzZXJ2ZXIncyBwcml2YXRlIGtleSBieSBkZXRlcm1pbmluZyBmYWN0b3JzIHVzaW5nIHRpbWluZyBkaWZmZXJlbmNlcyBvbiAoMSkgdGhlIG51bWJlciBvZiBleHRyYSByZWR1Y3Rpb25zIGR1cmluZyBNb250Z29tZXJ5IHJlZHVjdGlvbiwgYW5kICgyKSB0aGUgdXNlIG9mIGRpZmZlcmVudCBpbnRlZ2VyIG11bHRpcGxpY2F0aW9uIGFsZ29yaXRobXMgKCJLYXJhdHN1YmEiIGFuZCBub3JtYWwpLjx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuN2IgKEFmZmVjdGVkIDAuOS43LTAuOS43YSk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS42aiAoQWZmZWN0ZWQgMC45LjYtMC45LjZpKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMDMtMDA3ODwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMTkgRmVicnVhcnkgMjAwMzogPC9kdD48ZGQ+c2wzX2dldF9yZWNvcmQgaW4gczNfcGt0LmMgZGlkIG5vdCBwZXJmb3JtIGEgTUFDIGNvbXB1dGF0aW9uIGlmIGFuIGluY29ycmVjdCBibG9jayBjaXBoZXIgcGFkZGluZyB3YXMgdXNlZCwgY2F1c2luZyBhbiBpbmZvcm1hdGlvbiBsZWFrICh0aW1pbmcgZGlzY3JlcGFuY3kpIHRoYXQgbWF5IG1ha2UgaXQgZWFzaWVyIHRvIGxhdW5jaCBjcnlwdG9ncmFwaGljIGF0dGFja3MgdGhhdCByZWx5IG9uIGRpc3Rpbmd1aXNoaW5nIGJldHdlZW4gcGFkZGluZyBhbmQgTUFDIHZlcmlmaWNhdGlvbiBlcnJvcnMsIHBvc3NpYmx5IGxlYWRpbmcgdG8gZXh0cmFjdGlvbiBvZiB0aGUgb3JpZ2luYWwgcGxhaW50ZXh0LCBha2EgdGhlICJWYXVkZW5heSB0aW1pbmcgYXR0YWNrLiI8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45LjdhIChBZmZlY3RlZCAwLjkuNyk8L2xpPjxsaT5GaXhlZCBpbiBPcGVuU1NMIDAuOS42aSAoQWZmZWN0ZWQgMC45LjYtMC45LjZoKTwvbGk+PC91bD48L2RkPjwvZGw+PGgzPjxhID4yMDAyPC9hPjwvaDM+PGRsPjxkdD48YSA+Q1ZFLTIwMDItMTU2ODwvYT4gMDggQXVndXN0IDIwMDI6IDwvZHQ+PGRkPlRoZSB1c2Ugb2YgYXNzZXJ0aW9ucyB3aGVuIGRldGVjdGluZyBidWZmZXIgb3ZlcmZsb3cgYXR0YWNrcyBhbGxvd2VkIHJlbW90ZSBhdHRhY2tlcnMgdG8gY2F1c2UgYSBkZW5pYWwgb2Ygc2VydmljZSAoY3Jhc2gpIGJ5IHNlbmRpbmcgY2VydGFpbiBtZXNzYWdlcyB0byBjYXVzZSBPcGVuU1NMIHRvIGFib3J0IGZyb20gYSBmYWlsZWQgYXNzZXJ0aW9uLCBhcyBkZW1vbnN0cmF0ZWQgdXNpbmcgU1NMdjIgQ0xJRU5UX01BU1RFUl9LRVkgbWVzc2FnZXMsIHdoaWNoIHdlcmUgbm90IHByb3Blcmx5IGhhbmRsZWQgaW4gczJfc3J2ci5jLjx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuNmYgPGEgPihnaXQgY29tbWl0KTwvYT4gKEFmZmVjdGVkIDAuOS42ZSk8L2xpPjwvdWw+PC9kZD48ZHQ+PGEgPkNWRS0yMDAyLTA2NTk8L2E+IDxhID4oT3BlblNTTCBhZHZpc29yeSk8L2E+IDMwIEp1bHkgMjAwMjogPC9kdD48ZGQ+QSBmbGF3IGluIHRoZSBBU04xIGxpYnJhcnkgYWxsb3dlZCByZW1vdGUgYXR0YWNrZXJzIHRvIGNhdXNlIGEgZGVuaWFsIG9mIHNlcnZpY2UgYnkgc2VuZGluZyBpbnZhbGlkIGVuY29kaW5ncy48dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45LjZlIChBZmZlY3RlZCAwLjkuNmEtMC45LjZkKTwvbGk+PC91bD48L2RkPjxkdD48YSA+Q1ZFLTIwMDItMDY1NzwvYT4gPGEgPihPcGVuU1NMIGFkdmlzb3J5KTwvYT4gMzAgSnVseSAyMDAyOiA8L2R0PjxkZD5BIGJ1ZmZlciBvdmVyZmxvdyB3aGVuIEtlcmJlcm9zIGlzIGVuYWJsZWQgYWxsb3dlZCBhdHRhY2tlcnMgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSBieSBzZW5kaW5nIGEgbG9uZyBtYXN0ZXIga2V5LiBOb3RlIHRoYXQgdGhpcyBmbGF3IGRpZCBub3QgYWZmZWN0IGFueSByZWxlYXNlZCB2ZXJzaW9uIG9mIDAuOS42IG9yIDAuOS43IFJlcG9ydGVkIGJ5IE9wZW5TU0wgR3JvdXAgKEEuTC4gRGlnaXRhbCkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuNyAoQWZmZWN0ZWQgMC45LjctYmV0YTMpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAwMi0wNjU2PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAzMCBKdWx5IDIwMDI6IDwvZHQ+PGRkPkEgYnVmZmVyIG92ZXJmbG93IGFsbG93ZWQgcmVtb3RlIGF0dGFja2VycyB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIGJ5IHNlbmRpbmcgYSBsYXJnZSBjbGllbnQgbWFzdGVyIGtleSBpbiBTU0wyIG9yIGEgbGFyZ2Ugc2Vzc2lvbiBJRCBpbiBTU0wzLiBSZXBvcnRlZCBieSBPcGVuU1NMIEdyb3VwIChBLkwuIERpZ2l0YWwpLiA8dWw+PGxpPkZpeGVkIGluIE9wZW5TU0wgMC45LjZlIChBZmZlY3RlZCAwLjkuNi0wLjkuNmQpPC9saT48L3VsPjwvZGQ+PGR0PjxhID5DVkUtMjAwMi0wNjU1PC9hPiA8YSA+KE9wZW5TU0wgYWR2aXNvcnkpPC9hPiAzMCBKdWx5IDIwMDI6IDwvZHQ+PGRkPklucHJvcGVyIGhhbmRsaW5nIG9mIEFTQ0lJIHJlcHJlc2VudGF0aW9ucyBvZiBpbnRlZ2VycyBvbiA2NCBiaXQgcGxhdGZvcm1zIGFsbG93ZWQgcmVtb3RlIGF0dGFja2VycyB0byBjYXVzZSBhIGRlbmlhbCBvZiBzZXJ2aWNlIG9yIHBvc3NpYmx5IGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUuIFJlcG9ydGVkIGJ5IE9wZW5TU0wgR3JvdXAgKEEuTC4gRGlnaXRhbCkuIDx1bD48bGk+Rml4ZWQgaW4gT3BlblNTTCAwLjkuNmUgKEFmZmVjdGVkIDAuOS42LTAuOS42ZCk8L2xpPjwvdWw+PC9kZD48L2RsPiA8L2Rpdj4gPC9hcnRpY2xlPiA8L2Rpdj4gPC9kaXY+IDwvZGl2PiA8L2JvZHk+'</script>

      </head>
        <body class="valid" valid="valid" title="valid: True, node: 1, tag: body, level: 1" node_number="1"> <header class="valid" valid="valid" title="valid: True, node: 2, tag: header, level: 2" node_number="2"> <hgroup class="valid" valid="valid" title="valid: True, node: 3, tag: hgroup, level: 3" node_number="3"> <h1 class="valid" valid="valid" title="valid: True, node: 4, tag: h1, level: 4" node_number="4"> <a class="valid" valid="valid" title="valid: True, node: 5, tag: a, level: 5" node_number="5"> OpenSSL </a> </h1> <h2 class="valid" valid="valid" title="valid: True, node: 6, tag: h2, level: 4" node_number="6"> Cryptography and SSL/TLS Toolkit </h2> </hgroup> </header>  <div class="valid" valid="valid" title="valid: True, node: 7, tag: div, level: 2" node_number="7"> <div class="valid" valid="valid" title="valid: True, node: 8, tag: div, level: 3" node_number="8"> <div class="valid" valid="valid" title="valid: True, node: 9, tag: div, level: 4" node_number="9"> <article class="valid" valid="valid" title="valid: True, node: 10, tag: article, level: 5" node_number="10"> <header class="valid" valid="valid" title="valid: True, node: 11, tag: header, level: 6" node_number="11"><h2 class="valid" valid="valid" title="valid: True, node: 12, tag: h2, level: 7" node_number="12">Vulnerabilities</h2></header> <div class="valid" valid="valid" title="valid: True, node: 13, tag: div, level: 6" node_number="13"> <p class="valid" valid="valid" title="valid: True, node: 14, tag: p, level: 7" node_number="14"> If you think you have found a security bug in OpenSSL, please <a class="valid" valid="valid" title="valid: True, node: 15, tag: a, level: 8" node_number="15">report it to us</a>. </p> <p class="valid" valid="valid" title="valid: True, node: 16, tag: p, level: 7" node_number="16">Show issues fixed only in OpenSSL <a class="valid" valid="valid" title="valid: True, node: 17, tag: a, level: 8" node_number="17">3.0</a>, <a class="valid" valid="valid" title="valid: True, node: 18, tag: a, level: 8" node_number="18">1.1.1</a>, <a class="valid" valid="valid" title="valid: True, node: 19, tag: a, level: 8" node_number="19">1.1.0</a>, <a class="valid" valid="valid" title="valid: True, node: 20, tag: a, level: 8" node_number="20">1.0.2</a>, <a class="valid" valid="valid" title="valid: True, node: 21, tag: a, level: 8" node_number="21">1.0.1</a>, <a class="valid" valid="valid" title="valid: True, node: 22, tag: a, level: 8" node_number="22">1.0.0</a>, <a class="valid" valid="valid" title="valid: True, node: 23, tag: a, level: 8" node_number="23">0.9.8</a>, <a class="valid" valid="valid" title="valid: True, node: 24, tag: a, level: 8" node_number="24">0.9.7</a>, <a class="valid" valid="valid" title="valid: True, node: 25, tag: a, level: 8" node_number="25">0.9.6</a></p><p class="valid" valid="valid" title="valid: True, node: 26, tag: p, level: 7" node_number="26">Note: All OpenSSL versions before 1.1.1 are out of support and no longer receiving updates. Extended support is available for 1.0.2 from OpenSSL Software Services for premium support customers.</p><p class="valid" valid="valid" title="valid: True, node: 27, tag: p, level: 7" node_number="27"><a class="valid" valid="valid" title="valid: True, node: 28, tag: a, level: 8" node_number="28">Jump to year: </a><a class="valid" valid="valid" title="valid: True, node: 29, tag: a, level: 8" node_number="29">2021</a>, <a class="valid" valid="valid" title="valid: True, node: 30, tag: a, level: 8" node_number="30">2020</a>, <a class="valid" valid="valid" title="valid: True, node: 31, tag: a, level: 8" node_number="31">2019</a>, <a class="valid" valid="valid" title="valid: True, node: 32, tag: a, level: 8" node_number="32">2018</a>, <a class="valid" valid="valid" title="valid: True, node: 33, tag: a, level: 8" node_number="33">2017</a>, <a class="valid" valid="valid" title="valid: True, node: 34, tag: a, level: 8" node_number="34">2016</a>, <a class="valid" valid="valid" title="valid: True, node: 35, tag: a, level: 8" node_number="35">2015</a>, <a class="valid" valid="valid" title="valid: True, node: 36, tag: a, level: 8" node_number="36">2014</a>, <a class="valid" valid="valid" title="valid: True, node: 37, tag: a, level: 8" node_number="37">2013</a>, <a class="valid" valid="valid" title="valid: True, node: 38, tag: a, level: 8" node_number="38">2012</a>, <a class="valid" valid="valid" title="valid: True, node: 39, tag: a, level: 8" node_number="39">2011</a>, <a class="valid" valid="valid" title="valid: True, node: 40, tag: a, level: 8" node_number="40">2010</a>, <a class="valid" valid="valid" title="valid: True, node: 41, tag: a, level: 8" node_number="41">2009</a>, <a class="valid" valid="valid" title="valid: True, node: 42, tag: a, level: 8" node_number="42">2008</a>, <a class="valid" valid="valid" title="valid: True, node: 43, tag: a, level: 8" node_number="43">2007</a>, <a class="valid" valid="valid" title="valid: True, node: 44, tag: a, level: 8" node_number="44">2006</a>, <a class="valid" valid="valid" title="valid: True, node: 45, tag: a, level: 8" node_number="45">2005</a>, <a class="valid" valid="valid" title="valid: True, node: 46, tag: a, level: 8" node_number="46">2004</a>, <a class="valid" valid="valid" title="valid: True, node: 47, tag: a, level: 8" node_number="47">2003</a>, <a class="valid" valid="valid" title="valid: True, node: 48, tag: a, level: 8" node_number="48">2002</a></p><h3 class="valid" valid="valid" title="valid: True, node: 49, tag: h3, level: 7" node_number="49"><a class="valid" valid="valid" title="valid: True, node: 50, tag: a, level: 8" node_number="50">2021</a></h3><dl class="valid" valid="valid" title="valid: True, node: 51, tag: dl, level: 7" node_number="51"><dt class="valid" valid="valid" title="valid: True, node: 52, tag: dt, level: 8" node_number="52"><a class="valid" valid="valid" title="valid: True, node: 53, tag: a, level: 9" node_number="53">CVE-2021-4044</a> <a class="valid" valid="valid" title="valid: True, node: 54, tag: a, level: 9" node_number="54">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 55, tag: a, level: 9" node_number="55">[Moderate severity]</a> 14 December 2021: </dt><dd class="valid" valid="valid" title="valid: True, node: 56, tag: dd, level: 8" node_number="56">Internally libssl in OpenSSL calls X509_verify_cert() on the client side to verify a certificate supplied by a server. That function may return a negative return value to indicate an internal error (for example out of memory). Such a negative return value is mishandled by OpenSSL and will cause an IO function (such as SSL_connect() or SSL_do_handshake()) to not indicate success and a subsequent call to SSL_get_error() to return the value SSL_ERROR_WANT_RETRY_VERIFY. This return value is only supposed to be returned by OpenSSL if the application has previously called SSL_CTX_set_cert_verify_callback(). Since most applications do not do this the SSL_ERROR_WANT_RETRY_VERIFY return value from SSL_get_error() will be totally unexpected and applications may not behave correctly as a result. The exact behaviour will depend on the application but it could result in crashes, infinite loops or other similar incorrect responses. This issue is made more serious in combination with a separate bug in OpenSSL 3.0 that will cause X509_verify_cert() to indicate an internal error when processing a certificate chain. This will occur where a certificate does not include the Subject Alternative Name extension but where a Certificate Authority has enforced name constraints. This issue can occur even with valid chains. By combining the two issues an attacker could induce incorrect, application dependent behaviour. Reported by Tobias Nie&#223;en. <ul class="valid" valid="valid" title="valid: True, node: 57, tag: ul, level: 9" node_number="57"><li class="valid" valid="valid" title="valid: True, node: 58, tag: li, level: 10" node_number="58">Fixed in OpenSSL 3.0.1 <a class="valid" valid="valid" title="valid: True, node: 59, tag: a, level: 11" node_number="59">(git commit)</a> (Affected 3.0.0)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 60, tag: dt, level: 8" node_number="60"><a class="valid" valid="valid" title="valid: True, node: 61, tag: a, level: 9" node_number="61">CVE-2021-3712</a> <a class="valid" valid="valid" title="valid: True, node: 62, tag: a, level: 9" node_number="62">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 63, tag: a, level: 9" node_number="63">[Moderate severity]</a> 24 August 2021: </dt><dd class="valid" valid="valid" title="valid: True, node: 64, tag: dd, level: 8" node_number="64">ASN.1 strings are represented internally within OpenSSL as an ASN1_STRING structure which contains a buffer holding the string data and a field holding the buffer length. This contrasts with normal C strings which are repesented as a buffer for the string data which is terminated with a NUL (0) byte. Although not a strict requirement, ASN.1 strings that are parsed using OpenSSL's own "d2i" functions (and other similar parsing functions) as well as any string whose value has been set with the ASN1_STRING_set() function will additionally NUL terminate the byte array in the ASN1_STRING structure. However, it is possible for applications to directly construct valid ASN1_STRING structures which do not NUL terminate the byte array by directly setting the "data" and "length" fields in the ASN1_STRING array. This can also happen by using the ASN1_STRING_set0() function. Numerous OpenSSL functions that print ASN.1 data have been found to assume that the ASN1_STRING byte array will be NUL terminated, even though this is not guaranteed for strings that have been directly constructed. Where an application requests an ASN.1 structure to be printed, and where that ASN.1 structure contains ASN1_STRINGs that have been directly constructed by the application without NUL terminating the "data" field, then a read buffer overrun can occur. The same thing can also occur during name constraints processing of certificates (for example if a certificate has been directly constructed by the application instead of loading it via the OpenSSL parsing functions, and the certificate contains non NUL terminated ASN1_STRING structures). It can also occur in the X509_get1_email(), X509_REQ_get1_email() and X509_get1_ocsp() functions. If a malicious actor can cause an application to directly construct an ASN1_STRING and then process it through one of the affected OpenSSL functions then this issue could be hit. This might result in a crash (causing a Denial of Service attack). It could also result in the disclosure of private memory contents (such as private keys, or sensitive plaintext). Reported by Ingo Schwarze. <ul class="valid" valid="valid" title="valid: True, node: 65, tag: ul, level: 9" node_number="65"><li class="valid" valid="valid" title="valid: True, node: 66, tag: li, level: 10" node_number="66">Fixed in OpenSSL 1.1.1l <a class="valid" valid="valid" title="valid: True, node: 67, tag: a, level: 11" node_number="67">(git commit)</a> (Affected 1.1.1-1.1.1k)</li><li class="valid" valid="valid" title="valid: True, node: 68, tag: li, level: 10" node_number="68">Fixed in OpenSSL 1.0.2za <a class="valid" valid="valid" title="valid: True, node: 69, tag: a, level: 11" node_number="69">(git commit)</a> (Affected 1.0.2-1.0.2y)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 70, tag: dt, level: 8" node_number="70"><a class="valid" valid="valid" title="valid: True, node: 71, tag: a, level: 9" node_number="71">CVE-2021-3711</a> <a class="valid" valid="valid" title="valid: True, node: 72, tag: a, level: 9" node_number="72">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 73, tag: a, level: 9" node_number="73">[High severity]</a> 24 August 2021: </dt><dd class="valid" valid="valid" title="valid: True, node: 74, tag: dd, level: 8" node_number="74">In order to decrypt SM2 encrypted data an application is expected to call the API function EVP_PKEY_decrypt(). Typically an application will call this function twice. The first time, on entry, the "out" parameter can be NULL and, on exit, the "outlen" parameter is populated with the buffer size required to hold the decrypted plaintext. The application can then allocate a sufficiently sized buffer and call EVP_PKEY_decrypt() again, but this time passing a non-NULL value for the "out" parameter. A bug in the implementation of the SM2 decryption code means that the calculation of the buffer size required to hold the plaintext returned by the first call to EVP_PKEY_decrypt() can be smaller than the actual size required by the second call. This can lead to a buffer overflow when EVP_PKEY_decrypt() is called by the application a second time with a buffer that is too small. A malicious attacker who is able present SM2 content for decryption to an application could cause attacker chosen data to overflow the buffer by up to a maximum of 62 bytes altering the contents of other data held after the buffer, possibly changing application behaviour or causing the application to crash. The location of the buffer is application dependent but is typically heap allocated. Reported by John Ouyang. <ul class="valid" valid="valid" title="valid: True, node: 75, tag: ul, level: 9" node_number="75"><li class="valid" valid="valid" title="valid: True, node: 76, tag: li, level: 10" node_number="76">Fixed in OpenSSL 1.1.1l <a class="valid" valid="valid" title="valid: True, node: 77, tag: a, level: 11" node_number="77">(git commit)</a> (Affected 1.1.1-1.1.1k)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 78, tag: dt, level: 8" node_number="78"><a class="valid" valid="valid" title="valid: True, node: 79, tag: a, level: 9" node_number="79">CVE-2021-3450</a> <a class="valid" valid="valid" title="valid: True, node: 80, tag: a, level: 9" node_number="80">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 81, tag: a, level: 9" node_number="81">[High severity]</a> 25 March 2021: </dt><dd class="valid" valid="valid" title="valid: True, node: 82, tag: dd, level: 8" node_number="82">The X509_V_FLAG_X509_STRICT flag enables additional security checks of the certificates present in a certificate chain. It is not set by default. Starting from OpenSSL version 1.1.1h a check to disallow certificates in the chain that have explicitly encoded elliptic curve parameters was added as an additional strict check. An error in the implementation of this check meant that the result of a previous check to confirm that certificates in the chain are valid CA certificates was overwritten. This effectively bypasses the check that non-CA certificates must not be able to issue other certificates. If a "purpose" has been configured then there is a subsequent opportunity for checks that the certificate is a valid CA. All of the named "purpose" values implemented in libcrypto perform this check. Therefore, where a purpose is set the certificate chain will still be rejected even when the strict flag has been used. A purpose is set by default in libssl client and server certificate verification routines, but it can be overridden or removed by an application. In order to be affected, an application must explicitly set the X509_V_FLAG_X509_STRICT verification flag and either not set a purpose for the certificate verification or, in the case of TLS client or server applications, override the default purpose. OpenSSL versions 1.1.1h and newer are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1k. OpenSSL 1.0.2 is not impacted by this issue. Reported by Benjamin Kaduk (Akamai), Xiang Ding (Akamai), others at Akamai. <ul class="valid" valid="valid" title="valid: True, node: 83, tag: ul, level: 9" node_number="83"><li class="valid" valid="valid" title="valid: True, node: 84, tag: li, level: 10" node_number="84">Fixed in OpenSSL 1.1.1k <a class="valid" valid="valid" title="valid: True, node: 85, tag: a, level: 11" node_number="85">(git commit)</a> (Affected 1.1.1h-1.1.1j)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 86, tag: dt, level: 8" node_number="86"><a class="valid" valid="valid" title="valid: True, node: 87, tag: a, level: 9" node_number="87">CVE-2021-3449</a> <a class="valid" valid="valid" title="valid: True, node: 88, tag: a, level: 9" node_number="88">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 89, tag: a, level: 9" node_number="89">[High severity]</a> 25 March 2021: </dt><dd class="valid" valid="valid" title="valid: True, node: 90, tag: dd, level: 8" node_number="90">An OpenSSL TLS server may crash if sent a maliciously crafted renegotiation ClientHello message from a client. If a TLSv1.2 renegotiation ClientHello omits the signature_algorithms extension (where it was present in the initial ClientHello), but includes a signature_algorithms_cert extension then a NULL pointer dereference will result, leading to a crash and a denial of service attack. A server is only vulnerable if it has TLSv1.2 and renegotiation enabled (which is the default configuration). OpenSSL TLS clients are not impacted by this issue. All OpenSSL 1.1.1 versions are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1k. OpenSSL 1.0.2 is not impacted by this issue. Reported by Peter K&#228;stle (Nokia) and Samuel Sapalski (Nokia). <ul class="valid" valid="valid" title="valid: True, node: 91, tag: ul, level: 9" node_number="91"><li class="valid" valid="valid" title="valid: True, node: 92, tag: li, level: 10" node_number="92">Fixed in OpenSSL 1.1.1k <a class="valid" valid="valid" title="valid: True, node: 93, tag: a, level: 11" node_number="93">(git commit)</a> (Affected 1.1.1-1.1.1j)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 94, tag: dt, level: 8" node_number="94"><a class="valid" valid="valid" title="valid: True, node: 95, tag: a, level: 9" node_number="95">CVE-2021-23841</a> <a class="valid" valid="valid" title="valid: True, node: 96, tag: a, level: 9" node_number="96">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 97, tag: a, level: 9" node_number="97">[Moderate severity]</a> 16 February 2021: </dt><dd class="valid" valid="valid" title="valid: True, node: 98, tag: dd, level: 8" node_number="98">The OpenSSL public API function X509_issuer_and_serial_hash() attempts to create a unique hash value based on the issuer and serial number data contained within an X509 certificate. However it fails to correctly handle any errors that may occur while parsing the issuer field (which might occur if the issuer field is maliciously constructed). This may subsequently result in a NULL pointer deref and a crash leading to a potential denial of service attack. The function X509_issuer_and_serial_hash() is never directly called by OpenSSL itself so applications are only vulnerable if they use this function directly and they use it on certificates that may have been obtained from untrusted sources. OpenSSL versions 1.1.1i and below are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1j. OpenSSL versions 1.0.2x and below are affected by this issue. However OpenSSL 1.0.2 is out of support and no longer receiving public updates. Premium support customers of OpenSSL 1.0.2 should upgrade to 1.0.2y. Other users should upgrade to 1.1.1j. Reported by Tavis Ormandy (Google). <ul class="valid" valid="valid" title="valid: True, node: 99, tag: ul, level: 9" node_number="99"><li class="valid" valid="valid" title="valid: True, node: 100, tag: li, level: 10" node_number="100">Fixed in OpenSSL 1.1.1j <a class="valid" valid="valid" title="valid: True, node: 101, tag: a, level: 11" node_number="101">(git commit)</a> (Affected 1.1.1-1.1.1i)</li><li class="valid" valid="valid" title="valid: True, node: 102, tag: li, level: 10" node_number="102">Fixed in OpenSSL 1.0.2y <a class="valid" valid="valid" title="valid: True, node: 103, tag: a, level: 11" node_number="103">(git commit)</a> (Affected 1.0.2-1.0.2x)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 104, tag: dt, level: 8" node_number="104"><a class="valid" valid="valid" title="valid: True, node: 105, tag: a, level: 9" node_number="105">CVE-2021-23840</a> <a class="valid" valid="valid" title="valid: True, node: 106, tag: a, level: 9" node_number="106">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 107, tag: a, level: 9" node_number="107">[Low severity]</a> 16 February 2021: </dt><dd class="valid" valid="valid" title="valid: True, node: 108, tag: dd, level: 8" node_number="108">Calls to EVP_CipherUpdate, EVP_EncryptUpdate and EVP_DecryptUpdate may overflow the output length argument in some cases where the input length is close to the maximum permissable length for an integer on the platform. In such cases the return value from the function call will be 1 (indicating success), but the output length value will be negative. This could cause applications to behave incorrectly or crash. OpenSSL versions 1.1.1i and below are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1j. OpenSSL versions 1.0.2x and below are affected by this issue. However OpenSSL 1.0.2 is out of support and no longer receiving public updates. Premium support customers of OpenSSL 1.0.2 should upgrade to 1.0.2y. Other users should upgrade to 1.1.1j. Reported by Paul Kehrer. <ul class="valid" valid="valid" title="valid: True, node: 109, tag: ul, level: 9" node_number="109"><li class="valid" valid="valid" title="valid: True, node: 110, tag: li, level: 10" node_number="110">Fixed in OpenSSL 1.1.1j <a class="valid" valid="valid" title="valid: True, node: 111, tag: a, level: 11" node_number="111">(git commit)</a> (Affected 1.1.1-1.1.1i)</li><li class="valid" valid="valid" title="valid: True, node: 112, tag: li, level: 10" node_number="112">Fixed in OpenSSL 1.0.2y <a class="valid" valid="valid" title="valid: True, node: 113, tag: a, level: 11" node_number="113">(git commit)</a> (Affected 1.0.2-1.0.2x)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 114, tag: dt, level: 8" node_number="114"><a class="valid" valid="valid" title="valid: True, node: 115, tag: a, level: 9" node_number="115">CVE-2021-23839</a> <a class="valid" valid="valid" title="valid: True, node: 116, tag: a, level: 9" node_number="116">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 117, tag: a, level: 9" node_number="117">[Low severity]</a> 16 February 2021: </dt><dd class="valid" valid="valid" title="valid: True, node: 118, tag: dd, level: 8" node_number="118">OpenSSL 1.0.2 supports SSLv2. If a client attempts to negotiate SSLv2 with a server that is configured to support both SSLv2 and more recent SSL and TLS versions then a check is made for a version rollback attack when unpadding an RSA signature. Clients that support SSL or TLS versions greater than SSLv2 are supposed to use a special form of padding. A server that supports greater than SSLv2 is supposed to reject connection attempts from a client where this special form of padding is present, because this indicates that a version rollback has occurred (i.e. both client and server support greater than SSLv2, and yet this is the version that is being requested). The implementation of this padding check inverted the logic so that the connection attempt is accepted if the padding is present, and rejected if it is absent. This means that such as server will accept a connection if a version rollback attack has occurred. Further the server will erroneously reject a connection if a normal SSLv2 connection attempt is made. Only OpenSSL 1.0.2 servers from version 1.0.2s to 1.0.2x are affected by this issue. In order to be vulnerable a 1.0.2 server must: 1) have configured SSLv2 support at compile time (this is off by default), 2) have configured SSLv2 support at runtime (this is off by default), 3) have configured SSLv2 ciphersuites (these are not in the default ciphersuite list) OpenSSL 1.1.1 does not have SSLv2 support and therefore is not vulnerable to this issue. The underlying error is in the implementation of the RSA_padding_check_SSLv23() function. This also affects the RSA_SSLV23_PADDING padding mode used by various other functions. Although 1.1.1 does not support SSLv2 the RSA_padding_check_SSLv23() function still exists, as does the RSA_SSLV23_PADDING padding mode. Applications that directly call that function or use that padding mode will encounter this issue. However since there is no support for the SSLv2 protocol in 1.1.1 this is considered a bug and not a security issue in that version. OpenSSL 1.0.2 is out of support and no longer receiving public updates. Premium support customers of OpenSSL 1.0.2 should upgrade to 1.0.2y. Other users should upgrade to 1.1.1j. Reported by D. Katz and Joel Luellwitz (Trustwave). <ul class="valid" valid="valid" title="valid: True, node: 119, tag: ul, level: 9" node_number="119"><li class="valid" valid="valid" title="valid: True, node: 120, tag: li, level: 10" node_number="120">Fixed in OpenSSL 1.0.2y <a class="valid" valid="valid" title="valid: True, node: 121, tag: a, level: 11" node_number="121">(git commit)</a> (Affected 1.0.2s-1.0.2x)</li></ul></dd></dl><h3 class="valid" valid="valid" title="valid: True, node: 122, tag: h3, level: 7" node_number="122"><a class="valid" valid="valid" title="valid: True, node: 123, tag: a, level: 8" node_number="123">2020</a></h3><dl class="valid" valid="valid" title="valid: True, node: 124, tag: dl, level: 7" node_number="124"><dt class="valid" valid="valid" title="valid: True, node: 125, tag: dt, level: 8" node_number="125"><a class="valid" valid="valid" title="valid: True, node: 126, tag: a, level: 9" node_number="126">CVE-2020-1971</a> <a class="valid" valid="valid" title="valid: True, node: 127, tag: a, level: 9" node_number="127">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 128, tag: a, level: 9" node_number="128">[High severity]</a> 08 December 2020: </dt><dd class="valid" valid="valid" title="valid: True, node: 129, tag: dd, level: 8" node_number="129">The X.509 GeneralName type is a generic type for representing different types of names. One of those name types is known as EDIPartyName. OpenSSL provides a function GENERAL_NAME_cmp which compares different instances of a GENERAL_NAME to see if they are equal or not. This function behaves incorrectly when both GENERAL_NAMEs contain an EDIPARTYNAME. A NULL pointer dereference and a crash may occur leading to a possible denial of service attack. OpenSSL itself uses the GENERAL_NAME_cmp function for two purposes: 1) Comparing CRL distribution point names between an available CRL and a CRL distribution point embedded in an X509 certificate 2) When verifying that a timestamp response token signer matches the timestamp authority name (exposed via the API functions TS_RESP_verify_response and TS_RESP_verify_token) If an attacker can control both items being compared then that attacker could trigger a crash. For example if the attacker can trick a client or server into checking a malicious certificate against a malicious CRL then this may occur. Note that some applications automatically download CRLs based on a URL embedded in a certificate. This checking happens prior to the signatures on the certificate and CRL being verified. OpenSSL's s_server, s_client and verify tools have support for the "-crl_download" option which implements automatic CRL downloading and this attack has been demonstrated to work against those tools. Note that an unrelated bug means that affected versions of OpenSSL cannot parse or construct correct encodings of EDIPARTYNAME. However it is possible to construct a malformed EDIPARTYNAME that OpenSSL's parser will accept and hence trigger this attack. All OpenSSL 1.1.1 and 1.0.2 versions are affected by this issue. Other OpenSSL releases are out of support and have not been checked. Reported by David Benjamin (Google). <ul class="valid" valid="valid" title="valid: True, node: 130, tag: ul, level: 9" node_number="130"><li class="valid" valid="valid" title="valid: True, node: 131, tag: li, level: 10" node_number="131">Fixed in OpenSSL 1.1.1i <a class="valid" valid="valid" title="valid: True, node: 132, tag: a, level: 11" node_number="132">(git commit)</a> (Affected 1.1.1-1.1.1h)</li><li class="valid" valid="valid" title="valid: True, node: 133, tag: li, level: 10" node_number="133">Fixed in OpenSSL 1.0.2x <a class="valid" valid="valid" title="valid: True, node: 134, tag: a, level: 11" node_number="134">(git commit)</a> (Affected 1.0.2-1.0.2w)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 135, tag: dt, level: 8" node_number="135"><a class="valid" valid="valid" title="valid: True, node: 136, tag: a, level: 9" node_number="136">CVE-2020-1968</a> <a class="valid" valid="valid" title="valid: True, node: 137, tag: a, level: 9" node_number="137">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 138, tag: a, level: 9" node_number="138">[Low severity]</a> 09 September 2020: </dt><dd class="valid" valid="valid" title="valid: True, node: 139, tag: dd, level: 8" node_number="139">The Raccoon attack exploits a flaw in the TLS specification which can lead to an attacker being able to compute the pre-master secret in connections which have used a Diffie-Hellman (DH) based ciphersuite. In such a case this would result in the attacker being able to eavesdrop on all encrypted communications sent over that TLS connection. The attack can only be exploited if an implementation re-uses a DH secret across multiple TLS connections. Note that this issue only impacts DH ciphersuites and not ECDH ciphersuites. This issue affects OpenSSL 1.0.2 which is out of support and no longer receiving public updates. OpenSSL 1.1.1 is not vulnerable to this issue. Reported by Robert Merget, Marcus Brinkmann, Nimrod Aviram, and Juraj Somorovsky. <ul class="valid" valid="valid" title="valid: True, node: 140, tag: ul, level: 9" node_number="140"><li class="valid" valid="valid" title="valid: True, node: 141, tag: li, level: 10" node_number="141">Fixed in OpenSSL 1.0.2w (Affected 1.0.2-1.0.2v)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 142, tag: dt, level: 8" node_number="142"><a class="valid" valid="valid" title="valid: True, node: 143, tag: a, level: 9" node_number="143">CVE-2020-1967</a> <a class="valid" valid="valid" title="valid: True, node: 144, tag: a, level: 9" node_number="144">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 145, tag: a, level: 9" node_number="145">[High severity]</a> 21 April 2020: </dt><dd class="valid" valid="valid" title="valid: True, node: 146, tag: dd, level: 8" node_number="146">Server or client applications that call the SSL_check_chain() function during or after a TLS 1.3 handshake may crash due to a NULL pointer dereference as a result of incorrect handling of the "signature_algorithms_cert" TLS extension. The crash occurs if an invalid or unrecognised signature algorithm is received from the peer. This could be exploited by a malicious peer in a Denial of Service attack. OpenSSL version 1.1.1d, 1.1.1e, and 1.1.1f are affected by this issue. This issue did not affect OpenSSL versions prior to 1.1.1d. Reported by Bernd Edlinger. <ul class="valid" valid="valid" title="valid: True, node: 147, tag: ul, level: 9" node_number="147"><li class="valid" valid="valid" title="valid: True, node: 148, tag: li, level: 10" node_number="148">Fixed in OpenSSL 1.1.1g <a class="valid" valid="valid" title="valid: True, node: 149, tag: a, level: 11" node_number="149">(git commit)</a> (Affected 1.1.1d-1.1.1f)</li></ul></dd></dl><h3 class="valid" valid="valid" title="valid: True, node: 150, tag: h3, level: 7" node_number="150"><a class="valid" valid="valid" title="valid: True, node: 151, tag: a, level: 8" node_number="151">2019</a></h3><dl class="valid" valid="valid" title="valid: True, node: 152, tag: dl, level: 7" node_number="152"><dt class="valid" valid="valid" title="valid: True, node: 153, tag: dt, level: 8" node_number="153"><a class="valid" valid="valid" title="valid: True, node: 154, tag: a, level: 9" node_number="154">CVE-2019-1551</a> <a class="valid" valid="valid" title="valid: True, node: 155, tag: a, level: 9" node_number="155">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 156, tag: a, level: 9" node_number="156">[Low severity]</a> 06 December 2019: </dt><dd class="valid" valid="valid" title="valid: True, node: 157, tag: dd, level: 8" node_number="157">There is an overflow bug in the x64_64 Montgomery squaring procedure used in exponentiation with 512-bit moduli. No EC algorithms are affected. Analysis suggests that attacks against 2-prime RSA1024, 3-prime RSA1536, and DSA1024 as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH512 are considered just feasible. However, for an attack the target would have to re-use the DH512 private key, which is not recommended anyway. Also applications directly using the low level API BN_mod_exp may be affected if they use BN_FLG_CONSTTIME. Reported by OSS-Fuzz and Guido Vranken. <ul class="valid" valid="valid" title="valid: True, node: 158, tag: ul, level: 9" node_number="158"><li class="valid" valid="valid" title="valid: True, node: 159, tag: li, level: 10" node_number="159">Fixed in OpenSSL 1.1.1e <a class="valid" valid="valid" title="valid: True, node: 160, tag: a, level: 11" node_number="160">(git commit)</a> (Affected 1.1.1-1.1.1d)</li><li class="valid" valid="valid" title="valid: True, node: 161, tag: li, level: 10" node_number="161">Fixed in OpenSSL 1.0.2u <a class="valid" valid="valid" title="valid: True, node: 162, tag: a, level: 11" node_number="162">(git commit)</a> (Affected 1.0.2-1.0.2t)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 163, tag: dt, level: 8" node_number="163"><a class="valid" valid="valid" title="valid: True, node: 164, tag: a, level: 9" node_number="164">CVE-2019-1563</a> <a class="valid" valid="valid" title="valid: True, node: 165, tag: a, level: 9" node_number="165">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 166, tag: a, level: 9" node_number="166">[Low severity]</a> 10 September 2019: </dt><dd class="valid" valid="valid" title="valid: True, node: 167, tag: dd, level: 8" node_number="167">In situations where an attacker receives automated notification of the success or failure of a decryption attempt an attacker, after sending a very large number of messages to be decrypted, can recover a CMS/PKCS7 transported encryption key or decrypt any RSA encrypted message that was encrypted with the public RSA key, using a Bleichenbacher padding oracle attack. Applications are not affected if they use a certificate together with the private RSA key to the CMS_decrypt or PKCS7_decrypt functions to select the correct recipient info to decrypt. Reported by Bernd Edlinger. <ul class="valid" valid="valid" title="valid: True, node: 168, tag: ul, level: 9" node_number="168"><li class="valid" valid="valid" title="valid: True, node: 169, tag: li, level: 10" node_number="169">Fixed in OpenSSL 1.1.1d <a class="valid" valid="valid" title="valid: True, node: 170, tag: a, level: 11" node_number="170">(git commit)</a> (Affected 1.1.1-1.1.1c)</li><li class="valid" valid="valid" title="valid: True, node: 171, tag: li, level: 10" node_number="171">Fixed in OpenSSL 1.1.0l <a class="valid" valid="valid" title="valid: True, node: 172, tag: a, level: 11" node_number="172">(git commit)</a> (Affected 1.1.0-1.1.0k)</li><li class="valid" valid="valid" title="valid: True, node: 173, tag: li, level: 10" node_number="173">Fixed in OpenSSL 1.0.2t <a class="valid" valid="valid" title="valid: True, node: 174, tag: a, level: 11" node_number="174">(git commit)</a> (Affected 1.0.2-1.0.2s)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 175, tag: dt, level: 8" node_number="175"><a class="valid" valid="valid" title="valid: True, node: 176, tag: a, level: 9" node_number="176">CVE-2019-1549</a> <a class="valid" valid="valid" title="valid: True, node: 177, tag: a, level: 9" node_number="177">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 178, tag: a, level: 9" node_number="178">[Low severity]</a> 10 September 2019: </dt><dd class="valid" valid="valid" title="valid: True, node: 179, tag: dd, level: 8" node_number="179">OpenSSL 1.1.1 introduced a rewritten random number generator (RNG). This was intended to include protection in the event of a fork() system call in order to ensure that the parent and child processes did not share the same RNG state. However this protection was not being used in the default case. A partial mitigation for this issue is that the output from a high precision timer is mixed into the RNG state so the likelihood of a parent and child process sharing state is significantly reduced. If an application already calls OPENSSL_init_crypto() explicitly using OPENSSL_INIT_ATFORK then this problem does not occur at all. Reported by Matt Caswell. <ul class="valid" valid="valid" title="valid: True, node: 180, tag: ul, level: 9" node_number="180"><li class="valid" valid="valid" title="valid: True, node: 181, tag: li, level: 10" node_number="181">Fixed in OpenSSL 1.1.1d <a class="valid" valid="valid" title="valid: True, node: 182, tag: a, level: 11" node_number="182">(git commit)</a> (Affected 1.1.1-1.1.1c)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 183, tag: dt, level: 8" node_number="183"><a class="valid" valid="valid" title="valid: True, node: 184, tag: a, level: 9" node_number="184">CVE-2019-1547</a> <a class="valid" valid="valid" title="valid: True, node: 185, tag: a, level: 9" node_number="185">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 186, tag: a, level: 9" node_number="186">[Low severity]</a> 10 September 2019: </dt><dd class="valid" valid="valid" title="valid: True, node: 187, tag: dd, level: 8" node_number="187">Normally in OpenSSL EC groups always have a co-factor present and this is used in side channel resistant code paths. However, in some cases, it is possible to construct a group using explicit parameters (instead of using a named curve). In those cases it is possible that such a group does not have the cofactor present. This can occur even where all the parameters match a known named curve. If such a curve is used then OpenSSL falls back to non-side channel resistant code paths which may result in full key recovery during an ECDSA signature operation. In order to be vulnerable an attacker would have to have the ability to time the creation of a large number of signatures where explicit parameters with no co-factor present are in use by an application using libcrypto. For the avoidance of doubt libssl is not vulnerable because explicit parameters are never used. Reported by Cesar Pereida Garc&#237;a, Sohaib ul Hassan, Nicola Tuveri, Iaroslav Gridin, Alejandro Cabrera Aldaya, and Billy Brumley. <ul class="valid" valid="valid" title="valid: True, node: 188, tag: ul, level: 9" node_number="188"><li class="valid" valid="valid" title="valid: True, node: 189, tag: li, level: 10" node_number="189">Fixed in OpenSSL 1.1.1d <a class="valid" valid="valid" title="valid: True, node: 190, tag: a, level: 11" node_number="190">(git commit)</a> (Affected 1.1.1-1.1.1c)</li><li class="valid" valid="valid" title="valid: True, node: 191, tag: li, level: 10" node_number="191">Fixed in OpenSSL 1.1.0l <a class="valid" valid="valid" title="valid: True, node: 192, tag: a, level: 11" node_number="192">(git commit)</a> (Affected 1.1.0-1.1.0k)</li><li class="valid" valid="valid" title="valid: True, node: 193, tag: li, level: 10" node_number="193">Fixed in OpenSSL 1.0.2t <a class="valid" valid="valid" title="valid: True, node: 194, tag: a, level: 11" node_number="194">(git commit)</a> (Affected 1.0.2-1.0.2s)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 195, tag: dt, level: 8" node_number="195"><a class="valid" valid="valid" title="valid: True, node: 196, tag: a, level: 9" node_number="196">CVE-2019-1552</a> <a class="valid" valid="valid" title="valid: True, node: 197, tag: a, level: 9" node_number="197">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 198, tag: a, level: 9" node_number="198">[Low severity]</a> 30 July 2019: </dt><dd class="valid" valid="valid" title="valid: True, node: 199, tag: dd, level: 8" node_number="199">OpenSSL has internal defaults for a directory tree where it can find a configuration file as well as certificates used for verification in TLS. This directory is most commonly referred to as OPENSSLDIR, and is configurable with the --prefix / --openssldir configuration options. For OpenSSL versions 1.1.0 and 1.1.1, the mingw configuration targets assume that resulting programs and libraries are installed in a Unix-like environment and the default prefix for program installation as well as for OPENSSLDIR should be '/usr/local'. However, mingw programs are Windows programs, and as such, find themselves looking at sub-directories of 'C:/usr/local', which may be world writable, which enables untrusted users to modify OpenSSL's default configuration, insert CA certificates, modify (or even replace) existing engine modules, etc. For OpenSSL 1.0.2, '/usr/local/ssl' is used as default for OPENSSLDIR on all Unix and Windows targets, including Visual C builds. However, some build instructions for the diverse Windows targets on 1.0.2 encourage you to specify your own --prefix. OpenSSL versions 1.1.1, 1.1.0 and 1.0.2 are affected by this issue. Due to the limited scope of affected deployments this has been assessed as low severity and therefore we are not creating new releases at this time. Reported by Rich Mirch. <ul class="valid" valid="valid" title="valid: True, node: 200, tag: ul, level: 9" node_number="200"><li class="valid" valid="valid" title="valid: True, node: 201, tag: li, level: 10" node_number="201">Fixed in OpenSSL 1.1.1d <a class="valid" valid="valid" title="valid: True, node: 202, tag: a, level: 11" node_number="202">(git commit)</a> (Affected 1.1.1-1.1.1c)</li><li class="valid" valid="valid" title="valid: True, node: 203, tag: li, level: 10" node_number="203">Fixed in OpenSSL 1.1.0l <a class="valid" valid="valid" title="valid: True, node: 204, tag: a, level: 11" node_number="204">(git commit)</a> <a class="valid" valid="valid" title="valid: True, node: 205, tag: a, level: 11" node_number="205">(git commit)</a> (Affected 1.1.0-1.1.0k)</li><li class="valid" valid="valid" title="valid: True, node: 206, tag: li, level: 10" node_number="206">Fixed in OpenSSL 1.0.2t <a class="valid" valid="valid" title="valid: True, node: 207, tag: a, level: 11" node_number="207">(git commit)</a> (Affected 1.0.2-1.0.2s)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 208, tag: dt, level: 8" node_number="208"><a class="valid" valid="valid" title="valid: True, node: 209, tag: a, level: 9" node_number="209">CVE-2019-1543</a> <a class="valid" valid="valid" title="valid: True, node: 210, tag: a, level: 9" node_number="210">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 211, tag: a, level: 9" node_number="211">[Low severity]</a> 06 March 2019: </dt><dd class="valid" valid="valid" title="valid: True, node: 212, tag: dd, level: 8" node_number="212">ChaCha20-Poly1305 is an AEAD cipher, and requires a unique nonce input for every encryption operation. RFC 7539 specifies that the nonce value (IV) should be 96 bits (12 bytes). OpenSSL allows a variable nonce length and front pads the nonce with 0 bytes if it is less than 12 bytes. However it also incorrectly allows a nonce to be set of up to 16 bytes. In this case only the last 12 bytes are significant and any additional leading bytes are ignored. It is a requirement of using this cipher that nonce values are unique. Messages encrypted using a reused nonce value are susceptible to serious confidentiality and integrity attacks. If an application changes the default nonce length to be longer than 12 bytes and then makes a change to the leading bytes of the nonce expecting the new value to be a new unique nonce then such an application could inadvertently encrypt messages with a reused nonce. Additionally the ignored bytes in a long nonce are not covered by the integrity guarantee of this cipher. Any application that relies on the integrity of these ignored leading bytes of a long nonce may be further affected. Any OpenSSL internal use of this cipher, including in SSL/TLS, is safe because no such use sets such a long nonce value. However user applications that use this cipher directly and set a non-default nonce length to be longer than 12 bytes may be vulnerable. OpenSSL versions 1.1.1 and 1.1.0 are affected by this issue. Due to the limited scope of affected deployments this has been assessed as low severity and therefore we are not creating new releases at this time. Reported by Joran Dirk Greef of Ronomon. <ul class="valid" valid="valid" title="valid: True, node: 213, tag: ul, level: 9" node_number="213"><li class="valid" valid="valid" title="valid: True, node: 214, tag: li, level: 10" node_number="214">Fixed in OpenSSL 1.1.1c <a class="valid" valid="valid" title="valid: True, node: 215, tag: a, level: 11" node_number="215">(git commit)</a> (Affected 1.1.1-1.1.1b)</li><li class="valid" valid="valid" title="valid: True, node: 216, tag: li, level: 10" node_number="216">Fixed in OpenSSL 1.1.0k <a class="valid" valid="valid" title="valid: True, node: 217, tag: a, level: 11" node_number="217">(git commit)</a> (Affected 1.1.0-1.1.0j)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 218, tag: dt, level: 8" node_number="218"><a class="valid" valid="valid" title="valid: True, node: 219, tag: a, level: 9" node_number="219">CVE-2019-1559</a> <a class="valid" valid="valid" title="valid: True, node: 220, tag: a, level: 9" node_number="220">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 221, tag: a, level: 9" node_number="221">[Moderate severity]</a> 26 February 2019: </dt><dd class="valid" valid="valid" title="valid: True, node: 222, tag: dd, level: 8" node_number="222">If an application encounters a fatal protocol error and then calls SSL_shutdown() twice (once to send a close_notify, and once to receive one) then OpenSSL can respond differently to the calling application if a 0 byte record is received with invalid padding compared to if a 0 byte record is received with an invalid MAC. If the application then behaves differently based on that in a way that is detectable to the remote peer, then this amounts to a padding oracle that could be used to decrypt data. In order for this to be exploitable "non-stitched" ciphersuites must be in use. Stitched ciphersuites are optimised implementations of certain commonly used ciphersuites. Also the application must call SSL_shutdown() twice even if a protocol error has occurred (applications should not do this but some do anyway). AEAD ciphersuites are not impacted. Reported by Juraj Somorovsky, Robert Merget and Nimrod Aviram, with additional investigation by Steven Collison and Andrew Hourselt. <ul class="valid" valid="valid" title="valid: True, node: 223, tag: ul, level: 9" node_number="223"><li class="valid" valid="valid" title="valid: True, node: 224, tag: li, level: 10" node_number="224">Fixed in OpenSSL 1.0.2r <a class="valid" valid="valid" title="valid: True, node: 225, tag: a, level: 11" node_number="225">(git commit)</a> (Affected 1.0.2-1.0.2q)</li></ul></dd></dl><h3 class="valid" valid="valid" title="valid: True, node: 226, tag: h3, level: 7" node_number="226"><a class="valid" valid="valid" title="valid: True, node: 227, tag: a, level: 8" node_number="227">2018</a></h3><dl class="valid" valid="valid" title="valid: True, node: 228, tag: dl, level: 7" node_number="228"><dt class="valid" valid="valid" title="valid: True, node: 229, tag: dt, level: 8" node_number="229"><a class="valid" valid="valid" title="valid: True, node: 230, tag: a, level: 9" node_number="230">CVE-2018-5407</a> <a class="valid" valid="valid" title="valid: True, node: 231, tag: a, level: 9" node_number="231">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 232, tag: a, level: 9" node_number="232">[Low severity]</a> 02 November 2018: </dt><dd class="valid" valid="valid" title="valid: True, node: 233, tag: dd, level: 8" node_number="233">OpenSSL ECC scalar multiplication, used in e.g. ECDSA and ECDH, has been shown to be vulnerable to a microarchitecture timing side channel attack. An attacker with sufficient access to mount local timing attacks during ECDSA signature generation could recover the private key. Reported by Alejandro Cabrera Aldaya, Billy Brumley, Sohaib ul Hassan, Cesar Pereida Garcia and Nicola Tuveri. <ul class="valid" valid="valid" title="valid: True, node: 234, tag: ul, level: 9" node_number="234"><li class="valid" valid="valid" title="valid: True, node: 235, tag: li, level: 10" node_number="235">Fixed in OpenSSL 1.1.0i <a class="valid" valid="valid" title="valid: True, node: 236, tag: a, level: 11" node_number="236">(git commit)</a> (Affected 1.1.0-1.1.0h)</li><li class="valid" valid="valid" title="valid: True, node: 237, tag: li, level: 10" node_number="237">Fixed in OpenSSL 1.0.2q <a class="valid" valid="valid" title="valid: True, node: 238, tag: a, level: 11" node_number="238">(git commit)</a> (Affected 1.0.2-1.0.2p)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 239, tag: dt, level: 8" node_number="239"><a class="valid" valid="valid" title="valid: True, node: 240, tag: a, level: 9" node_number="240">CVE-2018-0734</a> <a class="valid" valid="valid" title="valid: True, node: 241, tag: a, level: 9" node_number="241">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 242, tag: a, level: 9" node_number="242">[Low severity]</a> 30 October 2018: </dt><dd class="valid" valid="valid" title="valid: True, node: 243, tag: dd, level: 8" node_number="243">The OpenSSL DSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Reported by Samuel Weiser. <ul class="valid" valid="valid" title="valid: True, node: 244, tag: ul, level: 9" node_number="244"><li class="valid" valid="valid" title="valid: True, node: 245, tag: li, level: 10" node_number="245">Fixed in OpenSSL 1.1.1a <a class="valid" valid="valid" title="valid: True, node: 246, tag: a, level: 11" node_number="246">(git commit)</a> (Affected 1.1.1)</li><li class="valid" valid="valid" title="valid: True, node: 247, tag: li, level: 10" node_number="247">Fixed in OpenSSL 1.1.0j <a class="valid" valid="valid" title="valid: True, node: 248, tag: a, level: 11" node_number="248">(git commit)</a> (Affected 1.1.0-1.1.0i)</li><li class="valid" valid="valid" title="valid: True, node: 249, tag: li, level: 10" node_number="249">Fixed in OpenSSL 1.0.2q <a class="valid" valid="valid" title="valid: True, node: 250, tag: a, level: 11" node_number="250">(git commit)</a> (Affected 1.0.2-1.0.2p)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 251, tag: dt, level: 8" node_number="251"><a class="valid" valid="valid" title="valid: True, node: 252, tag: a, level: 9" node_number="252">CVE-2018-0735</a> <a class="valid" valid="valid" title="valid: True, node: 253, tag: a, level: 9" node_number="253">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 254, tag: a, level: 9" node_number="254">[Low severity]</a> 29 October 2018: </dt><dd class="valid" valid="valid" title="valid: True, node: 255, tag: dd, level: 8" node_number="255">The OpenSSL ECDSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Reported by Samuel Weiser. <ul class="valid" valid="valid" title="valid: True, node: 256, tag: ul, level: 9" node_number="256"><li class="valid" valid="valid" title="valid: True, node: 257, tag: li, level: 10" node_number="257">Fixed in OpenSSL 1.1.1a <a class="valid" valid="valid" title="valid: True, node: 258, tag: a, level: 11" node_number="258">(git commit)</a> (Affected 1.1.1)</li><li class="valid" valid="valid" title="valid: True, node: 259, tag: li, level: 10" node_number="259">Fixed in OpenSSL 1.1.0j <a class="valid" valid="valid" title="valid: True, node: 260, tag: a, level: 11" node_number="260">(git commit)</a> (Affected 1.1.0-1.1.0i)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 261, tag: dt, level: 8" node_number="261"><a class="valid" valid="valid" title="valid: True, node: 262, tag: a, level: 9" node_number="262">CVE-2018-0732</a> <a class="valid" valid="valid" title="valid: True, node: 263, tag: a, level: 9" node_number="263">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 264, tag: a, level: 9" node_number="264">[Low severity]</a> 12 June 2018: </dt><dd class="valid" valid="valid" title="valid: True, node: 265, tag: dd, level: 8" node_number="265">During key agreement in a TLS handshake using a DH(E) based ciphersuite a malicious server can send a very large prime value to the client. This will cause the client to spend an unreasonably long period of time generating a key for this prime resulting in a hang until the client has finished. This could be exploited in a Denial Of Service attack. Reported by Guido Vranken. <ul class="valid" valid="valid" title="valid: True, node: 266, tag: ul, level: 9" node_number="266"><li class="valid" valid="valid" title="valid: True, node: 267, tag: li, level: 10" node_number="267">Fixed in OpenSSL 1.1.0i <a class="valid" valid="valid" title="valid: True, node: 268, tag: a, level: 11" node_number="268">(git commit)</a> (Affected 1.1.0-1.1.0h)</li><li class="valid" valid="valid" title="valid: True, node: 269, tag: li, level: 10" node_number="269">Fixed in OpenSSL 1.0.2p <a class="valid" valid="valid" title="valid: True, node: 270, tag: a, level: 11" node_number="270">(git commit)</a> (Affected 1.0.2-1.0.2o)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 271, tag: dt, level: 8" node_number="271"><a class="valid" valid="valid" title="valid: True, node: 272, tag: a, level: 9" node_number="272">CVE-2018-0737</a> <a class="valid" valid="valid" title="valid: True, node: 273, tag: a, level: 9" node_number="273">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 274, tag: a, level: 9" node_number="274">[Low severity]</a> 16 April 2018: </dt><dd class="valid" valid="valid" title="valid: True, node: 275, tag: dd, level: 8" node_number="275">The OpenSSL RSA Key generation algorithm has been shown to be vulnerable to a cache timing side channel attack. An attacker with sufficient access to mount cache timing attacks during the RSA key generation process could recover the private key. Reported by Alejandro Cabrera Aldaya, Billy Brumley, Cesar Pereida Garcia and Luis Manuel Alvarez Tapia. <ul class="valid" valid="valid" title="valid: True, node: 276, tag: ul, level: 9" node_number="276"><li class="valid" valid="valid" title="valid: True, node: 277, tag: li, level: 10" node_number="277">Fixed in OpenSSL 1.1.0i <a class="valid" valid="valid" title="valid: True, node: 278, tag: a, level: 11" node_number="278">(git commit)</a> (Affected 1.1.0-1.1.0h)</li><li class="valid" valid="valid" title="valid: True, node: 279, tag: li, level: 10" node_number="279">Fixed in OpenSSL 1.0.2p <a class="valid" valid="valid" title="valid: True, node: 280, tag: a, level: 11" node_number="280">(git commit)</a> (Affected 1.0.2-1.0.2o)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 281, tag: dt, level: 8" node_number="281"><a class="valid" valid="valid" title="valid: True, node: 282, tag: a, level: 9" node_number="282">CVE-2018-0739</a> <a class="valid" valid="valid" title="valid: True, node: 283, tag: a, level: 9" node_number="283">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 284, tag: a, level: 9" node_number="284">[Moderate severity]</a> 27 March 2018: </dt><dd class="valid" valid="valid" title="valid: True, node: 285, tag: dd, level: 8" node_number="285">Constructed ASN.1 types with a recursive definition (such as can be found in PKCS7) could eventually exceed the stack given malicious input with excessive recursion. This could result in a Denial Of Service attack. There are no such structures used within SSL/TLS that come from untrusted sources so this is considered safe. Reported by OSS-fuzz. <ul class="valid" valid="valid" title="valid: True, node: 286, tag: ul, level: 9" node_number="286"><li class="valid" valid="valid" title="valid: True, node: 287, tag: li, level: 10" node_number="287">Fixed in OpenSSL 1.1.0h <a class="valid" valid="valid" title="valid: True, node: 288, tag: a, level: 11" node_number="288">(git commit)</a> (Affected 1.1.0-1.1.0g)</li><li class="valid" valid="valid" title="valid: True, node: 289, tag: li, level: 10" node_number="289">Fixed in OpenSSL 1.0.2o <a class="valid" valid="valid" title="valid: True, node: 290, tag: a, level: 11" node_number="290">(git commit)</a> (Affected 1.0.2b-1.0.2n)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 291, tag: dt, level: 8" node_number="291"><a class="valid" valid="valid" title="valid: True, node: 292, tag: a, level: 9" node_number="292">CVE-2018-0733</a> <a class="valid" valid="valid" title="valid: True, node: 293, tag: a, level: 9" node_number="293">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 294, tag: a, level: 9" node_number="294">[Moderate severity]</a> 27 March 2018: </dt><dd class="valid" valid="valid" title="valid: True, node: 295, tag: dd, level: 8" node_number="295">Because of an implementation bug the PA-RISC CRYPTO_memcmp function is effectively reduced to only comparing the least significant bit of each byte. This allows an attacker to forge messages that would be considered as authenticated in an amount of tries lower than that guaranteed by the security claims of the scheme. The module can only be compiled by the HP-UX assembler, so that only HP-UX PA-RISC targets are affected. Reported by Peter Waltenberg (IBM). <ul class="valid" valid="valid" title="valid: True, node: 296, tag: ul, level: 9" node_number="296"><li class="valid" valid="valid" title="valid: True, node: 297, tag: li, level: 10" node_number="297">Fixed in OpenSSL 1.1.0h <a class="valid" valid="valid" title="valid: True, node: 298, tag: a, level: 11" node_number="298">(git commit)</a> (Affected 1.1.0-1.1.0g)</li></ul></dd></dl><h3 class="valid" valid="valid" title="valid: True, node: 299, tag: h3, level: 7" node_number="299"><a class="valid" valid="valid" title="valid: True, node: 300, tag: a, level: 8" node_number="300">2017</a></h3><dl class="valid" valid="valid" title="valid: True, node: 301, tag: dl, level: 7" node_number="301"><dt class="valid" valid="valid" title="valid: True, node: 302, tag: dt, level: 8" node_number="302"><a class="valid" valid="valid" title="valid: True, node: 303, tag: a, level: 9" node_number="303">CVE-2017-3738</a> <a class="valid" valid="valid" title="valid: True, node: 304, tag: a, level: 9" node_number="304">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 305, tag: a, level: 9" node_number="305">[Low severity]</a> 07 December 2017: </dt><dd class="valid" valid="valid" title="valid: True, node: 306, tag: dd, level: 8" node_number="306">There is an overflow bug in the AVX2 Montgomery multiplication procedure used in exponentiation with 1024-bit moduli. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH1024 are considered just feasible, because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be significant. However, for an attack on TLS to be meaningful, the server would have to share the DH1024 private key among multiple clients, which is no longer an option since CVE-2016-0701. This only affects processors that support the AVX2 but not ADX extensions like Intel Haswell (4th generation). Note: The impact from this issue is similar to CVE-2017-3736, CVE-2017-3732 and CVE-2015-3193. Due to the low severity of this issue we are not issuing a new release of OpenSSL 1.1.0 at this time. The fix will be included in OpenSSL 1.1.0h when it becomes available. The fix is also available in commit e502cc86d in the OpenSSL git repository. Reported by David Benjamin (Google)/Google OSS-Fuzz. <ul class="valid" valid="valid" title="valid: True, node: 307, tag: ul, level: 9" node_number="307"><li class="valid" valid="valid" title="valid: True, node: 308, tag: li, level: 10" node_number="308">Fixed in OpenSSL 1.1.0h <a class="valid" valid="valid" title="valid: True, node: 309, tag: a, level: 11" node_number="309">(git commit)</a> (Affected 1.1.0-1.1.0g)</li><li class="valid" valid="valid" title="valid: True, node: 310, tag: li, level: 10" node_number="310">Fixed in OpenSSL 1.0.2n <a class="valid" valid="valid" title="valid: True, node: 311, tag: a, level: 11" node_number="311">(git commit)</a> (Affected 1.0.2-1.0.2m)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 312, tag: dt, level: 8" node_number="312"><a class="valid" valid="valid" title="valid: True, node: 313, tag: a, level: 9" node_number="313">CVE-2017-3737</a> <a class="valid" valid="valid" title="valid: True, node: 314, tag: a, level: 9" node_number="314">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 315, tag: a, level: 9" node_number="315">[Moderate severity]</a> 07 December 2017: </dt><dd class="valid" valid="valid" title="valid: True, node: 316, tag: dd, level: 8" node_number="316">OpenSSL 1.0.2 (starting from version 1.0.2b) introduced an "error state" mechanism. The intent was that if a fatal error occurred during a handshake then OpenSSL would move into the error state and would immediately fail if you attempted to continue the handshake. This works as designed for the explicit handshake functions (SSL_do_handshake(), SSL_accept() and SSL_connect()), however due to a bug it does not work correctly if SSL_read() or SSL_write() is called directly. In that scenario, if the handshake fails then a fatal error will be returned in the initial function call. If SSL_read()/SSL_write() is subsequently called by the application for the same SSL object then it will succeed and the data is passed without being decrypted/encrypted directly from the SSL/TLS record layer. In order to exploit this issue an application bug would have to be present that resulted in a call to SSL_read()/SSL_write() being issued after having already received a fatal error. Reported by David Benjamin (Google). <ul class="valid" valid="valid" title="valid: True, node: 317, tag: ul, level: 9" node_number="317"><li class="valid" valid="valid" title="valid: True, node: 318, tag: li, level: 10" node_number="318">Fixed in OpenSSL 1.0.2n <a class="valid" valid="valid" title="valid: True, node: 319, tag: a, level: 11" node_number="319">(git commit)</a> (Affected 1.0.2b-1.0.2m)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 320, tag: dt, level: 8" node_number="320"><a class="valid" valid="valid" title="valid: True, node: 321, tag: a, level: 9" node_number="321">CVE-2017-3736</a> <a class="valid" valid="valid" title="valid: True, node: 322, tag: a, level: 9" node_number="322">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 323, tag: a, level: 9" node_number="323">[Moderate severity]</a> 02 November 2017: </dt><dd class="valid" valid="valid" title="valid: True, node: 324, tag: dd, level: 8" node_number="324">There is a carry propagating bug in the x86_64 Montgomery squaring procedure. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be very significant and likely only accessible to a limited number of attackers. An attacker would additionally need online access to an unpatched system using the target private key in a scenario with persistent DH parameters and a private key that is shared between multiple clients. This only affects processors that support the BMI1, BMI2 and ADX extensions like Intel Broadwell (5th generation) and later or AMD Ryzen. Reported by Google OSS-Fuzz. <ul class="valid" valid="valid" title="valid: True, node: 325, tag: ul, level: 9" node_number="325"><li class="valid" valid="valid" title="valid: True, node: 326, tag: li, level: 10" node_number="326">Fixed in OpenSSL 1.1.0g <a class="valid" valid="valid" title="valid: True, node: 327, tag: a, level: 11" node_number="327">(git commit)</a> (Affected 1.1.0-1.1.0f)</li><li class="valid" valid="valid" title="valid: True, node: 328, tag: li, level: 10" node_number="328">Fixed in OpenSSL 1.0.2m <a class="valid" valid="valid" title="valid: True, node: 329, tag: a, level: 11" node_number="329">(git commit)</a> (Affected 1.0.2-1.0.2l)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 330, tag: dt, level: 8" node_number="330"><a class="valid" valid="valid" title="valid: True, node: 331, tag: a, level: 9" node_number="331">CVE-2017-3735</a> <a class="valid" valid="valid" title="valid: True, node: 332, tag: a, level: 9" node_number="332">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 333, tag: a, level: 9" node_number="333">[Low severity]</a> 28 August 2017: </dt><dd class="valid" valid="valid" title="valid: True, node: 334, tag: dd, level: 8" node_number="334">While parsing an IPAdressFamily extension in an X.509 certificate, it is possible to do a one-byte overread. This would result in an incorrect text display of the certificate. Reported by Google OSS-Fuzz. <ul class="valid" valid="valid" title="valid: True, node: 335, tag: ul, level: 9" node_number="335"><li class="valid" valid="valid" title="valid: True, node: 336, tag: li, level: 10" node_number="336">Fixed in OpenSSL 1.1.0g <a class="valid" valid="valid" title="valid: True, node: 337, tag: a, level: 11" node_number="337">(git commit)</a> (Affected 1.1.0-1.1.0f)</li><li class="valid" valid="valid" title="valid: True, node: 338, tag: li, level: 10" node_number="338">Fixed in OpenSSL 1.0.2m <a class="valid" valid="valid" title="valid: True, node: 339, tag: a, level: 11" node_number="339">(git commit)</a> (Affected 1.0.2-1.0.2l)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 340, tag: dt, level: 8" node_number="340"><a class="valid" valid="valid" title="valid: True, node: 341, tag: a, level: 9" node_number="341">CVE-2017-3733</a> <a class="valid" valid="valid" title="valid: True, node: 342, tag: a, level: 9" node_number="342">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 343, tag: a, level: 9" node_number="343">[High severity]</a> 16 February 2017: </dt><dd class="valid" valid="valid" title="valid: True, node: 344, tag: dd, level: 8" node_number="344">During a renegotiation handshake if the Encrypt-Then-Mac extension is negotiated where it was not in the original handshake (or vice-versa) then this can cause OpenSSL to crash (dependent on ciphersuite). Both clients and servers are affected. Reported by Joe Orton (Red Hat). <ul class="valid" valid="valid" title="valid: True, node: 345, tag: ul, level: 9" node_number="345"><li class="valid" valid="valid" title="valid: True, node: 346, tag: li, level: 10" node_number="346">Fixed in OpenSSL 1.1.0e <a class="valid" valid="valid" title="valid: True, node: 347, tag: a, level: 11" node_number="347">(git commit)</a> (Affected 1.1.0-1.1.0d)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 348, tag: dt, level: 8" node_number="348"><a class="valid" valid="valid" title="valid: True, node: 349, tag: a, level: 9" node_number="349">CVE-2017-3732</a> <a class="valid" valid="valid" title="valid: True, node: 350, tag: a, level: 9" node_number="350">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 351, tag: a, level: 9" node_number="351">[Moderate severity]</a> 26 January 2017: </dt><dd class="valid" valid="valid" title="valid: True, node: 352, tag: dd, level: 8" node_number="352">There is a carry propagating bug in the x86_64 Montgomery squaring procedure. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be very significant and likely only accessible to a limited number of attackers. An attacker would additionally need online access to an unpatched system using the target private key in a scenario with persistent DH parameters and a private key that is shared between multiple clients. For example this can occur by default in OpenSSL DHE based SSL/TLS ciphersuites. Note: This issue is very similar to CVE-2015-3193 but must be treated as a separate problem. Reported by OSS-Fuzz project. <ul class="valid" valid="valid" title="valid: True, node: 353, tag: ul, level: 9" node_number="353"><li class="valid" valid="valid" title="valid: True, node: 354, tag: li, level: 10" node_number="354">Fixed in OpenSSL 1.1.0d <a class="valid" valid="valid" title="valid: True, node: 355, tag: a, level: 11" node_number="355">(git commit)</a> (Affected 1.1.0-1.1.0c)</li><li class="valid" valid="valid" title="valid: True, node: 356, tag: li, level: 10" node_number="356">Fixed in OpenSSL 1.0.2k <a class="valid" valid="valid" title="valid: True, node: 357, tag: a, level: 11" node_number="357">(git commit)</a> (Affected 1.0.2-1.0.2j)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 358, tag: dt, level: 8" node_number="358"><a class="valid" valid="valid" title="valid: True, node: 359, tag: a, level: 9" node_number="359">CVE-2017-3731</a> <a class="valid" valid="valid" title="valid: True, node: 360, tag: a, level: 9" node_number="360">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 361, tag: a, level: 9" node_number="361">[Moderate severity]</a> 26 January 2017: </dt><dd class="valid" valid="valid" title="valid: True, node: 362, tag: dd, level: 8" node_number="362">If an SSL/TLS server or client is running on a 32-bit host, and a specific cipher is being used, then a truncated packet can cause that server or client to perform an out-of-bounds read, usually resulting in a crash. For OpenSSL 1.1.0, the crash can be triggered when using CHACHA20/POLY1305; users should upgrade to 1.1.0d. For Openssl 1.0.2, the crash can be triggered when using RC4-MD5; users who have not disabled that algorithm should update to 1.0.2k Reported by Robert &#346;wi&#281;cki of Google. <ul class="valid" valid="valid" title="valid: True, node: 363, tag: ul, level: 9" node_number="363"><li class="valid" valid="valid" title="valid: True, node: 364, tag: li, level: 10" node_number="364">Fixed in OpenSSL 1.1.0d <a class="valid" valid="valid" title="valid: True, node: 365, tag: a, level: 11" node_number="365">(git commit)</a> (Affected 1.1.0-1.1.0c)</li><li class="valid" valid="valid" title="valid: True, node: 366, tag: li, level: 10" node_number="366">Fixed in OpenSSL 1.0.2k <a class="valid" valid="valid" title="valid: True, node: 367, tag: a, level: 11" node_number="367">(git commit)</a> (Affected 1.0.2-1.0.2j)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 368, tag: dt, level: 8" node_number="368"><a class="valid" valid="valid" title="valid: True, node: 369, tag: a, level: 9" node_number="369">CVE-2017-3730</a> <a class="valid" valid="valid" title="valid: True, node: 370, tag: a, level: 9" node_number="370">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 371, tag: a, level: 9" node_number="371">[Moderate severity]</a> 26 January 2017: </dt><dd class="valid" valid="valid" title="valid: True, node: 372, tag: dd, level: 8" node_number="372">If a malicious server supplies bad parameters for a DHE or ECDHE key exchange then this can result in the client attempting to dereference a NULL pointer leading to a client crash. This could be exploited in a Denial of Service attack. Reported by Guido Vranken. <ul class="valid" valid="valid" title="valid: True, node: 373, tag: ul, level: 9" node_number="373"><li class="valid" valid="valid" title="valid: True, node: 374, tag: li, level: 10" node_number="374">Fixed in OpenSSL 1.1.0d <a class="valid" valid="valid" title="valid: True, node: 375, tag: a, level: 11" node_number="375">(git commit)</a> (Affected 1.1.0-1.1.0c)</li></ul></dd></dl><h3 class="valid" valid="valid" title="valid: True, node: 376, tag: h3, level: 7" node_number="376"><a class="valid" valid="valid" title="valid: True, node: 377, tag: a, level: 8" node_number="377">2016</a></h3><dl class="valid" valid="valid" title="valid: True, node: 378, tag: dl, level: 7" node_number="378"><dt class="valid" valid="valid" title="valid: True, node: 379, tag: dt, level: 8" node_number="379"><a class="valid" valid="valid" title="valid: True, node: 380, tag: a, level: 9" node_number="380">CVE-2016-7055</a> <a class="valid" valid="valid" title="valid: True, node: 381, tag: a, level: 9" node_number="381">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 382, tag: a, level: 9" node_number="382">[Low severity]</a> 10 November 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 383, tag: dd, level: 8" node_number="383">There is a carry propagating bug in the Broadwell-specific Montgomery multiplication procedure that handles input lengths divisible by, but longer than 256 bits. Analysis suggests that attacks against RSA, DSA and DH private keys are impossible. This is because the subroutine in question is not used in operations with the private key itself and an input of the attacker's direct choice. Otherwise the bug can manifest itself as transient authentication and key negotiation failures or reproducible erroneous outcome of public-key operations with specially crafted input. Among EC algorithms only Brainpool P-512 curves are affected and one presumably can attack ECDH key negotiation. Impact was not analyzed in detail, because pre-requisites for attack are considered unlikely. Namely multiple clients have to choose the curve in question and the server has to share the private key among them, neither of which is default behaviour. Even then only clients that chose the curve will be affected. Reported by Publicly reported. <ul class="valid" valid="valid" title="valid: True, node: 384, tag: ul, level: 9" node_number="384"><li class="valid" valid="valid" title="valid: True, node: 385, tag: li, level: 10" node_number="385">Fixed in OpenSSL 1.1.0c <a class="valid" valid="valid" title="valid: True, node: 386, tag: a, level: 11" node_number="386">(git commit)</a> (Affected 1.1.0-1.1.0b)</li><li class="valid" valid="valid" title="valid: True, node: 387, tag: li, level: 10" node_number="387">Fixed in OpenSSL 1.0.2k <a class="valid" valid="valid" title="valid: True, node: 388, tag: a, level: 11" node_number="388">(git commit)</a> (Affected 1.0.2-1.0.2j)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 389, tag: dt, level: 8" node_number="389"><a class="valid" valid="valid" title="valid: True, node: 390, tag: a, level: 9" node_number="390">CVE-2016-7054</a> <a class="valid" valid="valid" title="valid: True, node: 391, tag: a, level: 9" node_number="391">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 392, tag: a, level: 9" node_number="392">[High severity]</a> 10 November 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 393, tag: dd, level: 8" node_number="393">TLS connections using *-CHACHA20-POLY1305 ciphersuites are susceptible to a DoS attack by corrupting larger payloads. This can result in an OpenSSL crash. This issue is not considered to be exploitable beyond a DoS. Reported by Robert &#346;wi&#281;cki (Google Security Team). <ul class="valid" valid="valid" title="valid: True, node: 394, tag: ul, level: 9" node_number="394"><li class="valid" valid="valid" title="valid: True, node: 395, tag: li, level: 10" node_number="395">Fixed in OpenSSL 1.1.0c <a class="valid" valid="valid" title="valid: True, node: 396, tag: a, level: 11" node_number="396">(git commit)</a> (Affected 1.1.0-1.1.0b)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 397, tag: dt, level: 8" node_number="397"><a class="valid" valid="valid" title="valid: True, node: 398, tag: a, level: 9" node_number="398">CVE-2016-7053</a> <a class="valid" valid="valid" title="valid: True, node: 399, tag: a, level: 9" node_number="399">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 400, tag: a, level: 9" node_number="400">[Moderate severity]</a> 10 November 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 401, tag: dd, level: 8" node_number="401">Applications parsing invalid CMS structures can crash with a NULL pointer dereference. This is caused by a bug in the handling of the ASN.1 CHOICE type in OpenSSL 1.1.0 which can result in a NULL value being passed to the structure callback if an attempt is made to free certain invalid encodings. Only CHOICE structures using a callback which do not handle NULL value are affected. Reported by Tyler Nighswander (ForAllSecure). <ul class="valid" valid="valid" title="valid: True, node: 402, tag: ul, level: 9" node_number="402"><li class="valid" valid="valid" title="valid: True, node: 403, tag: li, level: 10" node_number="403">Fixed in OpenSSL 1.1.0c <a class="valid" valid="valid" title="valid: True, node: 404, tag: a, level: 11" node_number="404">(git commit)</a> (Affected 1.1.0-1.1.0b)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 405, tag: dt, level: 8" node_number="405"><a class="valid" valid="valid" title="valid: True, node: 406, tag: a, level: 9" node_number="406">CVE-2016-7052</a> <a class="valid" valid="valid" title="valid: True, node: 407, tag: a, level: 9" node_number="407">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 408, tag: a, level: 9" node_number="408">[Moderate severity]</a> 26 September 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 409, tag: dd, level: 8" node_number="409">This issue only affects OpenSSL 1.0.2i, released on 22nd September 2016. A bug fix which included a CRL sanity check was added to OpenSSL 1.1.0 but was omitted from OpenSSL 1.0.2i. As a result any attempt to use CRLs in OpenSSL 1.0.2i will crash with a null pointer exception. Reported by Bruce Stephens and Thomas Jakobi. <ul class="valid" valid="valid" title="valid: True, node: 410, tag: ul, level: 9" node_number="410"><li class="valid" valid="valid" title="valid: True, node: 411, tag: li, level: 10" node_number="411">Fixed in OpenSSL 1.0.2j <a class="valid" valid="valid" title="valid: True, node: 412, tag: a, level: 11" node_number="412">(git commit)</a> (Affected 1.0.2i)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 413, tag: dt, level: 8" node_number="413"><a class="valid" valid="valid" title="valid: True, node: 414, tag: a, level: 9" node_number="414">CVE-2016-6309</a> <a class="valid" valid="valid" title="valid: True, node: 415, tag: a, level: 9" node_number="415">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 416, tag: a, level: 9" node_number="416">[Critical severity]</a> 26 September 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 417, tag: dd, level: 8" node_number="417">This issue only affects OpenSSL 1.1.0a, released on 22nd September 2016. The patch applied to address CVE-2016-6307 resulted in an issue where if a message larger than approx 16k is received then the underlying buffer to store the incoming message is reallocated and moved. Unfortunately a dangling pointer to the old location is left which results in an attempt to write to the previously freed location. This is likely to result in a crash, however it could potentially lead to execution of arbitrary code. Reported by Robert &#346;wi&#281;cki (Google Security Team). <ul class="valid" valid="valid" title="valid: True, node: 418, tag: ul, level: 9" node_number="418"><li class="valid" valid="valid" title="valid: True, node: 419, tag: li, level: 10" node_number="419">Fixed in OpenSSL 1.1.0b <a class="valid" valid="valid" title="valid: True, node: 420, tag: a, level: 11" node_number="420">(git commit)</a> (Affected 1.1.0a)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 421, tag: dt, level: 8" node_number="421"><a class="valid" valid="valid" title="valid: True, node: 422, tag: a, level: 9" node_number="422">CVE-2016-6305</a> <a class="valid" valid="valid" title="valid: True, node: 423, tag: a, level: 9" node_number="423">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 424, tag: a, level: 9" node_number="424">[Moderate severity]</a> 22 September 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 425, tag: dd, level: 8" node_number="425">OpenSSL 1.1.0 SSL/TLS will hang during a call to SSL_peek() if the peer sends an empty record. This could be exploited by a malicious peer in a Denial Of Service attack. Reported by Alex Gaynor. <ul class="valid" valid="valid" title="valid: True, node: 426, tag: ul, level: 9" node_number="426"><li class="valid" valid="valid" title="valid: True, node: 427, tag: li, level: 10" node_number="427">Fixed in OpenSSL 1.1.0a <a class="valid" valid="valid" title="valid: True, node: 428, tag: a, level: 11" node_number="428">(git commit)</a> (Affected 1.1.0)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 429, tag: dt, level: 8" node_number="429"><a class="valid" valid="valid" title="valid: True, node: 430, tag: a, level: 9" node_number="430">CVE-2016-6304</a> <a class="valid" valid="valid" title="valid: True, node: 431, tag: a, level: 9" node_number="431">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 432, tag: a, level: 9" node_number="432">[High severity]</a> 22 September 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 433, tag: dd, level: 8" node_number="433">A malicious client can send an excessively large OCSP Status Request extension. If that client continually requests renegotiation, sending a large OCSP Status Request extension each time, then there will be unbounded memory growth on the server. This will eventually lead to a Denial Of Service attack through memory exhaustion. Servers with a default configuration are vulnerable even if they do not support OCSP. Builds using the "no-ocsp" build time option are not affected. Servers using OpenSSL versions prior to 1.0.1g are not vulnerable in a default configuration, instead only if an application explicitly enables OCSP stapling support. Reported by Shi Lei (Gear Team, Qihoo 360 Inc.). <ul class="valid" valid="valid" title="valid: True, node: 434, tag: ul, level: 9" node_number="434"><li class="valid" valid="valid" title="valid: True, node: 435, tag: li, level: 10" node_number="435">Fixed in OpenSSL 1.1.0a <a class="valid" valid="valid" title="valid: True, node: 436, tag: a, level: 11" node_number="436">(git commit)</a> (Affected 1.1.0)</li><li class="valid" valid="valid" title="valid: True, node: 437, tag: li, level: 10" node_number="437">Fixed in OpenSSL 1.0.2i <a class="valid" valid="valid" title="valid: True, node: 438, tag: a, level: 11" node_number="438">(git commit)</a> (Affected 1.0.2-1.0.2h)</li><li class="valid" valid="valid" title="valid: True, node: 439, tag: li, level: 10" node_number="439">Fixed in OpenSSL 1.0.1u <a class="valid" valid="valid" title="valid: True, node: 440, tag: a, level: 11" node_number="440">(git commit)</a> (Affected 1.0.1-1.0.1t)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 441, tag: dt, level: 8" node_number="441"><a class="valid" valid="valid" title="valid: True, node: 442, tag: a, level: 9" node_number="442">CVE-2016-6308</a> <a class="valid" valid="valid" title="valid: True, node: 443, tag: a, level: 9" node_number="443">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 444, tag: a, level: 9" node_number="444">[Low severity]</a> 21 September 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 445, tag: dd, level: 8" node_number="445">A DTLS message includes 3 bytes for its length in the header for the message. This would allow for messages up to 16Mb in length. Messages of this length are excessive and OpenSSL includes a check to ensure that a peer is sending reasonably sized messages in order to avoid too much memory being consumed to service a connection. A flaw in the logic of version 1.1.0 means that memory for the message is allocated too early, prior to the excessive message length check. Due to way memory is allocated in OpenSSL this could mean an attacker could force up to 21Mb to be allocated to service a connection. This could lead to a Denial of Service through memory exhaustion. However, the excessive message length check still takes place, and this would cause the connection to immediately fail. Assuming that the application calls SSL_free() on the failed conneciton in a timely manner then the 21Mb of allocated memory will then be immediately freed again. Therefore the excessive memory allocation will be transitory in nature. This then means that there is only a security impact if: 1) The application does not call SSL_free() in a timely manner in the event that the connection fails or 2) The application is working in a constrained environment where there is very little free memory or 3) The attacker initiates multiple connection attempts such that there are multiple connections in a state where memory has been allocated for the connection; SSL_free() has not yet been called; and there is insufficient memory to service the multiple requests. Except in the instance of (1) above any Denial Of Service is likely to be transitory because as soon as the connection fails the memory is subsequently freed again in the SSL_free() call. However there is an increased risk during this period of application crashes due to the lack of memory - which would then mean a more serious Denial of Service. Reported by Shi Lei (Gear Team, Qihoo 360 Inc.). <ul class="valid" valid="valid" title="valid: True, node: 446, tag: ul, level: 9" node_number="446"><li class="valid" valid="valid" title="valid: True, node: 447, tag: li, level: 10" node_number="447">Fixed in OpenSSL 1.1.0a <a class="valid" valid="valid" title="valid: True, node: 448, tag: a, level: 11" node_number="448">(git commit)</a> (Affected 1.1.0)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 449, tag: dt, level: 8" node_number="449"><a class="valid" valid="valid" title="valid: True, node: 450, tag: a, level: 9" node_number="450">CVE-2016-6307</a> <a class="valid" valid="valid" title="valid: True, node: 451, tag: a, level: 9" node_number="451">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 452, tag: a, level: 9" node_number="452">[Low severity]</a> 21 September 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 453, tag: dd, level: 8" node_number="453">A TLS message includes 3 bytes for its length in the header for the message. This would allow for messages up to 16Mb in length. Messages of this length are excessive and OpenSSL includes a check to ensure that a peer is sending reasonably sized messages in order to avoid too much memory being consumed to service a connection. A flaw in the logic of version 1.1.0 means that memory for the message is allocated too early, prior to the excessive message length check. Due to way memory is allocated in OpenSSL this could mean an attacker could force up to 21Mb to be allocated to service a connection. This could lead to a Denial of Service through memory exhaustion. However, the excessive message length check still takes place, and this would cause the connection to immediately fail. Assuming that the application calls SSL_free() on the failed conneciton in a timely manner then the 21Mb of allocated memory will then be immediately freed again. Therefore the excessive memory allocation will be transitory in nature. This then means that there is only a security impact if: 1) The application does not call SSL_free() in a timely manner in the event that the connection fails or 2) The application is working in a constrained environment where there is very little free memory or 3) The attacker initiates multiple connection attempts such that there are multiple connections in a state where memory has been allocated for the connection; SSL_free() has not yet been called; and there is insufficient memory to service the multiple requests. Except in the instance of (1) above any Denial Of Service is likely to be transitory because as soon as the connection fails the memory is subsequently freed again in the SSL_free() call. However there is an increased risk during this period of application crashes due to the lack of memory - which would then mean a more serious Denial of Service. Reported by Shi Lei (Gear Team, Qihoo 360 Inc.). <ul class="valid" valid="valid" title="valid: True, node: 454, tag: ul, level: 9" node_number="454"><li class="valid" valid="valid" title="valid: True, node: 455, tag: li, level: 10" node_number="455">Fixed in OpenSSL 1.1.0a <a class="valid" valid="valid" title="valid: True, node: 456, tag: a, level: 11" node_number="456">(git commit)</a> (Affected 1.1.0)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 457, tag: dt, level: 8" node_number="457"><a class="valid" valid="valid" title="valid: True, node: 458, tag: a, level: 9" node_number="458">CVE-2016-6306</a> <a class="valid" valid="valid" title="valid: True, node: 459, tag: a, level: 9" node_number="459">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 460, tag: a, level: 9" node_number="460">[Low severity]</a> 21 September 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 461, tag: dd, level: 8" node_number="461">In OpenSSL 1.0.2 and earlier some missing message length checks can result in OOB reads of up to 2 bytes beyond an allocated buffer. There is a theoretical DoS risk but this has not been observed in practice on common platforms. The messages affected are client certificate, client certificate request and server certificate. As a result the attack can only be performed against a client or a server which enables client authentication. Reported by Shi Lei (Gear Team, Qihoo 360 Inc.). <ul class="valid" valid="valid" title="valid: True, node: 462, tag: ul, level: 9" node_number="462"><li class="valid" valid="valid" title="valid: True, node: 463, tag: li, level: 10" node_number="463">Fixed in OpenSSL 1.0.2i <a class="valid" valid="valid" title="valid: True, node: 464, tag: a, level: 11" node_number="464">(git commit)</a> (Affected 1.0.2-1.0.2h)</li><li class="valid" valid="valid" title="valid: True, node: 465, tag: li, level: 10" node_number="465">Fixed in OpenSSL 1.0.1u <a class="valid" valid="valid" title="valid: True, node: 466, tag: a, level: 11" node_number="466">(git commit)</a> (Affected 1.0.1-1.0.1t)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 467, tag: dt, level: 8" node_number="467"><a class="valid" valid="valid" title="valid: True, node: 468, tag: a, level: 9" node_number="468">CVE-2016-6303</a> <a class="valid" valid="valid" title="valid: True, node: 469, tag: a, level: 9" node_number="469">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 470, tag: a, level: 9" node_number="470">[Low severity]</a> 24 August 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 471, tag: dd, level: 8" node_number="471">An overflow can occur in MDC2_Update() either if called directly or through the EVP_DigestUpdate() function using MDC2. If an attacker is able to supply very large amounts of input data after a previous call to EVP_EncryptUpdate() with a partial block then a length check can overflow resulting in a heap corruption. The amount of data needed is comparable to SIZE_MAX which is impractical on most platforms. Reported by Shi Lei (Gear Team, Qihoo 360 Inc.). <ul class="valid" valid="valid" title="valid: True, node: 472, tag: ul, level: 9" node_number="472"><li class="valid" valid="valid" title="valid: True, node: 473, tag: li, level: 10" node_number="473">Fixed in OpenSSL 1.0.2i <a class="valid" valid="valid" title="valid: True, node: 474, tag: a, level: 11" node_number="474">(git commit)</a> (Affected 1.0.2-1.0.2h)</li><li class="valid" valid="valid" title="valid: True, node: 475, tag: li, level: 10" node_number="475">Fixed in OpenSSL 1.0.1u <a class="valid" valid="valid" title="valid: True, node: 476, tag: a, level: 11" node_number="476">(git commit)</a> (Affected 1.0.1-1.0.1t)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 477, tag: dt, level: 8" node_number="477"><a class="valid" valid="valid" title="valid: True, node: 478, tag: a, level: 9" node_number="478">CVE-2016-6302</a> <a class="valid" valid="valid" title="valid: True, node: 479, tag: a, level: 9" node_number="479">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 480, tag: a, level: 9" node_number="480">[Low severity]</a> 23 August 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 481, tag: dd, level: 8" node_number="481">If a server uses SHA512 for TLS session ticket HMAC it is vulnerable to a DoS attack where a malformed ticket will result in an OOB read which will ultimately crash. The use of SHA512 in TLS session tickets is comparatively rare as it requires a custom server callback and ticket lookup mechanism. Reported by Shi Lei (Gear Team, Qihoo 360 Inc.). <ul class="valid" valid="valid" title="valid: True, node: 482, tag: ul, level: 9" node_number="482"><li class="valid" valid="valid" title="valid: True, node: 483, tag: li, level: 10" node_number="483">Fixed in OpenSSL 1.0.2i <a class="valid" valid="valid" title="valid: True, node: 484, tag: a, level: 11" node_number="484">(git commit)</a> (Affected 1.0.2-1.0.2h)</li><li class="valid" valid="valid" title="valid: True, node: 485, tag: li, level: 10" node_number="485">Fixed in OpenSSL 1.0.1u <a class="valid" valid="valid" title="valid: True, node: 486, tag: a, level: 11" node_number="486">(git commit)</a> (Affected 1.0.1-1.0.1t)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 487, tag: dt, level: 8" node_number="487"><a class="valid" valid="valid" title="valid: True, node: 488, tag: a, level: 9" node_number="488">CVE-2016-2179</a> <a class="valid" valid="valid" title="valid: True, node: 489, tag: a, level: 9" node_number="489">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 490, tag: a, level: 9" node_number="490">[Low severity]</a> 22 August 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 491, tag: dd, level: 8" node_number="491">In a DTLS connection where handshake messages are delivered out-of-order those messages that OpenSSL is not yet ready to process will be buffered for later use. Under certain circumstances, a flaw in the logic means that those messages do not get removed from the buffer even though the handshake has been completed. An attacker could force up to approx. 15 messages to remain in the buffer when they are no longer required. These messages will be cleared when the DTLS connection is closed. The default maximum size for a message is 100k. Therefore the attacker could force an additional 1500k to be consumed per connection. By opening many simulataneous connections an attacker could cause a DoS attack through memory exhaustion. Reported by Quan Luo. <ul class="valid" valid="valid" title="valid: True, node: 492, tag: ul, level: 9" node_number="492"><li class="valid" valid="valid" title="valid: True, node: 493, tag: li, level: 10" node_number="493">Fixed in OpenSSL 1.0.2i <a class="valid" valid="valid" title="valid: True, node: 494, tag: a, level: 11" node_number="494">(git commit)</a> (Affected 1.0.2-1.0.2h)</li><li class="valid" valid="valid" title="valid: True, node: 495, tag: li, level: 10" node_number="495">Fixed in OpenSSL 1.0.1u <a class="valid" valid="valid" title="valid: True, node: 496, tag: a, level: 11" node_number="496">(git commit)</a> (Affected 1.0.1-1.0.1t)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 497, tag: dt, level: 8" node_number="497"><a class="valid" valid="valid" title="valid: True, node: 498, tag: a, level: 9" node_number="498">CVE-2016-2181</a> <a class="valid" valid="valid" title="valid: True, node: 499, tag: a, level: 9" node_number="499">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 500, tag: a, level: 9" node_number="500">[Low severity]</a> 19 August 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 501, tag: dd, level: 8" node_number="501">A flaw in the DTLS replay attack protection mechanism means that records that arrive for future epochs update the replay protection "window" before the MAC for the record has been validated. This could be exploited by an attacker by sending a record for the next epoch (which does not have to decrypt or have a valid MAC), with a very large sequence number. This means that all subsequent legitimate packets are dropped causing a denial of service for a specific DTLS connection. Reported by OCAP audit team. <ul class="valid" valid="valid" title="valid: True, node: 502, tag: ul, level: 9" node_number="502"><li class="valid" valid="valid" title="valid: True, node: 503, tag: li, level: 10" node_number="503">Fixed in OpenSSL 1.0.2i <a class="valid" valid="valid" title="valid: True, node: 504, tag: a, level: 11" node_number="504">(git commit)</a> (Affected 1.0.2-1.0.2h)</li><li class="valid" valid="valid" title="valid: True, node: 505, tag: li, level: 10" node_number="505">Fixed in OpenSSL 1.0.1u <a class="valid" valid="valid" title="valid: True, node: 506, tag: a, level: 11" node_number="506">(git commit)</a> (Affected 1.0.1-1.0.1t)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 507, tag: dt, level: 8" node_number="507"><a class="valid" valid="valid" title="valid: True, node: 508, tag: a, level: 9" node_number="508">CVE-2016-2182</a> <a class="valid" valid="valid" title="valid: True, node: 509, tag: a, level: 9" node_number="509">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 510, tag: a, level: 9" node_number="510">[Low severity]</a> 16 August 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 511, tag: dd, level: 8" node_number="511">The function BN_bn2dec() does not check the return value of BN_div_word(). This can cause an OOB write if an application uses this function with an overly large BIGNUM. This could be a problem if an overly large certificate or CRL is printed out from an untrusted source. TLS is not affected because record limits will reject an oversized certificate before it is parsed. Reported by Shi Lei (Gear Team, Qihoo 360 Inc.). <ul class="valid" valid="valid" title="valid: True, node: 512, tag: ul, level: 9" node_number="512"><li class="valid" valid="valid" title="valid: True, node: 513, tag: li, level: 10" node_number="513">Fixed in OpenSSL 1.0.2i (Affected 1.0.2-1.0.2h)</li><li class="valid" valid="valid" title="valid: True, node: 514, tag: li, level: 10" node_number="514">Fixed in OpenSSL 1.0.1u (Affected 1.0.1-1.0.1t)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 515, tag: dt, level: 8" node_number="515"><a class="valid" valid="valid" title="valid: True, node: 516, tag: a, level: 9" node_number="516">CVE-2016-2180</a> <a class="valid" valid="valid" title="valid: True, node: 517, tag: a, level: 9" node_number="517">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 518, tag: a, level: 9" node_number="518">[Low severity]</a> 22 July 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 519, tag: dd, level: 8" node_number="519">The function TS_OBJ_print_bio() misuses OBJ_obj2txt(): the return value is the total length the OID text representation would use and not the amount of data written. This will result in OOB reads when large OIDs are presented. Reported by Shi Lei (Gear Team, Qihoo 360 Inc.). <ul class="valid" valid="valid" title="valid: True, node: 520, tag: ul, level: 9" node_number="520"><li class="valid" valid="valid" title="valid: True, node: 521, tag: li, level: 10" node_number="521">Fixed in OpenSSL 1.0.2i (Affected 1.0.2-1.0.2h)</li><li class="valid" valid="valid" title="valid: True, node: 522, tag: li, level: 10" node_number="522">Fixed in OpenSSL 1.0.1u (Affected 1.0.1-1.0.1t)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 523, tag: dt, level: 8" node_number="523"><a class="valid" valid="valid" title="valid: True, node: 524, tag: a, level: 9" node_number="524">CVE-2016-2178</a> <a class="valid" valid="valid" title="valid: True, node: 525, tag: a, level: 9" node_number="525">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 526, tag: a, level: 9" node_number="526">[Low severity]</a> 07 June 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 527, tag: dd, level: 8" node_number="527">Operations in the DSA signing algorithm should run in constant time in order to avoid side channel attacks. A flaw in the OpenSSL DSA implementation means that a non-constant time codepath is followed for certain operations. This has been demonstrated through a cache-timing attack to be sufficient for an attacker to recover the private DSA key. Reported by C&#233;sar Pereida (Aalto University), Billy Brumley (Tampere University of Technology), and Yuval Yarom (The University of Adelaide and NICTA). <ul class="valid" valid="valid" title="valid: True, node: 528, tag: ul, level: 9" node_number="528"><li class="valid" valid="valid" title="valid: True, node: 529, tag: li, level: 10" node_number="529">Fixed in OpenSSL 1.0.2i (Affected 1.0.2-1.0.2h)</li><li class="valid" valid="valid" title="valid: True, node: 530, tag: li, level: 10" node_number="530">Fixed in OpenSSL 1.0.1u (Affected 1.0.1-1.0.1t)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 531, tag: dt, level: 8" node_number="531"><a class="valid" valid="valid" title="valid: True, node: 532, tag: a, level: 9" node_number="532">CVE-2016-2177</a> <a class="valid" valid="valid" title="valid: True, node: 533, tag: a, level: 9" node_number="533">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 534, tag: a, level: 9" node_number="534">[Low severity]</a> 01 June 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 535, tag: dd, level: 8" node_number="535">Avoid some undefined pointer arithmetic A common idiom in the codebase is to check limits in the following manner: "p + len &gt; limit" Where "p" points to some malloc'd data of SIZE bytes and limit == p + SIZE "len" here could be from some externally supplied data (e.g. from a TLS message). The rules of C pointer arithmetic are such that "p + len" is only well defined where len &lt;= SIZE. Therefore the above idiom is actually undefined behaviour. For example this could cause problems if some malloc implementation provides an address for "p" such that "p + len" actually overflows for values of len that are too big and therefore p + len &lt; limit. Reported by Guido Vranken. <ul class="valid" valid="valid" title="valid: True, node: 536, tag: ul, level: 9" node_number="536"><li class="valid" valid="valid" title="valid: True, node: 537, tag: li, level: 10" node_number="537">Fixed in OpenSSL 1.0.2i (Affected 1.0.2-1.0.2h)</li><li class="valid" valid="valid" title="valid: True, node: 538, tag: li, level: 10" node_number="538">Fixed in OpenSSL 1.0.1u (Affected 1.0.1-1.0.1t)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 539, tag: dt, level: 8" node_number="539"><a class="valid" valid="valid" title="valid: True, node: 540, tag: a, level: 9" node_number="540">CVE-2016-2176</a> <a class="valid" valid="valid" title="valid: True, node: 541, tag: a, level: 9" node_number="541">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 542, tag: a, level: 9" node_number="542">[Low severity]</a> 03 May 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 543, tag: dd, level: 8" node_number="543">ASN1 Strings that are over 1024 bytes can cause an overread in applications using the X509_NAME_oneline() function on EBCDIC systems. This could result in arbitrary stack data being returned in the buffer. Reported by Guido Vranken. <ul class="valid" valid="valid" title="valid: True, node: 544, tag: ul, level: 9" node_number="544"><li class="valid" valid="valid" title="valid: True, node: 545, tag: li, level: 10" node_number="545">Fixed in OpenSSL 1.0.2h (Affected 1.0.2-1.0.2g)</li><li class="valid" valid="valid" title="valid: True, node: 546, tag: li, level: 10" node_number="546">Fixed in OpenSSL 1.0.1t (Affected 1.0.1-1.0.1s)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 547, tag: dt, level: 8" node_number="547"><a class="valid" valid="valid" title="valid: True, node: 548, tag: a, level: 9" node_number="548">CVE-2016-2109</a> <a class="valid" valid="valid" title="valid: True, node: 549, tag: a, level: 9" node_number="549">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 550, tag: a, level: 9" node_number="550">[Low severity]</a> 03 May 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 551, tag: dd, level: 8" node_number="551">When ASN.1 data is read from a BIO using functions such as d2i_CMS_bio() a short invalid encoding can casuse allocation of large amounts of memory potentially consuming excessive resources or exhausting memory. Any application parsing untrusted data through d2i BIO functions is affected. The memory based functions such as d2i_X509() are *not* affected. Since the memory based functions are used by the TLS library, TLS applications are not affected. Reported by Brian Carpenter. <ul class="valid" valid="valid" title="valid: True, node: 552, tag: ul, level: 9" node_number="552"><li class="valid" valid="valid" title="valid: True, node: 553, tag: li, level: 10" node_number="553">Fixed in OpenSSL 1.0.2h (Affected 1.0.2-1.0.2g)</li><li class="valid" valid="valid" title="valid: True, node: 554, tag: li, level: 10" node_number="554">Fixed in OpenSSL 1.0.1t (Affected 1.0.1-1.0.1s)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 555, tag: dt, level: 8" node_number="555"><a class="valid" valid="valid" title="valid: True, node: 556, tag: a, level: 9" node_number="556">CVE-2016-2108</a> <a class="valid" valid="valid" title="valid: True, node: 557, tag: a, level: 9" node_number="557">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 558, tag: a, level: 9" node_number="558">[High severity]</a> 03 May 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 559, tag: dd, level: 8" node_number="559">This issue affected versions of OpenSSL prior to April 2015. The bug causing the vulnerability was fixed on April 18th 2015, and released as part of the June 11th 2015 security releases. The security impact of the bug was not known at the time. In previous versions of OpenSSL, ASN.1 encoding the value zero represented as a negative integer can cause a buffer underflow with an out-of-bounds write in i2c_ASN1_INTEGER. The ASN.1 parser does not normally create "negative zeroes" when parsing ASN.1 input, and therefore, an attacker cannot trigger this bug. However, a second, independent bug revealed that the ASN.1 parser (specifically, d2i_ASN1_TYPE) can misinterpret a large universal tag as a negative zero value. Large universal tags are not present in any common ASN.1 structures (such as X509) but are accepted as part of ANY structures. Therefore, if an application deserializes untrusted ASN.1 structures containing an ANY field, and later reserializes them, an attacker may be able to trigger an out-of-bounds write. This has been shown to cause memory corruption that is potentially exploitable with some malloc implementations. Applications that parse and re-encode X509 certificates are known to be vulnerable. Applications that verify RSA signatures on X509 certificates may also be vulnerable; however, only certificates with valid signatures trigger ASN.1 re-encoding and hence the bug. Specifically, since OpenSSL's default TLS X509 chain verification code verifies the certificate chain from root to leaf, TLS handshakes could only be targeted with valid certificates issued by trusted Certification Authorities. Reported by Huzaifa Sidhpurwala (Red Hat), Hanno B&#246;ck, David Benjamin (Google). <ul class="valid" valid="valid" title="valid: True, node: 560, tag: ul, level: 9" node_number="560"><li class="valid" valid="valid" title="valid: True, node: 561, tag: li, level: 10" node_number="561">Fixed in OpenSSL 1.0.2c (Affected 1.0.2-1.0.2b)</li><li class="valid" valid="valid" title="valid: True, node: 562, tag: li, level: 10" node_number="562">Fixed in OpenSSL 1.0.1o (Affected 1.0.1-1.0.1n)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 563, tag: dt, level: 8" node_number="563"><a class="valid" valid="valid" title="valid: True, node: 564, tag: a, level: 9" node_number="564">CVE-2016-2107</a> <a class="valid" valid="valid" title="valid: True, node: 565, tag: a, level: 9" node_number="565">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 566, tag: a, level: 9" node_number="566">[High severity]</a> 03 May 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 567, tag: dd, level: 8" node_number="567">A MITM attacker can use a padding oracle attack to decrypt traffic when the connection uses an AES CBC cipher and the server support AES-NI. This issue was introduced as part of the fix for Lucky 13 padding attack (CVE-2013-0169). The padding check was rewritten to be in constant time by making sure that always the same bytes are read and compared against either the MAC or padding bytes. But it no longer checked that there was enough data to have both the MAC and padding bytes. Reported by Juraj Somorovsky. <ul class="valid" valid="valid" title="valid: True, node: 568, tag: ul, level: 9" node_number="568"><li class="valid" valid="valid" title="valid: True, node: 569, tag: li, level: 10" node_number="569">Fixed in OpenSSL 1.0.2h <a class="valid" valid="valid" title="valid: True, node: 570, tag: a, level: 11" node_number="570">(git commit)</a> (Affected 1.0.2-1.0.2g)</li><li class="valid" valid="valid" title="valid: True, node: 571, tag: li, level: 10" node_number="571">Fixed in OpenSSL 1.0.1t (Affected 1.0.1-1.0.1s)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 572, tag: dt, level: 8" node_number="572"><a class="valid" valid="valid" title="valid: True, node: 573, tag: a, level: 9" node_number="573">CVE-2016-2106</a> <a class="valid" valid="valid" title="valid: True, node: 574, tag: a, level: 9" node_number="574">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 575, tag: a, level: 9" node_number="575">[Low severity]</a> 03 May 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 576, tag: dd, level: 8" node_number="576">An overflow can occur in the EVP_EncryptUpdate() function. If an attacker is able to supply very large amounts of input data after a previous call to EVP_EncryptUpdate() with a partial block then a length check can overflow resulting in a heap corruption. Following an analysis of all OpenSSL internal usage of the EVP_EncryptUpdate() function all usage is one of two forms. The first form is where the EVP_EncryptUpdate() call is known to be the first called function after an EVP_EncryptInit(), and therefore that specific call must be safe. The second form is where the length passed to EVP_EncryptUpdate() can be seen from the code to be some small value and therefore there is no possibility of an overflow. Since all instances are one of these two forms, it is believed that there can be no overflows in internal code due to this problem. It should be noted that EVP_DecryptUpdate() can call EVP_EncryptUpdate() in certain code paths. Also EVP_CipherUpdate() is a synonym for EVP_EncryptUpdate(). All instances of these calls have also been analysed too and it is believed there are no instances in internal usage where an overflow could occur. This could still represent a security issue for end user code that calls this function directly. Reported by Guido Vranken. <ul class="valid" valid="valid" title="valid: True, node: 577, tag: ul, level: 9" node_number="577"><li class="valid" valid="valid" title="valid: True, node: 578, tag: li, level: 10" node_number="578">Fixed in OpenSSL 1.0.2h (Affected 1.0.2-1.0.2g)</li><li class="valid" valid="valid" title="valid: True, node: 579, tag: li, level: 10" node_number="579">Fixed in OpenSSL 1.0.1t (Affected 1.0.1-1.0.1s)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 580, tag: dt, level: 8" node_number="580"><a class="valid" valid="valid" title="valid: True, node: 581, tag: a, level: 9" node_number="581">CVE-2016-2105</a> <a class="valid" valid="valid" title="valid: True, node: 582, tag: a, level: 9" node_number="582">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 583, tag: a, level: 9" node_number="583">[Low severity]</a> 03 May 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 584, tag: dd, level: 8" node_number="584">An overflow can occur in the EVP_EncodeUpdate() function which is used for Base64 encoding of binary data. If an attacker is able to supply very large amounts of input data then a length check can overflow resulting in a heap corruption. Internally to OpenSSL the EVP_EncodeUpdate() function is primarly used by the PEM_write_bio* family of functions. These are mainly used within the OpenSSL command line applications. These internal uses are not considered vulnerable because all calls are bounded with length checks so no overflow is possible. User applications that call these APIs directly with large amounts of untrusted data may be vulnerable. (Note: Initial analysis suggested that the PEM_write_bio* were vulnerable, and this is reflected in the patch commit message. This is no longer believed to be the case). Reported by Guido Vranken. <ul class="valid" valid="valid" title="valid: True, node: 585, tag: ul, level: 9" node_number="585"><li class="valid" valid="valid" title="valid: True, node: 586, tag: li, level: 10" node_number="586">Fixed in OpenSSL 1.0.2h (Affected 1.0.2-1.0.2g)</li><li class="valid" valid="valid" title="valid: True, node: 587, tag: li, level: 10" node_number="587">Fixed in OpenSSL 1.0.1t (Affected 1.0.1-1.0.1s)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 588, tag: dt, level: 8" node_number="588"><a class="valid" valid="valid" title="valid: True, node: 589, tag: a, level: 9" node_number="589">CVE-2016-0800</a> <a class="valid" valid="valid" title="valid: True, node: 590, tag: a, level: 9" node_number="590">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 591, tag: a, level: 9" node_number="591">[High severity]</a> 01 March 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 592, tag: dd, level: 8" node_number="592">A cross-protocol attack was discovered that could lead to decryption of TLS sessions by using a server supporting SSLv2 and EXPORT cipher suites as a Bleichenbacher RSA padding oracle. Note that traffic between clients and non-vulnerable servers can be decrypted provided another server supporting SSLv2 and EXPORT ciphers (even with a different protocol such as SMTP, IMAP or POP) shares the RSA keys of the non-vulnerable server. This vulnerability is known as DROWN (CVE-2016-0800). Recovering one session key requires the attacker to perform approximately 2^50 computation, as well as thousands of connections to the affected server. A more efficient variant of the DROWN attack exists against unpatched OpenSSL servers using versions that predate 1.0.2a, 1.0.1m, 1.0.0r and 0.9.8zf released on 19/Mar/2015 (see CVE-2016-0703 below). Users can avoid this issue by disabling the SSLv2 protocol in all their SSL/TLS servers, if they've not done so already. Disabling all SSLv2 ciphers is also sufficient, provided the patches for CVE-2015-3197 (fixed in OpenSSL 1.0.1r and 1.0.2f) have been deployed. Servers that have not disabled the SSLv2 protocol, and are not patched for CVE-2015-3197 are vulnerable to DROWN even if all SSLv2 ciphers are nominally disabled, because malicious clients can force the use of SSLv2 with EXPORT ciphers. OpenSSL 1.0.2g and 1.0.1s deploy the following mitigation against DROWN: SSLv2 is now by default disabled at build-time. Builds that are not configured with "enable-ssl2" will not support SSLv2. Even if "enable-ssl2" is used, users who want to negotiate SSLv2 via the version-flexible SSLv23_method() will need to explicitly call either of: SSL_CTX_clear_options(ctx, SSL_OP_NO_SSLv2); or SSL_clear_options(ssl, SSL_OP_NO_SSLv2); as appropriate. Even if either of those is used, or the application explicitly uses the version-specific SSLv2_method() or its client or server variants, SSLv2 ciphers vulnerable to exhaustive search key recovery have been removed. Specifically, the SSLv2 40-bit EXPORT ciphers, and SSLv2 56-bit DES are no longer available. In addition, weak ciphers in SSLv3 and up are now disabled in default builds of OpenSSL. Builds that are not configured with "enable-weak-ssl-ciphers" will not provide any "EXPORT" or "LOW" strength ciphers. Reported by Nimrod Aviram and Sebastian Schinzel. <ul class="valid" valid="valid" title="valid: True, node: 593, tag: ul, level: 9" node_number="593"><li class="valid" valid="valid" title="valid: True, node: 594, tag: li, level: 10" node_number="594">Fixed in OpenSSL 1.0.2g (Affected 1.0.2-1.0.2f)</li><li class="valid" valid="valid" title="valid: True, node: 595, tag: li, level: 10" node_number="595">Fixed in OpenSSL 1.0.1s (Affected 1.0.1-1.0.1r)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 596, tag: dt, level: 8" node_number="596"><a class="valid" valid="valid" title="valid: True, node: 597, tag: a, level: 9" node_number="597">CVE-2016-0799</a> <a class="valid" valid="valid" title="valid: True, node: 598, tag: a, level: 9" node_number="598">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 599, tag: a, level: 9" node_number="599">[Low severity]</a> 01 March 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 600, tag: dd, level: 8" node_number="600">The internal |fmtstr| function used in processing a "%s" format string in the BIO_*printf functions could overflow while calculating the length of a string and cause an OOB read when printing very long strings. Additionally the internal |doapr_outch| function can attempt to write to an OOB memory location (at an offset from the NULL pointer) in the event of a memory allocation failure. In 1.0.2 and below this could be caused where the size of a buffer to be allocated is greater than INT_MAX. E.g. this could be in processing a very long "%s" format string. Memory leaks can also occur. The first issue may mask the second issue dependent on compiler behaviour. These problems could enable attacks where large amounts of untrusted data is passed to the BIO_*printf functions. If applications use these functions in this way then they could be vulnerable. OpenSSL itself uses these functions when printing out human-readable dumps of ASN.1 data. Therefore applications that print this data could be vulnerable if the data is from untrusted sources. OpenSSL command line applications could also be vulnerable where they print out ASN.1 data, or if untrusted data is passed as command line arguments. Libssl is not considered directly vulnerable. Additionally certificates etc received via remote connections via libssl are also unlikely to be able to trigger these issues because of message size limits enforced within libssl. Reported by Guido Vranken. <ul class="valid" valid="valid" title="valid: True, node: 601, tag: ul, level: 9" node_number="601"><li class="valid" valid="valid" title="valid: True, node: 602, tag: li, level: 10" node_number="602">Fixed in OpenSSL 1.0.2g (Affected 1.0.2-1.0.2f)</li><li class="valid" valid="valid" title="valid: True, node: 603, tag: li, level: 10" node_number="603">Fixed in OpenSSL 1.0.1s (Affected 1.0.1-1.0.1r)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 604, tag: dt, level: 8" node_number="604"><a class="valid" valid="valid" title="valid: True, node: 605, tag: a, level: 9" node_number="605">CVE-2016-0798</a> <a class="valid" valid="valid" title="valid: True, node: 606, tag: a, level: 9" node_number="606">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 607, tag: a, level: 9" node_number="607">[Low severity]</a> 01 March 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 608, tag: dd, level: 8" node_number="608">The SRP user database lookup method SRP_VBASE_get_by_user had confusing memory management semantics; the returned pointer was sometimes newly allocated, and sometimes owned by the callee. The calling code has no way of distinguishing these two cases. Specifically, SRP servers that configure a secret seed to hide valid login information are vulnerable to a memory leak: an attacker connecting with an invalid username can cause a memory leak of around 300 bytes per connection. Servers that do not configure SRP, or configure SRP but do not configure a seed are not vulnerable. In Apache, the seed directive is known as SSLSRPUnknownUserSeed. To mitigate the memory leak, the seed handling in SRP_VBASE_get_by_user is now disabled even if the user has configured a seed. Applications are advised to migrate to SRP_VBASE_get1_by_user. However, note that OpenSSL makes no strong guarantees about the indistinguishability of valid and invalid logins. In particular, computations are currently not carried out in constant time. Reported by Emilia K&#228;sper (OpenSSL). <ul class="valid" valid="valid" title="valid: True, node: 609, tag: ul, level: 9" node_number="609"><li class="valid" valid="valid" title="valid: True, node: 610, tag: li, level: 10" node_number="610">Fixed in OpenSSL 1.0.2g (Affected 1.0.2-1.0.2f)</li><li class="valid" valid="valid" title="valid: True, node: 611, tag: li, level: 10" node_number="611">Fixed in OpenSSL 1.0.1s (Affected 1.0.1-1.0.1r)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 612, tag: dt, level: 8" node_number="612"><a class="valid" valid="valid" title="valid: True, node: 613, tag: a, level: 9" node_number="613">CVE-2016-0797</a> <a class="valid" valid="valid" title="valid: True, node: 614, tag: a, level: 9" node_number="614">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 615, tag: a, level: 9" node_number="615">[Low severity]</a> 01 March 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 616, tag: dd, level: 8" node_number="616">In the BN_hex2bn function the number of hex digits is calculated using an int value |i|. Later |bn_expand| is called with a value of |i * 4|. For large values of |i| this can result in |bn_expand| not allocating any memory because |i * 4| is negative. This can leave the internal BIGNUM data field as NULL leading to a subsequent NULL ptr deref. For very large values of |i|, the calculation |i * 4| could be a positive value smaller than |i|. In this case memory is allocated to the internal BIGNUM data field, but it is insufficiently sized leading to heap corruption. A similar issue exists in BN_dec2bn. This could have security consequences if BN_hex2bn/BN_dec2bn is ever called by user applications with very large untrusted hex/dec data. This is anticipated to be a rare occurrence. All OpenSSL internal usage of these functions use data that is not expected to be untrusted, e.g. config file data or application command line arguments. If user developed applications generate config file data based on untrusted data then it is possible that this could also lead to security consequences. This is also anticipated to be rare. Reported by Guido Vranken. <ul class="valid" valid="valid" title="valid: True, node: 617, tag: ul, level: 9" node_number="617"><li class="valid" valid="valid" title="valid: True, node: 618, tag: li, level: 10" node_number="618">Fixed in OpenSSL 1.0.2g (Affected 1.0.2-1.0.2f)</li><li class="valid" valid="valid" title="valid: True, node: 619, tag: li, level: 10" node_number="619">Fixed in OpenSSL 1.0.1s (Affected 1.0.1-1.0.1r)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 620, tag: dt, level: 8" node_number="620"><a class="valid" valid="valid" title="valid: True, node: 621, tag: a, level: 9" node_number="621">CVE-2016-0705</a> <a class="valid" valid="valid" title="valid: True, node: 622, tag: a, level: 9" node_number="622">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 623, tag: a, level: 9" node_number="623">[Low severity]</a> 01 March 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 624, tag: dd, level: 8" node_number="624">A double free bug was discovered when OpenSSL parses malformed DSA private keys and could lead to a DoS attack or memory corruption for applications that receive DSA private keys from untrusted sources. This scenario is considered rare. Reported by Adam Langley (Google/BoringSSL). <ul class="valid" valid="valid" title="valid: True, node: 625, tag: ul, level: 9" node_number="625"><li class="valid" valid="valid" title="valid: True, node: 626, tag: li, level: 10" node_number="626">Fixed in OpenSSL 1.0.2g (Affected 1.0.2-1.0.2f)</li><li class="valid" valid="valid" title="valid: True, node: 627, tag: li, level: 10" node_number="627">Fixed in OpenSSL 1.0.1s (Affected 1.0.1-1.0.1r)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 628, tag: dt, level: 8" node_number="628"><a class="valid" valid="valid" title="valid: True, node: 629, tag: a, level: 9" node_number="629">CVE-2016-0704</a> <a class="valid" valid="valid" title="valid: True, node: 630, tag: a, level: 9" node_number="630">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 631, tag: a, level: 9" node_number="631">[Moderate severity]</a> 01 March 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 632, tag: dd, level: 8" node_number="632">This issue only affected versions of OpenSSL prior to March 19th 2015 at which time the code was refactored to address the vulnerability CVE-2015-0293. s2_srvr.c overwrite the wrong bytes in the master-key when applying Bleichenbacher protection for export cipher suites. This provides a Bleichenbacher oracle, and could potentially allow more efficient variants of the DROWN attack. Reported by David Adrian and J.Alex Halderman (University of Michigan). <ul class="valid" valid="valid" title="valid: True, node: 633, tag: ul, level: 9" node_number="633"><li class="valid" valid="valid" title="valid: True, node: 634, tag: li, level: 10" node_number="634">Fixed in OpenSSL 1.0.2a (Affected 1.0.2)</li><li class="valid" valid="valid" title="valid: True, node: 635, tag: li, level: 10" node_number="635">Fixed in OpenSSL 1.0.1m (Affected 1.0.1-1.0.1l)</li><li class="valid" valid="valid" title="valid: True, node: 636, tag: li, level: 10" node_number="636">Fixed in OpenSSL 1.0.0r (Affected 1.0.0-1.0.0q)</li><li class="valid" valid="valid" title="valid: True, node: 637, tag: li, level: 10" node_number="637">Fixed in OpenSSL 0.9.8zf (Affected 0.9.8-0.9.8ze)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 638, tag: dt, level: 8" node_number="638"><a class="valid" valid="valid" title="valid: True, node: 639, tag: a, level: 9" node_number="639">CVE-2016-0703</a> <a class="valid" valid="valid" title="valid: True, node: 640, tag: a, level: 9" node_number="640">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 641, tag: a, level: 9" node_number="641">[High severity]</a> 01 March 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 642, tag: dd, level: 8" node_number="642">This issue only affected versions of OpenSSL prior to March 19th 2015 at which time the code was refactored to address vulnerability CVE-2015-0293. s2_srvr.c did not enforce that clear-key-length is 0 for non-export ciphers. If clear-key bytes are present for these ciphers, they *displace* encrypted-key bytes. This leads to an efficient divide-and-conquer key recovery attack: if an eavesdropper has intercepted an SSLv2 handshake, they can use the server as an oracle to determine the SSLv2 master-key, using only 16 connections to the server and negligible computation. More importantly, this leads to a more efficient version of DROWN that is effective against non-export ciphersuites, and requires no significant computation. Reported by David Adrian and J.Alex Halderman (University of Michigan). <ul class="valid" valid="valid" title="valid: True, node: 643, tag: ul, level: 9" node_number="643"><li class="valid" valid="valid" title="valid: True, node: 644, tag: li, level: 10" node_number="644">Fixed in OpenSSL 1.0.2a (Affected 1.0.2)</li><li class="valid" valid="valid" title="valid: True, node: 645, tag: li, level: 10" node_number="645">Fixed in OpenSSL 1.0.1m (Affected 1.0.1-1.0.1l)</li><li class="valid" valid="valid" title="valid: True, node: 646, tag: li, level: 10" node_number="646">Fixed in OpenSSL 1.0.0r (Affected 1.0.0-1.0.0q)</li><li class="valid" valid="valid" title="valid: True, node: 647, tag: li, level: 10" node_number="647">Fixed in OpenSSL 0.9.8zf (Affected 0.9.8-0.9.8ze)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 648, tag: dt, level: 8" node_number="648"><a class="valid" valid="valid" title="valid: True, node: 649, tag: a, level: 9" node_number="649">CVE-2016-0702</a> <a class="valid" valid="valid" title="valid: True, node: 650, tag: a, level: 9" node_number="650">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 651, tag: a, level: 9" node_number="651">[Low severity]</a> 01 March 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 652, tag: dd, level: 8" node_number="652">A side-channel attack was found which makes use of cache-bank conflicts on the Intel Sandy-Bridge microarchitecture which could lead to the recovery of RSA keys. The ability to exploit this issue is limited as it relies on an attacker who has control of code in a thread running on the same hyper-threaded core as the victim thread which is performing decryptions. Reported by Yuval Yarom, The University of Adelaide and NICTA, Daniel Genkin, Technion and Tel Aviv University, and Nadia Heninger, University of Pennsylvania. <ul class="valid" valid="valid" title="valid: True, node: 653, tag: ul, level: 9" node_number="653"><li class="valid" valid="valid" title="valid: True, node: 654, tag: li, level: 10" node_number="654">Fixed in OpenSSL 1.0.2g (Affected 1.0.2-1.0.2f)</li><li class="valid" valid="valid" title="valid: True, node: 655, tag: li, level: 10" node_number="655">Fixed in OpenSSL 1.0.1s (Affected 1.0.1-1.0.1r)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 656, tag: dt, level: 8" node_number="656"><a class="valid" valid="valid" title="valid: True, node: 657, tag: a, level: 9" node_number="657">CVE-2016-0701</a> <a class="valid" valid="valid" title="valid: True, node: 658, tag: a, level: 9" node_number="658">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 659, tag: a, level: 9" node_number="659">[High severity]</a> 28 January 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 660, tag: dd, level: 8" node_number="660">Historically OpenSSL usually only ever generated DH parameters based on "safe" primes. More recently (in version 1.0.2) support was provided for generating X9.42 style parameter files such as those required for RFC 5114 support. The primes used in such files may not be "safe". Where an application is using DH configured with parameters based on primes that are not "safe" then an attacker could use this fact to find a peer's private DH exponent. This attack requires that the attacker complete multiple handshakes in which the peer uses the same private DH exponent. For example this could be used to discover a TLS server's private DH exponent if it's reusing the private DH exponent or it's using a static DH ciphersuite. OpenSSL provides the option SSL_OP_SINGLE_DH_USE for ephemeral DH (DHE) in TLS. It is not on by default. If the option is not set then the server reuses the same private DH exponent for the life of the server process and would be vulnerable to this attack. It is believed that many popular applications do set this option and would therefore not be at risk. OpenSSL before 1.0.2f will reuse the key if: - SSL_CTX_set_tmp_dh()/SSL_set_tmp_dh() is used and SSL_OP_SINGLE_DH_USE is not set. - SSL_CTX_set_tmp_dh_callback()/SSL_set_tmp_dh_callback() is used, and both the parameters and the key are set and SSL_OP_SINGLE_DH_USE is not used. This is an undocumted feature and parameter files don't contain the key. - Static DH ciphersuites are used. The key is part of the certificate and so it will always reuse it. This is only supported in 1.0.2. It will not reuse the key for DHE ciphers suites if: - SSL_OP_SINGLE_DH_USE is set - SSL_CTX_set_tmp_dh_callback()/SSL_set_tmp_dh_callback() is used and the callback does not provide the key, only the parameters. The callback is almost always used like this. Non-safe primes are generated by OpenSSL when using: - genpkey with the dh_rfc5114 option. This will write an X9.42 style file including the prime-order subgroup size "q". This is supported since the 1.0.2 version. Older versions can't read files generated in this way. - dhparam with the -dsaparam option. This has always been documented as requiring the single use. The fix for this issue adds an additional check where a "q" parameter is available (as is the case in X9.42 based parameters). This detects the only known attack, and is the only possible defense for static DH ciphersuites. This could have some performance impact. Additionally the SSL_OP_SINGLE_DH_USE option has been switched on by default and cannot be disabled. This could have some performance impact. Reported by Antonio Sanso (Adobe). <ul class="valid" valid="valid" title="valid: True, node: 661, tag: ul, level: 9" node_number="661"><li class="valid" valid="valid" title="valid: True, node: 662, tag: li, level: 10" node_number="662">Fixed in OpenSSL 1.0.2f (Affected 1.0.2-1.0.2e)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 663, tag: dt, level: 8" node_number="663"><a class="valid" valid="valid" title="valid: True, node: 664, tag: a, level: 9" node_number="664">CVE-2015-3197</a> <a class="valid" valid="valid" title="valid: True, node: 665, tag: a, level: 9" node_number="665">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 666, tag: a, level: 9" node_number="666">[Low severity]</a> 28 January 2016: </dt><dd class="valid" valid="valid" title="valid: True, node: 667, tag: dd, level: 8" node_number="667">A malicious client can negotiate SSLv2 ciphers that have been disabled on the server and complete SSLv2 handshakes even if all SSLv2 ciphers have been disabled, provided that the SSLv2 protocol was not also disabled via SSL_OP_NO_SSLv2. Reported by Nimrod Aviram and Sebastian Schinzel. <ul class="valid" valid="valid" title="valid: True, node: 668, tag: ul, level: 9" node_number="668"><li class="valid" valid="valid" title="valid: True, node: 669, tag: li, level: 10" node_number="669">Fixed in OpenSSL 1.0.2f (Affected 1.0.2-1.0.2e)</li><li class="valid" valid="valid" title="valid: True, node: 670, tag: li, level: 10" node_number="670">Fixed in OpenSSL 1.0.1r (Affected 1.0.1-1.0.1q)</li></ul></dd></dl><h3 class="valid" valid="valid" title="valid: True, node: 671, tag: h3, level: 7" node_number="671"><a class="valid" valid="valid" title="valid: True, node: 672, tag: a, level: 8" node_number="672">2015</a></h3><dl class="valid" valid="valid" title="valid: True, node: 673, tag: dl, level: 7" node_number="673"><dt class="valid" valid="valid" title="valid: True, node: 674, tag: dt, level: 8" node_number="674"><a class="valid" valid="valid" title="valid: True, node: 675, tag: a, level: 9" node_number="675">CVE-2015-3196</a> <a class="valid" valid="valid" title="valid: True, node: 676, tag: a, level: 9" node_number="676">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 677, tag: a, level: 9" node_number="677">[Low severity]</a> 03 December 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 678, tag: dd, level: 8" node_number="678">If PSK identity hints are received by a multi-threaded client then the values are wrongly updated in the parent SSL_CTX structure. This can result in a race condition potentially leading to a double free of the identify hint data. Reported by Stephen Henson (OpenSSL). <ul class="valid" valid="valid" title="valid: True, node: 679, tag: ul, level: 9" node_number="679"><li class="valid" valid="valid" title="valid: True, node: 680, tag: li, level: 10" node_number="680">Fixed in OpenSSL 1.0.2d (Affected 1.0.2-1.0.2c)</li><li class="valid" valid="valid" title="valid: True, node: 681, tag: li, level: 10" node_number="681">Fixed in OpenSSL 1.0.1p (Affected 1.0.1-1.0.1o)</li><li class="valid" valid="valid" title="valid: True, node: 682, tag: li, level: 10" node_number="682">Fixed in OpenSSL 1.0.0t (Affected 1.0.0-1.0.0g,1.0.0h-1.0.0s)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 683, tag: dt, level: 8" node_number="683"><a class="valid" valid="valid" title="valid: True, node: 684, tag: a, level: 9" node_number="684">CVE-2015-3195</a> <a class="valid" valid="valid" title="valid: True, node: 685, tag: a, level: 9" node_number="685">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 686, tag: a, level: 9" node_number="686">[Moderate severity]</a> 03 December 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 687, tag: dd, level: 8" node_number="687">When presented with a malformed X509_ATTRIBUTE structure OpenSSL will leak memory. This structure is used by the PKCS#7 and CMS routines so any application which reads PKCS#7 or CMS data from untrusted sources is affected. SSL/TLS is not affected. Reported by Adam Langley (Google/BoringSSL) using libFuzzer. <ul class="valid" valid="valid" title="valid: True, node: 688, tag: ul, level: 9" node_number="688"><li class="valid" valid="valid" title="valid: True, node: 689, tag: li, level: 10" node_number="689">Fixed in OpenSSL 1.0.2e (Affected 1.0.2-1.0.2d)</li><li class="valid" valid="valid" title="valid: True, node: 690, tag: li, level: 10" node_number="690">Fixed in OpenSSL 1.0.1q (Affected 1.0.1-1.0.1p)</li><li class="valid" valid="valid" title="valid: True, node: 691, tag: li, level: 10" node_number="691">Fixed in OpenSSL 1.0.0t (Affected 1.0.0-1.0.0g,1.0.0h-1.0.0s)</li><li class="valid" valid="valid" title="valid: True, node: 692, tag: li, level: 10" node_number="692">Fixed in OpenSSL 0.9.8zh (Affected 0.9.8-0.9.8zg)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 693, tag: dt, level: 8" node_number="693"><a class="valid" valid="valid" title="valid: True, node: 694, tag: a, level: 9" node_number="694">CVE-2015-3194</a> <a class="valid" valid="valid" title="valid: True, node: 695, tag: a, level: 9" node_number="695">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 696, tag: a, level: 9" node_number="696">[Moderate severity]</a> 03 December 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 697, tag: dd, level: 8" node_number="697">The signature verification routines will crash with a NULL pointer dereference if presented with an ASN.1 signature using the RSA PSS algorithm and absent mask generation function parameter. Since these routines are used to verify certificate signature algorithms this can be used to crash any certificate verification operation and exploited in a DoS attack. Any application which performs certificate verification is vulnerable including OpenSSL clients and servers which enable client authentication. Reported by Lo&#239;c Jonas Etienne (Qnective AG). <ul class="valid" valid="valid" title="valid: True, node: 698, tag: ul, level: 9" node_number="698"><li class="valid" valid="valid" title="valid: True, node: 699, tag: li, level: 10" node_number="699">Fixed in OpenSSL 1.0.2e (Affected 1.0.2-1.0.2d)</li><li class="valid" valid="valid" title="valid: True, node: 700, tag: li, level: 10" node_number="700">Fixed in OpenSSL 1.0.1q (Affected 1.0.1-1.0.1p)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 701, tag: dt, level: 8" node_number="701"><a class="valid" valid="valid" title="valid: True, node: 702, tag: a, level: 9" node_number="702">CVE-2015-3193</a> <a class="valid" valid="valid" title="valid: True, node: 703, tag: a, level: 9" node_number="703">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 704, tag: a, level: 9" node_number="704">[Moderate severity]</a> 03 December 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 705, tag: dd, level: 8" node_number="705">There is a carry propagating bug in the x86_64 Montgomery squaring procedure. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be very significant and likely only accessible to a limited number of attackers. An attacker would additionally need online access to an unpatched system using the target private key in a scenario with persistent DH parameters and a private key that is shared between multiple clients. For example this can occur by default in OpenSSL DHE based SSL/TLS ciphersuites. Reported by Hanno B&#246;ck. <ul class="valid" valid="valid" title="valid: True, node: 706, tag: ul, level: 9" node_number="706"><li class="valid" valid="valid" title="valid: True, node: 707, tag: li, level: 10" node_number="707">Fixed in OpenSSL 1.0.2e (Affected 1.0.2-1.0.2d)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 708, tag: dt, level: 8" node_number="708"><a class="valid" valid="valid" title="valid: True, node: 709, tag: a, level: 9" node_number="709">CVE-2015-1794</a> <a class="valid" valid="valid" title="valid: True, node: 710, tag: a, level: 9" node_number="710">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 711, tag: a, level: 9" node_number="711">[Low severity]</a> 11 August 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 712, tag: dd, level: 8" node_number="712">If a client receives a ServerKeyExchange for an anonymous DH ciphersuite with the value of p set to 0 then a seg fault can occur leading to a possible denial of service attack. Reported by Guy Leaver (Cisco). <ul class="valid" valid="valid" title="valid: True, node: 713, tag: ul, level: 9" node_number="713"><li class="valid" valid="valid" title="valid: True, node: 714, tag: li, level: 10" node_number="714">Fixed in OpenSSL 1.0.2e (Affected 1.0.2-1.0.2d)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 715, tag: dt, level: 8" node_number="715"><a class="valid" valid="valid" title="valid: True, node: 716, tag: a, level: 9" node_number="716">CVE-2015-1793</a> <a class="valid" valid="valid" title="valid: True, node: 717, tag: a, level: 9" node_number="717">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 718, tag: a, level: 9" node_number="718">[High severity]</a> 09 July 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 719, tag: dd, level: 8" node_number="719">An error in the implementation of the alternative certificate chain logic could allow an attacker to cause certain checks on untrusted certificates to be bypassed, such as the CA flag, enabling them to use a valid leaf certificate to act as a CA and "issue" an invalid certificate. Reported by Adam Langley and David Benjamin (Google/BoringSSL). <ul class="valid" valid="valid" title="valid: True, node: 720, tag: ul, level: 9" node_number="720"><li class="valid" valid="valid" title="valid: True, node: 721, tag: li, level: 10" node_number="721">Fixed in OpenSSL 1.0.2d (Affected 1.0.2b-1.0.2c)</li><li class="valid" valid="valid" title="valid: True, node: 722, tag: li, level: 10" node_number="722">Fixed in OpenSSL 1.0.1p (Affected 1.0.1n-1.0.1o)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 723, tag: dt, level: 8" node_number="723"><a class="valid" valid="valid" title="valid: True, node: 724, tag: a, level: 9" node_number="724">CVE-2015-1792</a> <a class="valid" valid="valid" title="valid: True, node: 725, tag: a, level: 9" node_number="725">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 726, tag: a, level: 9" node_number="726">[Moderate severity]</a> 11 June 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 727, tag: dd, level: 8" node_number="727">When verifying a signedData message the CMS code can enter an infinite loop if presented with an unknown hash function OID. This can be used to perform denial of service against any system which verifies signedData messages using the CMS code. Reported by Johannes Bauer. <ul class="valid" valid="valid" title="valid: True, node: 728, tag: ul, level: 9" node_number="728"><li class="valid" valid="valid" title="valid: True, node: 729, tag: li, level: 10" node_number="729">Fixed in OpenSSL 1.0.2b (Affected 1.0.2-1.0.2a)</li><li class="valid" valid="valid" title="valid: True, node: 730, tag: li, level: 10" node_number="730">Fixed in OpenSSL 1.0.1n (Affected 1.0.1-1.0.1m)</li><li class="valid" valid="valid" title="valid: True, node: 731, tag: li, level: 10" node_number="731">Fixed in OpenSSL 1.0.0s (Affected 1.0.0-1.0.0r)</li><li class="valid" valid="valid" title="valid: True, node: 732, tag: li, level: 10" node_number="732">Fixed in OpenSSL 0.9.8zg (Affected 0.9.8-0.9.8zf)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 733, tag: dt, level: 8" node_number="733"><a class="valid" valid="valid" title="valid: True, node: 734, tag: a, level: 9" node_number="734">CVE-2015-1790</a> <a class="valid" valid="valid" title="valid: True, node: 735, tag: a, level: 9" node_number="735">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 736, tag: a, level: 9" node_number="736">[Moderate severity]</a> 11 June 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 737, tag: dd, level: 8" node_number="737">The PKCS#7 parsing code does not handle missing inner EncryptedContent correctly. An attacker can craft malformed ASN.1-encoded PKCS#7 blobs with missing content and trigger a NULL pointer dereference on parsing. Applications that decrypt PKCS#7 data or otherwise parse PKCS#7 structures from untrusted sources are affected. OpenSSL clients and servers are not affected. Reported by Michal Zalewski (Google). <ul class="valid" valid="valid" title="valid: True, node: 738, tag: ul, level: 9" node_number="738"><li class="valid" valid="valid" title="valid: True, node: 739, tag: li, level: 10" node_number="739">Fixed in OpenSSL 1.0.2b (Affected 1.0.2-1.0.2a)</li><li class="valid" valid="valid" title="valid: True, node: 740, tag: li, level: 10" node_number="740">Fixed in OpenSSL 1.0.1n (Affected 1.0.1-1.0.1m)</li><li class="valid" valid="valid" title="valid: True, node: 741, tag: li, level: 10" node_number="741">Fixed in OpenSSL 1.0.0s (Affected 1.0.0-1.0.0r)</li><li class="valid" valid="valid" title="valid: True, node: 742, tag: li, level: 10" node_number="742">Fixed in OpenSSL 0.9.8zg (Affected 0.9.8-0.9.8zf)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 743, tag: dt, level: 8" node_number="743"><a class="valid" valid="valid" title="valid: True, node: 744, tag: a, level: 9" node_number="744">CVE-2015-1789</a> <a class="valid" valid="valid" title="valid: True, node: 745, tag: a, level: 9" node_number="745">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 746, tag: a, level: 9" node_number="746">[Moderate severity]</a> 11 June 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 747, tag: dd, level: 8" node_number="747">X509_cmp_time does not properly check the length of the ASN1_TIME string and can read a few bytes out of bounds. In addition, X509_cmp_time accepts an arbitrary number of fractional seconds in the time string. An attacker can use this to craft malformed certificates and CRLs of various sizes and potentially cause a segmentation fault, resulting in a DoS on applications that verify certificates or CRLs. TLS clients that verify CRLs are affected. TLS clients and servers with client authentication enabled may be affected if they use custom verification callbacks. Reported by Robert &#346;wi&#281;cki (Google Security Team). Reported by Hanno B&#246;ck. <ul class="valid" valid="valid" title="valid: True, node: 748, tag: ul, level: 9" node_number="748"><li class="valid" valid="valid" title="valid: True, node: 749, tag: li, level: 10" node_number="749">Fixed in OpenSSL 1.0.2b (Affected 1.0.2-1.0.2a)</li><li class="valid" valid="valid" title="valid: True, node: 750, tag: li, level: 10" node_number="750">Fixed in OpenSSL 1.0.1n (Affected 1.0.1-1.0.1m)</li><li class="valid" valid="valid" title="valid: True, node: 751, tag: li, level: 10" node_number="751">Fixed in OpenSSL 1.0.0s (Affected 1.0.0-1.0.0r)</li><li class="valid" valid="valid" title="valid: True, node: 752, tag: li, level: 10" node_number="752">Fixed in OpenSSL 0.9.8zg (Affected 0.9.8-0.9.8zf)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 753, tag: dt, level: 8" node_number="753"><a class="valid" valid="valid" title="valid: True, node: 754, tag: a, level: 9" node_number="754">CVE-2015-1788</a> <a class="valid" valid="valid" title="valid: True, node: 755, tag: a, level: 9" node_number="755">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 756, tag: a, level: 9" node_number="756">[Moderate severity]</a> 11 June 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 757, tag: dd, level: 8" node_number="757">When processing an ECParameters structure OpenSSL enters an infinite loop if the curve specified is over a specially malformed binary polynomial field. This can be used to perform denial of service against any system which processes public keys, certificate requests or certificates. This includes TLS clients and TLS servers with client authentication enabled. Reported by Joseph Birr-Pixton. <ul class="valid" valid="valid" title="valid: True, node: 758, tag: ul, level: 9" node_number="758"><li class="valid" valid="valid" title="valid: True, node: 759, tag: li, level: 10" node_number="759">Fixed in OpenSSL 1.0.2b (Affected 1.0.2-1.0.2a)</li><li class="valid" valid="valid" title="valid: True, node: 760, tag: li, level: 10" node_number="760">Fixed in OpenSSL 1.0.1n (Affected 1.0.1-1.0.1m)</li><li class="valid" valid="valid" title="valid: True, node: 761, tag: li, level: 10" node_number="761">Fixed in OpenSSL 1.0.0e (Affected 1.0.0-1.0.0d)</li><li class="valid" valid="valid" title="valid: True, node: 762, tag: li, level: 10" node_number="762">Fixed in OpenSSL 0.9.8s (Affected 0.9.8-0.9.8r)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 763, tag: dt, level: 8" node_number="763"><a class="valid" valid="valid" title="valid: True, node: 764, tag: a, level: 9" node_number="764">CVE-2014-8176</a> <a class="valid" valid="valid" title="valid: True, node: 765, tag: a, level: 9" node_number="765">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 766, tag: a, level: 9" node_number="766">[Moderate severity]</a> 11 June 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 767, tag: dd, level: 8" node_number="767">This vulnerability does not affect current versions of OpenSSL. It existed in previous OpenSSL versions and was fixed in June 2014. If a DTLS peer receives application data between the ChangeCipherSpec and Finished messages, buffering of such data may cause an invalid free, resulting in a segmentation fault or potentially, memory corruption. Reported by Praveen Kariyanahalli, and subsequently by Ivan Fratric and Felix Groebert (Google). <ul class="valid" valid="valid" title="valid: True, node: 768, tag: ul, level: 9" node_number="768"><li class="valid" valid="valid" title="valid: True, node: 769, tag: li, level: 10" node_number="769">Fixed in OpenSSL 1.0.1h (Affected 1.0.1-1.0.1g)</li><li class="valid" valid="valid" title="valid: True, node: 770, tag: li, level: 10" node_number="770">Fixed in OpenSSL 1.0.0m (Affected 1.0.0-1.0.0l)</li><li class="valid" valid="valid" title="valid: True, node: 771, tag: li, level: 10" node_number="771">Fixed in OpenSSL 0.9.8za (Affected 0.9.8-0.9.8y)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 772, tag: dt, level: 8" node_number="772"><a class="valid" valid="valid" title="valid: True, node: 773, tag: a, level: 9" node_number="773">CVE-2015-1791</a> <a class="valid" valid="valid" title="valid: True, node: 774, tag: a, level: 9" node_number="774">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 775, tag: a, level: 9" node_number="775">[Low severity]</a> 02 June 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 776, tag: dd, level: 8" node_number="776">If a NewSessionTicket is received by a multi-threaded client when attempting to reuse a previous ticket then a race condition can occur potentially leading to a double free of the ticket data. Reported by Emilia K&#228;sper (OpenSSL). <ul class="valid" valid="valid" title="valid: True, node: 777, tag: ul, level: 9" node_number="777"><li class="valid" valid="valid" title="valid: True, node: 778, tag: li, level: 10" node_number="778">Fixed in OpenSSL 1.0.2b (Affected 1.0.2-1.0.2a)</li><li class="valid" valid="valid" title="valid: True, node: 779, tag: li, level: 10" node_number="779">Fixed in OpenSSL 1.0.1n (Affected 1.0.1-1.0.1m)</li><li class="valid" valid="valid" title="valid: True, node: 780, tag: li, level: 10" node_number="780">Fixed in OpenSSL 1.0.0s (Affected 1.0.0-1.0.0r)</li><li class="valid" valid="valid" title="valid: True, node: 781, tag: li, level: 10" node_number="781">Fixed in OpenSSL 0.9.8zg (Affected 0.9.8-0.9.8zf)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 782, tag: dt, level: 8" node_number="782"><a class="valid" valid="valid" title="valid: True, node: 783, tag: a, level: 9" node_number="783">CVE-2015-1787</a> <a class="valid" valid="valid" title="valid: True, node: 784, tag: a, level: 9" node_number="784">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 785, tag: a, level: 9" node_number="785">[Moderate severity]</a> 19 March 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 786, tag: dd, level: 8" node_number="786">Empty CKE with client auth and DHE. If client auth is used then a server can seg fault in the event of a DHE ciphersuite being selected and a zero length ClientKeyExchange message being sent by the client. This could be exploited in a DoS attack. Reported by Matt Caswell (OpenSSL development team). <ul class="valid" valid="valid" title="valid: True, node: 787, tag: ul, level: 9" node_number="787"><li class="valid" valid="valid" title="valid: True, node: 788, tag: li, level: 10" node_number="788">Fixed in OpenSSL 1.0.2a (Affected 1.0.2)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 789, tag: dt, level: 8" node_number="789"><a class="valid" valid="valid" title="valid: True, node: 790, tag: a, level: 9" node_number="790">CVE-2015-0293</a> <a class="valid" valid="valid" title="valid: True, node: 791, tag: a, level: 9" node_number="791">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 792, tag: a, level: 9" node_number="792">[Moderate severity]</a> 19 March 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 793, tag: dd, level: 8" node_number="793">DoS via reachable assert in SSLv2 servers. A malicious client can trigger an OPENSSL_assert in servers that both support SSLv2 and enable export cipher suites by sending a specially crafted SSLv2 CLIENT-MASTER-KEY message. Reported by Sean Burford (Google) and Emilia K&#228;sper (OpenSSL development team). <ul class="valid" valid="valid" title="valid: True, node: 794, tag: ul, level: 9" node_number="794"><li class="valid" valid="valid" title="valid: True, node: 795, tag: li, level: 10" node_number="795">Fixed in OpenSSL 1.0.2a (Affected 1.0.2)</li><li class="valid" valid="valid" title="valid: True, node: 796, tag: li, level: 10" node_number="796">Fixed in OpenSSL 1.0.1m (Affected 1.0.1-1.0.1l)</li><li class="valid" valid="valid" title="valid: True, node: 797, tag: li, level: 10" node_number="797">Fixed in OpenSSL 1.0.0r (Affected 1.0.0-1.0.0q)</li><li class="valid" valid="valid" title="valid: True, node: 798, tag: li, level: 10" node_number="798">Fixed in OpenSSL 0.9.8zf (Affected 0.9.8-0.9.8ze)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 799, tag: dt, level: 8" node_number="799"><a class="valid" valid="valid" title="valid: True, node: 800, tag: a, level: 9" node_number="800">CVE-2015-0292</a> <a class="valid" valid="valid" title="valid: True, node: 801, tag: a, level: 9" node_number="801">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 802, tag: a, level: 9" node_number="802">[Moderate severity]</a> 19 March 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 803, tag: dd, level: 8" node_number="803">A vulnerability existed in previous versions of OpenSSL related to the processing of base64 encoded data. Any code path that reads base64 data from an untrusted source could be affected (such as the PEM processing routines). Maliciously crafted base 64 data could trigger a segmenation fault or memory corruption. Reported by Robert Dugal, also David Ramos, also Huzaifa Sidhpurwala (Red Hat). <ul class="valid" valid="valid" title="valid: True, node: 804, tag: ul, level: 9" node_number="804"><li class="valid" valid="valid" title="valid: True, node: 805, tag: li, level: 10" node_number="805">Fixed in OpenSSL 1.0.1h (Affected 1.0.1-1.0.1g)</li><li class="valid" valid="valid" title="valid: True, node: 806, tag: li, level: 10" node_number="806">Fixed in OpenSSL 1.0.0m (Affected 1.0.0-1.0.0l)</li><li class="valid" valid="valid" title="valid: True, node: 807, tag: li, level: 10" node_number="807">Fixed in OpenSSL 0.9.8za (Affected 0.9.8-0.9.8y)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 808, tag: dt, level: 8" node_number="808"><a class="valid" valid="valid" title="valid: True, node: 809, tag: a, level: 9" node_number="809">CVE-2015-0291</a> <a class="valid" valid="valid" title="valid: True, node: 810, tag: a, level: 9" node_number="810">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 811, tag: a, level: 9" node_number="811">[High severity]</a> 19 March 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 812, tag: dd, level: 8" node_number="812">ClientHello sigalgs DoS. If a client connects to an OpenSSL 1.0.2 server and renegotiates with an invalid signature algorithms extension a NULL pointer dereference will occur. This can be exploited in a DoS attack against the server. Reported by David Ramos (Stanford University). <ul class="valid" valid="valid" title="valid: True, node: 813, tag: ul, level: 9" node_number="813"><li class="valid" valid="valid" title="valid: True, node: 814, tag: li, level: 10" node_number="814">Fixed in OpenSSL 1.0.2a (Affected 1.0.2)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 815, tag: dt, level: 8" node_number="815"><a class="valid" valid="valid" title="valid: True, node: 816, tag: a, level: 9" node_number="816">CVE-2015-0290</a> <a class="valid" valid="valid" title="valid: True, node: 817, tag: a, level: 9" node_number="817">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 818, tag: a, level: 9" node_number="818">[Moderate severity]</a> 19 March 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 819, tag: dd, level: 8" node_number="819">Multiblock corrupted pointer. OpenSSL 1.0.2 introduced the "multiblock" performance improvement. This feature only applies on 64 bit x86 architecture platforms that support AES NI instructions. A defect in the implementation of "multiblock" can cause OpenSSL's internal write buffer to become incorrectly set to NULL when using non-blocking IO. Typically, when the user application is using a socket BIO for writing, this will only result in a failed connection. However if some other BIO is used then it is likely that a segmentation fault will be triggered, thus enabling a potential DoS attack. Reported by Daniel Danner and Rainer Mueller. <ul class="valid" valid="valid" title="valid: True, node: 820, tag: ul, level: 9" node_number="820"><li class="valid" valid="valid" title="valid: True, node: 821, tag: li, level: 10" node_number="821">Fixed in OpenSSL 1.0.2a (Affected 1.0.2)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 822, tag: dt, level: 8" node_number="822"><a class="valid" valid="valid" title="valid: True, node: 823, tag: a, level: 9" node_number="823">CVE-2015-0289</a> <a class="valid" valid="valid" title="valid: True, node: 824, tag: a, level: 9" node_number="824">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 825, tag: a, level: 9" node_number="825">[Moderate severity]</a> 19 March 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 826, tag: dd, level: 8" node_number="826">PKCS#7 NULL pointer dereference. The PKCS#7 parsing code does not handle missing outer ContentInfo correctly. An attacker can craft malformed ASN.1-encoded PKCS#7 blobs with missing content and trigger a NULL pointer dereference on parsing. Applications that verify PKCS#7 signatures, decrypt PKCS#7 data or otherwise parse PKCS#7 structures from untrusted sources are affected. OpenSSL clients and servers are not affected. Reported by Michal Zalewski (Google). <ul class="valid" valid="valid" title="valid: True, node: 827, tag: ul, level: 9" node_number="827"><li class="valid" valid="valid" title="valid: True, node: 828, tag: li, level: 10" node_number="828">Fixed in OpenSSL 1.0.2a (Affected 1.0.2)</li><li class="valid" valid="valid" title="valid: True, node: 829, tag: li, level: 10" node_number="829">Fixed in OpenSSL 1.0.1m (Affected 1.0.1-1.0.1l)</li><li class="valid" valid="valid" title="valid: True, node: 830, tag: li, level: 10" node_number="830">Fixed in OpenSSL 1.0.0r (Affected 1.0.0-1.0.0q)</li><li class="valid" valid="valid" title="valid: True, node: 831, tag: li, level: 10" node_number="831">Fixed in OpenSSL 0.9.8zf (Affected 0.9.8-0.9.8ze)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 832, tag: dt, level: 8" node_number="832"><a class="valid" valid="valid" title="valid: True, node: 833, tag: a, level: 9" node_number="833">CVE-2015-0287</a> <a class="valid" valid="valid" title="valid: True, node: 834, tag: a, level: 9" node_number="834">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 835, tag: a, level: 9" node_number="835">[Moderate severity]</a> 19 March 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 836, tag: dd, level: 8" node_number="836">ASN.1 structure reuse memory corruption. Reusing a structure in ASN.1 parsing may allow an attacker to cause memory corruption via an invalid write. Such reuse is and has been strongly discouraged and is believed to be rare. Reported by Emilia K&#228;sper (OpenSSL development team). <ul class="valid" valid="valid" title="valid: True, node: 837, tag: ul, level: 9" node_number="837"><li class="valid" valid="valid" title="valid: True, node: 838, tag: li, level: 10" node_number="838">Fixed in OpenSSL 1.0.2a (Affected 1.0.2)</li><li class="valid" valid="valid" title="valid: True, node: 839, tag: li, level: 10" node_number="839">Fixed in OpenSSL 1.0.1m (Affected 1.0.1-1.0.1l)</li><li class="valid" valid="valid" title="valid: True, node: 840, tag: li, level: 10" node_number="840">Fixed in OpenSSL 1.0.0r (Affected 1.0.0-1.0.0q)</li><li class="valid" valid="valid" title="valid: True, node: 841, tag: li, level: 10" node_number="841">Fixed in OpenSSL 0.9.8zf (Affected 0.9.8-0.9.8ze)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 842, tag: dt, level: 8" node_number="842"><a class="valid" valid="valid" title="valid: True, node: 843, tag: a, level: 9" node_number="843">CVE-2015-0286</a> <a class="valid" valid="valid" title="valid: True, node: 844, tag: a, level: 9" node_number="844">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 845, tag: a, level: 9" node_number="845">[Moderate severity]</a> 19 March 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 846, tag: dd, level: 8" node_number="846">Segmentation fault in ASN1_TYPE_cmp. The function ASN1_TYPE_cmp will crash with an invalid read if an attempt is made to compare ASN.1 boolean types. Since ASN1_TYPE_cmp is used to check certificate signature algorithm consistency this can be used to crash any certificate verification operation and exploited in a DoS attack. Any application which performs certificate verification is vulnerable including OpenSSL clients and servers which enable client authentication. Reported by Stephen Henson (OpenSSL development team). <ul class="valid" valid="valid" title="valid: True, node: 847, tag: ul, level: 9" node_number="847"><li class="valid" valid="valid" title="valid: True, node: 848, tag: li, level: 10" node_number="848">Fixed in OpenSSL 1.0.2a (Affected 1.0.2)</li><li class="valid" valid="valid" title="valid: True, node: 849, tag: li, level: 10" node_number="849">Fixed in OpenSSL 1.0.1m (Affected 1.0.1-1.0.1l)</li><li class="valid" valid="valid" title="valid: True, node: 850, tag: li, level: 10" node_number="850">Fixed in OpenSSL 1.0.0r (Affected 1.0.0-1.0.0q)</li><li class="valid" valid="valid" title="valid: True, node: 851, tag: li, level: 10" node_number="851">Fixed in OpenSSL 0.9.8zf (Affected 0.9.8zd-0.9.8ze)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 852, tag: dt, level: 8" node_number="852"><a class="valid" valid="valid" title="valid: True, node: 853, tag: a, level: 9" node_number="853">CVE-2015-0209</a> <a class="valid" valid="valid" title="valid: True, node: 854, tag: a, level: 9" node_number="854">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 855, tag: a, level: 9" node_number="855">[Low severity]</a> 19 March 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 856, tag: dd, level: 8" node_number="856">Use After Free following d2i_ECPrivatekey error. A malformed EC private key file consumed via the d2i_ECPrivateKey function could cause a use after free condition. This, in turn, could cause a double free in several private key parsing functions (such as d2i_PrivateKey or EVP_PKCS82PKEY) and could lead to a DoS attack or memory corruption for applications that receive EC private keys from untrusted sources. This scenario is considered rare. Reported by The BoringSSL project. <ul class="valid" valid="valid" title="valid: True, node: 857, tag: ul, level: 9" node_number="857"><li class="valid" valid="valid" title="valid: True, node: 858, tag: li, level: 10" node_number="858">Fixed in OpenSSL 1.0.2a (Affected 1.0.2)</li><li class="valid" valid="valid" title="valid: True, node: 859, tag: li, level: 10" node_number="859">Fixed in OpenSSL 1.0.1m (Affected 1.0.1-1.0.1l)</li><li class="valid" valid="valid" title="valid: True, node: 860, tag: li, level: 10" node_number="860">Fixed in OpenSSL 1.0.0r (Affected 1.0.0-1.0.0q)</li><li class="valid" valid="valid" title="valid: True, node: 861, tag: li, level: 10" node_number="861">Fixed in OpenSSL 0.9.8zf (Affected 0.9.8-0.9.8ze)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 862, tag: dt, level: 8" node_number="862"><a class="valid" valid="valid" title="valid: True, node: 863, tag: a, level: 9" node_number="863">CVE-2015-0208</a> <a class="valid" valid="valid" title="valid: True, node: 864, tag: a, level: 9" node_number="864">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 865, tag: a, level: 9" node_number="865">[Moderate severity]</a> 19 March 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 866, tag: dd, level: 8" node_number="866">Segmentation fault for invalid PSS parameters. The signature verification routines will crash with a NULL pointer dereference if presented with an ASN.1 signature using the RSA PSS algorithm and invalid parameters. Since these routines are used to verify certificate signature algorithms this can be used to crash any certificate verification operation and exploited in a DoS attack. Any application which performs certificate verification is vulnerable including OpenSSL clients and servers which enable client authentication. Reported by Brian Carpenter. <ul class="valid" valid="valid" title="valid: True, node: 867, tag: ul, level: 9" node_number="867"><li class="valid" valid="valid" title="valid: True, node: 868, tag: li, level: 10" node_number="868">Fixed in OpenSSL 1.0.2a (Affected 1.0.2)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 869, tag: dt, level: 8" node_number="869"><a class="valid" valid="valid" title="valid: True, node: 870, tag: a, level: 9" node_number="870">CVE-2015-0207</a> <a class="valid" valid="valid" title="valid: True, node: 871, tag: a, level: 9" node_number="871">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 872, tag: a, level: 9" node_number="872">[Moderate severity]</a> 19 March 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 873, tag: dd, level: 8" node_number="873">Segmentation fault in DTLSv1_listen. A defect in the implementation of DTLSv1_listen means that state is preserved in the SSL object from one invocation to the next that can lead to a segmentation fault. Errors processing the initial ClientHello can trigger this scenario. An example of such an error could be that a DTLS1.0 only client is attempting to connect to a DTLS1.2 only server. Reported by Per Allansson. <ul class="valid" valid="valid" title="valid: True, node: 874, tag: ul, level: 9" node_number="874"><li class="valid" valid="valid" title="valid: True, node: 875, tag: li, level: 10" node_number="875">Fixed in OpenSSL 1.0.2a (Affected 1.0.2)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 876, tag: dt, level: 8" node_number="876"><a class="valid" valid="valid" title="valid: True, node: 877, tag: a, level: 9" node_number="877">CVE-2015-0285</a> <a class="valid" valid="valid" title="valid: True, node: 878, tag: a, level: 9" node_number="878">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 879, tag: a, level: 9" node_number="879">[Low severity]</a> 10 March 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 880, tag: dd, level: 8" node_number="880">Under certain conditions an OpenSSL 1.0.2 client can complete a handshake with an unseeded PRNG. If the handshake succeeds then the client random that has been used will have been generated from a PRNG with insufficient entropy and therefore the output may be predictable. Reported by Matt Caswell (OpenSSL development team). <ul class="valid" valid="valid" title="valid: True, node: 881, tag: ul, level: 9" node_number="881"><li class="valid" valid="valid" title="valid: True, node: 882, tag: li, level: 10" node_number="882">Fixed in OpenSSL 1.0.2a (Affected 1.0.2)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 883, tag: dt, level: 8" node_number="883"><a class="valid" valid="valid" title="valid: True, node: 884, tag: a, level: 9" node_number="884">CVE-2015-0288</a> <a class="valid" valid="valid" title="valid: True, node: 885, tag: a, level: 9" node_number="885">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 886, tag: a, level: 9" node_number="886">[Low severity]</a> 02 March 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 887, tag: dd, level: 8" node_number="887">X509_to_X509_REQ NULL pointer deref. The function X509_to_X509_REQ will crash with a NULL pointer dereference if the certificate key is invalid. This function is rarely used in practice. Reported by Brian Carpenter. <ul class="valid" valid="valid" title="valid: True, node: 888, tag: ul, level: 9" node_number="888"><li class="valid" valid="valid" title="valid: True, node: 889, tag: li, level: 10" node_number="889">Fixed in OpenSSL 1.0.2a (Affected 1.0.2)</li><li class="valid" valid="valid" title="valid: True, node: 890, tag: li, level: 10" node_number="890">Fixed in OpenSSL 1.0.1m (Affected 1.0.1-1.0.1l)</li><li class="valid" valid="valid" title="valid: True, node: 891, tag: li, level: 10" node_number="891">Fixed in OpenSSL 1.0.0r (Affected 1.0.0-1.0.0q)</li><li class="valid" valid="valid" title="valid: True, node: 892, tag: li, level: 10" node_number="892">Fixed in OpenSSL 0.9.8zf (Affected 0.9.8-0.9.8ze)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 893, tag: dt, level: 8" node_number="893"><a class="valid" valid="valid" title="valid: True, node: 894, tag: a, level: 9" node_number="894">CVE-2015-0206</a> <a class="valid" valid="valid" title="valid: True, node: 895, tag: a, level: 9" node_number="895">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 896, tag: a, level: 9" node_number="896">[Moderate severity]</a> 08 January 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 897, tag: dd, level: 8" node_number="897">A memory leak can occur in the dtls1_buffer_record function under certain conditions. In particular this could occur if an attacker sent repeated DTLS records with the same sequence number but for the next epoch. The memory leak could be exploited by an attacker in a Denial of Service attack through memory exhaustion. Reported by Chris Mueller. <ul class="valid" valid="valid" title="valid: True, node: 898, tag: ul, level: 9" node_number="898"><li class="valid" valid="valid" title="valid: True, node: 899, tag: li, level: 10" node_number="899">Fixed in OpenSSL 1.0.1k (Affected 1.0.1-1.0.1j)</li><li class="valid" valid="valid" title="valid: True, node: 900, tag: li, level: 10" node_number="900">Fixed in OpenSSL 1.0.0p (Affected 1.0.0-1.0.0o)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 901, tag: dt, level: 8" node_number="901"><a class="valid" valid="valid" title="valid: True, node: 902, tag: a, level: 9" node_number="902">CVE-2015-0205</a> <a class="valid" valid="valid" title="valid: True, node: 903, tag: a, level: 9" node_number="903">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 904, tag: a, level: 9" node_number="904">[Low severity]</a> 08 January 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 905, tag: dd, level: 8" node_number="905">An OpenSSL server will accept a DH certificate for client authentication without the certificate verify message. This effectively allows a client to authenticate without the use of a private key. This only affects servers which trust a client certificate authority which issues certificates containing DH keys: these are extremely rare and hardly ever encountered. Reported by Karthikeyan Bhargavan of the PROSECCO team at INRIA. <ul class="valid" valid="valid" title="valid: True, node: 906, tag: ul, level: 9" node_number="906"><li class="valid" valid="valid" title="valid: True, node: 907, tag: li, level: 10" node_number="907">Fixed in OpenSSL 1.0.1k (Affected 1.0.1-1.0.1j)</li><li class="valid" valid="valid" title="valid: True, node: 908, tag: li, level: 10" node_number="908">Fixed in OpenSSL 1.0.0p (Affected 1.0.0-1.0.0o)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 909, tag: dt, level: 8" node_number="909"><a class="valid" valid="valid" title="valid: True, node: 910, tag: a, level: 9" node_number="910">CVE-2014-3570</a> <a class="valid" valid="valid" title="valid: True, node: 911, tag: a, level: 9" node_number="911">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 912, tag: a, level: 9" node_number="912">[Low severity]</a> 08 January 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 913, tag: dd, level: 8" node_number="913">Bignum squaring (BN_sqr) may produce incorrect results on some platforms, including x86_64. This bug occurs at random with a very low probability, and is not known to be exploitable in any way, though its exact impact is difficult to determine. The following has been determined: *) The probability of BN_sqr producing an incorrect result at random is very low: 1/2^64 on the single affected 32-bit platform (MIPS) and 1/2^128 on affected 64-bit platforms. *) On most platforms, RSA follows a different code path and RSA operations are not affected at all. For the remaining platforms (e.g. OpenSSL built without assembly support), pre-existing countermeasures thwart bug attacks [1]. *) Static ECDH is theoretically affected: it is possible to construct elliptic curve points that would falsely appear to be on the given curve. However, there is no known computationally feasible way to construct such points with low order, and so the security of static ECDH private keys is believed to be unaffected. *) Other routines known to be theoretically affected are modular exponentiation, primality testing, DSA, RSA blinding, JPAKE and SRP. No exploits are known and straightforward bug attacks fail - either the attacker cannot control when the bug triggers, or no private key material is involved. Reported by Pieter Wuille (Blockstream). <ul class="valid" valid="valid" title="valid: True, node: 914, tag: ul, level: 9" node_number="914"><li class="valid" valid="valid" title="valid: True, node: 915, tag: li, level: 10" node_number="915">Fixed in OpenSSL 1.0.1k (Affected 1.0.1-1.0.1j)</li><li class="valid" valid="valid" title="valid: True, node: 916, tag: li, level: 10" node_number="916">Fixed in OpenSSL 1.0.0p (Affected 1.0.0-1.0.0o)</li><li class="valid" valid="valid" title="valid: True, node: 917, tag: li, level: 10" node_number="917">Fixed in OpenSSL 0.9.8zd (Affected 0.9.8-0.9.8zc)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 918, tag: dt, level: 8" node_number="918"><a class="valid" valid="valid" title="valid: True, node: 919, tag: a, level: 9" node_number="919">CVE-2015-0204</a> <a class="valid" valid="valid" title="valid: True, node: 920, tag: a, level: 9" node_number="920">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 921, tag: a, level: 9" node_number="921">[Low severity]</a> 06 January 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 922, tag: dd, level: 8" node_number="922">An OpenSSL client will accept the use of an RSA temporary key in a non-export RSA key exchange ciphersuite. A server could present a weak temporary key and downgrade the security of the session. Reported by Karthikeyan Bhargavan of the PROSECCO team at INRIA. <ul class="valid" valid="valid" title="valid: True, node: 923, tag: ul, level: 9" node_number="923"><li class="valid" valid="valid" title="valid: True, node: 924, tag: li, level: 10" node_number="924">Fixed in OpenSSL 1.0.1k (Affected 1.0.1-1.0.1j)</li><li class="valid" valid="valid" title="valid: True, node: 925, tag: li, level: 10" node_number="925">Fixed in OpenSSL 1.0.0p (Affected 1.0.0-1.0.0o)</li><li class="valid" valid="valid" title="valid: True, node: 926, tag: li, level: 10" node_number="926">Fixed in OpenSSL 0.9.8zd (Affected 0.9.8-0.9.8zc)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 927, tag: dt, level: 8" node_number="927"><a class="valid" valid="valid" title="valid: True, node: 928, tag: a, level: 9" node_number="928">CVE-2014-8275</a> <a class="valid" valid="valid" title="valid: True, node: 929, tag: a, level: 9" node_number="929">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 930, tag: a, level: 9" node_number="930">[Low severity]</a> 05 January 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 931, tag: dd, level: 8" node_number="931">OpenSSL accepts several non-DER-variations of certificate signature algorithm and signature encodings. OpenSSL also does not enforce a match between the signature algorithm between the signed and unsigned portions of the certificate. By modifying the contents of the signature algorithm or the encoding of the signature, it is possible to change the certificate's fingerprint. This does not allow an attacker to forge certificates, and does not affect certificate verification or OpenSSL servers/clients in any other way. It also does not affect common revocation mechanisms. Only custom applications that rely on the uniqueness of the fingerprint (e.g. certificate blacklists) may be affected. Reported by Antti Karjalainen and Tuomo Untinen from the Codenomicon CROSS program/Konrad Kraszewski from Google. <ul class="valid" valid="valid" title="valid: True, node: 932, tag: ul, level: 9" node_number="932"><li class="valid" valid="valid" title="valid: True, node: 933, tag: li, level: 10" node_number="933">Fixed in OpenSSL 1.0.1k (Affected 1.0.1-1.0.1j)</li><li class="valid" valid="valid" title="valid: True, node: 934, tag: li, level: 10" node_number="934">Fixed in OpenSSL 1.0.0p (Affected 1.0.0-1.0.0o)</li><li class="valid" valid="valid" title="valid: True, node: 935, tag: li, level: 10" node_number="935">Fixed in OpenSSL 0.9.8zd (Affected 0.9.8-0.9.8zc)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 936, tag: dt, level: 8" node_number="936"><a class="valid" valid="valid" title="valid: True, node: 937, tag: a, level: 9" node_number="937">CVE-2014-3572</a> <a class="valid" valid="valid" title="valid: True, node: 938, tag: a, level: 9" node_number="938">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 939, tag: a, level: 9" node_number="939">[Low severity]</a> 05 January 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 940, tag: dd, level: 8" node_number="940">An OpenSSL client will accept a handshake using an ephemeral ECDH ciphersuite using an ECDSA certificate if the server key exchange message is omitted. This effectively removes forward secrecy from the ciphersuite. Reported by Karthikeyan Bhargavan of the PROSECCO team at INRIA. <ul class="valid" valid="valid" title="valid: True, node: 941, tag: ul, level: 9" node_number="941"><li class="valid" valid="valid" title="valid: True, node: 942, tag: li, level: 10" node_number="942">Fixed in OpenSSL 1.0.1k (Affected 1.0.1-1.0.1j)</li><li class="valid" valid="valid" title="valid: True, node: 943, tag: li, level: 10" node_number="943">Fixed in OpenSSL 1.0.0p (Affected 1.0.0-1.0.0o)</li><li class="valid" valid="valid" title="valid: True, node: 944, tag: li, level: 10" node_number="944">Fixed in OpenSSL 0.9.8zd (Affected 0.9.8-0.9.8zc)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 945, tag: dt, level: 8" node_number="945"><a class="valid" valid="valid" title="valid: True, node: 946, tag: a, level: 9" node_number="946">CVE-2014-3571</a> <a class="valid" valid="valid" title="valid: True, node: 947, tag: a, level: 9" node_number="947">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 948, tag: a, level: 9" node_number="948">[Moderate severity]</a> 05 January 2015: </dt><dd class="valid" valid="valid" title="valid: True, node: 949, tag: dd, level: 8" node_number="949">A carefully crafted DTLS message can cause a segmentation fault in OpenSSL due to a NULL pointer dereference. This could lead to a Denial Of Service attack. Reported by Markus Stenberg of Cisco Systems, Inc. <ul class="valid" valid="valid" title="valid: True, node: 950, tag: ul, level: 9" node_number="950"><li class="valid" valid="valid" title="valid: True, node: 951, tag: li, level: 10" node_number="951">Fixed in OpenSSL 1.0.1k (Affected 1.0.1-1.0.1j)</li><li class="valid" valid="valid" title="valid: True, node: 952, tag: li, level: 10" node_number="952">Fixed in OpenSSL 1.0.0p (Affected 1.0.0-1.0.0o)</li><li class="valid" valid="valid" title="valid: True, node: 953, tag: li, level: 10" node_number="953">Fixed in OpenSSL 0.9.8zd (Affected 0.9.8-0.9.8zc)</li></ul></dd></dl><h3 class="valid" valid="valid" title="valid: True, node: 954, tag: h3, level: 7" node_number="954"><a class="valid" valid="valid" title="valid: True, node: 955, tag: a, level: 8" node_number="955">2014</a></h3><dl class="valid" valid="valid" title="valid: True, node: 956, tag: dl, level: 7" node_number="956"><dt class="valid" valid="valid" title="valid: True, node: 957, tag: dt, level: 8" node_number="957"><a class="valid" valid="valid" title="valid: True, node: 958, tag: a, level: 9" node_number="958">CVE-2014-3569</a> <a class="valid" valid="valid" title="valid: True, node: 959, tag: a, level: 9" node_number="959">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 960, tag: a, level: 9" node_number="960">[Low severity]</a> 21 October 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 961, tag: dd, level: 8" node_number="961">When openssl is built with the no-ssl3 option and a SSL v3 ClientHello is received the ssl method would be set to NULL which could later result in a NULL pointer dereference. Reported by Frank Schmirler. <ul class="valid" valid="valid" title="valid: True, node: 962, tag: ul, level: 9" node_number="962"><li class="valid" valid="valid" title="valid: True, node: 963, tag: li, level: 10" node_number="963">Fixed in OpenSSL 1.0.1k (Affected 1.0.1j)</li><li class="valid" valid="valid" title="valid: True, node: 964, tag: li, level: 10" node_number="964">Fixed in OpenSSL 1.0.0p (Affected 1.0.0o)</li><li class="valid" valid="valid" title="valid: True, node: 965, tag: li, level: 10" node_number="965">Fixed in OpenSSL 0.9.8zd (Affected 0.9.8zc)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 966, tag: dt, level: 8" node_number="966"><a class="valid" valid="valid" title="valid: True, node: 967, tag: a, level: 9" node_number="967">CVE-2014-3568</a> <a class="valid" valid="valid" title="valid: True, node: 968, tag: a, level: 9" node_number="968">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 969, tag: a, level: 9" node_number="969">[Low severity]</a> 15 October 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 970, tag: dd, level: 8" node_number="970">When OpenSSL is configured with "no-ssl3" as a build option, servers could accept and complete a SSL 3.0 handshake, and clients could be configured to send them. Reported by Akamai Technologies. <ul class="valid" valid="valid" title="valid: True, node: 971, tag: ul, level: 9" node_number="971"><li class="valid" valid="valid" title="valid: True, node: 972, tag: li, level: 10" node_number="972">Fixed in OpenSSL 1.0.1j (Affected 1.0.1-1.0.1i)</li><li class="valid" valid="valid" title="valid: True, node: 973, tag: li, level: 10" node_number="973">Fixed in OpenSSL 1.0.0o (Affected 1.0.0-1.0.0n)</li><li class="valid" valid="valid" title="valid: True, node: 974, tag: li, level: 10" node_number="974">Fixed in OpenSSL 0.9.8zc (Affected 0.9.8-0.9.8zb)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 975, tag: dt, level: 8" node_number="975"><a class="valid" valid="valid" title="valid: True, node: 976, tag: a, level: 9" node_number="976">CVE-2014-3567</a> <a class="valid" valid="valid" title="valid: True, node: 977, tag: a, level: 9" node_number="977">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 978, tag: a, level: 9" node_number="978">[Moderate severity]</a> 15 October 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 979, tag: dd, level: 8" node_number="979">When an OpenSSL SSL/TLS/DTLS server receives a session ticket the integrity of that ticket is first verified. In the event of a session ticket integrity check failing, OpenSSL will fail to free memory causing a memory leak. By sending a large number of invalid session tickets an attacker could exploit this issue in a Denial Of Service attack.<ul class="valid" valid="valid" title="valid: True, node: 980, tag: ul, level: 9" node_number="980"><li class="valid" valid="valid" title="valid: True, node: 981, tag: li, level: 10" node_number="981">Fixed in OpenSSL 1.0.1j (Affected 1.0.1-1.0.1i)</li><li class="valid" valid="valid" title="valid: True, node: 982, tag: li, level: 10" node_number="982">Fixed in OpenSSL 1.0.0o (Affected 1.0.0-1.0.0n)</li><li class="valid" valid="valid" title="valid: True, node: 983, tag: li, level: 10" node_number="983">Fixed in OpenSSL 0.9.8zc (Affected 0.9.8g-0.9.8zb)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 984, tag: dt, level: 8" node_number="984"><a class="valid" valid="valid" title="valid: True, node: 985, tag: a, level: 9" node_number="985">CVE-2014-3513</a> <a class="valid" valid="valid" title="valid: True, node: 986, tag: a, level: 9" node_number="986">(OpenSSL advisory)</a> <a class="valid" valid="valid" title="valid: True, node: 987, tag: a, level: 9" node_number="987">[High severity]</a> 15 October 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 988, tag: dd, level: 8" node_number="988">A flaw in the DTLS SRTP extension parsing code allows an attacker, who sends a carefully crafted handshake message, to cause OpenSSL to fail to free up to 64k of memory causing a memory leak. This could be exploited in a Denial Of Service attack. This issue affects OpenSSL 1.0.1 server implementations for both SSL/TLS and DTLS regardless of whether SRTP is used or configured. Implementations of OpenSSL that have been compiled with OPENSSL_NO_SRTP defined are not affected. Reported by LibreSSL project. <ul class="valid" valid="valid" title="valid: True, node: 989, tag: ul, level: 9" node_number="989"><li class="valid" valid="valid" title="valid: True, node: 990, tag: li, level: 10" node_number="990">Fixed in OpenSSL 1.0.1j (Affected 1.0.1-1.0.1i)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 991, tag: dt, level: 8" node_number="991">15 October 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 992, tag: dd, level: 8" node_number="992">OpenSSL has added support for TLS_FALLBACK_SCSV to allow applications to block the ability for a MITM attacker to force a protocol downgrade. Some client applications (such as browsers) will reconnect using a downgraded protocol to work around interoperability bugs in older servers. This could be exploited by an active man-in-the-middle to downgrade connections to SSL 3.0 even if both sides of the connection support higher protocols. SSL 3.0 contains a number of weaknesses including POODLE (CVE-2014-3566). See also https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00 and https://www.openssl.org/~bodo/ssl-poodle.pdf<ul class="valid" valid="valid" title="valid: True, node: 993, tag: ul, level: 9" node_number="993"><li class="valid" valid="valid" title="valid: True, node: 994, tag: li, level: 10" node_number="994">Fixed in OpenSSL 1.0.1j (Affected 1.0.1-1.0.1i)</li><li class="valid" valid="valid" title="valid: True, node: 995, tag: li, level: 10" node_number="995">Fixed in OpenSSL 1.0.0o (Affected 1.0.0-1.0.0n)</li><li class="valid" valid="valid" title="valid: True, node: 996, tag: li, level: 10" node_number="996">Fixed in OpenSSL 0.9.8zc (Affected 0.9.8-0.9.8zb)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 997, tag: dt, level: 8" node_number="997"><a class="valid" valid="valid" title="valid: True, node: 998, tag: a, level: 9" node_number="998">CVE-2014-5139</a> <a class="valid" valid="valid" title="valid: True, node: 999, tag: a, level: 9" node_number="999">(OpenSSL advisory)</a> 06 August 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 1000, tag: dd, level: 8" node_number="1000">A crash was found affecting SRP ciphersuites used in a Server Hello message. The issue affects OpenSSL clients and allows a malicious server to crash the client with a null pointer dereference (read) by specifying an SRP ciphersuite even though it was not properly negotiated with the client. This could lead to a Denial of Service. Reported by Joonas Kuorilehto and Riku Hietam&#228;ki (Codenomicon). <ul class="valid" valid="valid" title="valid: True, node: 1001, tag: ul, level: 9" node_number="1001"><li class="valid" valid="valid" title="valid: True, node: 1002, tag: li, level: 10" node_number="1002">Fixed in OpenSSL 1.0.1i (Affected 1.0.1-1.0.1h)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1003, tag: dt, level: 8" node_number="1003"><a class="valid" valid="valid" title="valid: True, node: 1004, tag: a, level: 9" node_number="1004">CVE-2014-3512</a> <a class="valid" valid="valid" title="valid: True, node: 1005, tag: a, level: 9" node_number="1005">(OpenSSL advisory)</a> 06 August 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 1006, tag: dd, level: 8" node_number="1006">A SRP buffer overrun was found. A malicious client or server can send invalid SRP parameters and overrun an internal buffer. Only applications which are explicitly set up for SRP use are affected. Reported by Sean Devlin and Watson Ladd (Cryptography Services, NCC Group). <ul class="valid" valid="valid" title="valid: True, node: 1007, tag: ul, level: 9" node_number="1007"><li class="valid" valid="valid" title="valid: True, node: 1008, tag: li, level: 10" node_number="1008">Fixed in OpenSSL 1.0.1i (Affected 1.0.1-1.0.1h)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1009, tag: dt, level: 8" node_number="1009"><a class="valid" valid="valid" title="valid: True, node: 1010, tag: a, level: 9" node_number="1010">CVE-2014-3511</a> <a class="valid" valid="valid" title="valid: True, node: 1011, tag: a, level: 9" node_number="1011">(OpenSSL advisory)</a> 06 August 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 1012, tag: dd, level: 8" node_number="1012">A flaw in the OpenSSL SSL/TLS server code causes the server to negotiate TLS 1.0 instead of higher protocol versions when the ClientHello message is badly fragmented. This allows a man-in-the-middle attacker to force a downgrade to TLS 1.0 even if both the server and the client support a higher protocol version, by modifying the client's TLS records. Reported by David Benjamin and Adam Langley (Google). <ul class="valid" valid="valid" title="valid: True, node: 1013, tag: ul, level: 9" node_number="1013"><li class="valid" valid="valid" title="valid: True, node: 1014, tag: li, level: 10" node_number="1014">Fixed in OpenSSL 1.0.1i (Affected 1.0.1-1.0.1h)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1015, tag: dt, level: 8" node_number="1015"><a class="valid" valid="valid" title="valid: True, node: 1016, tag: a, level: 9" node_number="1016">CVE-2014-3510</a> <a class="valid" valid="valid" title="valid: True, node: 1017, tag: a, level: 9" node_number="1017">(OpenSSL advisory)</a> 06 August 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 1018, tag: dd, level: 8" node_number="1018">A flaw in handling DTLS anonymous EC(DH) ciphersuites was found. OpenSSL DTLS clients enabling anonymous (EC)DH ciphersuites are subject to a denial of service attack. A malicious server can crash the client with a null pointer dereference (read) by specifying an anonymous (EC)DH ciphersuite and sending carefully crafted handshake messages. Reported by Felix Gr&#246;bert (Google). <ul class="valid" valid="valid" title="valid: True, node: 1019, tag: ul, level: 9" node_number="1019"><li class="valid" valid="valid" title="valid: True, node: 1020, tag: li, level: 10" node_number="1020">Fixed in OpenSSL 1.0.1i (Affected 1.0.1-1.0.1h)</li><li class="valid" valid="valid" title="valid: True, node: 1021, tag: li, level: 10" node_number="1021">Fixed in OpenSSL 1.0.0n (Affected 1.0.0-1.0.0m)</li><li class="valid" valid="valid" title="valid: True, node: 1022, tag: li, level: 10" node_number="1022">Fixed in OpenSSL 0.9.8zb (Affected 0.9.8-0.9.8za)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1023, tag: dt, level: 8" node_number="1023"><a class="valid" valid="valid" title="valid: True, node: 1024, tag: a, level: 9" node_number="1024">CVE-2014-3509</a> <a class="valid" valid="valid" title="valid: True, node: 1025, tag: a, level: 9" node_number="1025">(OpenSSL advisory)</a> 06 August 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 1026, tag: dd, level: 8" node_number="1026">A race condition was found in ssl_parse_serverhello_tlsext. If a multithreaded client connects to a malicious server using a resumed session and the server sends an ec point format extension, it could write up to 255 bytes to freed memory. Reported by Gabor Tyukasz (LogMeIn Inc). <ul class="valid" valid="valid" title="valid: True, node: 1027, tag: ul, level: 9" node_number="1027"><li class="valid" valid="valid" title="valid: True, node: 1028, tag: li, level: 10" node_number="1028">Fixed in OpenSSL 1.0.1i (Affected 1.0.1-1.0.1h)</li><li class="valid" valid="valid" title="valid: True, node: 1029, tag: li, level: 10" node_number="1029">Fixed in OpenSSL 1.0.0n (Affected 1.0.0-1.0.0m)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1030, tag: dt, level: 8" node_number="1030"><a class="valid" valid="valid" title="valid: True, node: 1031, tag: a, level: 9" node_number="1031">CVE-2014-3508</a> <a class="valid" valid="valid" title="valid: True, node: 1032, tag: a, level: 9" node_number="1032">(OpenSSL advisory)</a> 06 August 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 1033, tag: dd, level: 8" node_number="1033">A flaw in OBJ_obj2txt may cause pretty printing functions such as X509_name_oneline, X509_name_print_ex, to leak some information from the stack. Applications may be affected if they echo pretty printing output to the attacker. OpenSSL SSL/TLS clients and servers themselves are not affected. Reported by Ivan Fratric (Google). <ul class="valid" valid="valid" title="valid: True, node: 1034, tag: ul, level: 9" node_number="1034"><li class="valid" valid="valid" title="valid: True, node: 1035, tag: li, level: 10" node_number="1035">Fixed in OpenSSL 1.0.1i (Affected 1.0.1-1.0.1h)</li><li class="valid" valid="valid" title="valid: True, node: 1036, tag: li, level: 10" node_number="1036">Fixed in OpenSSL 1.0.0n (Affected 1.0.0-1.0.0m)</li><li class="valid" valid="valid" title="valid: True, node: 1037, tag: li, level: 10" node_number="1037">Fixed in OpenSSL 0.9.8zb (Affected 0.9.8-0.9.8za)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1038, tag: dt, level: 8" node_number="1038"><a class="valid" valid="valid" title="valid: True, node: 1039, tag: a, level: 9" node_number="1039">CVE-2014-3507</a> <a class="valid" valid="valid" title="valid: True, node: 1040, tag: a, level: 9" node_number="1040">(OpenSSL advisory)</a> 06 August 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 1041, tag: dd, level: 8" node_number="1041">A DTLS memory leak from zero-length fragments was found. By sending carefully crafted DTLS packets an attacker could cause OpenSSL to leak memory. This could lead to a Denial of Service attack. Reported by Adam Langley (Google). <ul class="valid" valid="valid" title="valid: True, node: 1042, tag: ul, level: 9" node_number="1042"><li class="valid" valid="valid" title="valid: True, node: 1043, tag: li, level: 10" node_number="1043">Fixed in OpenSSL 1.0.1i (Affected 1.0.1-1.0.1h)</li><li class="valid" valid="valid" title="valid: True, node: 1044, tag: li, level: 10" node_number="1044">Fixed in OpenSSL 1.0.0n (Affected 1.0.0a-1.0.0m)</li><li class="valid" valid="valid" title="valid: True, node: 1045, tag: li, level: 10" node_number="1045">Fixed in OpenSSL 0.9.8zb (Affected 0.9.8o-0.9.8za)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1046, tag: dt, level: 8" node_number="1046"><a class="valid" valid="valid" title="valid: True, node: 1047, tag: a, level: 9" node_number="1047">CVE-2014-3506</a> <a class="valid" valid="valid" title="valid: True, node: 1048, tag: a, level: 9" node_number="1048">(OpenSSL advisory)</a> 06 August 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 1049, tag: dd, level: 8" node_number="1049">A DTLS flaw leading to memory exhaustion was found. An attacker can force openssl to consume large amounts of memory whilst processing DTLS handshake messages. This could lead to a Denial of Service attack. Reported by Adam Langley (Google). <ul class="valid" valid="valid" title="valid: True, node: 1050, tag: ul, level: 9" node_number="1050"><li class="valid" valid="valid" title="valid: True, node: 1051, tag: li, level: 10" node_number="1051">Fixed in OpenSSL 1.0.1i (Affected 1.0.1-1.0.1h)</li><li class="valid" valid="valid" title="valid: True, node: 1052, tag: li, level: 10" node_number="1052">Fixed in OpenSSL 1.0.0n (Affected 1.0.0-1.0.0m)</li><li class="valid" valid="valid" title="valid: True, node: 1053, tag: li, level: 10" node_number="1053">Fixed in OpenSSL 0.9.8zb (Affected 0.9.8-0.9.8za)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1054, tag: dt, level: 8" node_number="1054"><a class="valid" valid="valid" title="valid: True, node: 1055, tag: a, level: 9" node_number="1055">CVE-2014-3505</a> <a class="valid" valid="valid" title="valid: True, node: 1056, tag: a, level: 9" node_number="1056">(OpenSSL advisory)</a> 06 August 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 1057, tag: dd, level: 8" node_number="1057">A Double Free was found when processing DTLS packets. An attacker can force an error condition which causes openssl to crash whilst processing DTLS packets due to memory being freed twice. This could lead to a Denial of Service attack. Reported by Adam Langley and Wan-Teh Chang (Google). <ul class="valid" valid="valid" title="valid: True, node: 1058, tag: ul, level: 9" node_number="1058"><li class="valid" valid="valid" title="valid: True, node: 1059, tag: li, level: 10" node_number="1059">Fixed in OpenSSL 1.0.1i (Affected 1.0.1-1.0.1h)</li><li class="valid" valid="valid" title="valid: True, node: 1060, tag: li, level: 10" node_number="1060">Fixed in OpenSSL 1.0.0n (Affected 1.0.0-1.0.0m)</li><li class="valid" valid="valid" title="valid: True, node: 1061, tag: li, level: 10" node_number="1061">Fixed in OpenSSL 0.9.8zb (Affected 0.9.8m-0.9.8za)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1062, tag: dt, level: 8" node_number="1062"><a class="valid" valid="valid" title="valid: True, node: 1063, tag: a, level: 9" node_number="1063">CVE-2014-0224</a> <a class="valid" valid="valid" title="valid: True, node: 1064, tag: a, level: 9" node_number="1064">(OpenSSL advisory)</a> 05 June 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 1065, tag: dd, level: 8" node_number="1065">An attacker can force the use of weak keying material in OpenSSL SSL/TLS clients and servers. This can be exploited by a Man-in-the-middle (MITM) attack where the attacker can decrypt and modify traffic from the attacked client and server. Reported by KIKUCHI Masashi (Lepidum Co. Ltd.). <ul class="valid" valid="valid" title="valid: True, node: 1066, tag: ul, level: 9" node_number="1066"><li class="valid" valid="valid" title="valid: True, node: 1067, tag: li, level: 10" node_number="1067">Fixed in OpenSSL 1.0.1h (Affected 1.0.1-1.0.1g)</li><li class="valid" valid="valid" title="valid: True, node: 1068, tag: li, level: 10" node_number="1068">Fixed in OpenSSL 1.0.0m (Affected 1.0.0-1.0.0l)</li><li class="valid" valid="valid" title="valid: True, node: 1069, tag: li, level: 10" node_number="1069">Fixed in OpenSSL 0.9.8za (Affected 0.9.8-0.9.8y)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1070, tag: dt, level: 8" node_number="1070"><a class="valid" valid="valid" title="valid: True, node: 1071, tag: a, level: 9" node_number="1071">CVE-2014-0221</a> <a class="valid" valid="valid" title="valid: True, node: 1072, tag: a, level: 9" node_number="1072">(OpenSSL advisory)</a> 05 June 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 1073, tag: dd, level: 8" node_number="1073">By sending an invalid DTLS handshake to an OpenSSL DTLS client the code can be made to recurse eventually crashing in a DoS attack. Only applications using OpenSSL as a DTLS client are affected. Reported by Imre Rad (Search-Lab Ltd.). <ul class="valid" valid="valid" title="valid: True, node: 1074, tag: ul, level: 9" node_number="1074"><li class="valid" valid="valid" title="valid: True, node: 1075, tag: li, level: 10" node_number="1075">Fixed in OpenSSL 1.0.1h (Affected 1.0.1-1.0.1g)</li><li class="valid" valid="valid" title="valid: True, node: 1076, tag: li, level: 10" node_number="1076">Fixed in OpenSSL 1.0.0m (Affected 1.0.0-1.0.0l)</li><li class="valid" valid="valid" title="valid: True, node: 1077, tag: li, level: 10" node_number="1077">Fixed in OpenSSL 0.9.8za (Affected 0.9.8-0.9.8y)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1078, tag: dt, level: 8" node_number="1078"><a class="valid" valid="valid" title="valid: True, node: 1079, tag: a, level: 9" node_number="1079">CVE-2014-0195</a> <a class="valid" valid="valid" title="valid: True, node: 1080, tag: a, level: 9" node_number="1080">(OpenSSL advisory)</a> 05 June 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 1081, tag: dd, level: 8" node_number="1081">A buffer overrun attack can be triggered by sending invalid DTLS fragments to an OpenSSL DTLS client or server. This is potentially exploitable to run arbitrary code on a vulnerable client or server. Only applications using OpenSSL as a DTLS client or server affected. Reported by J&#252;ri Aedla. <ul class="valid" valid="valid" title="valid: True, node: 1082, tag: ul, level: 9" node_number="1082"><li class="valid" valid="valid" title="valid: True, node: 1083, tag: li, level: 10" node_number="1083">Fixed in OpenSSL 1.0.1h (Affected 1.0.1-1.0.1g)</li><li class="valid" valid="valid" title="valid: True, node: 1084, tag: li, level: 10" node_number="1084">Fixed in OpenSSL 1.0.0m (Affected 1.0.0-1.0.0l)</li><li class="valid" valid="valid" title="valid: True, node: 1085, tag: li, level: 10" node_number="1085">Fixed in OpenSSL 0.9.8za (Affected 0.9.8o-0.9.8y)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1086, tag: dt, level: 8" node_number="1086"><a class="valid" valid="valid" title="valid: True, node: 1087, tag: a, level: 9" node_number="1087">CVE-2014-3470</a> <a class="valid" valid="valid" title="valid: True, node: 1088, tag: a, level: 9" node_number="1088">(OpenSSL advisory)</a> 30 May 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 1089, tag: dd, level: 8" node_number="1089">OpenSSL TLS clients enabling anonymous ECDH ciphersuites are subject to a denial of service attack. Reported by Felix Gr&#246;bert and Ivan Fratri&#263; (Google). <ul class="valid" valid="valid" title="valid: True, node: 1090, tag: ul, level: 9" node_number="1090"><li class="valid" valid="valid" title="valid: True, node: 1091, tag: li, level: 10" node_number="1091">Fixed in OpenSSL 1.0.1h (Affected 1.0.1-1.0.1g)</li><li class="valid" valid="valid" title="valid: True, node: 1092, tag: li, level: 10" node_number="1092">Fixed in OpenSSL 1.0.0m (Affected 1.0.0-1.0.0l)</li><li class="valid" valid="valid" title="valid: True, node: 1093, tag: li, level: 10" node_number="1093">Fixed in OpenSSL 0.9.8za (Affected 0.9.8-0.9.8y)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1094, tag: dt, level: 8" node_number="1094"><a class="valid" valid="valid" title="valid: True, node: 1095, tag: a, level: 9" node_number="1095">CVE-2014-0198</a> <a class="valid" valid="valid" title="valid: True, node: 1096, tag: a, level: 9" node_number="1096">(OpenSSL advisory)</a> 21 April 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 1097, tag: dd, level: 8" node_number="1097">A flaw in the do_ssl3_write function can allow remote attackers to cause a denial of service via a NULL pointer dereference. This flaw only affects OpenSSL 1.0.0 and 1.0.1 where SSL_MODE_RELEASE_BUFFERS is enabled, which is not the default and not common.<ul class="valid" valid="valid" title="valid: True, node: 1098, tag: ul, level: 9" node_number="1098"><li class="valid" valid="valid" title="valid: True, node: 1099, tag: li, level: 10" node_number="1099">Fixed in OpenSSL 1.0.1h (Affected 1.0.1-1.0.1g)</li><li class="valid" valid="valid" title="valid: True, node: 1100, tag: li, level: 10" node_number="1100">Fixed in OpenSSL 1.0.0m (Affected 1.0.0-1.0.0l)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1101, tag: dt, level: 8" node_number="1101"><a class="valid" valid="valid" title="valid: True, node: 1102, tag: a, level: 9" node_number="1102">CVE-2010-5298</a> <a class="valid" valid="valid" title="valid: True, node: 1103, tag: a, level: 9" node_number="1103">(OpenSSL advisory)</a> 08 April 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 1104, tag: dd, level: 8" node_number="1104">A race condition in the ssl3_read_bytes function can allow remote attackers to inject data across sessions or cause a denial of service. This flaw only affects multithreaded applications using OpenSSL 1.0.0 and 1.0.1, where SSL_MODE_RELEASE_BUFFERS is enabled, which is not the default and not common.<ul class="valid" valid="valid" title="valid: True, node: 1105, tag: ul, level: 9" node_number="1105"><li class="valid" valid="valid" title="valid: True, node: 1106, tag: li, level: 10" node_number="1106">Fixed in OpenSSL 1.0.1h (Affected 1.0.1-1.0.1g)</li><li class="valid" valid="valid" title="valid: True, node: 1107, tag: li, level: 10" node_number="1107">Fixed in OpenSSL 1.0.0m (Affected 1.0.0-1.0.0l)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1108, tag: dt, level: 8" node_number="1108"><a class="valid" valid="valid" title="valid: True, node: 1109, tag: a, level: 9" node_number="1109">CVE-2014-0160</a> <a class="valid" valid="valid" title="valid: True, node: 1110, tag: a, level: 9" node_number="1110">(OpenSSL advisory)</a> 07 April 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 1111, tag: dd, level: 8" node_number="1111">A missing bounds check in the handling of the TLS heartbeat extension can be used to reveal up to 64kB of memory to a connected client or server (a.k.a. Heartbleed). This issue did not affect versions of OpenSSL prior to 1.0.1. Reported by Neel Mehta. <ul class="valid" valid="valid" title="valid: True, node: 1112, tag: ul, level: 9" node_number="1112"><li class="valid" valid="valid" title="valid: True, node: 1113, tag: li, level: 10" node_number="1113">Fixed in OpenSSL 1.0.1g (Affected 1.0.1-1.0.1f)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1114, tag: dt, level: 8" node_number="1114"><a class="valid" valid="valid" title="valid: True, node: 1115, tag: a, level: 9" node_number="1115">CVE-2014-0076</a> <a class="valid" valid="valid" title="valid: True, node: 1116, tag: a, level: 9" node_number="1116">(OpenSSL advisory)</a> 14 February 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 1117, tag: dd, level: 8" node_number="1117">Fix for the attack described in the paper "Recovering OpenSSL ECDSA Nonces Using the FLUSH+RELOAD Cache Side-channel Attack" Reported by Yuval Yarom and Naomi Benger. <ul class="valid" valid="valid" title="valid: True, node: 1118, tag: ul, level: 9" node_number="1118"><li class="valid" valid="valid" title="valid: True, node: 1119, tag: li, level: 10" node_number="1119">Fixed in OpenSSL 1.0.1g <a class="valid" valid="valid" title="valid: True, node: 1120, tag: a, level: 11" node_number="1120">(git commit)</a> (Affected 1.0.1-1.0.1f)</li><li class="valid" valid="valid" title="valid: True, node: 1121, tag: li, level: 10" node_number="1121">Fixed in OpenSSL 1.0.0m <a class="valid" valid="valid" title="valid: True, node: 1122, tag: a, level: 11" node_number="1122">(git commit)</a> (Affected 1.0.0-1.0.0l)</li><li class="valid" valid="valid" title="valid: True, node: 1123, tag: li, level: 10" node_number="1123">Fixed in OpenSSL 0.9.8za (Affected 0.9.8-0.9.8y)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1124, tag: dt, level: 8" node_number="1124"><a class="valid" valid="valid" title="valid: True, node: 1125, tag: a, level: 9" node_number="1125">CVE-2013-4353</a> 06 January 2014: </dt><dd class="valid" valid="valid" title="valid: True, node: 1126, tag: dd, level: 8" node_number="1126">A carefully crafted invalid TLS handshake could crash OpenSSL with a NULL pointer exception. A malicious server could use this flaw to crash a connecting client. This issue only affected OpenSSL 1.0.1 versions. Reported by Anton Johansson. <ul class="valid" valid="valid" title="valid: True, node: 1127, tag: ul, level: 9" node_number="1127"><li class="valid" valid="valid" title="valid: True, node: 1128, tag: li, level: 10" node_number="1128">Fixed in OpenSSL 1.0.1f <a class="valid" valid="valid" title="valid: True, node: 1129, tag: a, level: 11" node_number="1129">(git commit)</a> (Affected 1.0.1-1.0.1e)</li></ul></dd></dl><h3 class="valid" valid="valid" title="valid: True, node: 1130, tag: h3, level: 7" node_number="1130"><a class="valid" valid="valid" title="valid: True, node: 1131, tag: a, level: 8" node_number="1131">2013</a></h3><dl class="valid" valid="valid" title="valid: True, node: 1132, tag: dl, level: 7" node_number="1132"><dt class="valid" valid="valid" title="valid: True, node: 1133, tag: dt, level: 8" node_number="1133"><a class="valid" valid="valid" title="valid: True, node: 1134, tag: a, level: 9" node_number="1134">CVE-2013-6449</a> 14 December 2013: </dt><dd class="valid" valid="valid" title="valid: True, node: 1135, tag: dd, level: 8" node_number="1135">A flaw in OpenSSL can cause an application using OpenSSL to crash when using TLS version 1.2. This issue only affected OpenSSL 1.0.1 versions. Reported by Ron Barber. <ul class="valid" valid="valid" title="valid: True, node: 1136, tag: ul, level: 9" node_number="1136"><li class="valid" valid="valid" title="valid: True, node: 1137, tag: li, level: 10" node_number="1137">Fixed in OpenSSL 1.0.1f <a class="valid" valid="valid" title="valid: True, node: 1138, tag: a, level: 11" node_number="1138">(git commit)</a> (Affected 1.0.1-1.0.1e)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1139, tag: dt, level: 8" node_number="1139"><a class="valid" valid="valid" title="valid: True, node: 1140, tag: a, level: 9" node_number="1140">CVE-2013-6450</a> 13 December 2013: </dt><dd class="valid" valid="valid" title="valid: True, node: 1141, tag: dd, level: 8" node_number="1141">A flaw in DTLS handling can cause an application using OpenSSL and DTLS to crash. This is not a vulnerability for OpenSSL prior to 1.0.0. Reported by Dmitry Sobinov. <ul class="valid" valid="valid" title="valid: True, node: 1142, tag: ul, level: 9" node_number="1142"><li class="valid" valid="valid" title="valid: True, node: 1143, tag: li, level: 10" node_number="1143">Fixed in OpenSSL 1.0.1f <a class="valid" valid="valid" title="valid: True, node: 1144, tag: a, level: 11" node_number="1144">(git commit)</a> (Affected 1.0.1-1.0.1e)</li><li class="valid" valid="valid" title="valid: True, node: 1145, tag: li, level: 10" node_number="1145">Fixed in OpenSSL 1.0.0l (Affected 1.0.0-1.0.0k)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1146, tag: dt, level: 8" node_number="1146"><a class="valid" valid="valid" title="valid: True, node: 1147, tag: a, level: 9" node_number="1147">CVE-2013-0166</a> <a class="valid" valid="valid" title="valid: True, node: 1148, tag: a, level: 9" node_number="1148">(OpenSSL advisory)</a> 05 February 2013: </dt><dd class="valid" valid="valid" title="valid: True, node: 1149, tag: dd, level: 8" node_number="1149">A flaw in the OpenSSL handling of OCSP response verification can be exploited in a denial of service attack. Reported by Stephen Henson. <ul class="valid" valid="valid" title="valid: True, node: 1150, tag: ul, level: 9" node_number="1150"><li class="valid" valid="valid" title="valid: True, node: 1151, tag: li, level: 10" node_number="1151">Fixed in OpenSSL 1.0.1d (Affected 1.0.1-1.0.1c)</li><li class="valid" valid="valid" title="valid: True, node: 1152, tag: li, level: 10" node_number="1152">Fixed in OpenSSL 1.0.0k (Affected 1.0.0-1.0.0j)</li><li class="valid" valid="valid" title="valid: True, node: 1153, tag: li, level: 10" node_number="1153">Fixed in OpenSSL 0.9.8y (Affected 0.9.8-0.9.8x)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1154, tag: dt, level: 8" node_number="1154"><a class="valid" valid="valid" title="valid: True, node: 1155, tag: a, level: 9" node_number="1155">CVE-2012-2686</a> <a class="valid" valid="valid" title="valid: True, node: 1156, tag: a, level: 9" node_number="1156">(OpenSSL advisory)</a> 05 February 2013: </dt><dd class="valid" valid="valid" title="valid: True, node: 1157, tag: dd, level: 8" node_number="1157">A flaw in the OpenSSL handling of CBC ciphersuites in TLS 1.1 and TLS 1.2 on AES-NI supporting platforms can be exploited in a DoS attack. Reported by Adam Langley and Wolfgang Ettlinger. <ul class="valid" valid="valid" title="valid: True, node: 1158, tag: ul, level: 9" node_number="1158"><li class="valid" valid="valid" title="valid: True, node: 1159, tag: li, level: 10" node_number="1159">Fixed in OpenSSL 1.0.1d (Affected 1.0.1-1.0.1c)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1160, tag: dt, level: 8" node_number="1160"><a class="valid" valid="valid" title="valid: True, node: 1161, tag: a, level: 9" node_number="1161">CVE-2013-0169</a> <a class="valid" valid="valid" title="valid: True, node: 1162, tag: a, level: 9" node_number="1162">(OpenSSL advisory)</a> 04 February 2013: </dt><dd class="valid" valid="valid" title="valid: True, node: 1163, tag: dd, level: 8" node_number="1163">A weakness in the handling of CBC ciphersuites in SSL, TLS and DTLS which could lead to plaintext recovery by exploiting timing differences arising during MAC processing. Reported by Nadhem J. AlFardan and Kenneth G. Paterson of the Information Security Group Royal Holloway, University of London. <ul class="valid" valid="valid" title="valid: True, node: 1164, tag: ul, level: 9" node_number="1164"><li class="valid" valid="valid" title="valid: True, node: 1165, tag: li, level: 10" node_number="1165">Fixed in OpenSSL 1.0.1d (Affected 1.0.1-1.0.1c)</li><li class="valid" valid="valid" title="valid: True, node: 1166, tag: li, level: 10" node_number="1166">Fixed in OpenSSL 1.0.0k (Affected 1.0.0-1.0.0j)</li><li class="valid" valid="valid" title="valid: True, node: 1167, tag: li, level: 10" node_number="1167">Fixed in OpenSSL 0.9.8y (Affected 0.9.8-0.9.8x)</li></ul></dd></dl><h3 class="valid" valid="valid" title="valid: True, node: 1168, tag: h3, level: 7" node_number="1168"><a class="valid" valid="valid" title="valid: True, node: 1169, tag: a, level: 8" node_number="1169">2012</a></h3><dl class="valid" valid="valid" title="valid: True, node: 1170, tag: dl, level: 7" node_number="1170"><dt class="valid" valid="valid" title="valid: True, node: 1171, tag: dt, level: 8" node_number="1171"><a class="valid" valid="valid" title="valid: True, node: 1172, tag: a, level: 9" node_number="1172">CVE-2012-2333</a> <a class="valid" valid="valid" title="valid: True, node: 1173, tag: a, level: 9" node_number="1173">(OpenSSL advisory)</a> 10 May 2012: </dt><dd class="valid" valid="valid" title="valid: True, node: 1174, tag: dd, level: 8" node_number="1174">An integer underflow flaw, leading to a buffer over-read, was found in the way OpenSSL handled TLS 1.1, TLS 1.2, and DTLS (Datagram Transport Layer Security) application data record lengths when using a block cipher in CBC (cipher-block chaining) mode. A malicious TLS 1.1, TLS 1.2, or DTLS client or server could use this flaw to crash its connection peer. Reported by Codenomicon. <ul class="valid" valid="valid" title="valid: True, node: 1175, tag: ul, level: 9" node_number="1175"><li class="valid" valid="valid" title="valid: True, node: 1176, tag: li, level: 10" node_number="1176">Fixed in OpenSSL 1.0.1c (Affected 1.0.1-1.0.1b)</li><li class="valid" valid="valid" title="valid: True, node: 1177, tag: li, level: 10" node_number="1177">Fixed in OpenSSL 1.0.0j (Affected 1.0.0-1.0.0i)</li><li class="valid" valid="valid" title="valid: True, node: 1178, tag: li, level: 10" node_number="1178">Fixed in OpenSSL 0.9.8x (Affected 0.9.8-0.9.8w)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1179, tag: dt, level: 8" node_number="1179"><a class="valid" valid="valid" title="valid: True, node: 1180, tag: a, level: 9" node_number="1180">CVE-2012-2131</a> <a class="valid" valid="valid" title="valid: True, node: 1181, tag: a, level: 9" node_number="1181">(OpenSSL advisory)</a> 24 April 2012: </dt><dd class="valid" valid="valid" title="valid: True, node: 1182, tag: dd, level: 8" node_number="1182">It was discovered that the fix for CVE-2012-2110 released on 19 Apr 2012 was not sufficient to correct the issue for OpenSSL 0.9.8. This issue only affects OpenSSL 0.9.8v. OpenSSL 1.0.1a and 1.0.0i already contain a patch sufficient to correct CVE-2012-2110. Reported by Red Hat. <ul class="valid" valid="valid" title="valid: True, node: 1183, tag: ul, level: 9" node_number="1183"><li class="valid" valid="valid" title="valid: True, node: 1184, tag: li, level: 10" node_number="1184">Fixed in OpenSSL 0.9.8w (Affected 0.9.8v)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1185, tag: dt, level: 8" node_number="1185"><a class="valid" valid="valid" title="valid: True, node: 1186, tag: a, level: 9" node_number="1186">CVE-2012-2110</a> <a class="valid" valid="valid" title="valid: True, node: 1187, tag: a, level: 9" node_number="1187">(OpenSSL advisory)</a> 19 April 2012: </dt><dd class="valid" valid="valid" title="valid: True, node: 1188, tag: dd, level: 8" node_number="1188">Multiple numeric conversion errors, leading to a buffer overflow, were found in the way OpenSSL parsed ASN.1 (Abstract Syntax Notation One) data from BIO (OpenSSL's I/O abstraction) inputs. Specially-crafted DER (Distinguished Encoding Rules) encoded data read from a file or other BIO input could cause an application using the OpenSSL library to crash or, potentially, execute arbitrary code. Reported by Tavis Ormandy. <ul class="valid" valid="valid" title="valid: True, node: 1189, tag: ul, level: 9" node_number="1189"><li class="valid" valid="valid" title="valid: True, node: 1190, tag: li, level: 10" node_number="1190">Fixed in OpenSSL 1.0.1a (Affected 1.0.1)</li><li class="valid" valid="valid" title="valid: True, node: 1191, tag: li, level: 10" node_number="1191">Fixed in OpenSSL 1.0.0i (Affected 1.0.0-1.0.0g)</li><li class="valid" valid="valid" title="valid: True, node: 1192, tag: li, level: 10" node_number="1192">Fixed in OpenSSL 0.9.8v (Affected 0.9.8-0.9.8u)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1193, tag: dt, level: 8" node_number="1193"><a class="valid" valid="valid" title="valid: True, node: 1194, tag: a, level: 9" node_number="1194">CVE-2012-0884</a> <a class="valid" valid="valid" title="valid: True, node: 1195, tag: a, level: 9" node_number="1195">(OpenSSL advisory)</a> 12 March 2012: </dt><dd class="valid" valid="valid" title="valid: True, node: 1196, tag: dd, level: 8" node_number="1196">A weakness in the OpenSSL CMS and PKCS #7 code can be exploited using Bleichenbacher's attack on PKCS #1 v1.5 RSA padding also known as the million message attack (MMA). Only users of CMS, PKCS #7, or S/MIME decryption operations are affected, SSL/TLS applications are not affected by this issue. Reported by Ivan Nestlerode. <ul class="valid" valid="valid" title="valid: True, node: 1197, tag: ul, level: 9" node_number="1197"><li class="valid" valid="valid" title="valid: True, node: 1198, tag: li, level: 10" node_number="1198">Fixed in OpenSSL 1.0.0h (Affected 1.0.0-1.0.0g)</li><li class="valid" valid="valid" title="valid: True, node: 1199, tag: li, level: 10" node_number="1199">Fixed in OpenSSL 0.9.8u (Affected 0.9.8-0.9.8t)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1200, tag: dt, level: 8" node_number="1200"><a class="valid" valid="valid" title="valid: True, node: 1201, tag: a, level: 9" node_number="1201">CVE-2012-0050</a> <a class="valid" valid="valid" title="valid: True, node: 1202, tag: a, level: 9" node_number="1202">(OpenSSL advisory)</a> 04 January 2012: </dt><dd class="valid" valid="valid" title="valid: True, node: 1203, tag: dd, level: 8" node_number="1203">A flaw in the fix to CVE-2011-4108 can be exploited in a denial of service attack. Only DTLS applications are affected. Reported by Antonio Martin. <ul class="valid" valid="valid" title="valid: True, node: 1204, tag: ul, level: 9" node_number="1204"><li class="valid" valid="valid" title="valid: True, node: 1205, tag: li, level: 10" node_number="1205">Fixed in OpenSSL 1.0.0g (Affected 1.0.0f)</li><li class="valid" valid="valid" title="valid: True, node: 1206, tag: li, level: 10" node_number="1206">Fixed in OpenSSL 0.9.8t (Affected 0.9.8s)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1207, tag: dt, level: 8" node_number="1207"><a class="valid" valid="valid" title="valid: True, node: 1208, tag: a, level: 9" node_number="1208">CVE-2012-0027</a> <a class="valid" valid="valid" title="valid: True, node: 1209, tag: a, level: 9" node_number="1209">(OpenSSL advisory)</a> 04 January 2012: </dt><dd class="valid" valid="valid" title="valid: True, node: 1210, tag: dd, level: 8" node_number="1210">A malicious TLS client can send an invalid set of GOST parameters which will cause the server to crash due to lack of error checking. This could be used in a denial-of-service attack. Only users of the OpenSSL GOST ENGINE are affected by this bug. Reported by Andrey Kulikov. <ul class="valid" valid="valid" title="valid: True, node: 1211, tag: ul, level: 9" node_number="1211"><li class="valid" valid="valid" title="valid: True, node: 1212, tag: li, level: 10" node_number="1212">Fixed in OpenSSL 1.0.0f (Affected 1.0.0-1.0.0e)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1213, tag: dt, level: 8" node_number="1213"><a class="valid" valid="valid" title="valid: True, node: 1214, tag: a, level: 9" node_number="1214">CVE-2011-4619</a> <a class="valid" valid="valid" title="valid: True, node: 1215, tag: a, level: 9" node_number="1215">(OpenSSL advisory)</a> 04 January 2012: </dt><dd class="valid" valid="valid" title="valid: True, node: 1216, tag: dd, level: 8" node_number="1216">Support for handshake restarts for server gated cryptograpy (SGC) can be used in a denial-of-service attack. Reported by George Kadianakis. <ul class="valid" valid="valid" title="valid: True, node: 1217, tag: ul, level: 9" node_number="1217"><li class="valid" valid="valid" title="valid: True, node: 1218, tag: li, level: 10" node_number="1218">Fixed in OpenSSL 1.0.0f (Affected 1.0.0-1.0.0e)</li><li class="valid" valid="valid" title="valid: True, node: 1219, tag: li, level: 10" node_number="1219">Fixed in OpenSSL 0.9.8s (Affected 0.9.8-0.9.8r)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1220, tag: dt, level: 8" node_number="1220"><a class="valid" valid="valid" title="valid: True, node: 1221, tag: a, level: 9" node_number="1221">CVE-2011-4577</a> <a class="valid" valid="valid" title="valid: True, node: 1222, tag: a, level: 9" node_number="1222">(OpenSSL advisory)</a> 04 January 2012: </dt><dd class="valid" valid="valid" title="valid: True, node: 1223, tag: dd, level: 8" node_number="1223">RFC 3779 data can be included in certificates, and if it is malformed, may trigger an assertion failure. This could be used in a denial-of-service attack. Builds of OpenSSL are only vulnerable if configured with "enable-rfc3779", which is not a default. Reported by Andrew Chi. <ul class="valid" valid="valid" title="valid: True, node: 1224, tag: ul, level: 9" node_number="1224"><li class="valid" valid="valid" title="valid: True, node: 1225, tag: li, level: 10" node_number="1225">Fixed in OpenSSL 1.0.0f (Affected 1.0.0-1.0.0e)</li><li class="valid" valid="valid" title="valid: True, node: 1226, tag: li, level: 10" node_number="1226">Fixed in OpenSSL 0.9.8s (Affected 0.9.8-0.9.8r)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1227, tag: dt, level: 8" node_number="1227"><a class="valid" valid="valid" title="valid: True, node: 1228, tag: a, level: 9" node_number="1228">CVE-2011-4576</a> <a class="valid" valid="valid" title="valid: True, node: 1229, tag: a, level: 9" node_number="1229">(OpenSSL advisory)</a> 04 January 2012: </dt><dd class="valid" valid="valid" title="valid: True, node: 1230, tag: dd, level: 8" node_number="1230">OpenSSL failed to clear the bytes used as block cipher padding in SSL 3.0 records which could leak the contents of memory in some circumstances. Reported by Adam Langley. <ul class="valid" valid="valid" title="valid: True, node: 1231, tag: ul, level: 9" node_number="1231"><li class="valid" valid="valid" title="valid: True, node: 1232, tag: li, level: 10" node_number="1232">Fixed in OpenSSL 1.0.0f (Affected 1.0.0-1.0.0e)</li><li class="valid" valid="valid" title="valid: True, node: 1233, tag: li, level: 10" node_number="1233">Fixed in OpenSSL 0.9.8s (Affected 0.9.8-0.9.8r)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1234, tag: dt, level: 8" node_number="1234"><a class="valid" valid="valid" title="valid: True, node: 1235, tag: a, level: 9" node_number="1235">CVE-2011-4109</a> <a class="valid" valid="valid" title="valid: True, node: 1236, tag: a, level: 9" node_number="1236">(OpenSSL advisory)</a> 04 January 2012: </dt><dd class="valid" valid="valid" title="valid: True, node: 1237, tag: dd, level: 8" node_number="1237">If X509_V_FLAG_POLICY_CHECK is set in OpenSSL 0.9.8, then a policy check failure can lead to a double-free. The bug does not occur unless this flag is set. Users of OpenSSL 1.0.0 are not affected Reported by Ben Laurie. <ul class="valid" valid="valid" title="valid: True, node: 1238, tag: ul, level: 9" node_number="1238"><li class="valid" valid="valid" title="valid: True, node: 1239, tag: li, level: 10" node_number="1239">Fixed in OpenSSL 0.9.8s (Affected 0.9.8-0.9.8r)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1240, tag: dt, level: 8" node_number="1240"><a class="valid" valid="valid" title="valid: True, node: 1241, tag: a, level: 9" node_number="1241">CVE-2011-4108</a> <a class="valid" valid="valid" title="valid: True, node: 1242, tag: a, level: 9" node_number="1242">(OpenSSL advisory)</a> 04 January 2012: </dt><dd class="valid" valid="valid" title="valid: True, node: 1243, tag: dd, level: 8" node_number="1243">OpenSSL was susceptable an extension of the Vaudenay padding oracle attack on CBC mode encryption which enables an efficient plaintext recovery attack against the OpenSSL implementation of DTLS by exploiting timing differences arising during decryption processing. Reported by Nadhem Alfardan and Kenny Paterson. <ul class="valid" valid="valid" title="valid: True, node: 1244, tag: ul, level: 9" node_number="1244"><li class="valid" valid="valid" title="valid: True, node: 1245, tag: li, level: 10" node_number="1245">Fixed in OpenSSL 1.0.0f (Affected 1.0.0-1.0.0e)</li><li class="valid" valid="valid" title="valid: True, node: 1246, tag: li, level: 10" node_number="1246">Fixed in OpenSSL 0.9.8s (Affected 0.9.8-0.9.8r)</li></ul></dd></dl><h3 class="valid" valid="valid" title="valid: True, node: 1247, tag: h3, level: 7" node_number="1247"><a class="valid" valid="valid" title="valid: True, node: 1248, tag: a, level: 8" node_number="1248">2011</a></h3><dl class="valid" valid="valid" title="valid: True, node: 1249, tag: dl, level: 7" node_number="1249"><dt class="valid" valid="valid" title="valid: True, node: 1250, tag: dt, level: 8" node_number="1250"><a class="valid" valid="valid" title="valid: True, node: 1251, tag: a, level: 9" node_number="1251">CVE-2011-3210</a> <a class="valid" valid="valid" title="valid: True, node: 1252, tag: a, level: 9" node_number="1252">(OpenSSL advisory)</a> 06 September 2011: </dt><dd class="valid" valid="valid" title="valid: True, node: 1253, tag: dd, level: 8" node_number="1253">OpenSSL server code for ephemeral ECDH ciphersuites is not thread-safe, and furthermore can crash if a client violates the protocol by sending handshake messages in incorrect order. Only server-side applications that specifically support ephemeral ECDH ciphersuites are affected, and only if ephemeral ECDH ciphersuites are enabled in the configuration. Reported by Adam Langley. <ul class="valid" valid="valid" title="valid: True, node: 1254, tag: ul, level: 9" node_number="1254"><li class="valid" valid="valid" title="valid: True, node: 1255, tag: li, level: 10" node_number="1255">Fixed in OpenSSL 1.0.0e (Affected 1.0.0-1.0.0d)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1256, tag: dt, level: 8" node_number="1256"><a class="valid" valid="valid" title="valid: True, node: 1257, tag: a, level: 9" node_number="1257">CVE-2011-3207</a> <a class="valid" valid="valid" title="valid: True, node: 1258, tag: a, level: 9" node_number="1258">(OpenSSL advisory)</a> 06 September 2011: </dt><dd class="valid" valid="valid" title="valid: True, node: 1259, tag: dd, level: 8" node_number="1259">Under certain circumstances OpenSSL's internal certificate verification routines can incorrectly accept a CRL whose nextUpdate field is in the past. Applications are only affected by the CRL checking vulnerability if they enable OpenSSL's internal CRL checking which is off by default. Applications which use their own custom CRL checking (such as Apache) are not affected. Reported by Kaspar Brand. <ul class="valid" valid="valid" title="valid: True, node: 1260, tag: ul, level: 9" node_number="1260"><li class="valid" valid="valid" title="valid: True, node: 1261, tag: li, level: 10" node_number="1261">Fixed in OpenSSL 1.0.0e (Affected 1.0.0-1.0.0d)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1262, tag: dt, level: 8" node_number="1262"><a class="valid" valid="valid" title="valid: True, node: 1263, tag: a, level: 9" node_number="1263">CVE-2011-0014</a> <a class="valid" valid="valid" title="valid: True, node: 1264, tag: a, level: 9" node_number="1264">(OpenSSL advisory)</a> 08 February 2011: </dt><dd class="valid" valid="valid" title="valid: True, node: 1265, tag: dd, level: 8" node_number="1265">A buffer over-read flaw was discovered in the way OpenSSL parsed the Certificate Status Request TLS extensions in ClientHello TLS handshake messages. A remote attacker could possibly use this flaw to crash an SSL server using the affected OpenSSL functionality. Reported by Neel Mehta. <ul class="valid" valid="valid" title="valid: True, node: 1266, tag: ul, level: 9" node_number="1266"><li class="valid" valid="valid" title="valid: True, node: 1267, tag: li, level: 10" node_number="1267">Fixed in OpenSSL 1.0.0d (Affected 1.0.0-1.0.0c)</li><li class="valid" valid="valid" title="valid: True, node: 1268, tag: li, level: 10" node_number="1268">Fixed in OpenSSL 0.9.8r (Affected 0.9.8h-0.9.8q)</li></ul></dd></dl><h3 class="valid" valid="valid" title="valid: True, node: 1269, tag: h3, level: 7" node_number="1269"><a class="valid" valid="valid" title="valid: True, node: 1270, tag: a, level: 8" node_number="1270">2010</a></h3><dl class="valid" valid="valid" title="valid: True, node: 1271, tag: dl, level: 7" node_number="1271"><dt class="valid" valid="valid" title="valid: True, node: 1272, tag: dt, level: 8" node_number="1272"><a class="valid" valid="valid" title="valid: True, node: 1273, tag: a, level: 9" node_number="1273">CVE-2010-4252</a> <a class="valid" valid="valid" title="valid: True, node: 1274, tag: a, level: 9" node_number="1274">(OpenSSL advisory)</a> 02 December 2010: </dt><dd class="valid" valid="valid" title="valid: True, node: 1275, tag: dd, level: 8" node_number="1275">An error in OpenSSL's experimental J-PAKE implementation which could lead to successful validation by someone with no knowledge of the shared secret. The OpenSSL Team still consider the implementation of J-PAKE to be experimental and is not compiled by default. Reported by Sebastian Martini. <ul class="valid" valid="valid" title="valid: True, node: 1276, tag: ul, level: 9" node_number="1276"><li class="valid" valid="valid" title="valid: True, node: 1277, tag: li, level: 10" node_number="1277">Fixed in OpenSSL 1.0.0c (Affected 1.0.0-1.0.0b)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1278, tag: dt, level: 8" node_number="1278"><a class="valid" valid="valid" title="valid: True, node: 1279, tag: a, level: 9" node_number="1279">CVE-2010-4180</a> <a class="valid" valid="valid" title="valid: True, node: 1280, tag: a, level: 9" node_number="1280">(OpenSSL advisory)</a> 02 December 2010: </dt><dd class="valid" valid="valid" title="valid: True, node: 1281, tag: dd, level: 8" node_number="1281">A flaw in the OpenSSL SSL/TLS server code where an old bug workaround allows malicious clients to modify the stored session cache ciphersuite. In some cases the ciphersuite can be downgraded to a weaker one on subsequent connections. This issue only affects OpenSSL based SSL/TLS server if it uses OpenSSL's internal caching mechanisms and the SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG flag (many applications enable this by using the SSL_OP_ALL option). Reported by Martin Rex. <ul class="valid" valid="valid" title="valid: True, node: 1282, tag: ul, level: 9" node_number="1282"><li class="valid" valid="valid" title="valid: True, node: 1283, tag: li, level: 10" node_number="1283">Fixed in OpenSSL 1.0.0c (Affected 1.0.0-1.0.0b)</li><li class="valid" valid="valid" title="valid: True, node: 1284, tag: li, level: 10" node_number="1284">Fixed in OpenSSL 0.9.8q (Affected 0.9.8-0.9.8p)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1285, tag: dt, level: 8" node_number="1285"><a class="valid" valid="valid" title="valid: True, node: 1286, tag: a, level: 9" node_number="1286">CVE-2010-3864</a> <a class="valid" valid="valid" title="valid: True, node: 1287, tag: a, level: 9" node_number="1287">(OpenSSL advisory)</a> 16 November 2010: </dt><dd class="valid" valid="valid" title="valid: True, node: 1288, tag: dd, level: 8" node_number="1288">A flaw in the OpenSSL TLS server extension code parsing which on affected servers can be exploited in a buffer overrun attack. Any OpenSSL based TLS server is vulnerable if it is multi-threaded and uses OpenSSL's internal caching mechanism. Servers that are multi-process and/or disable internal session caching are NOT affected. Reported by Rob Hulswit. <ul class="valid" valid="valid" title="valid: True, node: 1289, tag: ul, level: 9" node_number="1289"><li class="valid" valid="valid" title="valid: True, node: 1290, tag: li, level: 10" node_number="1290">Fixed in OpenSSL 1.0.0b (Affected 1.0.0-1.0.0a)</li><li class="valid" valid="valid" title="valid: True, node: 1291, tag: li, level: 10" node_number="1291">Fixed in OpenSSL 0.9.8p (Affected 0.9.8-0.9.8o)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1292, tag: dt, level: 8" node_number="1292"><a class="valid" valid="valid" title="valid: True, node: 1293, tag: a, level: 9" node_number="1293">CVE-2010-1633</a> <a class="valid" valid="valid" title="valid: True, node: 1294, tag: a, level: 9" node_number="1294">(OpenSSL advisory)</a> 01 June 2010: </dt><dd class="valid" valid="valid" title="valid: True, node: 1295, tag: dd, level: 8" node_number="1295">An invalid Return value check in pkey_rsa_verifyrecover was discovered. When verification recovery fails for RSA keys an uninitialised buffer with an undefined length is returned instead of an error code. This could lead to an information leak. Reported by Peter-Michael Hager. <ul class="valid" valid="valid" title="valid: True, node: 1296, tag: ul, level: 9" node_number="1296"><li class="valid" valid="valid" title="valid: True, node: 1297, tag: li, level: 10" node_number="1297">Fixed in OpenSSL 1.0.0a (Affected 1.0.0)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1298, tag: dt, level: 8" node_number="1298"><a class="valid" valid="valid" title="valid: True, node: 1299, tag: a, level: 9" node_number="1299">CVE-2010-0742</a> <a class="valid" valid="valid" title="valid: True, node: 1300, tag: a, level: 9" node_number="1300">(OpenSSL advisory)</a> 01 June 2010: </dt><dd class="valid" valid="valid" title="valid: True, node: 1301, tag: dd, level: 8" node_number="1301">A flaw in the handling of CMS structures containing OriginatorInfo was found which could lead to a write to invalid memory address or double free. CMS support is disabled by default in OpenSSL 0.9.8 versions. Reported by Ronald Moesbergen. <ul class="valid" valid="valid" title="valid: True, node: 1302, tag: ul, level: 9" node_number="1302"><li class="valid" valid="valid" title="valid: True, node: 1303, tag: li, level: 10" node_number="1303">Fixed in OpenSSL 1.0.0a (Affected 1.0.0)</li><li class="valid" valid="valid" title="valid: True, node: 1304, tag: li, level: 10" node_number="1304">Fixed in OpenSSL 0.9.8o (Affected 0.9.8h-0.9.8n)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1305, tag: dt, level: 8" node_number="1305"><a class="valid" valid="valid" title="valid: True, node: 1306, tag: a, level: 9" node_number="1306">CVE-2010-0740</a> <a class="valid" valid="valid" title="valid: True, node: 1307, tag: a, level: 9" node_number="1307">(OpenSSL advisory)</a> 24 March 2010: </dt><dd class="valid" valid="valid" title="valid: True, node: 1308, tag: dd, level: 8" node_number="1308">In TLS connections, certain incorrectly formatted records can cause an OpenSSL client or server to crash due to a read attempt at NULL. Reported by Bodo Moeller and Adam Langley (Google). <ul class="valid" valid="valid" title="valid: True, node: 1309, tag: ul, level: 9" node_number="1309"><li class="valid" valid="valid" title="valid: True, node: 1310, tag: li, level: 10" node_number="1310">Fixed in OpenSSL 0.9.8n (Affected 0.9.8f-0.9.8m)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1311, tag: dt, level: 8" node_number="1311"><a class="valid" valid="valid" title="valid: True, node: 1312, tag: a, level: 9" node_number="1312">CVE-2009-3245</a> 23 February 2010: </dt><dd class="valid" valid="valid" title="valid: True, node: 1313, tag: dd, level: 8" node_number="1313">It was discovered that OpenSSL did not always check the return value of the bn_wexpand() function. An attacker able to trigger a memory allocation failure in that function could cause an application using the OpenSSL library to crash or, possibly, execute arbitrary code Reported by Martin Olsson, Neel Mehta. <ul class="valid" valid="valid" title="valid: True, node: 1314, tag: ul, level: 9" node_number="1314"><li class="valid" valid="valid" title="valid: True, node: 1315, tag: li, level: 10" node_number="1315">Fixed in OpenSSL 0.9.8m <a class="valid" valid="valid" title="valid: True, node: 1316, tag: a, level: 11" node_number="1316">(git commit)</a> (Affected 0.9.8-0.9.8l)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1317, tag: dt, level: 8" node_number="1317"><a class="valid" valid="valid" title="valid: True, node: 1318, tag: a, level: 9" node_number="1318">CVE-2010-0433</a> 19 January 2010: </dt><dd class="valid" valid="valid" title="valid: True, node: 1319, tag: dd, level: 8" node_number="1319">A missing return value check flaw was discovered in OpenSSL, that could possibly cause OpenSSL to call a Kerberos library function with invalid arguments, resulting in a NULL pointer dereference crash in the MIT Kerberos library. In certain configurations, a remote attacker could use this flaw to crash a TLS/SSL server using OpenSSL by requesting Kerberos cipher suites during the TLS handshake Reported by Todd Rinaldo, Tomas Hoger (Red Hat). <ul class="valid" valid="valid" title="valid: True, node: 1320, tag: ul, level: 9" node_number="1320"><li class="valid" valid="valid" title="valid: True, node: 1321, tag: li, level: 10" node_number="1321">Fixed in OpenSSL 0.9.8n <a class="valid" valid="valid" title="valid: True, node: 1322, tag: a, level: 11" node_number="1322">(git commit)</a> (Affected 0.9.8-0.9.8m)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1323, tag: dt, level: 8" node_number="1323"><a class="valid" valid="valid" title="valid: True, node: 1324, tag: a, level: 9" node_number="1324">CVE-2009-4355</a> 13 January 2010: </dt><dd class="valid" valid="valid" title="valid: True, node: 1325, tag: dd, level: 8" node_number="1325">A memory leak in the zlib_stateful_finish function in crypto/comp/c_zlib.c allows remote attackers to cause a denial of service via vectors that trigger incorrect calls to the CRYPTO_cleanup_all_ex_data function. Reported by Michael K Johnson and Andy Grimm (rPath). <ul class="valid" valid="valid" title="valid: True, node: 1326, tag: ul, level: 9" node_number="1326"><li class="valid" valid="valid" title="valid: True, node: 1327, tag: li, level: 10" node_number="1327">Fixed in OpenSSL 0.9.8m <a class="valid" valid="valid" title="valid: True, node: 1328, tag: a, level: 11" node_number="1328">(git commit)</a> (Affected 0.9.8-0.9.8l)</li></ul></dd></dl><h3 class="valid" valid="valid" title="valid: True, node: 1329, tag: h3, level: 7" node_number="1329"><a class="valid" valid="valid" title="valid: True, node: 1330, tag: a, level: 8" node_number="1330">2009</a></h3><dl class="valid" valid="valid" title="valid: True, node: 1331, tag: dl, level: 7" node_number="1331"><dt class="valid" valid="valid" title="valid: True, node: 1332, tag: dt, level: 8" node_number="1332"><a class="valid" valid="valid" title="valid: True, node: 1333, tag: a, level: 9" node_number="1333">CVE-2009-3555</a> <a class="valid" valid="valid" title="valid: True, node: 1334, tag: a, level: 9" node_number="1334">(OpenSSL advisory)</a> 05 November 2009: </dt><dd class="valid" valid="valid" title="valid: True, node: 1335, tag: dd, level: 8" node_number="1335">Implement RFC5746 to address vulnerabilities in SSL/TLS renegotiation.<ul class="valid" valid="valid" title="valid: True, node: 1336, tag: ul, level: 9" node_number="1336"><li class="valid" valid="valid" title="valid: True, node: 1337, tag: li, level: 10" node_number="1337">Fixed in OpenSSL 0.9.8m (Affected 0.9.8-0.9.8l)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1338, tag: dt, level: 8" node_number="1338"><a class="valid" valid="valid" title="valid: True, node: 1339, tag: a, level: 9" node_number="1339">CVE-2009-1386</a> 02 June 2009: </dt><dd class="valid" valid="valid" title="valid: True, node: 1340, tag: dd, level: 8" node_number="1340">Fix a NULL pointer dereference if a DTLS server recieved ChangeCipherSpec as first record. A remote attacker could use this flaw to cause a DTLS server to crash Reported by Alex Lam. <ul class="valid" valid="valid" title="valid: True, node: 1341, tag: ul, level: 9" node_number="1341"><li class="valid" valid="valid" title="valid: True, node: 1342, tag: li, level: 10" node_number="1342">Fixed in OpenSSL 0.9.8i <a class="valid" valid="valid" title="valid: True, node: 1343, tag: a, level: 11" node_number="1343">(git commit)</a> (Affected 0.9.8-0.9.8h)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1344, tag: dt, level: 8" node_number="1344"><a class="valid" valid="valid" title="valid: True, node: 1345, tag: a, level: 9" node_number="1345">CVE-2009-1379</a> <a class="valid" valid="valid" title="valid: True, node: 1346, tag: a, level: 9" node_number="1346">(OpenSSL advisory)</a> 12 May 2009: </dt><dd class="valid" valid="valid" title="valid: True, node: 1347, tag: dd, level: 8" node_number="1347">Use-after-free vulnerability in the dtls1_retrieve_buffered_fragment function could cause a client accessing a malicious DTLS server to crash. Reported by Daniel Mentz, Robin Seggelmann. <ul class="valid" valid="valid" title="valid: True, node: 1348, tag: ul, level: 9" node_number="1348"><li class="valid" valid="valid" title="valid: True, node: 1349, tag: li, level: 10" node_number="1349">Fixed in OpenSSL 0.9.8m <a class="valid" valid="valid" title="valid: True, node: 1350, tag: a, level: 11" node_number="1350">(git commit)</a> (Affected 0.9.8-0.9.8l)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1351, tag: dt, level: 8" node_number="1351"><a class="valid" valid="valid" title="valid: True, node: 1352, tag: a, level: 9" node_number="1352">CVE-2009-1378</a> <a class="valid" valid="valid" title="valid: True, node: 1353, tag: a, level: 9" node_number="1353">(OpenSSL advisory)</a> 12 May 2009: </dt><dd class="valid" valid="valid" title="valid: True, node: 1354, tag: dd, level: 8" node_number="1354">Fix a denial of service flaw in the DTLS implementation. In dtls1_process_out_of_seq_message() the check if the current message is already buffered was missing. For every new message was memory allocated, allowing an attacker to perform an denial of service attack against a DTLS server by sending out of seq handshake messages until there is no memory left. Reported by Daniel Mentz, Robin Seggelmann. <ul class="valid" valid="valid" title="valid: True, node: 1355, tag: ul, level: 9" node_number="1355"><li class="valid" valid="valid" title="valid: True, node: 1356, tag: li, level: 10" node_number="1356">Fixed in OpenSSL 0.9.8m <a class="valid" valid="valid" title="valid: True, node: 1357, tag: a, level: 11" node_number="1357">(git commit)</a> (Affected 0.9.8-0.9.8l)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1358, tag: dt, level: 8" node_number="1358"><a class="valid" valid="valid" title="valid: True, node: 1359, tag: a, level: 9" node_number="1359">CVE-2009-1377</a> <a class="valid" valid="valid" title="valid: True, node: 1360, tag: a, level: 9" node_number="1360">(OpenSSL advisory)</a> 12 May 2009: </dt><dd class="valid" valid="valid" title="valid: True, node: 1361, tag: dd, level: 8" node_number="1361">Fix a denial of service flaw in the DTLS implementation. Records are buffered if they arrive with a future epoch to be processed after finishing the corresponding handshake. There is currently no limitation to this buffer allowing an attacker to perform a DOS attack to a DTLS server by sending records with future epochs until there is no memory left. Reported by Daniel Mentz, Robin Seggelmann. <ul class="valid" valid="valid" title="valid: True, node: 1362, tag: ul, level: 9" node_number="1362"><li class="valid" valid="valid" title="valid: True, node: 1363, tag: li, level: 10" node_number="1363">Fixed in OpenSSL 0.9.8m <a class="valid" valid="valid" title="valid: True, node: 1364, tag: a, level: 11" node_number="1364">(git commit)</a> (Affected 0.9.8-0.9.8l)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1365, tag: dt, level: 8" node_number="1365"><a class="valid" valid="valid" title="valid: True, node: 1366, tag: a, level: 9" node_number="1366">CVE-2009-0789</a> <a class="valid" valid="valid" title="valid: True, node: 1367, tag: a, level: 9" node_number="1367">(OpenSSL advisory)</a> 25 March 2009: </dt><dd class="valid" valid="valid" title="valid: True, node: 1368, tag: dd, level: 8" node_number="1368">When a malformed ASN1 structure is received it's contents are freed up and zeroed and an error condition returned. On a small number of platforms where sizeof(long) &lt; sizeof(void *) (for example WIN64) this can cause an invalid memory access later resulting in a crash when some invalid structures are read, for example RSA public keys. Reported by Paolo Ganci. <ul class="valid" valid="valid" title="valid: True, node: 1369, tag: ul, level: 9" node_number="1369"><li class="valid" valid="valid" title="valid: True, node: 1370, tag: li, level: 10" node_number="1370">Fixed in OpenSSL 0.9.8k (Affected 0.9.8-0.9.8j)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1371, tag: dt, level: 8" node_number="1371"><a class="valid" valid="valid" title="valid: True, node: 1372, tag: a, level: 9" node_number="1372">CVE-2009-0591</a> <a class="valid" valid="valid" title="valid: True, node: 1373, tag: a, level: 9" node_number="1373">(OpenSSL advisory)</a> 25 March 2009: </dt><dd class="valid" valid="valid" title="valid: True, node: 1374, tag: dd, level: 8" node_number="1374">The function CMS_verify() does not correctly handle an error condition involving malformed signed attributes. This will cause an invalid set of signed attributes to appear valid and content digests will not be checked. Reported by Ivan Nestlerode, IBM. <ul class="valid" valid="valid" title="valid: True, node: 1375, tag: ul, level: 9" node_number="1375"><li class="valid" valid="valid" title="valid: True, node: 1376, tag: li, level: 10" node_number="1376">Fixed in OpenSSL 0.9.8k (Affected 0.9.8h-0.9.8j)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1377, tag: dt, level: 8" node_number="1377"><a class="valid" valid="valid" title="valid: True, node: 1378, tag: a, level: 9" node_number="1378">CVE-2009-0590</a> <a class="valid" valid="valid" title="valid: True, node: 1379, tag: a, level: 9" node_number="1379">(OpenSSL advisory)</a> 25 March 2009: </dt><dd class="valid" valid="valid" title="valid: True, node: 1380, tag: dd, level: 8" node_number="1380">The function ASN1_STRING_print_ex() when used to print a BMPString or UniversalString will crash with an invalid memory access if the encoded length of the string is illegal. Any OpenSSL application which prints out the contents of a certificate could be affected by this bug, including SSL servers, clients and S/MIME software.<ul class="valid" valid="valid" title="valid: True, node: 1381, tag: ul, level: 9" node_number="1381"><li class="valid" valid="valid" title="valid: True, node: 1382, tag: li, level: 10" node_number="1382">Fixed in OpenSSL 0.9.8k (Affected 0.9.8-0.9.8j)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1383, tag: dt, level: 8" node_number="1383"><a class="valid" valid="valid" title="valid: True, node: 1384, tag: a, level: 9" node_number="1384">CVE-2009-1387</a> <a class="valid" valid="valid" title="valid: True, node: 1385, tag: a, level: 9" node_number="1385">(OpenSSL advisory)</a> 05 February 2009: </dt><dd class="valid" valid="valid" title="valid: True, node: 1386, tag: dd, level: 8" node_number="1386">Fix denial of service flaw due in the DTLS implementation. A remote attacker could use this flaw to cause a DTLS server to crash. Reported by Robin Seggelmann. <ul class="valid" valid="valid" title="valid: True, node: 1387, tag: ul, level: 9" node_number="1387"><li class="valid" valid="valid" title="valid: True, node: 1388, tag: li, level: 10" node_number="1388">Fixed in OpenSSL 0.9.8m (Affected 0.9.8-0.9.8l)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1389, tag: dt, level: 8" node_number="1389"><a class="valid" valid="valid" title="valid: True, node: 1390, tag: a, level: 9" node_number="1390">CVE-2008-5077</a> <a class="valid" valid="valid" title="valid: True, node: 1391, tag: a, level: 9" node_number="1391">(OpenSSL advisory)</a> 07 January 2009: </dt><dd class="valid" valid="valid" title="valid: True, node: 1392, tag: dd, level: 8" node_number="1392">The Google Security Team discovered several functions inside OpenSSL incorrectly checked the result after calling the EVP_VerifyFinal function, allowing a malformed signature to be treated as a good signature rather than as an error. This issue affected the signature checks on DSA and ECDSA keys used with SSL/TLS. One way to exploit this flaw would be for a remote attacker who is in control of a malicious server or who can use a 'man in the middle' attack to present a malformed SSL/TLS signature from a certificate chain to a vulnerable client, bypassing validation. Reported by google. <ul class="valid" valid="valid" title="valid: True, node: 1393, tag: ul, level: 9" node_number="1393"><li class="valid" valid="valid" title="valid: True, node: 1394, tag: li, level: 10" node_number="1394">Fixed in OpenSSL 0.9.8j (Affected 0.9.8-0.9.8i)</li></ul></dd></dl><h3 class="valid" valid="valid" title="valid: True, node: 1395, tag: h3, level: 7" node_number="1395"><a class="valid" valid="valid" title="valid: True, node: 1396, tag: a, level: 8" node_number="1396">2008</a></h3><dl class="valid" valid="valid" title="valid: True, node: 1397, tag: dl, level: 7" node_number="1397"><dt class="valid" valid="valid" title="valid: True, node: 1398, tag: dt, level: 8" node_number="1398"><a class="valid" valid="valid" title="valid: True, node: 1399, tag: a, level: 9" node_number="1399">CVE-2008-1672</a> <a class="valid" valid="valid" title="valid: True, node: 1400, tag: a, level: 9" node_number="1400">(OpenSSL advisory)</a> 28 May 2008: </dt><dd class="valid" valid="valid" title="valid: True, node: 1401, tag: dd, level: 8" node_number="1401">Testing using the Codenomicon TLS test suite discovered a flaw if the 'Server Key exchange message' is omitted from a TLS handshake in OpenSSL 0.9.8f and OpenSSL 0.9.8g. If a client connects to a malicious server with particular cipher suites, the server could cause the client to crash. Reported by codenomicon. <ul class="valid" valid="valid" title="valid: True, node: 1402, tag: ul, level: 9" node_number="1402"><li class="valid" valid="valid" title="valid: True, node: 1403, tag: li, level: 10" node_number="1403">Fixed in OpenSSL 0.9.8h (Affected 0.9.8f-0.9.8g)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1404, tag: dt, level: 8" node_number="1404"><a class="valid" valid="valid" title="valid: True, node: 1405, tag: a, level: 9" node_number="1405">CVE-2008-0891</a> <a class="valid" valid="valid" title="valid: True, node: 1406, tag: a, level: 9" node_number="1406">(OpenSSL advisory)</a> 28 May 2008: </dt><dd class="valid" valid="valid" title="valid: True, node: 1407, tag: dd, level: 8" node_number="1407">Testing using the Codenomicon TLS test suite discovered a flaw in the handling of server name extension data in OpenSSL 0.9.8f and OpenSSL 0.9.8g. If OpenSSL has been compiled using the non-default TLS server name extensions, a remote attacker could send a carefully crafted packet to a server application using OpenSSL and cause it to crash. Reported by codenomicon. <ul class="valid" valid="valid" title="valid: True, node: 1408, tag: ul, level: 9" node_number="1408"><li class="valid" valid="valid" title="valid: True, node: 1409, tag: li, level: 10" node_number="1409">Fixed in OpenSSL 0.9.8h (Affected 0.9.8f-0.9.8g)</li></ul></dd></dl><h3 class="valid" valid="valid" title="valid: True, node: 1410, tag: h3, level: 7" node_number="1410"><a class="valid" valid="valid" title="valid: True, node: 1411, tag: a, level: 8" node_number="1411">2007</a></h3><dl class="valid" valid="valid" title="valid: True, node: 1412, tag: dl, level: 7" node_number="1412"><dt class="valid" valid="valid" title="valid: True, node: 1413, tag: dt, level: 8" node_number="1413"><a class="valid" valid="valid" title="valid: True, node: 1414, tag: a, level: 9" node_number="1414">CVE-2007-5502</a> <a class="valid" valid="valid" title="valid: True, node: 1415, tag: a, level: 9" node_number="1415">(OpenSSL advisory)</a> 29 November 2007: </dt><dd class="valid" valid="valid" title="valid: True, node: 1416, tag: dd, level: 8" node_number="1416">The PRNG implementation for the OpenSSL FIPS Object Module 1.1.1 does not perform auto-seeding during the FIPS self-test, which generates random data that is more predictable than expected and makes it easier for attackers to bypass protection mechanisms that rely on the randomness. Reported by Geoff Lowe. <ul class="valid" valid="valid" title="valid: True, node: 1417, tag: ul, level: 9" node_number="1417"><li class="valid" valid="valid" title="valid: True, node: 1418, tag: li, level: 10" node_number="1418">Fixed in OpenSSL fips-1.1.2 (Affected fips-1.1.1)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1419, tag: dt, level: 8" node_number="1419"><a class="valid" valid="valid" title="valid: True, node: 1420, tag: a, level: 9" node_number="1420">CVE-2007-5135</a> <a class="valid" valid="valid" title="valid: True, node: 1421, tag: a, level: 9" node_number="1421">(OpenSSL advisory)</a> 12 October 2007: </dt><dd class="valid" valid="valid" title="valid: True, node: 1422, tag: dd, level: 8" node_number="1422">A flaw was found in the SSL_get_shared_ciphers() utility function. An attacker could send a list of ciphers to an application that used this function and overrun a buffer with a single byte. Few applications make use of this vulnerable function and generally it is used only when applications are compiled for debugging. Reported by Moritz Jodeit. <ul class="valid" valid="valid" title="valid: True, node: 1423, tag: ul, level: 9" node_number="1423"><li class="valid" valid="valid" title="valid: True, node: 1424, tag: li, level: 10" node_number="1424">Fixed in OpenSSL 0.9.8f (Affected 0.9.8-0.9.8e)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1425, tag: dt, level: 8" node_number="1425"><a class="valid" valid="valid" title="valid: True, node: 1426, tag: a, level: 9" node_number="1426">CVE-2007-4995</a> <a class="valid" valid="valid" title="valid: True, node: 1427, tag: a, level: 9" node_number="1427">(OpenSSL advisory)</a> 12 October 2007: </dt><dd class="valid" valid="valid" title="valid: True, node: 1428, tag: dd, level: 8" node_number="1428">A flaw in DTLS support. An attacker could create a malicious client or server that could trigger a heap overflow. This is possibly exploitable to run arbitrary code, but it has not been verified. Reported by Andy Polyakov. <ul class="valid" valid="valid" title="valid: True, node: 1429, tag: ul, level: 9" node_number="1429"><li class="valid" valid="valid" title="valid: True, node: 1430, tag: li, level: 10" node_number="1430">Fixed in OpenSSL 0.9.8f (Affected 0.9.8-0.9.8e)</li></ul></dd></dl><h3 class="valid" valid="valid" title="valid: True, node: 1431, tag: h3, level: 7" node_number="1431"><a class="valid" valid="valid" title="valid: True, node: 1432, tag: a, level: 8" node_number="1432">2006</a></h3><dl class="valid" valid="valid" title="valid: True, node: 1433, tag: dl, level: 7" node_number="1433"><dt class="valid" valid="valid" title="valid: True, node: 1434, tag: dt, level: 8" node_number="1434"><a class="valid" valid="valid" title="valid: True, node: 1435, tag: a, level: 9" node_number="1435">CVE-2006-4343</a> <a class="valid" valid="valid" title="valid: True, node: 1436, tag: a, level: 9" node_number="1436">(OpenSSL advisory)</a> 28 September 2006: </dt><dd class="valid" valid="valid" title="valid: True, node: 1437, tag: dd, level: 8" node_number="1437">A flaw in the SSLv2 client code was discovered. When a client application used OpenSSL to create an SSLv2 connection to a malicious server, that server could cause the client to crash. Reported by openssl. <ul class="valid" valid="valid" title="valid: True, node: 1438, tag: ul, level: 9" node_number="1438"><li class="valid" valid="valid" title="valid: True, node: 1439, tag: li, level: 10" node_number="1439">Fixed in OpenSSL 0.9.8d (Affected 0.9.8-0.9.8c)</li><li class="valid" valid="valid" title="valid: True, node: 1440, tag: li, level: 10" node_number="1440">Fixed in OpenSSL 0.9.7l (Affected 0.9.7-0.9.7k)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1441, tag: dt, level: 8" node_number="1441"><a class="valid" valid="valid" title="valid: True, node: 1442, tag: a, level: 9" node_number="1442">CVE-2006-3738</a> <a class="valid" valid="valid" title="valid: True, node: 1443, tag: a, level: 9" node_number="1443">(OpenSSL advisory)</a> 28 September 2006: </dt><dd class="valid" valid="valid" title="valid: True, node: 1444, tag: dd, level: 8" node_number="1444">A buffer overflow was discovered in the SSL_get_shared_ciphers() utility function. An attacker could send a list of ciphers to an application that uses this function and overrun a buffer. Reported by openssl. <ul class="valid" valid="valid" title="valid: True, node: 1445, tag: ul, level: 9" node_number="1445"><li class="valid" valid="valid" title="valid: True, node: 1446, tag: li, level: 10" node_number="1446">Fixed in OpenSSL 0.9.8d (Affected 0.9.8-0.9.8c)</li><li class="valid" valid="valid" title="valid: True, node: 1447, tag: li, level: 10" node_number="1447">Fixed in OpenSSL 0.9.7l (Affected 0.9.7-0.9.7k)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1448, tag: dt, level: 8" node_number="1448"><a class="valid" valid="valid" title="valid: True, node: 1449, tag: a, level: 9" node_number="1449">CVE-2006-2940</a> <a class="valid" valid="valid" title="valid: True, node: 1450, tag: a, level: 9" node_number="1450">(OpenSSL advisory)</a> 28 September 2006: </dt><dd class="valid" valid="valid" title="valid: True, node: 1451, tag: dd, level: 8" node_number="1451">Certain types of public key can take disproportionate amounts of time to process. This could be used by an attacker in a denial of service attack. Reported by openssl. <ul class="valid" valid="valid" title="valid: True, node: 1452, tag: ul, level: 9" node_number="1452"><li class="valid" valid="valid" title="valid: True, node: 1453, tag: li, level: 10" node_number="1453">Fixed in OpenSSL 0.9.8d (Affected 0.9.8-0.9.8c)</li><li class="valid" valid="valid" title="valid: True, node: 1454, tag: li, level: 10" node_number="1454">Fixed in OpenSSL 0.9.7l (Affected 0.9.7-0.9.7k)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1455, tag: dt, level: 8" node_number="1455"><a class="valid" valid="valid" title="valid: True, node: 1456, tag: a, level: 9" node_number="1456">CVE-2006-2937</a> <a class="valid" valid="valid" title="valid: True, node: 1457, tag: a, level: 9" node_number="1457">(OpenSSL advisory)</a> 28 September 2006: </dt><dd class="valid" valid="valid" title="valid: True, node: 1458, tag: dd, level: 8" node_number="1458">During the parsing of certain invalid ASN.1 structures an error condition is mishandled. This can result in an infinite loop which consumes system memory Reported by openssl. <ul class="valid" valid="valid" title="valid: True, node: 1459, tag: ul, level: 9" node_number="1459"><li class="valid" valid="valid" title="valid: True, node: 1460, tag: li, level: 10" node_number="1460">Fixed in OpenSSL 0.9.8d (Affected 0.9.8-0.9.8c)</li><li class="valid" valid="valid" title="valid: True, node: 1461, tag: li, level: 10" node_number="1461">Fixed in OpenSSL 0.9.7l (Affected 0.9.7-0.9.7k)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1462, tag: dt, level: 8" node_number="1462"><a class="valid" valid="valid" title="valid: True, node: 1463, tag: a, level: 9" node_number="1463">CVE-2006-4339</a> <a class="valid" valid="valid" title="valid: True, node: 1464, tag: a, level: 9" node_number="1464">(OpenSSL advisory)</a> 05 September 2006: </dt><dd class="valid" valid="valid" title="valid: True, node: 1465, tag: dd, level: 8" node_number="1465">Daniel Bleichenbacher discovered an attack on PKCS #1 v1.5 signatures where under certain circumstances it may be possible for an attacker to forge a PKCS #1 v1.5 signature that would be incorrectly verified by OpenSSL. Reported by openssl. <ul class="valid" valid="valid" title="valid: True, node: 1466, tag: ul, level: 9" node_number="1466"><li class="valid" valid="valid" title="valid: True, node: 1467, tag: li, level: 10" node_number="1467">Fixed in OpenSSL 0.9.8c (Affected 0.9.8-0.9.8b)</li><li class="valid" valid="valid" title="valid: True, node: 1468, tag: li, level: 10" node_number="1468">Fixed in OpenSSL 0.9.7k (Affected 0.9.7-0.9.7j)</li></ul></dd></dl><h3 class="valid" valid="valid" title="valid: True, node: 1469, tag: h3, level: 7" node_number="1469"><a class="valid" valid="valid" title="valid: True, node: 1470, tag: a, level: 8" node_number="1470">2005</a></h3><dl class="valid" valid="valid" title="valid: True, node: 1471, tag: dl, level: 7" node_number="1471"><dt class="valid" valid="valid" title="valid: True, node: 1472, tag: dt, level: 8" node_number="1472"><a class="valid" valid="valid" title="valid: True, node: 1473, tag: a, level: 9" node_number="1473">CVE-2005-2969</a> <a class="valid" valid="valid" title="valid: True, node: 1474, tag: a, level: 9" node_number="1474">(OpenSSL advisory)</a> 11 October 2005: </dt><dd class="valid" valid="valid" title="valid: True, node: 1475, tag: dd, level: 8" node_number="1475">A deprecated option, SSL_OP_MISE_SSLV2_RSA_PADDING, could allow an attacker acting as a "man in the middle" to force a connection to downgrade to SSL 2.0 even if both parties support better protocols. Reported by researcher. <ul class="valid" valid="valid" title="valid: True, node: 1476, tag: ul, level: 9" node_number="1476"><li class="valid" valid="valid" title="valid: True, node: 1477, tag: li, level: 10" node_number="1477">Fixed in OpenSSL 0.9.8a (Affected 0.9.8)</li><li class="valid" valid="valid" title="valid: True, node: 1478, tag: li, level: 10" node_number="1478">Fixed in OpenSSL 0.9.7h (Affected 0.9.7-0.9.7g)</li></ul></dd></dl><h3 class="valid" valid="valid" title="valid: True, node: 1479, tag: h3, level: 7" node_number="1479"><a class="valid" valid="valid" title="valid: True, node: 1480, tag: a, level: 8" node_number="1480">2004</a></h3><dl class="valid" valid="valid" title="valid: True, node: 1481, tag: dl, level: 7" node_number="1481"><dt class="valid" valid="valid" title="valid: True, node: 1482, tag: dt, level: 8" node_number="1482"><a class="valid" valid="valid" title="valid: True, node: 1483, tag: a, level: 9" node_number="1483">CVE-2004-0975</a> 30 September 2004: </dt><dd class="valid" valid="valid" title="valid: True, node: 1484, tag: dd, level: 8" node_number="1484">The der_chop script created temporary files insecurely which could allow local users to overwrite files via a symlink attack on temporary files. Note that it is quite unlikely that a user would be using the redundant der_chop script, and this script was removed from the OpenSSL distribution.<ul class="valid" valid="valid" title="valid: True, node: 1485, tag: ul, level: 9" node_number="1485"><li class="valid" valid="valid" title="valid: True, node: 1486, tag: li, level: 10" node_number="1486">Fixed in OpenSSL 0.9.7f <a class="valid" valid="valid" title="valid: True, node: 1487, tag: a, level: 11" node_number="1487">(git commit)</a> (Affected 0.9.7-0.9.7e)</li><li class="valid" valid="valid" title="valid: True, node: 1488, tag: li, level: 10" node_number="1488">Fixed in OpenSSL 0.9.6-cvs (Affected 0.9.6-0.9.6m)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1489, tag: dt, level: 8" node_number="1489"><a class="valid" valid="valid" title="valid: True, node: 1490, tag: a, level: 9" node_number="1490">CVE-2004-0112</a> <a class="valid" valid="valid" title="valid: True, node: 1491, tag: a, level: 9" node_number="1491">(OpenSSL advisory)</a> 17 March 2004: </dt><dd class="valid" valid="valid" title="valid: True, node: 1492, tag: dd, level: 8" node_number="1492">A flaw in SSL/TLS handshaking code when using Kerberos ciphersuites. A remote attacker could perform a carefully crafted SSL/TLS handshake against a server configured to use Kerberos ciphersuites in such a way as to cause OpenSSL to crash. Most applications have no ability to use Kerberos ciphersuites and will therefore be unaffected. Reported by OpenSSL group (Stephen Henson). <ul class="valid" valid="valid" title="valid: True, node: 1493, tag: ul, level: 9" node_number="1493"><li class="valid" valid="valid" title="valid: True, node: 1494, tag: li, level: 10" node_number="1494">Fixed in OpenSSL 0.9.7d (Affected 0.9.7a-0.9.7c)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1495, tag: dt, level: 8" node_number="1495"><a class="valid" valid="valid" title="valid: True, node: 1496, tag: a, level: 9" node_number="1496">CVE-2004-0081</a> <a class="valid" valid="valid" title="valid: True, node: 1497, tag: a, level: 9" node_number="1497">(OpenSSL advisory)</a> 17 March 2004: </dt><dd class="valid" valid="valid" title="valid: True, node: 1498, tag: dd, level: 8" node_number="1498">The Codenomicon TLS Test Tool found that some unknown message types were handled incorrectly, allowing a remote attacker to cause a denial of service (infinite loop). Reported by OpenSSL group. <ul class="valid" valid="valid" title="valid: True, node: 1499, tag: ul, level: 9" node_number="1499"><li class="valid" valid="valid" title="valid: True, node: 1500, tag: li, level: 10" node_number="1500">Fixed in OpenSSL 0.9.6d (Affected 0.9.6-0.9.6c)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1501, tag: dt, level: 8" node_number="1501"><a class="valid" valid="valid" title="valid: True, node: 1502, tag: a, level: 9" node_number="1502">CVE-2004-0079</a> <a class="valid" valid="valid" title="valid: True, node: 1503, tag: a, level: 9" node_number="1503">(OpenSSL advisory)</a> 17 March 2004: </dt><dd class="valid" valid="valid" title="valid: True, node: 1504, tag: dd, level: 8" node_number="1504">The Codenomicon TLS Test Tool uncovered a null-pointer assignment in the do_change_cipher_spec() function. A remote attacker could perform a carefully crafted SSL/TLS handshake against a server that used the OpenSSL library in such a way as to cause a crash. Reported by OpenSSL group. <ul class="valid" valid="valid" title="valid: True, node: 1505, tag: ul, level: 9" node_number="1505"><li class="valid" valid="valid" title="valid: True, node: 1506, tag: li, level: 10" node_number="1506">Fixed in OpenSSL 0.9.7d (Affected 0.9.7-0.9.7c)</li><li class="valid" valid="valid" title="valid: True, node: 1507, tag: li, level: 10" node_number="1507">Fixed in OpenSSL 0.9.6m (Affected 0.9.6c-0.9.6l)</li></ul></dd></dl><h3 class="valid" valid="valid" title="valid: True, node: 1508, tag: h3, level: 7" node_number="1508"><a class="valid" valid="valid" title="valid: True, node: 1509, tag: a, level: 8" node_number="1509">2003</a></h3><dl class="valid" valid="valid" title="valid: True, node: 1510, tag: dl, level: 7" node_number="1510"><dt class="valid" valid="valid" title="valid: True, node: 1511, tag: dt, level: 8" node_number="1511"><a class="valid" valid="valid" title="valid: True, node: 1512, tag: a, level: 9" node_number="1512">CVE-2003-0851</a> <a class="valid" valid="valid" title="valid: True, node: 1513, tag: a, level: 9" node_number="1513">(OpenSSL advisory)</a> 04 November 2003: </dt><dd class="valid" valid="valid" title="valid: True, node: 1514, tag: dd, level: 8" node_number="1514">A flaw in OpenSSL 0.9.6k (only) would cause certain ASN.1 sequences to trigger a large recursion. On platforms such as Windows this large recursion cannot be handled correctly and so the bug causes OpenSSL to crash. A remote attacker could exploit this flaw if they can send arbitrary ASN.1 sequences which would cause OpenSSL to crash. This could be performed for example by sending a client certificate to a SSL/TLS enabled server which is configured to accept them. Reported by Novell. <ul class="valid" valid="valid" title="valid: True, node: 1515, tag: ul, level: 9" node_number="1515"><li class="valid" valid="valid" title="valid: True, node: 1516, tag: li, level: 10" node_number="1516">Fixed in OpenSSL 0.9.6l (Affected 0.9.6k)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1517, tag: dt, level: 8" node_number="1517"><a class="valid" valid="valid" title="valid: True, node: 1518, tag: a, level: 9" node_number="1518">CVE-2003-0545</a> <a class="valid" valid="valid" title="valid: True, node: 1519, tag: a, level: 9" node_number="1519">(OpenSSL advisory)</a> 30 September 2003: </dt><dd class="valid" valid="valid" title="valid: True, node: 1520, tag: dd, level: 8" node_number="1520">Certain ASN.1 encodings that were rejected as invalid by the parser could trigger a bug in the deallocation of the corresponding data structure, corrupting the stack, leading to a crash. Reported by NISCC. <ul class="valid" valid="valid" title="valid: True, node: 1521, tag: ul, level: 9" node_number="1521"><li class="valid" valid="valid" title="valid: True, node: 1522, tag: li, level: 10" node_number="1522">Fixed in OpenSSL 0.9.7c (Affected 0.9.7-0.9.7b)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1523, tag: dt, level: 8" node_number="1523"><a class="valid" valid="valid" title="valid: True, node: 1524, tag: a, level: 9" node_number="1524">CVE-2003-0544</a> <a class="valid" valid="valid" title="valid: True, node: 1525, tag: a, level: 9" node_number="1525">(OpenSSL advisory)</a> 30 September 2003: </dt><dd class="valid" valid="valid" title="valid: True, node: 1526, tag: dd, level: 8" node_number="1526">Incorrect tracking of the number of characters in certain ASN.1 inputs could allow remote attackers to cause a denial of service (crash) by sending an SSL client certificate that causes OpenSSL to read past the end of a buffer when the long form is used. Reported by NISCC. <ul class="valid" valid="valid" title="valid: True, node: 1527, tag: ul, level: 9" node_number="1527"><li class="valid" valid="valid" title="valid: True, node: 1528, tag: li, level: 10" node_number="1528">Fixed in OpenSSL 0.9.7c (Affected 0.9.7-0.9.7b)</li><li class="valid" valid="valid" title="valid: True, node: 1529, tag: li, level: 10" node_number="1529">Fixed in OpenSSL 0.9.6k (Affected 0.9.6-0.9.6j)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1530, tag: dt, level: 8" node_number="1530"><a class="valid" valid="valid" title="valid: True, node: 1531, tag: a, level: 9" node_number="1531">CVE-2003-0543</a> <a class="valid" valid="valid" title="valid: True, node: 1532, tag: a, level: 9" node_number="1532">(OpenSSL advisory)</a> 30 September 2003: </dt><dd class="valid" valid="valid" title="valid: True, node: 1533, tag: dd, level: 8" node_number="1533">An integer overflow could allow remote attackers to cause a denial of service (crash) via an SSL client certificate with certain ASN.1 tag values. Reported by NISCC. <ul class="valid" valid="valid" title="valid: True, node: 1534, tag: ul, level: 9" node_number="1534"><li class="valid" valid="valid" title="valid: True, node: 1535, tag: li, level: 10" node_number="1535">Fixed in OpenSSL 0.9.7c (Affected 0.9.7-0.9.7b)</li><li class="valid" valid="valid" title="valid: True, node: 1536, tag: li, level: 10" node_number="1536">Fixed in OpenSSL 0.9.6k (Affected 0.9.6-0.9.6j)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1537, tag: dt, level: 8" node_number="1537"><a class="valid" valid="valid" title="valid: True, node: 1538, tag: a, level: 9" node_number="1538">CVE-2003-0131</a> <a class="valid" valid="valid" title="valid: True, node: 1539, tag: a, level: 9" node_number="1539">(OpenSSL advisory)</a> 19 March 2003: </dt><dd class="valid" valid="valid" title="valid: True, node: 1540, tag: dd, level: 8" node_number="1540">The SSL and TLS components allowed remote attackers to perform an unauthorized RSA private key operation via a modified Bleichenbacher attack that uses a large number of SSL or TLS connections using PKCS #1 v1.5 padding that caused OpenSSL to leak information regarding the relationship between ciphertext and the associated plaintext, aka the "Klima-Pokorny-Rosa attack"<ul class="valid" valid="valid" title="valid: True, node: 1541, tag: ul, level: 9" node_number="1541"><li class="valid" valid="valid" title="valid: True, node: 1542, tag: li, level: 10" node_number="1542">Fixed in OpenSSL 0.9.7b (Affected 0.9.7-0.9.7a)</li><li class="valid" valid="valid" title="valid: True, node: 1543, tag: li, level: 10" node_number="1543">Fixed in OpenSSL 0.9.6j (Affected 0.9.6-0.9.6i)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1544, tag: dt, level: 8" node_number="1544"><a class="valid" valid="valid" title="valid: True, node: 1545, tag: a, level: 9" node_number="1545">CVE-2003-0147</a> <a class="valid" valid="valid" title="valid: True, node: 1546, tag: a, level: 9" node_number="1546">(OpenSSL advisory)</a> 14 March 2003: </dt><dd class="valid" valid="valid" title="valid: True, node: 1547, tag: dd, level: 8" node_number="1547">RSA blinding was not enabled by default, which could allow local and remote attackers to obtain a server's private key by determining factors using timing differences on (1) the number of extra reductions during Montgomery reduction, and (2) the use of different integer multiplication algorithms ("Karatsuba" and normal).<ul class="valid" valid="valid" title="valid: True, node: 1548, tag: ul, level: 9" node_number="1548"><li class="valid" valid="valid" title="valid: True, node: 1549, tag: li, level: 10" node_number="1549">Fixed in OpenSSL 0.9.7b (Affected 0.9.7-0.9.7a)</li><li class="valid" valid="valid" title="valid: True, node: 1550, tag: li, level: 10" node_number="1550">Fixed in OpenSSL 0.9.6j (Affected 0.9.6-0.9.6i)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1551, tag: dt, level: 8" node_number="1551"><a class="valid" valid="valid" title="valid: True, node: 1552, tag: a, level: 9" node_number="1552">CVE-2003-0078</a> <a class="valid" valid="valid" title="valid: True, node: 1553, tag: a, level: 9" node_number="1553">(OpenSSL advisory)</a> 19 February 2003: </dt><dd class="valid" valid="valid" title="valid: True, node: 1554, tag: dd, level: 8" node_number="1554">sl3_get_record in s3_pkt.c did not perform a MAC computation if an incorrect block cipher padding was used, causing an information leak (timing discrepancy) that may make it easier to launch cryptographic attacks that rely on distinguishing between padding and MAC verification errors, possibly leading to extraction of the original plaintext, aka the "Vaudenay timing attack."<ul class="valid" valid="valid" title="valid: True, node: 1555, tag: ul, level: 9" node_number="1555"><li class="valid" valid="valid" title="valid: True, node: 1556, tag: li, level: 10" node_number="1556">Fixed in OpenSSL 0.9.7a (Affected 0.9.7)</li><li class="valid" valid="valid" title="valid: True, node: 1557, tag: li, level: 10" node_number="1557">Fixed in OpenSSL 0.9.6i (Affected 0.9.6-0.9.6h)</li></ul></dd></dl><h3 class="valid" valid="valid" title="valid: True, node: 1558, tag: h3, level: 7" node_number="1558"><a class="valid" valid="valid" title="valid: True, node: 1559, tag: a, level: 8" node_number="1559">2002</a></h3><dl class="valid" valid="valid" title="valid: True, node: 1560, tag: dl, level: 7" node_number="1560"><dt class="valid" valid="valid" title="valid: True, node: 1561, tag: dt, level: 8" node_number="1561"><a class="valid" valid="valid" title="valid: True, node: 1562, tag: a, level: 9" node_number="1562">CVE-2002-1568</a> 08 August 2002: </dt><dd class="valid" valid="valid" title="valid: True, node: 1563, tag: dd, level: 8" node_number="1563">The use of assertions when detecting buffer overflow attacks allowed remote attackers to cause a denial of service (crash) by sending certain messages to cause OpenSSL to abort from a failed assertion, as demonstrated using SSLv2 CLIENT_MASTER_KEY messages, which were not properly handled in s2_srvr.c.<ul class="valid" valid="valid" title="valid: True, node: 1564, tag: ul, level: 9" node_number="1564"><li class="valid" valid="valid" title="valid: True, node: 1565, tag: li, level: 10" node_number="1565">Fixed in OpenSSL 0.9.6f <a class="valid" valid="valid" title="valid: True, node: 1566, tag: a, level: 11" node_number="1566">(git commit)</a> (Affected 0.9.6e)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1567, tag: dt, level: 8" node_number="1567"><a class="valid" valid="valid" title="valid: True, node: 1568, tag: a, level: 9" node_number="1568">CVE-2002-0659</a> <a class="valid" valid="valid" title="valid: True, node: 1569, tag: a, level: 9" node_number="1569">(OpenSSL advisory)</a> 30 July 2002: </dt><dd class="valid" valid="valid" title="valid: True, node: 1570, tag: dd, level: 8" node_number="1570">A flaw in the ASN1 library allowed remote attackers to cause a denial of service by sending invalid encodings.<ul class="valid" valid="valid" title="valid: True, node: 1571, tag: ul, level: 9" node_number="1571"><li class="valid" valid="valid" title="valid: True, node: 1572, tag: li, level: 10" node_number="1572">Fixed in OpenSSL 0.9.6e (Affected 0.9.6a-0.9.6d)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1573, tag: dt, level: 8" node_number="1573"><a class="valid" valid="valid" title="valid: True, node: 1574, tag: a, level: 9" node_number="1574">CVE-2002-0657</a> <a class="valid" valid="valid" title="valid: True, node: 1575, tag: a, level: 9" node_number="1575">(OpenSSL advisory)</a> 30 July 2002: </dt><dd class="valid" valid="valid" title="valid: True, node: 1576, tag: dd, level: 8" node_number="1576">A buffer overflow when Kerberos is enabled allowed attackers to execute arbitrary code by sending a long master key. Note that this flaw did not affect any released version of 0.9.6 or 0.9.7 Reported by OpenSSL Group (A.L. Digital). <ul class="valid" valid="valid" title="valid: True, node: 1577, tag: ul, level: 9" node_number="1577"><li class="valid" valid="valid" title="valid: True, node: 1578, tag: li, level: 10" node_number="1578">Fixed in OpenSSL 0.9.7 (Affected 0.9.7-beta3)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1579, tag: dt, level: 8" node_number="1579"><a class="valid" valid="valid" title="valid: True, node: 1580, tag: a, level: 9" node_number="1580">CVE-2002-0656</a> <a class="valid" valid="valid" title="valid: True, node: 1581, tag: a, level: 9" node_number="1581">(OpenSSL advisory)</a> 30 July 2002: </dt><dd class="valid" valid="valid" title="valid: True, node: 1582, tag: dd, level: 8" node_number="1582">A buffer overflow allowed remote attackers to execute arbitrary code by sending a large client master key in SSL2 or a large session ID in SSL3. Reported by OpenSSL Group (A.L. Digital). <ul class="valid" valid="valid" title="valid: True, node: 1583, tag: ul, level: 9" node_number="1583"><li class="valid" valid="valid" title="valid: True, node: 1584, tag: li, level: 10" node_number="1584">Fixed in OpenSSL 0.9.6e (Affected 0.9.6-0.9.6d)</li></ul></dd><dt class="valid" valid="valid" title="valid: True, node: 1585, tag: dt, level: 8" node_number="1585"><a class="valid" valid="valid" title="valid: True, node: 1586, tag: a, level: 9" node_number="1586">CVE-2002-0655</a> <a class="valid" valid="valid" title="valid: True, node: 1587, tag: a, level: 9" node_number="1587">(OpenSSL advisory)</a> 30 July 2002: </dt><dd class="valid" valid="valid" title="valid: True, node: 1588, tag: dd, level: 8" node_number="1588">Inproper handling of ASCII representations of integers on 64 bit platforms allowed remote attackers to cause a denial of service or possibly execute arbitrary code. Reported by OpenSSL Group (A.L. Digital). <ul class="valid" valid="valid" title="valid: True, node: 1589, tag: ul, level: 9" node_number="1589"><li class="valid" valid="valid" title="valid: True, node: 1590, tag: li, level: 10" node_number="1590">Fixed in OpenSSL 0.9.6e (Affected 0.9.6-0.9.6d)</li></ul></dd></dl> </div> </article> </div> </div> </div> </body>
        <style tyle='text/css'>
body{
    position: relative;
    padding-left: 30px;
    top: 60px;
}
* {
    border: 1px solid #eee;
    padding: 5px 12px;
    margin: 3px 0;
    box-sizing: content-box;
    background-color: #fff;
    cursor: no-drop;
}
main:hover > *, section:hover > *, header:hover > *, nav:hover > *, a:hover > *, div:hover > *, p:hover > *, ul:hover > *, h1:hover > *, h2:hover > *, h3:hover > *, li:hover > *, span:hover > *{
    border: 2px solid green;
    background-color: #fffeee;
    padding: 5px 23px !important;
    margin: 1px 0;
    color: green;
}
main:hover, section:hover, header:hover, nav:hover, a:hover, div:hover, p:hover, ul:hover, h1:hover, h2:hover, h3:hover, li:hover, span:hover{
    border: 1px solid #fff;
    background-color: #eee;
}
a, span {
    display: block;
}
.selected {
    border: 2px solid orchid !important;
    opacity: 0.8;
    color: orchid !important;
}
.selected * {
    padding: 2px !important;
    color: orchid !important;
}
.valid {
  cursor: pointer;
}
.btn{
  cursor: pointer;
  font-weight: bolder;
  padding: 8px;
}
</style> 
        <script>function OpenOriginalLink($event){
    $event.stopPropagation();
    console.log(url);
}

function removeItem($event){
    $event.stopPropagation();
    console.log('Remove item: ', url)
    localStorage.removeItem(url)
}

function exportData($event){
    $event.stopPropagation();

    result = []
    for(let i=0; i<localStorage.length; i++) {
        let key = localStorage.key(i);
        result.push(localStorage.getItem(key))
    }
    const _url = URL.createObjectURL(new Blob([result.join("\n")], {type: 'text/plain'}))
    $event.target.href = _url;
    localStorage.clear()
}

var removeItemBtn = document.createElement("BUTTON");   // Create a <button> element
removeItemBtn.innerHTML = "Remove Item";
removeItemBtn.classList.add('btn');
removeItemBtn.style.position = "fixed";
removeItemBtn.style.left = '5px';
removeItemBtn.style.top = 0;
removeItemBtn.style.border = "1px solid";
removeItemBtn.style.boxShadow = "3px 3px #888";
removeItemBtn.onclick = removeItem;
document.body.appendChild(removeItemBtn);

var goToOriginLink = document.createElement("A");   // Create a <button> element
goToOriginLink.innerHTML = "GoToOrigin";
goToOriginLink.classList.add('btn');
goToOriginLink.style.position = "fixed"
goToOriginLink.style.left = '115px'
goToOriginLink.style.top = 0;
goToOriginLink.onclick = OpenOriginalLink;
goToOriginLink.setAttribute('href', decodeURIComponent(url));
goToOriginLink.target = '_blank';
document.body.appendChild(goToOriginLink);

var current = new Date
var exportDataLink = document.createElement("A");   // Create a <button> element
exportDataLink.innerHTML = "Export data";
exportDataLink.classList.add('btn');
exportDataLink.download = current.toISOString() + '.exported.txt';
exportDataLink.style.position = "fixed";
exportDataLink.style.right = '5px';
exportDataLink.style.top = 0;
exportDataLink.style.border = "1px solid #888";
exportDataLink.style.boxShadow = "3px 3px #888";
exportDataLink.onclick = exportData;
document.body.appendChild(exportDataLink);

data = {
    'title': null ,
    'article': null
}

var body = document.getElementsByTagName("body")[0];

body.onclick = function($e){
    var num = $e.target.getAttribute('node_number')
    var valid = $e.target.getAttribute('valid')

    if(!valid){
        console.log("Element is invalid")
        return
    }

    if(data.length > 2){
        data = data.splice(0, 2)
    }

    console.log("node:", $e.target)

    if(!data.title && !data.article){
        data.title = num;
        console.log("data:", data)
        $e.target.classList.add('selected')
    }else if (data.title && !data.article){
        data.article = num;
        console.log("data:", data)
        $e.target.classList.add('selected')
    }else{
        selected = Array.from(document.getElementsByClassName("selected"))
        selected.forEach(function(el){
            el.classList.remove('selected')
        })

        data.title = num;
        data.article = null;
        $e.target.classList.add('selected')

    }

    if(data.title && data.article){
        var obj = {
            url: url,
            text: body_html,
            title: data.title,
            article: data.article,
        }

        var datasetItem = JSON.stringify(obj)
        localStorage.setItem(url, datasetItem)
    }
}
</script> 
      </html>