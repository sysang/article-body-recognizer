<!DOCTYPE html>
<html>
<head>

      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

        <script> var url = encodeURIComponent('https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.15.12');</script>

        <script> var body_html = 'PGJvZHk+PHA+Y29tbWl0IDI1OTYwY2FmYTA2ZTZmY2Q4MzBlNmM3OTJlNmE3ZGU2OGMxZTI1ZWQgQXV0aG9yOiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gRGF0ZTogV2VkIERlYyAyOSAxMjoyOTowMyAyMDIxICswMTAwIExpbnV4IDUuMTUuMTIgTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8yMDIxMTIyNzE1MTMzMS41MDI1MDEzNjdAbGludXhmb3VuZGF0aW9uLm9yZyBUZXN0ZWQtYnk6IEZsb3JpYW4gRmFpbmVsbGkgPGYuZmFpbmVsbGk+IFRlc3RlZC1ieTogTGludXggS2VybmVsIEZ1bmN0aW9uYWwgVGVzdGluZyA8bGtmdD4gVGVzdGVkLWJ5OiBSdWRpIEhlaXRiYXVtIDxydWRpPiBUZXN0ZWQtYnk6IFN1ZGlwIE11a2hlcmplZSA8c3VkaXAubXVraGVyamVlPiBUZXN0ZWQtYnk6IEplZmZyaW4gSm9zZSBUIDxqZWZmcmluPiBUZXN0ZWQtYnk6IEd1ZW50ZXIgUm9lY2sgPGxpbnV4PiBUZXN0ZWQtYnk6IFNodWFoIEtoYW4gPHNraGFuPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDUzY2NkYzczZWVkYWYwZTkyMmM0NWI1NjliNzk3ZDI3OTZmYmFhZmEgQXV0aG9yOiBSw6ltaSBEZW5pcy1Db3VybW9udCA8cmVtaT4gRGF0ZTogU3VuIERlYyAxOSAxOTowMzozOSAyMDIxICswMjAwIHBob25ldC9wZXA6IHJlZnVzZSB0byBlbmFibGUgYW4gdW5ib3VuZCBwaXBlIGNvbW1pdCA3NWEyZjMxNTIwMDk1NjAwZjY1MDU5N2MwYWM0MWY0OGI1YmEwMDY4IHVwc3RyZWFtLiBUaGlzIGlvY3RsKCkgaW1wbGljaXRseSBhc3N1bWVkIHRoYXQgdGhlIHNvY2tldCB3YXMgYWxyZWFkeSBib3VuZCB0byBhIHZhbGlkIGxvY2FsIHNvY2tldCBuYW1lLCBpLmUuIFBob25ldCBvYmplY3QuIElmIHRoZSBzb2NrZXQgd2FzIG5vdCBib3VuZCwgdHdvIHNlcGFyYXRlIHByb2JsZW1zIHdvdWxkIG9jY3VyOiAxKSBXZSdkIHNlbmQgYW4gcGlwZSBlbmFibGVtZW50IHJlcXVlc3Qgd2l0aCBhbiBpbnZhbGlkIHNvdXJjZSBvYmplY3QuIDIpIExhdGVyIHNvY2tldCBjYWxscyBjb3VsZCBCVUcgb24gdGhlIHNvY2tldCB1bmV4cGVjdGVkbHkgYmVpbmcgY29ubmVjdGVkIHlldCBub3QgYm91bmQgdG8gYSB2YWxpZCBvYmplY3QuIFJlcG9ydGVkLWJ5OiBzeXpib3QrMmRjOTFlN2ZjM2RlYTg4YjFlOGFAc3l6a2FsbGVyLmFwcHNwb3RtYWlsLmNvbSBTaWduZWQtb2ZmLWJ5OiBSw6ltaSBEZW5pcy1Db3VybW9udCA8cmVtaT4gU2lnbmVkLW9mZi1ieTogRGF2aWQgUy4gTWlsbGVyIDxkYXZlbT4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCAzY2I1YWU3Nzc5OWU4ZWQ2ZWMzZmVjMGI2YjRjZDA3ZjAxNjUwY2M1IEF1dGhvcjogR2VvcmdlIEtlbm5lZHkgPGdlb3JnZS5rZW5uZWR5PiBEYXRlOiBUaHUgRGVjIDE2IDEzOjI1OjMyIDIwMjEgLTA1MDAgdHVuOiBhdm9pZCBkb3VibGUgZnJlZSBpbiB0dW5fZnJlZV9uZXRkZXYgY29tbWl0IDE1OGI1MTVmNzAzZTc1ZTdkNjgyODliZjRkOThjNjY0ZTFkNjMyZGYgdXBzdHJlYW0uIEF2b2lkIGRvdWJsZSBmcmVlIGluIHR1bl9mcmVlX25ldGRldigpIGJ5IG1vdmluZyB0aGUgZGV2LSZndDt0c3RhdHMgYW5kIHR1bi0mZ3Q7c2VjdXJpdHkgYWxsb2NzIHRvIGEgbmV3IG5kb19pbml0IHJvdXRpbmUgKHR1bl9uZXRfaW5pdCgpKSB0aGF0IHdpbGwgYmUgY2FsbGVkIGJ5IHJlZ2lzdGVyX25ldGRldmljZSgpLiBuZG9faW5pdCBpcyBwYWlyZWQgd2l0aCB0aGUgZGVzY3RydWN0b3IgKHR1bl9mcmVlX25ldGRldigpKSwgc28gaWYgdGhlcmUncyBhbiBlcnJvciBpbiByZWdpc3Rlcl9uZXRkZXZpY2UoKSB0aGUgZGVzdHJ1Y3RvciB3aWxsIGhhbmRsZSB0aGUgZnJlZXMuIEJVRzogS0FTQU46IGRvdWJsZS1mcmVlIG9yIGludmFsaWQtZnJlZSBpbiBzZWxpbnV4X3R1bl9kZXZfZnJlZV9zZWN1cml0eSsweDFhLzB4MjAgc2VjdXJpdHkvc2VsaW51eC9ob29rcy5jOjU2MDUgQ1BVOiAwIFBJRDogMjU3NTAgQ29tbTogc3l6LWV4ZWN1dG9yNDE2IE5vdCB0YWludGVkIDUuMTYuMC1yYzItc3l6ayAjMSBIYXJkd2FyZSBuYW1lOiBSZWQgSGF0IEtWTSwgQklPUyBDYWxsIFRyYWNlOiA8dGFzaz4gX19kdW1wX3N0YWNrIGxpYi9kdW1wX3N0YWNrLmM6ODggW2lubGluZV0gZHVtcF9zdGFja19sdmwrMHg4OS8weGI1IGxpYi9kdW1wX3N0YWNrLmM6MTA2IHByaW50X2FkZHJlc3NfZGVzY3JpcHRpb24uY29uc3Rwcm9wLjkrMHgyOC8weDE2MCBtbS9rYXNhbi9yZXBvcnQuYzoyNDcga2FzYW5fcmVwb3J0X2ludmFsaWRfZnJlZSsweDU1LzB4ODAgbW0va2FzYW4vcmVwb3J0LmM6MzcyIF9fX19rYXNhbl9zbGFiX2ZyZWUgbW0va2FzYW4vY29tbW9uLmM6MzQ2IFtpbmxpbmVdIF9fa2FzYW5fc2xhYl9mcmVlKzB4MTA3LzB4MTIwIG1tL2thc2FuL2NvbW1vbi5jOjM3NCBrYXNhbl9zbGFiX2ZyZWUgaW5jbHVkZS9saW51eC9rYXNhbi5oOjIzNSBbaW5saW5lXSBzbGFiX2ZyZWVfaG9vayBtbS9zbHViLmM6MTcyMyBbaW5saW5lXSBzbGFiX2ZyZWVfZnJlZWxpc3RfaG9vayBtbS9zbHViLmM6MTc0OSBbaW5saW5lXSBzbGFiX2ZyZWUgbW0vc2x1Yi5jOjM1MTMgW2lubGluZV0ga2ZyZWUrMHhhYy8weDJkMCBtbS9zbHViLmM6NDU2MSBzZWxpbnV4X3R1bl9kZXZfZnJlZV9zZWN1cml0eSsweDFhLzB4MjAgc2VjdXJpdHkvc2VsaW51eC9ob29rcy5jOjU2MDUgc2VjdXJpdHlfdHVuX2Rldl9mcmVlX3NlY3VyaXR5KzB4NGYvMHg5MCBzZWN1cml0eS9zZWN1cml0eS5jOjIzNDIgdHVuX2ZyZWVfbmV0ZGV2KzB4ZTYvMHgxNTAgZHJpdmVycy9uZXQvdHVuLmM6MjIxNSBuZXRkZXZfcnVuX3RvZG8rMHg0ZGYvMHg4NDAgbmV0L2NvcmUvZGV2LmM6MTA2MjcgcnRubF91bmxvY2srMHgxMy8weDIwIG5ldC9jb3JlL3J0bmV0bGluay5jOjExMiBfX3R1bl9jaHJfaW9jdGwrMHg4MGMvMHgyODcwIGRyaXZlcnMvbmV0L3R1bi5jOjMzMDIgdHVuX2Nocl9pb2N0bCsweDJmLzB4NDAgZHJpdmVycy9uZXQvdHVuLmM6MzMxMSB2ZnNfaW9jdGwgZnMvaW9jdGwuYzo1MSBbaW5saW5lXSBfX2RvX3N5c19pb2N0bCBmcy9pb2N0bC5jOjg3NCBbaW5saW5lXSBfX3NlX3N5c19pb2N0bCBmcy9pb2N0bC5jOjg2MCBbaW5saW5lXSBfX3g2NF9zeXNfaW9jdGwrMHgxOWQvMHgyMjAgZnMvaW9jdGwuYzo4NjAgZG9fc3lzY2FsbF94NjQgYXJjaC94ODYvZW50cnkvY29tbW9uLmM6NTAgW2lubGluZV0gZG9fc3lzY2FsbF82NCsweDNhLzB4ODAgYXJjaC94ODYvZW50cnkvY29tbW9uLmM6ODAgZW50cnlfU1lTQ0FMTF82NF9hZnRlcl9od2ZyYW1lKzB4NDQvMHhhZSBSZXBvcnRlZC1ieTogc3l6a2FsbGVyIDxzeXprYWxsZXI+IFNpZ25lZC1vZmYtYnk6IEdlb3JnZSBLZW5uZWR5IDxnZW9yZ2Uua2VubmVkeT4gU3VnZ2VzdGVkLWJ5OiBKYWt1YiBLaWNpbnNraSA8a3ViYT4gTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8xNjM5Njc5MTMyLTE5ODg0LTEtZ2l0LXNlbmQtZW1haWwtZ2VvcmdlLmtlbm5lZHlAb3JhY2xlLmNvbSBTaWduZWQtb2ZmLWJ5OiBKYWt1YiBLaWNpbnNraSA8a3ViYT4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCAwM2QwMGY3ZjE4MTVlYzAwZGFiNTAzNTg1MWIzZGU4M2FmZDA1NGE4IEF1dGhvcjogTGluIE1hIDxsaW5tYT4gRGF0ZTogRnJpIERlYyAxNyAxMDoxMzo1NiAyMDIxICswODAwIGhhbXJhZGlvOiBpbXByb3ZlIHRoZSBpbmNvbXBsZXRlIGZpeCB0byBhdm9pZCBOUEQgY29tbWl0IGIyZjM3YWVhZDFiODJhNzcwYzQ4YjVkNTgzZjM1ZWMyMmFhYmI2MWUgdXBzdHJlYW0uIFRoZSBwcmV2aW91cyBjb21taXQgM2UwNTg4YzI5MWQ2ICgiaGFtcmFkaW86IGRlZmVyIGF4MjUga2ZyZWUgYWZ0ZXIgdW5yZWdpc3Rlcl9uZXRkZXYiKSByZW9yZGVyIHRoZSBrZnJlZSBvcGVyYXRpb25zIGFuZCB1bnJlZ2lzdGVyX25ldGRldiBvcGVyYXRpb24gdG8gcHJldmVudCBVQUYuIFRoaXMgY29tbWl0IGltcHJvdmVzIHRoZSBwcmV2aW91cyBvbmUgYnkgYWxzbyBkZWZlcnJpbmcgdGhlIG51bGxpZnkgb2YgdGhlIGF4LSZndDt0dHkgcG9pbnRlci4gT3RoZXJ3aXNlLCBhIE5VTEwgcG9pbnRlciBkZXJlZmVyZW5jZSBidWcgb2NjdXJzLiBQYXJ0aWFsIG9mIHRoZSBzdGFjayB0cmFjZSBpcyBzaG93biBiZWxvdy4gQlVHOiBrZXJuZWwgTlVMTCBwb2ludGVyIGRlcmVmZXJlbmNlLCBhZGRyZXNzOiAwMDAwMDAwMDAwMDAwNTM4IFJJUDogMDAxMDpheF94bWl0KzB4MWY5LzB4NDAwIC4uLiBDYWxsIFRyYWNlOiBkZXZfaGFyZF9zdGFydF94bWl0KzB4ZWMvMHgzMjAgc2NoX2RpcmVjdF94bWl0KzB4ZWEvMHgyNDAgX19xZGlzY19ydW4rMHgxNjYvMHg1YzAgX19kZXZfcXVldWVfeG1pdCsweDJjNy8weGFmMCBheDI1X3N0ZF9lc3RhYmxpc2hfZGF0YV9saW5rKzB4NTkvMHg2MCBheDI1X2Nvbm5lY3QrMHgzYTAvMHg1MDAgPyBzZWN1cml0eV9zb2NrZXRfY29ubmVjdCsweDJiLzB4NDAgX19zeXNfY29ubmVjdCsweDk2LzB4YzAgPyBfX2hydGltZXJfaW5pdCsweGMwLzB4YzAgPyBjb21tb25fbnNsZWVwKzB4MmUvMHg1MCA/IHN3aXRjaF9mcHVfcmV0dXJuKzB4MTM5LzB4MWEwIF9feDY0X3N5c19jb25uZWN0KzB4MTEvMHgyMCBkb19zeXNjYWxsXzY0KzB4MzMvMHg0MCBlbnRyeV9TWVNDQUxMXzY0X2FmdGVyX2h3ZnJhbWUrMHg0NC8weGE5IFRoZSBjcmFzaCBwb2ludCBpcyBzaG93biBhcyBiZWxvdyBzdGF0aWMgdm9pZCBheF9lbmNhcHMoLi4uKSB7IC4uLiBzZXRfYml0KFRUWV9ET19XUklURV9XQUtFVVAsIGF4LSZndDt0dHktJmd0O2ZsYWdzKTsgLy8gYXgtJmd0O3R0eSA9IE5VTEwhIC4uLiB9IEJ5IHBsYWNpbmcgdGhlIG51bGxpZnkgYWN0aW9uIGFmdGVyIHRoZSB1bnJlZ2lzdGVyX25ldGRldiwgdGhlIGF4LSZndDt0dHkgcG9pbnRlciB3b24ndCBiZSBhc3NpZ25lZCBhcyBOVUxMIG5ldF9kZXZpY2UgZnJhbWV3b3JrIGxheWVyIGlzIHdlbGwgc3luY2hyb25pemVkLiBTaWduZWQtb2ZmLWJ5OiBMaW4gTWEgPGxpbm1hPiBTaWduZWQtb2ZmLWJ5OiBEYXZpZCBTLiBNaWxsZXIgPGRhdmVtPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGNiNmM5OWFlZGQyYzg0MzA1NmE1OThhODkwN2E2MTI4Y2IwNzYwM2IgQXV0aG9yOiBMaW4gTWEgPGxpbm1hPiBEYXRlOiBNb24gTm92IDggMTg6Mzc6MjEgMjAyMSArMDgwMCBoYW1yYWRpbzogZGVmZXIgYXgyNSBrZnJlZSBhZnRlciB1bnJlZ2lzdGVyX25ldGRldiBjb21taXQgM2UwNTg4YzI5MWQ2Y2UyMjVmMmI4OTE3NTNjYTQxZDQ1YmE0MjQ2OSB1cHN0cmVhbS4gVGhlcmUgaXMgYSBwb3NzaWJsZSByYWNlIGNvbmRpdGlvbiAodXNlLWFmdGVyLWZyZWUpIGxpa2UgYmVsb3cgKFVTRSkgfCAoRlJFRSkgYXgyNV9zZW5kbXNnIHwgYXgyNV9xdWV1ZV94bWl0IHwgZGV2X3F1ZXVlX3htaXQgfCBfX2Rldl9xdWV1ZV94bWl0IHwgX19kZXZfeG1pdF9za2IgfCBzY2hfZGlyZWN0X3htaXQgfCAuLi4geG1pdF9vbmUgfCBuZXRkZXZfc3RhcnRfeG1pdCB8IHR0eV9sZGlzY19raWxsIF9fbmV0ZGV2X3N0YXJ0X3htaXQgfCBta2lzc19jbG9zZSBheF94bWl0IHwga2ZyZWUgYXhfZW5jYXBzIHwgfCBFdmVuIHRob3VnaCB0aGVyZSBhcmUgdHdvIHN5bmNocm9uaXphdGlvbiBwcmltaXRpdmVzIGJlZm9yZSB0aGUga2ZyZWU6IDEuIHdhaXRfZm9yX2NvbXBsZXRpb24oYXgtJmd0O2RlYWQpLiBUaGlzIGNhbiBwcmV2ZW50IHRoZSByYWNlIHdpdGggcm91dGluZXMgZnJvbSBta2lzc19pb2N0bC4gSG93ZXZlciwgaXQgY2Fubm90IHN0b3AgdGhlIHJvdXRpbmUgY29taW5nIGZyb20gdXBwZXIgbGF5ZXIsIGkuZS4sIHRoZSBheDI1X3NlbmRtc2cuIDIuIG5ldGlmX3N0b3BfcXVldWUoYXgtJmd0O2RldikuIEl0IHNlZW1zIHRoYXQgdGhpcyBsaW5lIG9mIGNvZGUgYWltcyB0byBoYWx0IHRoZSB0cmFuc21pdCBxdWV1ZSBidXQgaXQgZmFpbHMgdG8gc3RvcCB0aGUgcm91dGluZSB0aGF0IGFscmVhZHkgYmVpbmcgeG1pdC4gVGhpcyBwYXRjaCByZW9yZGVyIHRoZSBrZnJlZSBhZnRlciB0aGUgdW5yZWdpc3Rlcl9uZXRkZXYgdG8gYXZvaWQgdGhlIHBvc3NpYmxlIFVBRiBhcyB0aGUgdW5yZWdpc3Rlcl9uZXRkZXYoKSBpcyB3ZWxsIHN5bmNocm9uaXplZCBhbmQgd29uJ3QgcmV0dXJuIGlmIHRoZXJlIGlzIGEgcnVubmluZyByb3V0aW5lLiBTaWduZWQtb2ZmLWJ5OiBMaW4gTWEgPGxpbm1hPiBTaWduZWQtb2ZmLWJ5OiBEYXZpZCBTLiBNaWxsZXIgPGRhdmVtPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGE4ZTRhNjRjZGM5NzdjZGEwMmQ3Yzk1Y2QwMTAwNGZkMzM5NzhhYjcgQXV0aG9yOiBMaW4gTWEgPGxpbm1hPiBEYXRlOiBGcmkgRGVjIDE3IDEwOjI5OjQxIDIwMjEgKzA4MDAgYXgyNTogTlBEIGJ1ZyB3aGVuIGRldGFjaGluZyBBWDI1IGRldmljZSBjb21taXQgMWFkZTQ4ZDBjMjdkNWRhMWNjZjRiNTgzZDhjNWZjOGI1MzRhM2FjOCB1cHN0cmVhbS4gVGhlIGV4aXN0aW5nIGNsZWFudXAgcm91dGluZSBpbXBsZW1lbnRhdGlvbiBpcyBub3Qgd2VsbCBzeW5jaHJvbml6ZWQgd2l0aCB0aGUgc3lzY2FsbCByb3V0aW5lLiBXaGVuIGEgZGV2aWNlIGlzIGRldGFjaGluZywgYmVsb3cgcmFjZSBjb3VsZCBvY2N1ci4gc3RhdGljIGludCBheDI1X3NlbmRtc2coLi4uKSB7IC4uLiBsb2NrX3NvY2soKSBheDI1ID0gc2tfdG9fYXgyNShzayk7IGlmIChheDI1LSZndDtheDI1X2RldiA9PSBOVUxMKSAvLyBDSEVDSyAuLi4gYXgyNV9xdWV1ZV94bWl0KHNrYiwgYXgyNS0mZ3Q7YXgyNV9kZXYtJmd0O2Rldik7IC8vIFVTRSAuLi4gfSBzdGF0aWMgdm9pZCBheDI1X2tpbGxfYnlfZGV2aWNlKC4uLikgeyAuLi4gaWYgKHMtJmd0O2F4MjVfZGV2ID09IGF4MjVfZGV2KSB7IHMtJmd0O2F4MjVfZGV2ID0gTlVMTDsgLi4uIH0gT3RoZXIgc3lzY2FsbCBmdW5jdGlvbnMgbGlrZSBheDI1X2dldHNvY2tvcHQsIGF4MjVfZ2V0bmFtZSwgYXgyNV9pbmZvX3Nob3cgYWxzbyBzdWZmZXIgZnJvbSBzaW1pbGFyIHJhY2VzLiBUbyBmaXggdGhlbSwgdGhpcyBwYXRjaCBpbnRyb2R1Y2UgbG9ja19zb2NrKCkgaW50byBheDI1X2tpbGxfYnlfZGV2aWNlIGluIG9yZGVyIHRvIGd1YXJhbnRlZSB0aGF0IHRoZSBudWxsaWZ5IGFjdGlvbiBpbiBjbGVhbnVwIHJvdXRpbmUgY2Fubm90IHByb2NlZWQgd2hlbiBhbm90aGVyIHNvY2tldCByZXF1ZXN0IGlzIHBlbmRpbmcuIFNpZ25lZC1vZmYtYnk6IEhhbmppZSBXdSA8bmFnaT4gU2lnbmVkLW9mZi1ieTogTGluIE1hIDxsaW5tYT4gU2lnbmVkLW9mZi1ieTogRGF2aWQgUy4gTWlsbGVyIDxkYXZlbT4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCBmNTQ3YjBmOGYzY2ViMWViNTQ0YjdkZjFkZjAxOTZjMGY4MzQ1ODBjIEF1dGhvcjogSGF5ZXMgV2FuZyA8aGF5ZXN3YW5nPiBEYXRlOiBUaHUgRGVjIDIzIDE3OjI3OjAyIDIwMjEgKzA4MDAgcjgxNTI6IHN5bmMgb2NwIGJhc2UgY29tbWl0IGIyNGVkY2EzMDk1MzVjMmQ5YWY4NmFhYjk1ZDY0MDY1ZjZlZjFkMjYgdXBzdHJlYW0uIFRoZXJlIGFyZSBzb21lIGNoYW5jZXMgdGhhdCB0aGUgYWN0dWFsIGJhc2Ugb2YgaGFyZHdhcmUgaXMgZGlmZmVyZW50IGZyb20gdGhlIHZhbHVlIHJlY29yZGVkIGJ5IGRyaXZlciwgc28gd2UgaGF2ZSB0byByZXNldCB0aGUgdmFyaWFibGUgb2Ygb2NwX2Jhc2UgdG8gc3luYyBpdC4gU2V0IG9jcF9iYXNlIHRvIC0xLiBUaGVuLCBpdCB3b3VsZCBiZSB1cGRhdGVkIGFuZCB0aGUgbmV3IGJhc2Ugd291bGQgYmUgc2V0IHRvIHRoZSBoYXJkd2FyZSBuZXh0IHRpbWUuIFNpZ25lZC1vZmYtYnk6IEhheWVzIFdhbmcgPGhheWVzd2FuZz4gU2lnbmVkLW9mZi1ieTogSmFrdWIgS2ljaW5za2kgPGt1YmE+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgNWNjODgxM2M0OTY2MjdiYWQzY2VmMDJmMmNkZmExYmE0M2EzYTFlOSBBdXRob3I6IEd1ZW50ZXIgUm9lY2sgPGxpbnV4PiBEYXRlOiBGcmkgRGVjIDMgMTM6NDI6MjIgMjAyMSAtMDgwMCBod21vbjogKGxtOTApIERvIG5vdCByZXBvcnQgJ2J1c3knIHN0YXR1cyBiaXQgYXMgYWxhcm0gY29tbWl0IGNkYzUyODdhY2FkOWVkZTEyMTkyNGE5YzkzMTM1NDRiODBkMTU4NDIgdXBzdHJlYW0uIEJpdCA3IG9mIHRoZSBzdGF0dXMgcmVnaXN0ZXIgaW5kaWNhdGVzIHRoYXQgdGhlIGNoaXAgaXMgYnVzeSBkb2luZyBhIGNvbnZlcnNpb24uIEl0IGRvZXMgbm90IGluZGljYXRlIGFuIGFsYXJtIHN0YXR1cy4gU3RvcCByZXBvcnRpbmcgaXQgYXMgYWxhcm0gc3RhdHVzIGJpdC4gU2lnbmVkLW9mZi1ieTogR3VlbnRlciBSb2VjayA8bGludXg+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgNzIyZmM0NWJlMDQ5ZThhYzE3MTJmY2M4YTI4MTI2NWRiOGU5ZTczNiBBdXRob3I6IEd1ZW50ZXIgUm9lY2sgPGxpbnV4PiBEYXRlOiBGcmkgTm92IDI2IDIyOjQzOjM5IDIwMjEgLTA4MDAgaHdtb206IChsbTkwKSBGaXggY2l0aWNhbCBhbGFybSBzdGF0dXMgZm9yIE1BWDY2ODAvTUFYNjY4MSBjb21taXQgZGE3ZGMwNTY4NDkxMTA0YzdhY2I2MzJlOWQ0MWRkY2U5YWFhYmJiMSB1cHN0cmVhbS4gVGVzdHMgd2l0aCBhIHJlYWwgY2hpcCBhbmQgYSBjbG9zZXIgbG9vayBpbnRvIHRoZSBkYXRhc2hlZXQgcmV2ZWFscyB0aGF0IHRoZSBsb2NhbCBhbmQgcmVtb3RlIGNyaXRpY2FsIGFsYXJtIHN0YXR1cyBiaXRzIGFyZSBzd2FwcGVkIGZvciBNQVg2NjgwL01BWDY2ODEuIFNpZ25lZC1vZmYtYnk6IEd1ZW50ZXIgUm9lY2sgPGxpbnV4PiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGZiNTYzYmFhM2ViOGU3YTE1ZjJjZmYzYzI2OTVlMmNjYTA0OTNlNjkgQXV0aG9yOiBHdW9kb25nIExpdSA8Z3VvZG9uZy5saXU+IERhdGU6IFdlZCBOb3YgMTAgMTU6MTk6MDAgMjAyMSArMDgwMCBwaW5jdHJsOiBtZWRpYXRlazogZml4IGdsb2JhbC1vdXQtb2YtYm91bmRzIGlzc3VlIGNvbW1pdCAyZDU0NDZkYTVhY2VjZjljNjdkYjFjOWQ1NWFlMmMzZTVkZTAxZjhkIHVwc3RyZWFtLiBXaGVuIGVpbnQgdmlydHVhbCBlaW50IG51bWJlciBpcyBncmVhdGVyIHRoYW4gZ3BpbyBudW1iZXIsIGl0IG1heWJlIHByb2R1Y2UgJ2Rlc2NbZWludF9uXScgc2l6ZSBnbG9ibGUtb3V0LW9mLWJvdW5kcyBpc3N1ZS4gU2lnbmVkLW9mZi1ieTogR3VvZG9uZyBMaXUgPGd1b2RvbmcubGl1PiBTaWduZWQtb2ZmLWJ5OiBaaGl5b25nIFRhbyA8emhpeW9uZy50YW8+IFJldmlld2VkLWJ5OiBDaGVuLVl1IFRzYWkgPHdlbnN0PiBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMTEwMDcxOTAwLjQ0OTAtMi16aGl5b25nLnRhb0BtZWRpYXRlay5jb20gU2lnbmVkLW9mZi1ieTogTGludXMgV2FsbGVpaiA8bGludXMud2FsbGVpaj4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCBhYTUwNDA2ZjM2YTE2MzY3NjkyMmI4ZWRjYmIyZGFjOTM1ZTMyOGVkIEF1dGhvcjogRGVyZWsgRmFuZyA8ZGVyZWsuZmFuZz4gRGF0ZTogVHVlIERlYyAxNCAxODo1MDozMyAyMDIxICswODAwIEFTb0M6IHJ0NTY4MjogZml4IHRoZSB3cm9uZyBqYWNrIHR5cGUgZGV0ZWN0ZWQgY29tbWl0IDhkZWIzNGE5MGYwNjM3NGZkMjZmNzIyYzJhNzllMTUxNjBmNjZiZTcgdXBzdHJlYW0uIFNvbWUgcG93ZXJzIHdlcmUgY2hhbmdlZCBkdXJpbmcgdGhlIGphY2sgaW5zZXJ0IGRldGVjdGlvbiBhbmQgY2xrJ3MgZW5hYmxlL2Rpc2FibGUgaW4gQ0NGLiBJZiBpbiBwYXJhbGxlbCwgdGhlIGluZmx1ZW5jZSBoYXMgYSBjaGFuY2UgdG8gZGV0ZWN0IHRoZSB3cm9uZyBqYWNrIHR5cGUsIHNvIGFkZCBhIGxvY2suIFNpZ25lZC1vZmYtYnk6IERlcmVrIEZhbmcgPGRlcmVrLmZhbmc+IExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMjAyMTEyMTQxMDUwMzMuNDcxLTEtZGVyZWsuZmFuZ0ByZWFsdGVrLmNvbSBTaWduZWQtb2ZmLWJ5OiBNYXJrIEJyb3duIFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgNDZiM2ZlMWViMmI3M2Q1NjU4ZDkxOWM2YTMyNWU1ODAyMzAyODBkMiBBdXRob3I6IEthaSBWZWhtYW5lbiA8a2FpLnZlaG1hbmVuPiBEYXRlOiBGcmkgRGVjIDMgMTk6MTU6NDEgMjAyMSArMDIwMCBBU29DOiBTT0Y6IEludGVsOiBwY2ktdGdsOiBhZGQgQURMLU4gc3VwcG9ydCBjb21taXQgY2Q1N2ViM2M0MDNjYjg2NGU1NTU4ODc0ZWNkNTdkZDk1NGE1YTdmNyB1cHN0cmVhbS4gQWRkIFBDSSBESUQgZm9yIEludGVsIEFsZGVyTGFrZS1OLiBTaWduZWQtb2ZmLWJ5OiBLYWkgVmVobWFuZW4gPGthaS52ZWhtYW5lbj4gUmV2aWV3ZWQtYnk6IFBpZXJyZS1Mb3VpcyBCb3NzYXJ0IDxwaWVycmUtbG91aXMuYm9zc2FydD4gTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8yMDIxMTIwMzE3MTU0Mi4xMDIxMzk5LTEta2FpLnZlaG1hbmVuQGxpbnV4LmludGVsLmNvbSBTaWduZWQtb2ZmLWJ5OiBNYXJrIEJyb3duIFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgZDBmYThjMjUyOTU2ZGY5ZDIzZmNhMDAxZGQ2YTQ5M2Q4MzUzOTI4ZCBBdXRob3I6IEthaSBWZWhtYW5lbiA8a2FpLnZlaG1hbmVuPiBEYXRlOiBGcmkgRGVjIDMgMTk6MTU6NDIgMjAyMSArMDIwMCBBU29DOiBTT0Y6IEludGVsOiBwY2ktdGdsOiBhZGQgbmV3IEFETC1QIHZhcmlhbnQgY29tbWl0IGRlN2RkOTA5MmNkMzgzODRmNzc0ZDM0NWNjY2FmZTgxYjRiODY2YjAgdXBzdHJlYW0uIEFkZCBhIFBDSSBESUQgZm9yIGEgdmFyaWFudCBvZiBJbnRlbCBBbGRlckxha2UtUC4gU2lnbmVkLW9mZi1ieTogS2FpIFZlaG1hbmVuIDxrYWkudmVobWFuZW4+IFJldmlld2VkLWJ5OiBQaWVycmUtTG91aXMgQm9zc2FydCA8cGllcnJlLWxvdWlzLmJvc3NhcnQ+IExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMjAyMTEyMDMxNzE1NDIuMTAyMTM5OS0yLWthaS52ZWhtYW5lbkBsaW51eC5pbnRlbC5jb20gU2lnbmVkLW9mZi1ieTogTWFyayBCcm93biBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGQ5YWQwYWU4YmZhMDZlNmI4NmE2Y2VlODYzZjVkMDMxNjIyYzkwNTIgQXV0aG9yOiBNYXJ0aW4gUG92acWhZXIgPHBvdmlrPiBEYXRlOiBNb24gRGVjIDYgMjI6NDU6NDMgMjAyMSArMDAwMCBBU29DOiB0YXMyNzcwOiBGaXggc2V0dGluZyBvZiBoaWdoIHNhbXBsZSByYXRlcyBjb21taXQgODBkNWJlMWEwNTdlMDVmMDFkNjZlOTg2Y2ZkMzRkNzE4NDVlNTE5MCB1cHN0cmVhbS4gQWx0aG91Z2ggdGhlIGNvZGVjIGFkdmVydGlzZXMgc3VwcG9ydCBmb3IgMTc2LjQgYW5kIDE5MiBrc3BzLCB3aXRob3V0IHRoaXMgZml4IHNldHRpbmcgdGhvc2Ugc2FtcGxlIHJhdGVzIGZhaWxzIHdpdGggRUlOVkFMIGF0IGh3X3BhcmFtcyB0aW1lLiBTaWduZWQtb2ZmLWJ5OiBNYXJ0aW4gUG92acWhZXIgPHBvdmlrPiBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMjA2MjI0NTI5Ljc0NjU2LTEtcG92aWtAcHJvdG9ubWFpbC5jb20gU2lnbmVkLW9mZi1ieTogTWFyayBCcm93biBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGNjNzFhNzIzZjNkODhjNTU0NjAxNDRjMjA0YTFjNjczNjFjMzIzYzAgQXV0aG9yOiBIYW5zIGRlIEdvZWRlIDxoZGVnb2VkZT4gRGF0ZTogTW9uIERlYyA2IDIzOjI5OjI3IDIwMjEgLTA4MDAgSW5wdXQ6IGdvb2RpeCAtIGFkZCBpZC0mZ3Q7bW9kZWwgbWFwcGluZyBmb3IgdGhlICI5MTExIiBtb2RlbCBjb21taXQgODFlODE4ODY5YmU1MjJiYzhmYTZmN2RmMWI5MmQ3ZTc2NTM3OTI2YyB1cHN0cmVhbS4gQWRkIGQtJmd0O21vZGVsIG1hcHBpbmcgZm9yIHRoZSAiOTExMSIgbW9kZWwsIHRoaXMgZml4ZXMgdXNlcyB1c2luZyBhIHdyb25nIGNvbmZpZ19sZW4gb2YgMjQwIGJ5dGVzIHdoaWxlIHRoZSAiOTExMSIgbW9kZWwgdXNlcyBvbmx5IDE4NiBieXRlcyBvZiBjb25maWcuIFNpZ25lZC1vZmYtYnk6IEhhbnMgZGUgR29lZGUgPGhkZWdvZWRlPiBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMjA2MTY0NzQ3LjE5NzMwOS0yLWhkZWdvZWRlQHJlZGhhdC5jb20gU2lnbmVkLW9mZi1ieTogRG1pdHJ5IFRvcm9raG92IDxkbWl0cnkudG9yb2tob3Y+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgZWZhYTMyN2I0MTQ2MmY3ODk4ZjZhMDU3N2Y5Zjk0YWYyOGRiYmFhMyBBdXRob3I6IEpvaG5ueSBDaHVhbmcgPGpvaG5ueS5jaHVhbmcuZW1jPiBEYXRlOiBNb24gRGVjIDIwIDAwOjI4OjQ1IDIwMjEgLTA4MDAgSW5wdXQ6IGVsYW50c19pMmMgLSBkbyBub3QgY2hlY2sgUmVtYXJrIElEIG9uIGVLVEgzOTAwL2VLVEg1MzEyIGNvbW1pdCA0ZWJmZWUyYmJjMWE5YzM0M2RkNTA1NjViYTVhZTI0OWZhYzMyMjY3IHVwc3RyZWFtLiBUaGUgZUtUSDM5MDAvZUtUSDUzMTIgc2VyaWVzIGRvIG5vdCBzdXBwb3J0IHRoZSBmaXJtd2FyZSB1cGRhdGUgcnVsZXMgb2YgUmVtYXJrIElELiBFeGNsdWRlIHRoZXNlIHR3byBzZXJpZXMgZnJvbSBjaGVja2luZyBpdCB3aGVuIHVwZGF0aW5nIHRoZSBmaXJtd2FyZSBpbiB0b3VjaCBjb250cm9sbGVycy4gU2lnbmVkLW9mZi1ieTogSm9obm55IENodWFuZyA8am9obm55LmNodWFuZy5lbWM+IExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMTYzOTYxOTYwMy0yMDYxNi0xLWdpdC1zZW5kLWVtYWlsLWpvaG5ueS5jaHVhbmcuZW1jQGdtYWlsLmNvbSBTaWduZWQtb2ZmLWJ5OiBEbWl0cnkgVG9yb2tob3YgPGRtaXRyeS50b3Jva2hvdj4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCA3MDc1MDA1NjYyMGIyNDFkZWUzYmY4ZjJlMGY1NmJkZjYzYmI0YWNhIEF1dGhvcjogSmVmZiBMYUJ1bmR5IDxqZWZmPiBEYXRlOiBTdW4gTm92IDI4IDIzOjQxOjQyIDIwMjEgLTA4MDAgSW5wdXQ6IGlxczYyNmEgLSBwcm9oaWJpdCBpbmxpbmluZyBvZiBjaGFubmVsIHBhcnNpbmcgZnVuY3Rpb25zIGNvbW1pdCBlMWY1ZTg0ODIwOWExYjUxY2NhZTUwNzIxYjI3Njg0YzZmOWQ5NzhmIHVwc3RyZWFtLiBTb21lIGF1dG9tYXRlZCBidWlsZHMgcmVwb3J0IGEgc3RhY2sgZnJhbWUgc2l6ZSBpbiBleGNlc3Mgb2YgMiBrQiBmb3IgaXFzNjI2X3Byb2JlKCk7IHRoZSBjdWxwcml0IGFwcGVhcnMgdG8gYmUgdGhlIGNhbGwgdG8gaXFzNjI2X3BhcnNlX3Byb3AoKS4gVG8gc29sdmUgdGhpcyBwcm9ibGVtLCBzcGVjaWZ5IG5vaW5saW5lX2Zvcl9zdGFjayBmb3IgYWxsIG9mIHRoZSBpcXM2MjZfcGFyc2VfKigpIGhlbHBlciBmdW5jdGlvbnMgd2hpY2ggYXJlIGNhbGxlZCBpbnNpZGUgYSBmb3IgbG9vcCB3aXRoaW4gaXFzNjI2X3BhcnNlX3Byb3AoKS4gQXMgYSByZXN1bHQsIGEgYnVpbGQgd2l0aCAnLVdmcmFtZS1sYXJnZXItdGhhbicgYXMgbG93IGFzIDUxMiBpcyBmcmVlIG9mIGFueSBzdWNoIHdhcm5pbmdzLiBSZXBvcnRlZC1ieToga2VybmVsIHRlc3Qgcm9ib3QgPGxrcD4gU2lnbmVkLW9mZi1ieTogSmVmZiBMYUJ1bmR5IDxqZWZmPiBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMTI5MDA0MTA0LjQ1MzkzMC0xLWplZmZAbGFidW5keS5jb20gU2lnbmVkLW9mZi1ieTogRG1pdHJ5IFRvcm9raG92IDxkbWl0cnkudG9yb2tob3Y+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgMmYwNmM4MjkzZDI3ZjYzMzdmOTA3MDQyYzYwMmM5Yzk1Mzk4OGM0OCBBdXRob3I6IEJhb2t1biBMaSA8bGliYW9rdW4xPiBEYXRlOiBGcmkgRGVjIDI0IDIxOjEyOjMyIDIwMjEgLTA4MDAga2ZlbmNlOiBmaXggbWVtb3J5IGxlYWsgd2hlbiBjYXQga2ZlbmNlIG9iamVjdHMgY29tbWl0IDAxMjlhYjFmMjY4YjZjZjg4ODI1ZWFlODE5YjliODRhYTBhODU2MzQgdXBzdHJlYW0uIEh1bGsgcm9ib3QgcmVwb3J0ZWQgYSBrbWVtbGVhayBwcm9ibGVtOiB1bnJlZmVyZW5jZWQgb2JqZWN0IDB4ZmZmZjkzZDFkOGNjMDJlOCAoc2l6ZSAyNDgpOiBjb21tICJjYXQiLCBwaWQgMjMzMjcsIGppZmZpZXMgNDYyNDY3MDE0MSAoYWdlIDQ5NTk5Mi4yMTdzKSBoZXggZHVtcCAoZmlyc3QgMzIgYnl0ZXMpOiAwMCA0MCA4NSAxOSBkNCA5MyBmZiBmZiAwMCAxMCAwMCAwMCAwMCAwMCAwMCAwMCAuQC4uLi4uLi4uLi4uLi4uIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIC4uLi4uLi4uLi4uLi4uLi4gYmFja3RyYWNlOiBzZXFfb3BlbisweDJhLzB4ODAgZnVsbF9wcm94eV9vcGVuKzB4MTY3LzB4MWUwIGRvX2RlbnRyeV9vcGVuKzB4MWUxLzB4M2EwIHBhdGhfb3BlbmF0KzB4OTYxLzB4YTIwIGRvX2ZpbHBfb3BlbisweGFlLzB4MTIwIGRvX3N5c19vcGVuYXQyKzB4MjE2LzB4MmYwIGRvX3N5c19vcGVuKzB4NTcvMHg4MCBkb19zeXNjYWxsXzY0KzB4MzMvMHg0MCBlbnRyeV9TWVNDQUxMXzY0X2FmdGVyX2h3ZnJhbWUrMHg0NC8weGE5IHVucmVmZXJlbmNlZCBvYmplY3QgMHhmZmZmOTNkNDE5ODU0MDAwIChzaXplIDQwOTYpOiBjb21tICJjYXQiLCBwaWQgMjMzMjcsIGppZmZpZXMgNDYyNDY3MDE0MSAoYWdlIDQ5NTk5Mi4yMTdzKSBoZXggZHVtcCAoZmlyc3QgMzIgYnl0ZXMpOiA2YiA2NiA2NSA2ZSA2MyA2NSAyZCAyMyAzMiAzNSAzMCAzYSAyMCAzMCA3OCAzMCBrZmVuY2UtIzI1MDogMHgwIDMwIDMwIDMwIDMwIDMwIDMwIDMwIDM3IDM1IDM0IDYyIDY0IDYxIDMxIDMyIDJkIDAwMDAwMDA3NTRiZGExMi0gYmFja3RyYWNlOiBzZXFfcmVhZF9pdGVyKzB4MzEzLzB4NDQwIHNlcV9yZWFkKzB4MTRiLzB4MWEwIGZ1bGxfcHJveHlfcmVhZCsweDU2LzB4ODAgdmZzX3JlYWQrMHhhNS8weDFiMCBrc3lzX3JlYWQrMHhhMC8weGYwIGRvX3N5c2NhbGxfNjQrMHgzMy8weDQwIGVudHJ5X1NZU0NBTExfNjRfYWZ0ZXJfaHdmcmFtZSsweDQ0LzB4YTkgSSBmaW5kIHRoYXQgd2UgY2FuIGVhc2lseSByZXByb2R1Y2UgdGhpcyBwcm9ibGVtIHdpdGggdGhlIGZvbGxvd2luZyBjb21tYW5kczogY2F0IC9zeXMva2VybmVsL2RlYnVnL2tmZW5jZS9vYmplY3RzIGVjaG8gc2NhbiAmZ3Q7IC9zeXMva2VybmVsL2RlYnVnL2ttZW1sZWFrIGNhdCAvc3lzL2tlcm5lbC9kZWJ1Zy9rbWVtbGVhayBUaGUgbGVha2VkIG1lbW9yeSBpcyBhbGxvY2F0ZWQgaW4gdGhlIHN0YWNrIGJlbG93OiBkb19zeXNjYWxsXzY0IGRvX3N5c19vcGVuIGRvX2RlbnRyeV9vcGVuIGZ1bGxfcHJveHlfb3BlbiBzZXFfb3BlbiAtLS0mZ3Q7IGFsbG9jIHNlcV9maWxlIHZmc19yZWFkIGZ1bGxfcHJveHlfcmVhZCBzZXFfcmVhZCBzZXFfcmVhZF9pdGVyIHRyYXZlcnNlIC0tLSZndDsgYWxsb2Mgc2VxX2J1ZiBBbmQgaXQgc2hvdWxkIGhhdmUgYmVlbiByZWxlYXNlZCBpbiB0aGUgZm9sbG93aW5nIHByb2Nlc3M6IGRvX3N5c2NhbGxfNjQgc3lzY2FsbF9leGl0X3RvX3VzZXJfbW9kZSBleGl0X3RvX3VzZXJfbW9kZV9wcmVwYXJlIHRhc2tfd29ya19ydW4gX19fX2ZwdXQgX19mcHV0IGZ1bGxfcHJveHlfcmVsZWFzZSAtLS0mZ3Q7IGZyZWUgaGVyZSBIb3dldmVyLCB0aGUgcmVsZWFzZSBmdW5jdGlvbiBjb3JyZXNwb25kaW5nIHRvIGZpbGVfb3BlcmF0aW9ucyBpcyBub3QgaW1wbGVtZW50ZWQgaW4ga2ZlbmNlLiBBcyBhIHJlc3VsdCwgYSBtZW1vcnkgbGVhayBvY2N1cnMuIFRoZXJlZm9yZSwgdGhlIHNvbHV0aW9uIHRvIHRoaXMgcHJvYmxlbSBpcyB0byBpbXBsZW1lbnQgdGhlIGNvcnJlc3BvbmRpbmcgcmVsZWFzZSBmdW5jdGlvbi4gTGluazogaHR0cHM6Ly9sa21sLmtlcm5lbC5vcmcvci8yMDIxMTIwNjEzMzYyOC4yODIyNTQ1LTEtbGliYW9rdW4xQGh1YXdlaS5jb20gRml4ZXM6IDBjZTIwZGQ4NDA4OSAoIm1tOiBhZGQgS2VybmVsIEVsZWN0cmljLUZlbmNlIGluZnJhc3RydWN0dXJlIikgU2lnbmVkLW9mZi1ieTogQmFva3VuIExpIDxsaWJhb2t1bjE+IFJlcG9ydGVkLWJ5OiBIdWxrIFJvYm90IDxodWxrY2k+IEFja2VkLWJ5OiBNYXJjbyBFbHZlciA8ZWx2ZXI+IFJldmlld2VkLWJ5OiBLZWZlbmcgV2FuZyA8d2FuZ2tlZmVuZy53YW5nPiBDYzogQWxleGFuZGVyIFBvdGFwZW5rbyA8Z2xpZGVyPiBDYzogRG1pdHJ5IFZ5dWtvdiA8ZHZ5dWtvdj4gQ2M6IFl1IEt1YWkgPHl1a3VhaTM+IFNpZ25lZC1vZmYtYnk6IEFuZHJldyBNb3J0b24gPGFrcG0+IFNpZ25lZC1vZmYtYnk6IExpbnVzIFRvcnZhbGRzIDx0b3J2YWxkcz4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCBjYTM4ODMzYzkxNWVhMWRhODU1NjhhMDJkOTVkNjBjZTQwNTdhMmE5IEF1dGhvcjogWmhhbmcgWWluZy0yMjQ1NSA8eWluZy56aGFuZzIyNDU1PiBEYXRlOiBUdWUgRGVjIDE0IDAxOjIzOjMzIDIwMjEgLTA2MDAgYXJtNjQ6IGR0czogbHgyMTYwYTogZml4IHNjbC1ncGlvcyBwcm9wZXJ0eSBuYW1lIGNvbW1pdCA4NDllMDg3YmE2OGFjNjk1NmMxMTAxNmNlMzRmOWYxMGEwOWE0MTg2IHVwc3RyZWFtLiBGaXggdGhlIHR5cG8gaW4gdGhlIHByb3BlcnR5IG5hbWUuIEZpeGVzOiBkNTQ4YzIxN2M2YTNjICgiYXJtNjQ6IGR0czogYWRkIFFvcklRIExYMjE2MEEgU29DIHN1cHBvcnQiKSBTaWduZWQtb2ZmLWJ5OiBaaGFuZyBZaW5nIDx5aW5nLnpoYW5nMjI0NTU+IFNpZ25lZC1vZmYtYnk6IExpIFlhbmcgPGxlb3lhbmcubGk+IFNpZ25lZC1vZmYtYnk6IFNoYXduIEd1byA8c2hhd25ndW8+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgMGFlNTE5ZWNiYmRiMjQzYWFlMTI2MmY0OTFlNTNiNGFlZGEzZjI4ZCBBdXRob3I6IFNlYW4gQ2hyaXN0b3BoZXJzb24gPHNlYW5qYz4gRGF0ZTogVHVlIERlYyA3IDE5OjMwOjA1IDIwMjEgKzAwMDAgS1ZNOiBWTVg6IEZpeCBzdGFsZSBkb2NzIGZvciBrdm0taW50ZWwuZW11bGF0ZV9pbnZhbGlkX2d1ZXN0X3N0YXRlIGNvbW1pdCAwZmYyOTcwMWZmYWQ5YTVkNWEyNDM0NGQ4YjA5ZjNhZjdiOTZmZmRhIHVwc3RyZWFtLiBVcGRhdGUgdGhlIGRvY3VtZW50YXRpb24gZm9yIGt2bS1pbnRlbCdzIGVtdWxhdGVfaW52YWxpZF9ndWVzdF9zdGF0ZSB0byByZWN0aWZ5IHRoZSBkZXNjcmlwdGlvbiBvZiBLVk0ncyBkZWZhdWx0IGJlaGF2aW9yLCBhbmQgdG8gZG9jdW1lbnQgdGhhdCB0aGUgYmVoYXZpb3IgYW5kIHRodXMgcGFyYW1ldGVyIG9ubHkgYXBwbGllcyB0byBMMS4gRml4ZXM6IGEyNzY4NWMzM2FjYyAoIktWTTogVk1YOiBFbXVsYXRlIGludmFsaWQgZ3Vlc3Qgc3RhdGUgYnkgZGVmYXVsdCIpIFNpZ25lZC1vZmYtYnk6IFNlYW4gQ2hyaXN0b3BoZXJzb24gPHNlYW5qYz4gTWVzc2FnZS1JZDogJmx0OzIwMjExMjA3MTkzMDA2LjEyMDk5Ny00LXNlYW5qY0Bnb29nbGUuY29tJmd0OyBSZXZpZXdlZC1ieTogTWF4aW0gTGV2aXRza3kgPG1sZXZpdHNrPiBTaWduZWQtb2ZmLWJ5OiBQYW9sbyBCb256aW5pIDxwYm9uemluaT4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCAzNWY5ZmY0NWVlNWM5MTE5OTYxODU3NThhZTk1OTM3YWYzNTQ3MWZmIEF1dGhvcjogSmVmZmxlIFh1IDxqZWZmbGV4dT4gRGF0ZTogVHVlIERlYyA3IDExOjE0OjQ5IDIwMjEgKzA4MDAgbmV0ZnM6IGZpeCBwYXJhbWV0ZXIgb2YgY2xlYW51cCgpIGNvbW1pdCAzY2ZlZjFiNjEyZTE1YTBjMmY1YjFjOWQzZjNmMzFhZDcyZDU2ZmNkIHVwc3RyZWFtLiBUaGUgb3JkZXIgb2YgdGhlc2UgdHdvIHBhcmFtZXRlcnMgaXMganVzdCByZXZlcnNlZC4gZ2NjIGRpZG4ndCB3YXJuIG9uIHRoYXQsIHByb2JhYmx5IGJlY2F1c2UgJ3ZvaWQgKicgY2FuIGJlIGNvbnZlcnRlZCBmcm9tIG9yIHRvIG90aGVyIHBvaW50ZXIgdHlwZXMgd2l0aG91dCB3YXJuaW5nLiBDYzogc3RhYmxlQHZnZXIua2VybmVsLm9yZyBGaXhlczogM2QzYzk1MDQ2NzQyICgibmV0ZnM6IFByb3ZpZGUgcmVhZGFoZWFkIGFuZCByZWFkcGFnZSBuZXRmcyBoZWxwZXJzIikgRml4ZXM6IGUxYjEyNDBjMWZmNSAoIm5ldGZzOiBBZGQgd3JpdGVfYmVnaW4gaGVscGVyIikgU2lnbmVkLW9mZi1ieTogSmVmZmxlIFh1IDxqZWZmbGV4dT4gU2lnbmVkLW9mZi1ieTogRGF2aWQgSG93ZWxscyA8ZGhvd2VsbHM+IFJldmlld2VkLWJ5OiBKZWZmIExheXRvbiA8amxheXRvbj4gTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8yMDIxMTIwNzAzMTQ0OS4xMDA1MTAtMS1qZWZmbGV4dUBsaW51eC5hbGliYWJhLmNvbS8gIyB2MSBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGE4YTlkNzUzZWRkN2Y3MWU2YTJlZGFhNTgwZDgxODI1MzBiNjg3OTEgQXV0aG9yOiBDaGFvIFl1IDxjaGFvPiBEYXRlOiBTdW4gRGVjIDEyIDE3OjE2OjMwIDIwMjEgKzA4MDAgZjJmczogZml4IHRvIGRvIHNhbml0eSBjaGVjayBvbiBsYXN0IHhhdHRyIGVudHJ5IGluIF9fZjJmc19zZXR4YXR0cigpIGNvbW1pdCA1NTk4YjI0ZWZhZjQ4OTI3NDFjNzk4YjQyNWQ1NDNlNGJlZDM1N2ExIHVwc3RyZWFtLiBBcyBXZW5xaW5nIExpdSByZXBvcnRlZCBpbiBidWd6aWxsYTogaHR0cHM6Ly9idWd6aWxsYS5rZXJuZWwub3JnL3Nob3dfYnVnLmNnaT9pZD0yMTUyMzUgLSBPdmVydmlldyBwYWdlIGZhdWx0IGluIGYyZnNfc2V0eGF0dHIoKSB3aGVuIG1vdW50IGFuZCBvcGVyYXRlIG9uIGNvcnJ1cHRlZCBpbWFnZSAtIFJlcHJvZHVjZSB0ZXN0ZWQgb24ga2VybmVsIDUuMTYtcmMzLCA1LjE1LlggdW5kZXIgcm9vdCAxLiB1bnppcCB0bXA3LnppcCAyLiAuL3NpbmdsZS5zaCBmMmZzIDcgU29tZXRpbWVzIG5lZWQgdG8gcnVuIHRoZSBzY3JpcHQgc2V2ZXJhbCB0aW1lcyAtIEtlcm5lbCBkdW1wIGxvb3AwOiBkZXRlY3RlZCBjYXBhY2l0eSBjaGFuZ2UgZnJvbSAwIHRvIDEzMTA3MiBGMkZTLWZzIChsb29wMCk6IEZvdW5kIG5hdF9iaXRzIGluIGNoZWNrcG9pbnQgRjJGUy1mcyAobG9vcDApOiBNb3VudGVkIHdpdGggY2hlY2twb2ludCB2ZXJzaW9uID0gNzU0OGMyZWUgQlVHOiB1bmFibGUgdG8gaGFuZGxlIHBhZ2UgZmF1bHQgZm9yIGFkZHJlc3M6IGZmZmZlNDdiYzcxMjNmNDggUklQOiAwMDEwOmtmcmVlKzB4NjYvMHgzMjAgQ2FsbCBUcmFjZTogX19mMmZzX3NldHhhdHRyKzB4MmFhLzB4YzAwIFtmMmZzXSBmMmZzX3NldHhhdHRyKzB4ZmEvMHg0ODAgW2YyZnNdIF9fZjJmc19zZXRfYWNsKzB4MTliLzB4MzMwIFtmMmZzXSBfX3Zmc19yZW1vdmV4YXR0cisweDUyLzB4NzAgX192ZnNfcmVtb3ZleGF0dHJfbG9ja2VkKzB4YjEvMHgxNDAgdmZzX3JlbW92ZXhhdHRyKzB4NTYvMHgxMDAgcmVtb3ZleGF0dHIrMHg1Ny8weDgwIHBhdGhfcmVtb3ZleGF0dHIrMHhhMy8weGMwIF9feDY0X3N5c19yZW1vdmV4YXR0cisweDE3LzB4MjAgZG9fc3lzY2FsbF82NCsweDM3LzB4YjAgZW50cnlfU1lTQ0FMTF82NF9hZnRlcl9od2ZyYW1lKzB4NDQvMHhhZSBUaGUgcm9vdCBjYXVzZSBpcyBpbiBfX2YyZnNfc2V0eGF0dHIoKSwgd2UgbWlzc2VkIHRvIGRvIHNhbml0eSBjaGVjayBvbiBsYXN0IHhhdHRyIGVudHJ5LCByZXN1bHQgaW4gb3V0LW9mLWJvdW5kIG1lbW9yeSBhY2Nlc3MgZHVyaW5nIHVwZGF0aW5nIGluY29uc2lzdGVudCB4YXR0ciBkYXRhIG9mIHRhcmdldCBpbm9kZS4gQWZ0ZXIgdGhlIGZpeCwgaXQgY2FuIGRldGVjdCBzdWNoIHhhdHRyIGluY29uc2lzdGVuY3kgYXMgYmVsb3c6IEYyRlMtZnMgKGxvb3AxMSk6IGlub2RlICg3KSBoYXMgaW52YWxpZCBsYXN0IHhhdHRyIGVudHJ5LCBlbnRyeV9zaXplOiA2MDY3NiBGMkZTLWZzIChsb29wMTEpOiBpbm9kZSAoOCkgaGFzIGNvcnJ1cHRlZCB4YXR0ciBGMkZTLWZzIChsb29wMTEpOiBpbm9kZSAoOCkgaGFzIGNvcnJ1cHRlZCB4YXR0ciBGMkZTLWZzIChsb29wMTEpOiBpbm9kZSAoOCkgaGFzIGludmFsaWQgbGFzdCB4YXR0ciBlbnRyeSwgZW50cnlfc2l6ZTogNDc3MzYgQ2M6IHN0YWJsZUB2Z2VyLmtlcm5lbC5vcmcgUmVwb3J0ZWQtYnk6IFdlbnFpbmcgTGl1IDx3ZW5xaW5nbGl1MDEyMD4gU2lnbmVkLW9mZi1ieTogQ2hhbyBZdSA8Y2hhbz4gU2lnbmVkLW9mZi1ieTogSmFlZ2V1ayBLaW0gPGphZWdldWs+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgOTFlOTRlNDJmNmZjNDk2MzVmMWExNmQ4YWUzZjc5NTUyYmNmZGEyOSBBdXRob3I6IFN1bWl0IEdhcmcgPHN1bWl0Lmdhcmc+IERhdGU6IFRodSBEZWMgMTYgMTE6MTc6MjUgMjAyMSArMDUzMCB0ZWU6IG9wdGVlOiBGaXggaW5jb3JyZWN0IHBhZ2UgZnJlZSBidWcgY29tbWl0IDE4NTQ5YmY0YjIxYzczOWE5ZGVmMzlmMjdkY2FjNTNlMjcyODZhYjUgdXBzdHJlYW0uIFBvaW50ZXIgdG8gdGhlIGFsbG9jYXRlZCBwYWdlcyAoc3RydWN0IHBhZ2UgKnBhZ2UpIGhhcyBhbHJlYWR5IHByb2dyZXNzZWQgdG93YXJkcyB0aGUgZW5kIG9mIGFsbG9jYXRpb24uIEl0IGlzIGluY29ycmVjdCB0byBwZXJmb3JtIF9fZnJlZV9wYWdlcyhwYWdlLCBvcmRlcikgdXNpbmcgdGhpcyBwb2ludGVyIGFzIHdlIHdvdWxkIGZyZWUgYW55IGFyYml0cmFyeSBwYWdlcy4gRml4IHRoaXMgYnkgc3RvcCBtb2RpZnlpbmcgdGhlIHBhZ2UgcG9pbnRlci4gRml4ZXM6IGVjMTg1ZGQzYWIyNSAoIm9wdGVlOiBGaXggbWVtb3J5IGxlYWsgd2hlbiBmYWlsaW5nIHRvIHJlZ2lzdGVyIHNobSBwYWdlcyIpIENjOiBzdGFibGVAdmdlci5rZXJuZWwub3JnIFJlcG9ydGVkLWJ5OiBQYXRyaWsgTGFudHogPHBhdHJpay5sYW50ej4gU2lnbmVkLW9mZi1ieTogU3VtaXQgR2FyZyA8c3VtaXQuZ2FyZz4gUmV2aWV3ZWQtYnk6IFR5bGVyIEhpY2tzIDx0eWhpY2tzPiBTaWduZWQtb2ZmLWJ5OiBKZW5zIFdpa2xhbmRlciA8amVucy53aWtsYW5kZXI+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgMzMwYzYxMTdhODJjMTZhOWEzNjVhNTFjZWM1YzlhYjMwYjEzMjQ1YyBBdXRob3I6IFNlb25nSmFlIFBhcmsgPHNqPiBEYXRlOiBGcmkgRGVjIDI0IDIxOjEyOjU0IDIwMjEgLTA4MDAgbW0vZGFtb24vZGJnZnM6IHByb3RlY3QgdGFyZ2V0cyBkZXN0cnVjdGlvbnMgd2l0aCBrZGFtb25kX2xvY2sgY29tbWl0IDM0Nzk2NDE3OTY0YjhkMGFlZjQ1YTk5Y2Y2YzJkMjBjZWJlMzM3MzMgdXBzdHJlYW0uIERBTU9OIGRlYnVnZnMgaW50ZXJmYWNlIGl0ZXJhdGVzIGN1cnJlbnQgbW9uaXRvcmluZyB0YXJnZXRzIGluICdkYmdmc190YXJnZXRfaWRzX3JlYWQoKScgd2hpbGUgaG9sZGluZyB0aGUgY29ycmVzcG9uZGluZyAna2RhbW9uZF9sb2NrJy4gSG93ZXZlciwgaXQgYWxzbyBkZXN0cnVjdHMgdGhlIG1vbml0b3JpbmcgdGFyZ2V0cyBpbiAnZGJnZnNfYmVmb3JlX3Rlcm1pbmF0ZSgpJyB3aXRob3V0IGhvbGRpbmcgdGhlIGxvY2suIFRoaXMgY2FuIHJlc3VsdCBpbiBhIHVzZV9hZnRlcl9mcmVlIGJ1Zy4gVGhpcyBjb21taXQgYXZvaWRzIHRoZSByYWNlIGJ5IHByb3RlY3RpbmcgdGhlIGRlc3RydWN0aW9uIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgJ2tkYW1vbmRfbG9jaycuIExpbms6IGh0dHBzOi8vbGttbC5rZXJuZWwub3JnL3IvMjAyMTEyMjEwOTQ0NDcuMjI0MS0xLXNqQGtlcm5lbC5vcmcgUmVwb3J0ZWQtYnk6IFNhbmd3b28gQmFlIDxzYW5nd29vYj4gRml4ZXM6IDRiYzA1OTU0ZDAwNyAoIm1tL2RhbW9uOiBpbXBsZW1lbnQgYSBkZWJ1Z2ZzLWJhc2VkIHVzZXIgc3BhY2UgaW50ZXJmYWNlIikgU2lnbmVkLW9mZi1ieTogU2VvbmdKYWUgUGFyayA8c2o+IENjOiA8c3RhYmxlPiBbNS4xNS54XSBTaWduZWQtb2ZmLWJ5OiBBbmRyZXcgTW9ydG9uIDxha3BtPiBTaWduZWQtb2ZmLWJ5OiBMaW51cyBUb3J2YWxkcyA8dG9ydmFsZHM+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgYzY5MWU3NTc1ZWZmNzZlNTYzYjAxOTljMjNlYzQ2YmQ0NTRmNDNlMyBBdXRob3I6IExpdSBTaGl4aW4gPGxpdXNoaXhpbjI+IERhdGU6IEZyaSBEZWMgMjQgMjE6MTI6NTggMjAyMSAtMDgwMCBtbS9od3BvaXNvbjogY2xlYXIgTUZfQ09VTlRfSU5DUkVBU0VEIGJlZm9yZSByZXRyeWluZyBnZXRfYW55X3BhZ2UoKSBjb21taXQgMmE1N2Q4M2M3OGY4ODliZjNmNTRlZWRlOTA4ZDA2NDNjNDBkNTQxOCB1cHN0cmVhbS4gSHVsayBSb2JvdCByZXBvcnRlZCBhIHBhbmljIGluIHB1dF9wYWdlX3Rlc3R6ZXJvKCkgd2hlbiB0ZXN0aW5nIG1hZHZpc2UoKSB3aXRoIE1BRFZfU09GVF9PRkZMSU5FLiBUaGUgQlVHKCkgaXMgdHJpZ2dlcmVkIHdoZW4gcmV0cnlpbmcgZ2V0X2FueV9wYWdlKCkuIFRoaXMgaXMgYmVjYXVzZSB3ZSBrZWVwIE1GX0NPVU5UX0lOQ1JFQVNFRCBmbGFnIGluIHNlY29uZCB0cnkgYnV0IHRoZSByZWZjbnQgaXMgbm90IGluY3JlYXNlZC4gcGFnZSBkdW1wZWQgYmVjYXVzZTogVk1fQlVHX09OX1BBR0UocGFnZV9yZWZfY291bnQocGFnZSkgPT0gMCkgLS0tLS0tLS0tLS0tWyBjdXQgaGVyZSBdLS0tLS0tLS0tLS0tIGtlcm5lbCBCVUcgYXQgaW5jbHVkZS9saW51eC9tbS5oOjczNyEgaW52YWxpZCBvcGNvZGU6IDAwMDAgWyMxXSBQUkVFTVBUIFNNUCBDUFU6IDUgUElEOiAyMTM1IENvbW06IHNzaGQgVGFpbnRlZDogRyBCIDUuMTYuMC1yYzYtZGlydHkgIzM3MyBIYXJkd2FyZSBuYW1lOiBRRU1VIFN0YW5kYXJkIFBDIChpNDQwRlggKyBQSUlYLCAxOTk2KSwgQklPUyAxLjEzLjAtMXVidW50dTEuMSAwNC8wMS8yMDE0IFJJUDogcmVsZWFzZV9wYWdlcysweDUzZi8weDg0MCBDYWxsIFRyYWNlOiBmcmVlX3BhZ2VzX2FuZF9zd2FwX2NhY2hlKzB4NjQvMHg4MCB0bGJfZmx1c2hfbW11KzB4NmYvMHgyMjAgdW5tYXBfcGFnZV9yYW5nZSsweGU2Yy8weDEyYzAgdW5tYXBfc2luZ2xlX3ZtYSsweDkwLzB4MTcwIHVubWFwX3ZtYXMrMHhjNC8weDE4MCBleGl0X21tYXArMHhkZS8weDNhMCBtbXB1dCsweGEzLzB4MjUwIGRvX2V4aXQrMHg1NjQvMHgxNDcwIGRvX2dyb3VwX2V4aXQrMHgzYi8weDEwMCBfX2RvX3N5c19leGl0X2dyb3VwKzB4MTMvMHgyMCBfX3g2NF9zeXNfZXhpdF9ncm91cCsweDE2LzB4MjAgZG9fc3lzY2FsbF82NCsweDM0LzB4ODAgZW50cnlfU1lTQ0FMTF82NF9hZnRlcl9od2ZyYW1lKzB4NDQvMHhhZSBNb2R1bGVzIGxpbmtlZCBpbjogLS0tWyBlbmQgdHJhY2UgZTk5NTc5YjU3MGZlMDY0OSBdLS0tIFJJUDogMDAxMDpyZWxlYXNlX3BhZ2VzKzB4NTNmLzB4ODQwIExpbms6IGh0dHBzOi8vbGttbC5rZXJuZWwub3JnL3IvMjAyMTEyMjEwNzQ5MDguMzkxMDI4Ni0xLWxpdXNoaXhpbjJAaHVhd2VpLmNvbSBGaXhlczogYjk0ZTAyODIyZGViICgibW0saHdwb2lzb246IHRyeSB0byBuYXJyb3cgd2luZG93IHJhY2UgZm9yIGZyZWUgcGFnZXMiKSBTaWduZWQtb2ZmLWJ5OiBMaXUgU2hpeGluIDxsaXVzaGl4aW4yPiBSZXBvcnRlZC1ieTogSHVsayBSb2JvdCA8aHVsa2NpPiBSZXZpZXdlZC1ieTogT3NjYXIgU2FsdmFkb3IgPG9zYWx2YWRvcj4gQWNrZWQtYnk6IE5hb3lhIEhvcmlndWNoaSA8bmFveWEuaG9yaWd1Y2hpPiBDYzogPHN0YWJsZT4gU2lnbmVkLW9mZi1ieTogQW5kcmV3IE1vcnRvbiA8YWtwbT4gU2lnbmVkLW9mZi1ieTogTGludXMgVG9ydmFsZHMgPHRvcnZhbGRzPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDdhNzdlMjJmZGU2MzQ5ZDI3NmY4NjJhNTIxZDE5MGFkOTMyZTcxMWQgQXV0aG9yOiBOYW95YSBIb3JpZ3VjaGkgPG5hb3lhLmhvcmlndWNoaT4gRGF0ZTogRnJpIERlYyAyNCAyMToxMjo0NSAyMDIxIC0wODAwIG1tLCBod3BvaXNvbjogZml4IGNvbmRpdGlvbiBpbiBmcmVlIGh1Z2V0bGIgcGFnZSBwYXRoIGNvbW1pdCBlMzdlN2IwYjNiZDUyZWM0ZjhhYjcxYjAyN2JjZWMwOGY1N2YxYjNiIHVwc3RyZWFtLiBXaGVuIGEgbWVtb3J5IGVycm9yIGhpdHMgYSB0YWlsIHBhZ2Ugb2YgYSBmcmVlIGh1Z2VwYWdlLCBfX3BhZ2VfaGFuZGxlX3BvaXNvbigpIGlzIGV4cGVjdGVkIHRvIGJlIGNhbGxlZCB0byBpc29sYXRlIHRoZSBlcnJvciBpbiA0a0IgdW5pdCwgYnV0IGl0J3Mgbm90IGNhbGxlZCBkdWUgdG8gdGhlIG91dGRhdGVkIGlmLWNvbmRpdGlvbiBpbiBtZW1vcnlfZmFpbHVyZV9odWdldGxiKCkuIFRoaXMgbG9zZXMgdGhlIGNoYW5jZSB0byBpc29sYXRlIHRoZSBlcnJvciBpbiB0aGUgZmluZXIgdW5pdCwgc28gaXQncyBub3Qgb3B0aW1hbC4gRHJvcCB0aGUgY29uZGl0aW9uLiBUaGlzICIocCAhPSBoZWFkIFRlc3RTZXRQYWdlSFdQb2lzb24oaGVhZCkiIGNvbmRpdGlvbiBpcyBiYXNlZCBvbiB0aGUgb2xkIHNlbWFudGljcyBvZiBQYWdlSFdQb2lzb24gb24gaHVnZXBhZ2UgKHdoZXJlIFBHX2h3cG9pc29uIGZsYWcgd2FzIHNldCBvbiB0aGUgc3VicGFnZSksIHNvIGl0J3Mgbm90IG5lY2Vzc3JheSBhbnkgbW9yZS4gQnkgZ2V0dGluZyB0byBzZXQgUEdfaHdwb2lzb24gb24gaGVhZCBwYWdlIGZvciBodWdlcGFnZXMsIGNvbmN1cnJlbnQgZXJyb3IgZXZlbnRzIG9uIGRpZmZlcmVudCBzdWJwYWdlcyBpbiBhIHNpbmdsZSBodWdlcGFnZSBjYW4gYmUgcHJldmVudGVkIGJ5IFRlc3RTZXRQYWdlSFdQb2lzb24oaGVhZCkgYXQgdGhlIGJlZ2lubmluZyBvZiBtZW1vcnlfZmFpbHVyZV9odWdldGxiKCkuIFNvIGRyb3BwaW5nIHRoZSBjb25kaXRpb24gc2hvdWxkIG5vdCByZW9wZW4gdGhlIHJhY2Ugd2luZG93IG9yaWdpbmFsbHkgbWVudGlvbmVkIGluIGNvbW1pdCBiOTg1MTk0YzhjMGEgKCJod3BvaXNvbiwgaHVnZXRsYjogbG9ja19wYWdlL3VubG9ja19wYWdlIGRvZXMgbm90IG1hdGNoIGZvciBoYW5kbGluZyBhIGZyZWUgaHVnZXBhZ2UiKSBbbmFveWEuaG9yaWd1Y2hpQGxpbnV4LmRldjogZml4ICJIYXJkd2FyZUNvcnJ1cHRlZCIgY291bnRlcl0gTGluazogaHR0cHM6Ly9sa21sLmtlcm5lbC5vcmcvci8yMDIxMTIyMDA4NDg1MS5HQTE0NjAyNjRAdTIwMDQgTGluazogaHR0cHM6Ly9sa21sLmtlcm5lbC5vcmcvci8yMDIxMTIxMDExMDIwOC44Nzk3NDAtMS1uYW95YS5ob3JpZ3VjaGlAbGludXguZGV2IFNpZ25lZC1vZmYtYnk6IE5hb3lhIEhvcmlndWNoaSA8bmFveWEuaG9yaWd1Y2hpPiBSZXBvcnRlZC1ieTogRmVpIEx1byA8bHVvZmVpPiBSZXZpZXdlZC1ieTogTWlrZSBLcmF2ZXR6IDxtaWtlLmtyYXZldHo+IENjOiA8c3RhYmxlPiBbNS4xNCtdIFNpZ25lZC1vZmYtYnk6IEFuZHJldyBNb3J0b24gPGFrcG0+IFNpZ25lZC1vZmYtYnk6IExpbnVzIFRvcnZhbGRzIDx0b3J2YWxkcz4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCA2YjJjZGNjOGY1NTUyNjE1YzdiZGZjMGJhM2ZhNDVhNWQwZDE1NjgwIEF1dGhvcjogQW5kcmV5IFJ5YWJpbmluIDxhcmJuPiBEYXRlOiBGcmkgRGVjIDI0IDIxOjEyOjM1IDIwMjEgLTA4MDAgbW06IG1lbXBvbGljeTogZml4IFRIUCBhbGxvY2F0aW9ucyBlc2NhcGluZyBtZW1wb2xpY3kgcmVzdHJpY3Rpb25zIGNvbW1pdCAzMzg2MzUzNDA2NjlkNWIzMTdjN2U4ZGNmNGZmZjRhMGYzNjUxZDg3IHVwc3RyZWFtLiBhbGxvY19wYWdlc192bWEoKSBtYXkgdHJ5IHRvIGFsbG9jYXRlIFRIUCBwYWdlIG9uIHRoZSBsb2NhbCBOVU1BIG5vZGUgZmlyc3Q6IHBhZ2UgPSBfX2FsbG9jX3BhZ2VzX25vZGUoaHBhZ2Vfbm9kZSwgZ2ZwIHwgX19HRlBfVEhJU05PREUgfCBfX0dGUF9OT1JFVFJZLCBvcmRlcik7IEFuZCBpZiB0aGUgYWxsb2NhdGlvbiBmYWlscyBpdCByZXRyaWVzIGFsbG93aW5nIHJlbW90ZSBtZW1vcnk6IGlmICghcGFnZSAoZ2ZwIF9fR0ZQX0RJUkVDVF9SRUNMQUlNKSkgcGFnZSA9IF9fYWxsb2NfcGFnZXNfbm9kZShocGFnZV9ub2RlLCBnZnAsIG9yZGVyKTsgSG93ZXZlciwgdGhpcyByZXRyeSBhbGxvY2F0aW9uIGNvbXBsZXRlbHkgaWdub3JlcyBtZW1vcnkgcG9saWN5IG5vZGVtYXNrIGFsbG93aW5nIGFsbG9jYXRpb24gdG8gZXNjYXBlIHJlc3RyaWN0aW9ucy4gVGhlIGZpcnN0IGFwcGVhcmFuY2Ugb2YgdGhpcyBidWcgc2VlbXMgdG8gYmUgdGhlIGNvbW1pdCBhYzViMmMxODkxMWYgKCJtbTogdGhwOiByZWxheCBfX0dGUF9USElTTk9ERSBmb3IgTUFEVl9IVUdFUEFHRSBtYXBwaW5ncyIpLiBUaGUgYnVnIGRpc2FwcGVhcmVkIGxhdGVyIGluIHRoZSBjb21taXQgODljODNmYjUzOWY5ICgibW0sIHRocDogY29uc29saWRhdGUgVEhQIGdmcCBoYW5kbGluZyBpbnRvIGFsbG9jX2h1Z2VwYWdlX2RpcmVjdF9nZnBtYXNrIikgYW5kIHJlYXBwZWFyZWQgYWdhaW4gaW4gc2xpZ2h0bHkgZGlmZmVyZW50IGZvcm0gaW4gdGhlIGNvbW1pdCA3NmU2NTRjYzkxYmIgKCJtbSwgcGFnZV9hbGxvYzogYWxsb3cgaHVnZXBhZ2UgZmFsbGJhY2sgdG8gcmVtb3RlIG5vZGVzIHdoZW4gbWFkdmlzZWQiKSBGaXggdGhpcyBieSBwYXNzaW5nIGNvcnJlY3Qgbm9kZW1hc2sgdG8gdGhlIF9fYWxsb2NfcGFnZXMoKSBjYWxsLiBUaGUgZGVtb25zdHJhdGlvbi9yZXByb2R1Y2VyIG9mIHRoZSBwcm9ibGVtOiAkIG1vdW50IC1vcmVtb3VudCxzaXplPTRHLGh1Z2U9YWx3YXlzIC9kZXYvc2htLyAkIGVjaG8gYWx3YXlzICZndDsgL3N5cy9rZXJuZWwvbW0vdHJhbnNwYXJlbnRfaHVnZXBhZ2UvZGVmcmFnICQgY2F0IG1iaW5kX3RocC5jICNpbmNsdWRlIDx1bmlzdGQuaD4gI2luY2x1ZGUgPHN5cz4gI2luY2x1ZGUgPHN5cz4gI2luY2x1ZGUgPGZjbnRsLmg+ICNpbmNsdWRlIDxhc3NlcnQuaD4gI2luY2x1ZGUgPHN0ZGxpYi5oPiAjaW5jbHVkZSA8c3RkaW8uaD4gI2luY2x1ZGUgPG51bWFpZi5oPiAjZGVmaW5lIFNJWkUgMlVMTCAmbHQ7Jmx0OyAzMCBpbnQgbWFpbihpbnQgYXJnYywgY2hhciAqKmFyZ3YpIHsgaW50IGZkOyB1bnNpZ25lZCBsb25nIGxvbmcgaTsgY2hhciAqYWRkcjsgcGlkX3QgcGlkOyBjaGFyIGJ1ZlsxMDBdOyB1bnNpZ25lZCBsb25nIG5vZGVtYXNrID0gMTsgZmQgPSBvcGVuKCIvZGV2L3NobS90ZXN0IiwgT19SRFdSfE9fQ1JFQVQpOyBhc3NlcnQoZmQgJmd0OyAwKTsgYXNzZXJ0KGZ0cnVuY2F0ZShmZCwgU0laRSkgPT0gMCk7IGFkZHIgPSBtbWFwKE5VTEwsIFNJWkUsIFBST1RfUkVBRHxQUk9UX1dSSVRFLCBNQVBfU0hBUkVELCBmZCwgMCk7IGFzc2VydChtYmluZChhZGRyLCBTSVpFLCBNUE9MX0JJTkQsIG5vZGVtYXNrLCAyLCBNUE9MX01GX1NUUklDVHxNUE9MX01GX01PVkUpPT0wKTsgZm9yIChpID0gMDsgaSAmbHQ7IFNJWkU7IGkrPTQwOTYpIHsgYWRkcltpXSA9IDE7IH0gcGlkID0gZ2V0cGlkKCk7IHNucHJpbnRmKGJ1Ziwgc2l6ZW9mKGJ1ZiksICJncmVwIHNobSAvcHJvYy8lZC9udW1hX21hcHMiLCBwaWQpOyBzeXN0ZW0oYnVmKTsgc2xlZXAoMTAwMDApOyByZXR1cm4gMDsgfSAkIGdjYyBtYmluZF90aHAuYyAtbyBtYmluZF90aHAgLWxudW1hICQgbnVtYWN0bCAtSCBhdmFpbGFibGU6IDIgbm9kZXMgKDAtMSkgbm9kZSAwIGNwdXM6IDAgMiBub2RlIDAgc2l6ZTogMTkxOCBNQiBub2RlIDAgZnJlZTogMTU5NSBNQiBub2RlIDEgY3B1czogMSAzIG5vZGUgMSBzaXplOiAyMDE0IE1CIG5vZGUgMSBmcmVlOiAxNzMxIE1CIG5vZGUgZGlzdGFuY2VzOiBub2RlIDAgMSAwOiAxMCAyMCAxOiAyMCAxMCAkIHJtIC1mIC9kZXYvc2htL3Rlc3Q7IHRhc2tzZXQgLWMgMCAuL21iaW5kX3RocCA3ZmQ5NzBhMDAwMDAgYmluZDowIGZpbGU9L2Rldi9zaG0vdGVzdCBkaXJ0eT01MjQyODggYWN0aXZlPTAgTjA9Mzk2ODAwIE4xPTEyNzQ4OCBrZXJuZWxwYWdlc2l6ZV9rQj00IExpbms6IGh0dHBzOi8vbGttbC5rZXJuZWwub3JnL3IvMjAyMTEyMDgxNjUzNDMuMjIzNDktMS1hcmJuQHlhbmRleC10ZWFtLmNvbSBGaXhlczogYWM1YjJjMTg5MTFmICgibW06IHRocDogcmVsYXggX19HRlBfVEhJU05PREUgZm9yIE1BRFZfSFVHRVBBR0UgbWFwcGluZ3MiKSBTaWduZWQtb2ZmLWJ5OiBBbmRyZXkgUnlhYmluaW4gPGFyYm4+IEFja2VkLWJ5OiBNaWNoYWwgSG9ja28gPG1ob2Nrbz4gQWNrZWQtYnk6IE1lbCBHb3JtYW4gPG1nb3JtYW4+IEFja2VkLWJ5OiBEYXZpZCBSaWVudGplcyA8cmllbnRqZXM+IENjOiBBbmRyZWEgQXJjYW5nZWxpIDxhYXJjYW5nZT4gQ2M6IDxzdGFibGU+IFNpZ25lZC1vZmYtYnk6IEFuZHJldyBNb3J0b24gPGFrcG0+IFNpZ25lZC1vZmYtYnk6IExpbnVzIFRvcnZhbGRzIDx0b3J2YWxkcz4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCBjMWQxZWM0ZGI1ZjcyNjRjZmMyMTk5M2U1OWU4ZjJkY2VjZjRiNDRmIEF1dGhvcjogSm9oYW5uZXMgQmVyZyA8am9oYW5uZXMuYmVyZz4gRGF0ZTogTW9uIERlYyAyMCAxMDoyMjo0MCAyMDIxICswMTAwIG1hYzgwMjExOiBmaXggbG9ja2luZyBpbiBpZWVlODAyMTFfc3RhcnRfYXAgZXJyb3IgcGF0aCBjb21taXQgODdhMjcwNjI1YTg5ZmM4NDFmMWE3ZTIxYWFlNjE3NjU0M2Q4Mzg1YyB1cHN0cmVhbS4gV2UgbmVlZCB0byBob2xkIHRoZSBsb2NhbC0mZ3Q7bXR4IHRvIHJlbGVhc2UgdGhlIGNoYW5uZWwgY29udGV4dCwgYXMgZXZlbiBlbmNvZGVkIGJ5IHRoZSBsb2NrZGVwX2Fzc2VydF9oZWxkKCkgdGhlcmUuIEZpeCBpdC4gQ2M6IHN0YWJsZUB2Z2VyLmtlcm5lbC5vcmcgRml4ZXM6IDI5NWIwMmM0YmU3NCAoIm1hYzgwMjExOiBBZGQgRklMUyBkaXNjb3Zlcnkgc3VwcG9ydCIpIFJlcG9ydGVkLWFuZC10ZXN0ZWQtYnk6IHN5emJvdCsxMWMzNDJlNWUzMGU5NTM5Y2FiZEBzeXprYWxsZXIuYXBwc3BvdG1haWwuY29tIExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMjAyMTEyMjAwOTA4MzYuY2VlM2Q1OWExOTE1LkkzNmJiYTliNzlkYzJmZjRkNTdjM2M3YWEzMGRmZjlhMDAzZmU4YzVjQGNoYW5nZWlkIFNpZ25lZC1vZmYtYnk6IEpvaGFubmVzIEJlcmcgPGpvaGFubmVzLmJlcmc+IFNpZ25lZC1vZmYtYnk6IERhdmlkIFMuIE1pbGxlciA8ZGF2ZW0+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgYTJjMTQ0ZDE3NjIzOTg0ZmRhZmE0NjM0ZWNmNGFiNjQ1ODBkMjliYiBBdXRob3I6IE1hcmNvcyBEZWwgU29sIFZpdmVzIDxtYXJjb3M+IERhdGU6IFRodSBEZWMgMTYgMTE6Mzc6MjIgMjAyMSArMDEwMCBrc21iZDogZGlzYWJsZSBTTUIyX0dMT0JBTF9DQVBfRU5DUllQVElPTiBmb3IgU01CIDMuMS4xIGNvbW1pdCA4MzkxMmQ2ZDU1YmUxMGQ2NWI1MjY4ZDE4NzExNjhiOWViZTFlYzRiIHVwc3RyZWFtLiBBY2NvcmRpbmcgdG8gdGhlIG9mZmljaWFsIE1pY3Jvc29mdCBNUy1TTUIyIGRvY3VtZW50IHNlY3Rpb24gMy4zLjUuNCwgdGhpcyBmbGFnIHNob3VsZCBiZSB1c2VkIG9ubHkgZm9yIDMuMCBhbmQgMy4wLjIgZGlhbGVjdHMuIFNldHRpbmcgaXQgZm9yIDMuMS4xIGlzIGEgdmlvbGF0aW9uIG9mIHRoZSBzcGVjaWZpY2F0aW9uLiBUaGlzIGNhdXNlcyBteSBXaW5kb3dzIDEwIGNsaWVudCB0byBkZXRlY3QgYW4gYW5vbWFseSBpbiB0aGUgbmVnb3RpYXRpb24sIGFuZCBkaXNhYmxlIGVuY3J5cHRpb24gZW50aXJlbHkgZGVzcGl0ZSBiZWluZyBleHBsaWNpdGx5IGVuYWJsZWQgaW4ga3NtYmQsIGNhdXNpbmcgYWxsIGRhdGEgdHJhbnNmZXJzIHRvIGdvIGluIHBsYWluIHRleHQuIEZpeGVzOiBlMmYzNDQ4MWIyNGQgKCJjaWZzZDogYWRkIHNlcnZlci1zaWRlIHByb2NlZHVyZXMgZm9yIFNNQjMiKSBDYzogc3RhYmxlQHZnZXIua2VybmVsLm9yZyAjIHY1LjE1IEFja2VkLWJ5OiBOYW1qYWUgSmVvbiBTaWduZWQtb2ZmLWJ5OiBNYXJjb3MgRGVsIFNvbCBWaXZlcyA8bWFyY29zPiBTaWduZWQtb2ZmLWJ5OiBTdGV2ZSBGcmVuY2ggPHN0ZnJlbmNoPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGY0M2JhODZhODIxMTk0Nzc4ZmNiMWMxMGMwZDY4OTA5ZDZhNzI4ODkgQXV0aG9yOiBOYW1qYWUgSmVvbiBEYXRlOiBXZWQgRGVjIDEgMTA6MTI6MzkgMjAyMSArMDkwMCBrc21iZDogZml4IHVuaW5pdGlhbGl6ZWQgc3ltYm9sICdwbnRzZF9zaXplJyBjb21taXQgZjJlNzhhZmZjNDhkZWUyOWI5ODljMWQ5YjBkODliNTAzZGNkMTIwNCB1cHN0cmVhbS4gTm8gY2hlY2sgZm9yIGlmICJyYyIgaXMgYW4gZXJyb3IgY29kZSBmb3IgYnVpbGRfc2VjX2Rlc2MoKS4gVGhpcyBjYW4gY2F1c2UgcHJvYmxlbXMgd2l0aCB1c2luZyB1bmluaXRpYWxpemVkIHBudHNkX3NpemUuIEZpeGVzOiBlMmYzNDQ4MWIyNGQgKCJjaWZzZDogYWRkIHNlcnZlci1zaWRlIHByb2NlZHVyZXMgZm9yIFNNQjMiKSBDYzogc3RhYmxlQHZnZXIua2VybmVsLm9yZyAjIHY1LjE1IFJlcG9ydGVkLWJ5OiBEYW4gQ2FycGVudGVyIDxkYW4uY2FycGVudGVyPiBTaWduZWQtb2ZmLWJ5OiBOYW1qYWUgSmVvbiBTaWduZWQtb2ZmLWJ5OiBTdGV2ZSBGcmVuY2ggPHN0ZnJlbmNoPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDg5ZDBmZmI0YmI5NjBkNmNjZmFjNGQwMWNiZDVlMGU0NzI3YzFlYmMgQXV0aG9yOiBEYW4gQ2FycGVudGVyIDxkYW4uY2FycGVudGVyPiBEYXRlOiBUdWUgTm92IDMwIDE1OjUwOjQ3IDIwMjEgKzAzMDAga3NtYmQ6IGZpeCBlcnJvciBjb2RlIGluIG5kcl9yZWFkX2ludDMyKCkgY29tbWl0IGVmMzk5NDY5ZDljZWI5ZjIxNzFjZGQ3OTg2M2Y5NDM0YjlmYTNlZGMgdXBzdHJlYW0uIFRoaXMgaXMgYSBmYWlsdXJlIHBhdGggYW5kIGl0IHNob3VsZCByZXR1cm4gLUVJTlZBTCBpbnN0ZWFkIG9mIHN1Y2Nlc3MuIE90aGVyd2lzZSBpdCBjb3VsZCByZXN1bHQgaW4gdGhlIGNhbGxlciB1c2luZyB1bmluaXRpYWxpemVkIG1lbW9yeS4gRml4ZXM6IDMwM2ZmZjJiOGM3NyAoImtzbWJkOiBhZGQgdmFsaWRhdGlvbiBmb3IgbmRyIHJlYWQvd3JpdGUgZnVuY3Rpb25zIikgQ2M6IHN0YWJsZUB2Z2VyLmtlcm5lbC5vcmcgIyB2NS4xNSBBY2tlZC1ieTogTmFtamFlIEplb24gU2lnbmVkLW9mZi1ieTogRGFuIENhcnBlbnRlciA8ZGFuLmNhcnBlbnRlcj4gU2lnbmVkLW9mZi1ieTogU3RldmUgRnJlbmNoIDxzdGZyZW5jaD4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCBjOTk1MTNkZmZkMzYxZDVlMjEyMWQzYzIzYzdlODQwYTUwNWRiNGUxIEF1dGhvcjogQXJkIEJpZXNoZXV2ZWwgPGFyZGI+IERhdGU6IFdlZCBEZWMgMTUgMDk6MzE6MzYgMjAyMSArMDEwMCBBUk06IDkxNjkvMTogZW50cnk6IGZpeCBUaHVtYjIgYnVnIGluIGlXTU1YdCBleGNlcHRpb24gaGFuZGxpbmcgY29tbWl0IDg1MzZhNWVmODg2MDA1YmM0NDNjMmRhOWI4NDJkNjlmZDNkNzY0N2YgdXBzdHJlYW0uIFRoZSBUaHVtYjIgdmVyc2lvbiBvZiB0aGUgRlAgZXhjZXB0aW9uIGhhbmRsaW5nIGVudHJ5IGNvZGUgdHJlYXRzIHRoZSByZWdpc3RlciBob2xkaW5nIHRoZSBDUCBudW1iZXIgKFI4KSBkaWZmZXJlbnRseSwgcmVzdWx0aW5nIGluIHRoZSBpV01NWFQgQ1AgbnVtYmVyIGNoZWNrIHRvIGJlIGluY29ycmVjdC4gRml4IHRoaXMgYnkgdW5pZnlpbmcgdGhlIEFSTSBhbmQgVGh1bWIyIGNvZGUgcGF0aHMsIGFuZCBzd2l0Y2ggdGhlIG9yZGVyIG9mIHRoZSBhZGRpdGlvbnMgb2YgdGhlIFRJX1VTRURfQ1Agb2Zmc2V0IGFuZCB0aGUgc2hpZnRlZCBDUCBpbmRleC4gQ2M6IDxzdGFibGU+IEZpeGVzOiBiODYwNDBhNTlmZWIgKCJUaHVtYi0yOiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgdW5pZmllZCBzdGFydC11cCBhbmQgZXhjZXB0aW9ucyBjb2RlIikgU2lnbmVkLW9mZi1ieTogQXJkIEJpZXNoZXV2ZWwgPGFyZGI+IFNpZ25lZC1vZmYtYnk6IFJ1c3NlbGwgS2luZyAoT3JhY2xlKSA8cm1rPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGM3ODE0NTY5YjM4N2MxYmU4ODRkNmM1Y2Q5NDZmMTNmMjE0YjliYjYgQXV0aG9yOiBZYW5uIEdhdXRpZXIgPHlhbm4uZ2F1dGllcj4gRGF0ZTogV2VkIERlYyAxNSAxNToxNzoyNiAyMDIxICswMTAwIG1tYzogbW1jaTogc3RtMzI6IGNsZWFyIERMWUJfQ1IgYWZ0ZXIgc2VuZGluZyB0dW5pbmcgY29tbWFuZCBjb21taXQgZmYzMWVlMGEwZjQ3MTc3NmY2N2JlNWU1Mjc1YzE4ZDE3NzM2ZmM2YiB1cHN0cmVhbS4gRHVyaW5nIHRlc3QgY2FtcGFpZ24sIGFuZCBlc3BlY2lhbGx5IGFmdGVyIHNldmVyYWwgdW5iaW5kL2JpbmQgc2VxdWVuY2VzLCBpdCBoYXMgYmVlbiBzZWVuIHRoYXQgdGhlIFNELWNhcmQgb24gU0RNTUMxIHRocmVhZCBjb3VsZCBmcmVlemUuIFRoZSBmcmVlemUgYWx3YXlzIGFwcGVhciBvbiBhIENNRDIzIGZvbGxvd2luZyBhIENNRDE5LiBDaGVja2luZyBTRE1NQyBpbnRlcm5hbCByZWdpc3RlcnMgc2hvd3MgdGhhdCB0aGUgdHVuaW5nIGNvbW1hbmQgKENNRDE5KSBoYXMgZmFpbGVkLiBUaGUgZnJlZXplIGlzIHRoZW4gZHVlIHRvIHRoZSBkZWxheSBibG9jayBpbnZvbHZlZCBpbiB0aGUgdHVuaW5nIHNlcXVlbmNlLiBUbyBjb3JyZWN0IHRoaXMsIGNsZWFyIHRoZSBkZWxheSBibG9jayByZWdpc3RlciBETFlCX0NSIHJlZ2lzdGVyIGFmdGVyIHRoZSB0dW5pbmcgY29tbWFuZHMuIFNpZ25lZC1vZmYtYnk6IENocmlzdG9waGUgS2VyZWxsbyA8Y2hyaXN0b3BoZS5rZXJlbGxvPiBTaWduZWQtb2ZmLWJ5OiBZYW5uIEdhdXRpZXIgPHlhbm4uZ2F1dGllcj4gUmV2aWV3ZWQtYnk6IExpbnVzIFdhbGxlaWogPGxpbnVzLndhbGxlaWo+IEZpeGVzOiAxMTAzZjgwN2EzYjkgKCJtbWM6IG1tY2lfc2RtbWM6IEFkZCBleGVjdXRlIHR1bmluZyB3aXRoIGRlbGF5IGJsb2NrIikgQ2M6IHN0YWJsZUB2Z2VyLmtlcm5lbC5vcmcgTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8yMDIxMTIxNTE0MTcyNy40OTAxLTQteWFubi5nYXV0aWVyQGZvc3Muc3QuY29tIFNpZ25lZC1vZmYtYnk6IFVsZiBIYW5zc29uIDx1bGYuaGFuc3Nvbj4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCBjMGRiMDZmZDA5OTM3YjNhODBkNTU0ZjJlOTM1YWMzNDUyYTViNmQ4IEF1dGhvcjogVWxmIEhhbnNzb24gPHVsZi5oYW5zc29uPiBEYXRlOiBGcmkgRGVjIDMgMTU6MTU6NTQgMjAyMSArMDEwMCBtbWM6IGNvcmU6IERpc2FibGUgY2FyZCBkZXRlY3QgZHVyaW5nIHNodXRkb3duIGNvbW1pdCA2NmM5MTVkMDliOTQyZmIzYjJiMGNiMmY1NjU2MjE4MDkwMWZiYTE3IHVwc3RyZWFtLiBJdCdzIHNlZW1zIHByb25lIHRvIHByb2JsZW1zIGJ5IGFsbG93aW5nIGNhcmQgZGV0ZWN0IGFuZCBpdHMgY29ycmVzcG9uZGluZyBtbWNfcmVzY2FuKCkgd29yayB0byBydW4sIGR1cmluZyBwbGF0Zm9ybSBzaHV0ZG93bi4gRm9yIGV4YW1wbGUsIHdlIG1heSBlbmQgdXAgdHVybmluZyBvZmYgdGhlIHBvd2VyIHdoaWxlIGluaXRpYWxpemluZyBhIGNhcmQsIHdoaWNoIHBvdGVudGlhbGx5IGNvdWxkIGRhbWFnZSBpdC4gVG8gYXZvaWQgdGhpcyBzY2VuYXJpbywgbGV0J3MgYWRkIC0mZ3Q7c2h1dGRvd25fcHJlKCkgY2FsbGJhY2sgZm9yIHRoZSBtbWMgaG9zdCBjbGFzcyBkZXZpY2UgYW5kIHRoZW4gdHVybiBvZiB0aGUgY2FyZCBkZXRlY3QgZnJvbSB0aGVyZS4gUmVwb3J0ZWQtYnk6IEFsIENvb3BlciA8YWxjb29wZXJ4PiBTdWdnZXN0ZWQtYnk6IEFkcmlhbiBIdW50ZXIgPGFkcmlhbi5odW50ZXI+IFNpZ25lZC1vZmYtYnk6IFVsZiBIYW5zc29uIDx1bGYuaGFuc3Nvbj4gQ2M6IHN0YWJsZUB2Z2VyLmtlcm5lbC5vcmcgTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8yMDIxMTIwMzE0MTU1NS4xMDUzNTEtMS11bGYuaGFuc3NvbkBsaW5hcm8ub3JnIFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgOWQ5M2M4NjNkMDRmZWE3ODM1MTE4N2NiMDAzMWNlMmNjMzAzOTQyOSBBdXRob3I6IE1hcnRpbiBCbHVtZW5zdGluZ2wgPG1hcnRpbi5ibHVtZW5zdGluZ2w+IERhdGU6IFN1biBEZWMgMTkgMTY6MzQ6NDEgMjAyMSArMDEwMCBtbWM6IG1lc29uLW14LXNkaGM6IFNldCBNQU5VQUxfU1RPUCBmb3IgbXVsdGktYmxvY2sgU0RJTyBjb21tYW5kcyBjb21taXQgZjg5YjU0OGNhNjZiZTc1MDBkY2Q5MmVlOGU2MTU5MGY3ZDA4YWM5MSB1cHN0cmVhbS4gVGhlIHZlbmRvciBkcml2ZXIgaW1wbGVtZW50cyBzcGVjaWFsIGhhbmRsaW5nIGZvciBtdWx0aS1ibG9jayBTRF9JT19SV19FWFRFTkRFRCAoYW5kIFNEX0lPX1JXX0RJUkVDVCkgY29tbWFuZHMgd2hpY2ggaGF2ZSBkYXRhIGF0dGFjaGVkIHRvIHRoZW0uIEl0IHNldHMgdGhlIE1BTlVBTF9TVE9QIGJpdCBpbiB0aGUgTUVTT05fU0RIQ19NSVNDIHJlZ2lzdGVyIGZvciB0aGVzZSBjb21tYW5kcy4gSW4gYWxsIG90aGVyIGNhc2VzIHRoaXMgYml0IGlzIGNsZWFyZWQuIEhlcmUgd2Ugb21pdCBTRF9JT19SV19ESVJFQ1Qgc2luY2UgdGhhdCBjb21tYW5kIG5ldmVyIGhhcyBhbnkgZGF0YSBhdHRhY2hlZCB0byBpdC4gVGhpcyBmaXhlcyBTRElPIHdpZmkgdXNpbmcgdGhlIGJyY21mbWFjIGRyaXZlciB3aGljaCByZXBvcnRlZCB0aGUgZm9sbG93aW5nIGVycm9yIHdpdGhvdXQgdGhpcyBjaGFuZ2Ugb24gYSBOZXR4ZW9uIFM4MiBib2FyZCB1c2luZyBhIE1lc29uOCAoUzgwMikgU29DOiBicmNtZl9md19hbGxvY19yZXF1ZXN0OiB1c2luZyBicmNtL2JyY21mbWFjNDMzNjItc2RpbyBmb3IgY2hpcCBCQ000MzM2Mi8xIGJyY21mX3NkaW9kX3JhbXJ3OiBtZW1ieXRlcyB0cmFuc2ZlciBmYWlsZWQgYnJjbWZfc2Rpb19kb3dubG9hZF9jb2RlX2ZpbGU6IGVycm9yIC0xMTAgb24gd3JpdGluZyAyMTk1NTcgbWVtYnl0ZXMgYXQgMHgwMDAwMDAwMCBicmNtZl9zZGlvX2Rvd25sb2FkX2Zpcm13YXJlOiBkb25nbGUgaW1hZ2UgZmlsZSBkb3dubG9hZCBmYWlsZWQgQW5kIHdpdGggdGhpcyBjaGFuZ2U6IGJyY21mX2Z3X2FsbG9jX3JlcXVlc3Q6IHVzaW5nIGJyY20vYnJjbWZtYWM0MzM2Mi1zZGlvIGZvciBjaGlwIEJDTTQzMzYyLzEgYnJjbWZfY19wcm9jZXNzX2NsbV9ibG9iOiBubyBjbG1fYmxvYiBhdmFpbGFibGUgKGVycj0tMiksIGRldmljZSBtYXkgaGF2ZSBsaW1pdGVkIGNoYW5uZWxzIGF2YWlsYWJsZSBicmNtZl9jX3ByZWluaXRfZGNtZHM6IEZpcm13YXJlOiBCQ000MzM2Mi8xIHdsMDogQXByIDIyIDIwMTMgMTQ6NTA6MDAgdmVyc2lvbiA1LjkwLjE5NS44OS42IEZXSUQgMDEtYjMwYTQyN2QgRml4ZXM6IGU0YmYxYjA5NzBlZjk2ICgibW1jOiBob3N0OiBtZXNvbi1teC1zZGhjOiBuZXcgZHJpdmVyIGZvciB0aGUgQW1sb2dpYyBNZXNvbiBTREhDIGhvc3QiKSBTaWduZWQtb2ZmLWJ5OiBNYXJ0aW4gQmx1bWVuc3RpbmdsIDxtYXJ0aW4uYmx1bWVuc3RpbmdsPiBDYzogc3RhYmxlQHZnZXIua2VybmVsLm9yZyBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMjE5MTUzNDQyLjQ2Mzg2My0yLW1hcnRpbi5ibHVtZW5zdGluZ2xAZ29vZ2xlbWFpbC5jb20gU2lnbmVkLW9mZi1ieTogVWxmIEhhbnNzb24gPHVsZi5oYW5zc29uPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDQ2ZTJmYzI2MDU0M2JiYTJlYzJjZTNmNzJkYjJmNjIxNzQzMjlkMjAgQXV0aG9yOiBQcmF0aGFtZXNoIFNoZXRlIDxwc2hldGU+IERhdGU6IFR1ZSBEZWMgMTQgMTc6MDY6NTMgMjAyMSArMDUzMCBtbWM6IHNkaGNpLXRlZ3JhOiBGaXggc3dpdGNoIHRvIEhTNDAwRVMgbW9kZSBjb21taXQgNGZjNzI2MWRiYWIxMzlkM2M2NGMzYjYxODI2MjUwNGUxNmNmZTdlZSB1cHN0cmVhbS4gV2hlbiBDTUQxMyBpcyBzZW50IGFmdGVyIHN3aXRjaGluZyB0byBIUzQwMEVTIG1vZGUsIHRoZSBidXMgaXMgb3BlcmF0aW5nIGF0IGVpdGhlciBNTUNfSElHSF8yNl9NQVhfRFRSIG9yIE1NQ19ISUdIXzUyX01BWF9EVFIuIFRvIG1lZXQgVGVncmEgU0RIQ0kgcmVxdWlyZW1lbnQgYXQgSFM0MDBFUyBtb2RlLCBmb3JjZSBTREhDSSBpbnRlcmZhY2UgY2xvY2sgdG8gTU1DX0hTMjAwX01BWF9EVFIgKDIwMCBNSHopIHNvIHRoYXQgaG9zdCBjb250cm9sbGVyIENBUiBjbG9jayBhbmQgdGhlIGludGVyZmFjZSBjbG9jayBhcmUgcmF0ZSBtYXRjaGVkLiBTaWduZWQtb2ZmLWJ5OiBQcmF0aGFtZXNoIFNoZXRlIDxwc2hldGU+IEFja2VkLWJ5OiBBZHJpYW4gSHVudGVyIDxhZHJpYW4uaHVudGVyPiBGaXhlczogZGZjOTcwMGNlZjc3ICgibW1jOiB0ZWdyYTogSW1wbGVtZW50IEhTNDAwIGVuaGFuY2VkIHN0cm9iZSIpIENjOiBzdGFibGVAdmdlci5rZXJuZWwub3JnIExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMjAyMTEyMTQxMTM2NTMuNDYzMS0xLXBzaGV0ZUBudmlkaWEuY29tIFNpZ25lZC1vZmYtYnk6IFVsZiBIYW5zc29uIDx1bGYuaGFuc3Nvbj4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCBlNWRkM2U2MWJhZWQ3NGQwYWJmYzYzZDA1ZDY5ZGJmZjllNDhkMWJkIEF1dGhvcjogTm9yYWxmIFRyw7hubmVzIDxub3JhbGY+IERhdGU6IE1vbiBPY3QgMTggMTM6MjI6MDEgMjAyMSArMDIwMCBncGlvOiBkbG4yOiBGaXggaW50ZXJydXB0cyB3aGVuIHJlcGx1Z2dpbmcgdGhlIGRldmljZSBjb21taXQgOWE1ODc1ZjE0YjBlM2ExM2FlMzE0ODgzZjFiYjcyYjdmMzFmYWMwNyB1cHN0cmVhbS4gV2hlbiByZXBsdWdnaW5nIHRoZSBkZXZpY2UgdGhlIGZvbGxvd2luZyBtZXNzYWdlIHNob3dzIHVwOiBncGlvIGdwaW9jaGlwMjogKGRsbjIpOiBkZXRlY3RlZCBpcnFjaGlwIHRoYXQgaXMgc2hhcmVkIHdpdGggbXVsdGlwbGUgZ3Bpb2NoaXBzOiBwbGVhc2UgZml4IHRoZSBkcml2ZXIuIFRoaXMgYWxzbyBoYXMgdGhlIGVmZmVjdCB0aGF0IGludGVycnVwdHMgd29uJ3Qgd29yay4gVGhlIHNhbWUgcHJvYmxlbSB3b3VsZCBhbHNvIHNob3cgdXAgaWYgbXVsdGlwbGUgZGV2aWNlcyB3aGVyZSBwbHVnZ2VkIGluLiBGaXggdGhpcyBieSBhbGxvY2F0aW5nIHRoZSBpcnFfY2hpcCBkYXRhIHN0cnVjdHVyZSBwZXIgaW5zdGFuY2UgbGlrZSBvdGhlciBkcml2ZXJzIGRvLiBJIGRvbid0IGtub3cgd2hlbiB0aGlzIHByb2JsZW0gYXBwZWFyZWQsIGJ1dCBpdCBpcyBwcmVzZW50IGluIDUuMTAuIENjOiA8c3RhYmxlPiAjIDUuMTArIENjOiBEYW5pZWwgQmFsdXRhIDxkYW5pZWwuYmFsdXRhPiBTaWduZWQtb2ZmLWJ5OiBOb3JhbGYgVHLDuG5uZXMgPG5vcmFsZj4gU2lnbmVkLW9mZi1ieTogQmFydG9zeiBHb2xhc3pld3NraSBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGMxY2UzYzQxMDAzOGJiOGM5MWI5MWE0MGU3M2ZhY2I5ODE1NDkyMzYgQXV0aG9yOiBGYWJpZW4gRGVzc2VubmUgPGZhYmllbi5kZXNzZW5uZT4gRGF0ZTogV2VkIERlYyAxNSAxMDo1ODowOCAyMDIxICswMTAwIHBpbmN0cmw6IHN0bTMyOiBjb25zaWRlciB0aGUgR1BJTyBvZmZzZXQgdG8gZXhwb3NlIGFsbCB0aGUgR1BJTyBsaW5lcyBjb21taXQgYjY3MjEwY2MyMTdmOWNhMWM1NzY5MDk0NTRkODQ2OTcwYzEzZGZkNCB1cHN0cmVhbS4gQ29uc2lkZXIgdGhlIEdQSU8gY29udHJvbGxlciBvZmZzZXQgKGZyb20gImdwaW8tcmFuZ2VzIikgdG8gY29tcHV0ZSB0aGUgbWF4aW11bSBHUElPIGxpbmUgbnVtYmVyLiBUaGlzIGZpeGVzIGFuIGlzc3VlIHdoZXJlIGdwaW8tcmFuZ2VzIHVzZXMgYSBub24tbnVsbCBvZmZzZXQuIGUuZy46IGdwaW8tcmFuZ2VzID0gSW4gdGhhdCBjYXNlIHRoZSBsYXN0IHZhbGlkIEdQSU8gbGluZSBpcyBub3QgOSBidXQgMTUgKDYgKyAxMCAtIDEpIENjOiBzdGFibGVAdmdlci5rZXJuZWwub3JnIEZpeGVzOiA2N2UyOTk2ZjcyYzcgKCJwaW5jdHJsOiBzdG0zMjogZml4IHRoZSByZXBvcnRlZCBudW1iZXIgb2YgR1BJTyBsaW5lcyBwZXIgYmFuayIpIFJlcG9ydGVkLWJ5OiBDaHJpc3RvcGggRnJpdHogPGNoZi5mcml0ej4gU2lnbmVkLW9mZi1ieTogRmFiaWVuIERlc3Nlbm5lIDxmYWJpZW4uZGVzc2VubmU+IExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMjAyMTEyMTUwOTU4MDguNjIxNzE2LTEtZmFiaWVuLmRlc3Nlbm5lQGZvc3Muc3QuY29tIFNpZ25lZC1vZmYtYnk6IExpbnVzIFdhbGxlaWogPGxpbnVzLndhbGxlaWo+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgYjlkN2M3YTViZjZlZmYyZTUwMDJmMzM5NjdkMGI1YWUxMjE4MDIyOSBBdXRob3I6IFNlYW4gQ2hyaXN0b3BoZXJzb24gPHNlYW5qYz4gRGF0ZTogVHVlIERlYyAyMSAxMDozNzowMCAyMDIxIC0wNTAwIEtWTTogVk1YOiBXYWtlIHZDUFUgd2hlbiBkZWxpdmVyaW5nIHBvc3RlZCBJUlEgZXZlbiBpZiB2Q1BVID09IHRoaXMgdkNQVSBjb21taXQgZmRiYTYwOGYxNWUyNDI3NDE5OTk3YjA4OTg3NTBhNDlhNzM1YWZjYiB1cHN0cmVhbS4gRHJvcCBhIGNoZWNrIHRoYXQgZ3VhcmRzIHRyaWdnZXJpbmcgYSBwb3N0ZWQgaW50ZXJydXB0IG9uIHRoZSBjdXJyZW50bHkgcnVubmluZyB2Q1BVLCBhbmQgbW9yZSBpbXBvcnRhbnRseSBndWFyZHMgd2FraW5nIHRoZSB0YXJnZXQgdkNQVSBpZiB0cmlnZ2VyaW5nIGEgcG9zdGVkIGludGVycnVwdCBmYWlscyBiZWNhdXNlIHRoZSB2Q1BVIGlzbid0IElOX0dVRVNUX01PREUuIElmIGEgdklSUSBpcyBkZWxpdmVyZWQgZnJvbSBhc3luY2hyb25vdXMgY29udGV4dCwgdGhlIHRhcmdldCB2Q1BVIGNhbiBiZSB0aGUgY3VycmVudGx5IHJ1bm5pbmcgdkNQVSBhbmQgY2FuIGFsc28gYmUgYmxvY2tpbmcsIGluIHdoaWNoIGNhc2Ugc2tpcHBpbmcga3ZtX3ZjcHVfd2FrZV91cCgpIGlzIGVmZmVjdGl2ZWx5IGRyb3BwaW5nIHdoYXQgaXMgc3VwcG9zZWQgdG8gYmUgYSB3YWtlIGV2ZW50IGZvciB0aGUgdkNQVS4gVGhlICJkbyBub3RoaW5nIiBsb2dpYyB3aGVuICJ2Y3B1ID09IHJ1bm5pbmdfdmNwdSIgbW9zdGx5IHdvcmtzIG9ubHkgYmVjYXVzZSB0aGUgbWFqb3JpdHkgb2YgY2FsbHMgdG8gLSZndDtkZWxpdmVyX3Bvc3RlZF9pbnRlcnJ1cHQoKSwgZXNwZWNpYWxseSB3aGVuIHVzaW5nIHBvc3RlZCBpbnRlcnJ1cHRzLCBjb21lIGZyb20gc3luY2hyb25vdXMgS1ZNIGNvbnRleHQuIEJ1dCBpZiBhIGRldmljZSBpcyBleHBvc2VkIHRvIHRoZSBndWVzdCB1c2luZyB2ZmlvLXBjaSBwYXNzdGhyb3VnaCwgdGhlIFZGSU8gSVJRIGFuZCB2Q1BVIGFyZSBib3VuZCB0byB0aGUgc2FtZSBwQ1BVLCBhbmQgdGhlIElSUSBpcyBfbm90XyBjb25maWd1cmVkIHRvIHVzZSBwb3N0ZWQgaW50ZXJydXB0cywgd2FrZSBldmVudHMgZnJvbSB0aGUgZGV2aWNlIHdpbGwgYmUgZGVsaXZlcmVkIHRvIEtWTSBmcm9tIElSUSBjb250ZXh0LCBlLmcuIHZmaW9fbXNpaGFuZGxlcigpIHwgfC0mZ3Q7IGV2ZW50ZmRfc2lnbmFsKCkgfCB8LSZndDsgLi4uIHwgfC0mZ3Q7IGlycWZkX3dha2V1cCgpIHwgfC0mZ3Q7a3ZtX2FyY2hfc2V0X2lycV9pbmF0b21pYygpIHwgfC0mZ3Q7IGt2bV9pcnFfZGVsaXZlcnlfdG9fYXBpY19mYXN0KCkgfCB8LSZndDsga3ZtX2FwaWNfc2V0X2lycSgpIFRoaXMgYWxzbyBhbGlnbnMgdGhlIG5vbi1uZXN0ZWQgYW5kIG5lc3RlZCB1c2FnZSBvZiB0cmlnZ2VyaW5nIHBvc3RlZCBpbnRlcnJ1cHRzLCBhbmQgd2lsbCBhbGxvdyBmb3IgYWRkaXRpb25hbCBjbGVhbnVwcy4gRml4ZXM6IDM3OWEzYzhlZTQ0NCAoIktWTTogVk1YOiBPcHRpbWl6ZSBwb3N0ZWQtaW50ZXJydXB0IGRlbGl2ZXJ5IGZvciB0aW1lciBmYXN0cGF0aCIpIENjOiBzdGFibGVAdmdlci5rZXJuZWwub3JnIFJlcG9ydGVkLWJ5OiBMb25ncGVuZyAoTWlrZSkgPGxvbmdwZW5nMj4gU2lnbmVkLW9mZi1ieTogU2VhbiBDaHJpc3RvcGhlcnNvbiA8c2VhbmpjPiBSZXZpZXdlZC1ieTogTWF4aW0gTGV2aXRza3kgPG1sZXZpdHNrPiBNZXNzYWdlLUlkOiAmbHQ7MjAyMTEyMDgwMTUyMzYuMTYxNjY5Ny0xOC1zZWFuamNAZ29vZ2xlLmNvbSZndDsgU2lnbmVkLW9mZi1ieTogUGFvbG8gQm9uemluaSA8cGJvbnppbmk+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgZTRlNGU3Y2IyMjk4MjFjZDIxNTAzMWFiYzQ3ZWZkYWI1NDg2YTY3YyBBdXRob3I6IFNlYW4gQ2hyaXN0b3BoZXJzb24gPHNlYW5qYz4gRGF0ZTogVHVlIERlYyA3IDE5OjMwOjAzIDIwMjEgKzAwMDAgS1ZNOiBWTVg6IEFsd2F5cyBjbGVhciB2bXgtJmd0O2ZhaWwgb24gZW11bGF0aW9uX3JlcXVpcmVkIGNvbW1pdCBhODBkZmMwMjU5MjQwMjRkMmM2MWE0YzFiOGVmNjJiMmZjZTc2YTA0IHVwc3RyZWFtLiBSZXZlcnQgYSByZWxhdGl2ZWx5IHJlY2VudCBjaGFuZ2UgdGhhdCBzZXQgdm14LSZndDtmYWlsIGlmIHRoZSB2Q1BVIGlzIGluIEwyIGFuZCBlbXVsYXRpb25fcmVxdWlyZWQgaXMgdHJ1ZSwgYXMgdGhhdCBiZWhhdmlvciBpcyBjb21wbGV0ZWx5IGJvZ3VzLiBTZXR0aW5nIHZteC0mZ3Q7ZmFpbCBhbmQgc3ludGhlc2l6aW5nIGEgVk0tRXhpdCBpcyBjb250cmFkaWN0b3J5IGFuZCB3cm9uZzogKGEpIGl0J3MgaW1wb3NzaWJsZSB0byBoYXZlIGJvdGggYSBWTS1GYWlsIGFuZCBWTS1FeGl0IChiKSB2bWNzLkVYSVRfUkVBU09OIGlzIG5vdCBtb2RpZmllZCBvbiBWTS1GYWlsIChjKSBlbXVsYXRpb25fcmVxdWlyZWQgcmVmZXJzIHRvIGd1ZXN0IHN0YXRlIGFuZCBndWVzdCBzdGF0ZSBjaGVja3MgYXJlIGFsd2F5cyBWTS1FeGl0cywgbm90IFZNLUZhaWxzLiBGb3IgS1ZNIHNwZWNpZmljYWxseSwgZW11bGF0aW9uX3JlcXVpcmVkIGlzIGhhbmRsZWQgYmVmb3JlIG5lc3RlZCBleGl0cyBpbiBfX3ZteF9oYW5kbGVfZXhpdCgpLCB0aHVzIHNldHRpbmcgdm14LSZndDtmYWlsIGhhcyBubyBpbW1lZGlhdGUgZWZmZWN0LCBpLmUuIEtWTSBjYWxscyBpbnRvIGhhbmRsZV9pbnZhbGlkX2d1ZXN0X3N0YXRlKCkgYW5kIHZteC0mZ3Q7ZmFpbCBpcyBpZ25vcmVkLiBTZXR0aW5nIHZteC0mZ3Q7ZmFpbCBjYW4gdWx0aW1hdGVseSByZXN1bHQgaW4gYSBXQVJOIGluIG5lc3RlZF92bXhfdm1leGl0KCkgZmlyaW5nIHdoZW4gdGVhcmluZyBkb3duIHRoZSBWTSBhcyBLVk0gbmV2ZXIgZXhwZWN0cyB2bXgtJmd0O2ZhaWwgdG8gYmUgc2V0IHdoZW4gTDIgaXMgYWN0aXZlLCBLVk0gYWx3YXlzIHJlZmxlY3RzIHRob3NlIGVycm9ycyBpbnRvIEwxLiAtLS0tLS0tLS0tLS1bIGN1dCBoZXJlIF0tLS0tLS0tLS0tLS0gV0FSTklORzogQ1BVOiAwIFBJRDogMjExNTggYXQgYXJjaC94ODYva3ZtL3ZteC9uZXN0ZWQuYzo0NTQ4IG5lc3RlZF92bXhfdm1leGl0KzB4MTZiZC8weDE3ZTAgYXJjaC94ODYva3ZtL3ZteC9uZXN0ZWQuYzo0NTQ3IE1vZHVsZXMgbGlua2VkIGluOiBDUFU6IDAgUElEOiAyMTE1OCBDb21tOiBzeXotZXhlY3V0b3IuMSBOb3QgdGFpbnRlZCA1LjE2LjAtcmMzLXN5emthbGxlciAjMCBIYXJkd2FyZSBuYW1lOiBHb29nbGUgR29vZ2xlIENvbXB1dGUgRW5naW5lL0dvb2dsZSBDb21wdXRlIEVuZ2luZSwgQklPUyBHb29nbGUgMDEvMDEvMjAxMSBSSVA6IDAwMTA6bmVzdGVkX3ZteF92bWV4aXQrMHgxNmJkLzB4MTdlMCBhcmNoL3g4Ni9rdm0vdm14L25lc3RlZC5jOjQ1NDcgQ29kZTogJmx0OzBmJmd0OyAwYiBlOSAyZSBmOCBmZiBmZiBlOCA1NyBiMyA1ZCAwMCAwZiAwYiBlOSAwMCBmMSBmZiBmZiA4OSBlOSA4MCBDYWxsIFRyYWNlOiB2bXhfbGVhdmVfbmVzdGVkIGFyY2gveDg2L2t2bS92bXgvbmVzdGVkLmM6NjIyMCBbaW5saW5lXSBuZXN0ZWRfdm14X2ZyZWVfdmNwdSsweDgzLzB4YzAgYXJjaC94ODYva3ZtL3ZteC9uZXN0ZWQuYzozMzAgdm14X2ZyZWVfdmNwdSsweDExZi8weDJhMCBhcmNoL3g4Ni9rdm0vdm14L3ZteC5jOjY3OTkga3ZtX2FyY2hfdmNwdV9kZXN0cm95KzB4NmIvMHgyNDAgYXJjaC94ODYva3ZtL3g4Ni5jOjEwOTg5IGt2bV92Y3B1X2Rlc3Ryb3krMHgyOS8weDkwIGFyY2gveDg2L2t2bS8uLi8uLi8uLi92aXJ0L2t2bS9rdm1fbWFpbi5jOjQ0MSBrdm1fZnJlZV92Y3B1cyBhcmNoL3g4Ni9rdm0veDg2LmM6MTE0MjYgW2lubGluZV0ga3ZtX2FyY2hfZGVzdHJveV92bSsweDNlZi8weDZiMCBhcmNoL3g4Ni9rdm0veDg2LmM6MTE1NDUga3ZtX2Rlc3Ryb3lfdm0gYXJjaC94ODYva3ZtLy4uLy4uLy4uL3ZpcnQva3ZtL2t2bV9tYWluLmM6MTE4OSBbaW5saW5lXSBrdm1fcHV0X2t2bSsweDc1MS8weGU0MCBhcmNoL3g4Ni9rdm0vLi4vLi4vLi4vdmlydC9rdm0va3ZtX21haW4uYzoxMjIwIGt2bV92Y3B1X3JlbGVhc2UrMHg1My8weDYwIGFyY2gveDg2L2t2bS8uLi8uLi8uLi92aXJ0L2t2bS9rdm1fbWFpbi5jOjM0ODkgX19mcHV0KzB4M2ZjLzB4ODcwIGZzL2ZpbGVfdGFibGUuYzoyODAgdGFza193b3JrX3J1bisweDE0Ni8weDFjMCBrZXJuZWwvdGFza193b3JrLmM6MTY0IGV4aXRfdGFza193b3JrIGluY2x1ZGUvbGludXgvdGFza193b3JrLmg6MzIgW2lubGluZV0gZG9fZXhpdCsweDcwNS8weDI0ZjAga2VybmVsL2V4aXQuYzo4MzIgZG9fZ3JvdXBfZXhpdCsweDE2OC8weDJkMCBrZXJuZWwvZXhpdC5jOjkyOSBnZXRfc2lnbmFsKzB4MTc0MC8weDIxMjAga2VybmVsL3NpZ25hbC5jOjI4NTIgYXJjaF9kb19zaWduYWxfb3JfcmVzdGFydCsweDljLzB4NzMwIGFyY2gveDg2L2tlcm5lbC9zaWduYWwuYzo4NjggaGFuZGxlX3NpZ25hbF93b3JrIGtlcm5lbC9lbnRyeS9jb21tb24uYzoxNDggW2lubGluZV0gZXhpdF90b191c2VyX21vZGVfbG9vcCBrZXJuZWwvZW50cnkvY29tbW9uLmM6MTcyIFtpbmxpbmVdIGV4aXRfdG9fdXNlcl9tb2RlX3ByZXBhcmUrMHgxOTEvMHgyMjAga2VybmVsL2VudHJ5L2NvbW1vbi5jOjIwNyBfX3N5c2NhbGxfZXhpdF90b191c2VyX21vZGVfd29yayBrZXJuZWwvZW50cnkvY29tbW9uLmM6Mjg5IFtpbmxpbmVdIHN5c2NhbGxfZXhpdF90b191c2VyX21vZGUrMHgyZS8weDcwIGtlcm5lbC9lbnRyeS9jb21tb24uYzozMDAgZG9fc3lzY2FsbF82NCsweDUzLzB4ZDAgYXJjaC94ODYvZW50cnkvY29tbW9uLmM6ODYgZW50cnlfU1lTQ0FMTF82NF9hZnRlcl9od2ZyYW1lKzB4NDQvMHhhZSBGaXhlczogYzg2MDdlNGEwODZmICgiS1ZNOiB4ODY6IG5WTVg6IGRvbid0IGZhaWwgbmVzdGVkIFZNIGVudHJ5IG9uIGludmFsaWQgZ3Vlc3Qgc3RhdGUgaWYgIWZyb21fdm1lbnRyeSIpIFJlcG9ydGVkLWJ5OiBzeXpib3QrZjFkMjEzNmRiOWM4MGQ0NzMzZThAc3l6a2FsbGVyLmFwcHNwb3RtYWlsLmNvbSBSZXZpZXdlZC1ieTogTWF4aW0gTGV2aXRza3kgPG1sZXZpdHNrPiBDYzogc3RhYmxlQHZnZXIua2VybmVsLm9yZyBTaWduZWQtb2ZmLWJ5OiBTZWFuIENocmlzdG9waGVyc29uIDxzZWFuamM+IE1lc3NhZ2UtSWQ6ICZsdDsyMDIxMTIwNzE5MzAwNi4xMjA5OTctMi1zZWFuamNAZ29vZ2xlLmNvbSZndDsgU2lnbmVkLW9mZi1ieTogUGFvbG8gQm9uemluaSA8cGJvbnppbmk+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgNTQzYmZiY2I1Y2Y1MTE0NzdhMTQzYzcxMTQwZDNlMjZiNTgyNjg0YSBBdXRob3I6IFNlYW4gQ2hyaXN0b3BoZXJzb24gPHNlYW5qYz4gRGF0ZTogVHVlIERlYyA3IDE5OjMwOjA0IDIwMjEgKzAwMDAgS1ZNOiBuVk1YOiBTeW50aGVzaXplIFRSSVBMRV9GQVVMVCBmb3IgTDIgaWYgZW11bGF0aW9uIGlzIHJlcXVpcmVkIGNvbW1pdCBjZDBlNjE1YzQ5ZTVlNWQ2OTg4NWFmOWFjM2I0ZmE3YmIzMzg3ZjU4IHVwc3RyZWFtLiBTeW50aGVzaXplIGEgdHJpcGxlIGZhdWx0IGlmIEwyIGd1ZXN0IHN0YXRlIGlzIGludmFsaWQgYXQgdGhlIHRpbWUgb2YgVk0tRW50ZXIsIHdoaWNoIGNhbiBoYXBwZW4gaWYgTDEgbW9kaWZpZXMgU01SQU0gb3IgaWYgdXNlcnNwYWNlIHN0dWZmcyBndWVzdCBzdGF0ZSB2aWEgaW9jdGxzKCksIGUuZy4gS1ZNX1NFVF9TUkVHUy4gS1ZNIHNob3VsZCBuZXZlciBlbXVsYXRlIGludmFsaWQgZ3Vlc3Qgc3RhdGUsIHNpbmNlIGZyb20gTDEncyBwZXJzcGVjdGl2ZSwgaXQncyBhcmNoaXRlY3R1cmFsbHkgaW1wb3NzaWJsZSBmb3IgTDIgdG8gaGF2ZSBpbnZhbGlkIHN0YXRlIHdoaWxlIEwyIGlzIHJ1bm5pbmcgaW4gaGFyZHdhcmUuIEUuZy4gYXR0ZW1wdHMgdG8gc2V0IENSMCBvciBDUjQgdG8gdW5zdXBwb3J0ZWQgdmFsdWVzIHdpbGwgZWl0aGVyIFZNLUV4aXQgb3IgI0dQLiBNb2RpZnlpbmcgdkNQVSBzdGF0ZSB2aWEgUlNNK1NNUkFNIGFuZCBpb2N0bCgpIGFyZSB0aGUgb25seSBwYXRocyB0aGF0IGNhbiB0cmlnZ2VyIHRoaXMgc2NlbmFyaW8sIGFzIG5lc3RlZCBWTS1FbnRlciBjb3JyZWN0bHkgcmVqZWN0cyBhbnkgYXR0ZW1wdCB0byBlbnRlciBMMiB3aXRoIGludmFsaWQgc3RhdGUuIFJTTSBpcyBhIHN0cmFpZ2h0Zm9yd2FyZCBjYXNlIGFzIChhKSBLVk0gZm9sbG93cyBBTUQncyBTTVJBTSBsYXlvdXQgYW5kIGJlaGF2aW9yLCBhbmQgKGIpIEludGVsJ3MgU0RNIHN0YXRlcyB0aGF0IGxvYWRpbmcgcmVzZXJ2ZWQgQ1IwL0NSNCBiaXRzIHZpYSBSU00gcmVzdWx0cyBpbiBzaHV0ZG93biwgaS5lLiB0aGVyZSBpcyBwcmVjZWRlbnQgZm9yIEtWTSdzIGJlaGF2aW9yLiBGb2xsb3dpbmcgQU1EJ3MgU01SQU0gbGF5b3V0IGlzIGltcG9ydGFudCBhcyBBTUQncyBsYXlvdXQgc2F2ZXMvcmVzdG9yZXMgdGhlIGRlc2NyaXB0b3IgY2FjaGUgaW5mb3JtYXRpb24sIGluY2x1ZGluZyBDUy5SUEwgYW5kIFNTLlJQTCwgYW5kIGFsc28gZGVmaW5lcyBhbGwgdGhlIGZpZWxkcyByZWxldmFudCB0byBpbnZhbGlkIGd1ZXN0IHN0YXRlIGFzIHJlYWQtb25seSwgaS5lLiBzbyBsb25nIGFzIHRoZSB2Q1BVIGhhZCB2YWxpZCBzdGF0ZSBiZWZvcmUgdGhlIFNNSSwgd2hpY2ggaXMgZ3VhcmFudGVlZCBmb3IgTDIsIFJTTSB3aWxsIGdlbmVyYXRlIHZhbGlkIHN0YXRlIHVubGVzcyBTTVJBTSB3YXMgbW9kaWZpZWQuIEludGVsJ3MgbGF5b3V0IHNhdmVzL3Jlc3RvcmVzIG9ubHkgdGhlIHNlbGVjdG9yLCB3aGljaCBtZWFucyB0aGF0IHNjZW5hcmlvcyB3aGVyZSB0aGUgc2VsZWN0b3IgYW5kIGNhY2hlZCBSUEwgZG9uJ3QgbWF0Y2gsIGUuZy4gY29uZm9ybWluZyBjb2RlIHNlZ21lbnRzLCB3b3VsZCB5aWVsZCBpbnZhbGlkIGd1ZXN0IHN0YXRlLiBJbnRlbCBDUFVzIGZ1ZGdlIGFyb3VuZCB0aGlzIGlzc3VlZCBieSBzdHVmZmluZyBTUy5SUEwgYW5kIENTLlJQTCBvbiBSU00uIFBlciBJbnRlbCdzIFNETSBvbiB0aGUgIkRlZmF1bHQgVHJlYXRtZW50IG9mIFJTTSIsIHBhcmFwaHJhc2luZyBmb3IgYnJldml0eTogSUYgaW50ZXJuYWwgc3RvcmFnZSBpbmRpY2F0ZXMgdGhhdCB0aGUgW0NQVSB3YXMgcG9zdC1WTVhPTl0gVEhFTiBlbnRlciBWTVggb3BlcmF0aW9uIChyb290IG9yIG5vbi1yb290KTsgcmVzdG9yZSBWTVgtY3JpdGljYWwgc3RhdGUgYXMgZGVmaW5lZCBpbiBTZWN0aW9uIDM0LjE0LjE7IHNldCB0byB0aGVpciBmaXhlZCB2YWx1ZXMgYW55IGJpdHMgaW4gQ1IwIGFuZCBDUjQgd2hvc2UgdmFsdWVzIG11c3QgYmUgZml4ZWQgaW4gVk1YIG9wZXJhdGlvbiBbdW5sZXNzIGNvbWluZyBmcm9tIGFuIHVucmVzdHJpY3RlZCBndWVzdF07IElGIFJGTEFHUy5WTSA9IDAgQU5EIChpbiBWTVggcm9vdCBvcGVyYXRpb24gT1IgdGhlIOKAnHVucmVzdHJpY3RlZCBndWVzdOKAnSBWTS1leGVjdXRpb24gY29udHJvbCBpcyAwKSBUSEVOIENTLlJQTCA6PSBTUy5EUEw7IFNTLlJQTCA6PSBTUy5EUEw7IEZJOyByZXN0b3JlIGN1cnJlbnQgVk1DUyBwb2ludGVyOyBGSTsgTm90ZSB0aGF0IEludGVsIENQVXMgYWxzbyBvdmVyd3JpdGUgdGhlIGZpeGVkIENSMC9DUjQgYml0cywgd2hlcmVhcyBLVk0gd2lsbCBzeXRoZXNpemUgVFJJUExFX0ZBVUxUIGluIHRoaXMgc2NlbmFyaW8uIEtWTSdzIGJlaGF2aW9yIGlzIGFsbG93ZWQgYXMgYm90aCBJbnRlbCBhbmQgQU1EIGRlZmluZSBDUjAvQ1I0IFNNUkFNIGZpZWxkcyBhcyByZWFkLW9ubHksIGkuZS4gdGhlIG9ubHkgd2F5IGZvciBDUjAgYW5kL29yIENSNCB0byBoYXZlIGlsbGVnYWwgdmFsdWVzIGlzIGlmIHRoZXkgd2VyZSBtb2RpZmllZCBieSB0aGUgTDEgU01NIGhhbmRsZXIsIGFuZCBJbnRlbCdzIFNETSAiU01SQU0gU3RhdGUgU2F2ZSBNYXAiIHNlY3Rpb24gc3RhdGVzICJtb2RpZnlpbmcgdGhlc2UgcmVnaXN0ZXJzIHdpbGwgcmVzdWx0IGluIHVucHJlZGljdGFibGUgYmVoYXZpb3IiLiBLVk0ncyBpb2N0bCgpIGJlaGF2aW9yIGlzIGxlc3Mgc3RyYWlnaHRmb3J3YXJkLiBCZWNhdXNlIEtWTSBhbGxvd3MgaW9jdGxzKCkgdG8gYmUgZXhlY3V0ZWQgaW4gYW55IG9yZGVyLCByZWplY3RpbmcgYW4gaW9jdGwoKSBpZiBpdCB3b3VsZCByZXN1bHQgaW4gaW52YWxpZCBMMiBndWVzdCBzdGF0ZSBpcyBub3QgYW4gb3B0aW9uIGFzIEtWTSBjYW5ub3Qga25vdyBpZiBhIGZ1dHVyZSBpb2N0bCgpIHdvdWxkIHJlc29sdmUgdGhlIGludmFsaWQgc3RhdGUsIGUuZy4gS1ZNX1NFVF9TUkVHUywgb3IgZHJvcCB0aGUgdkNQVSBvdXQgb2YgTDIsIGUuZy4gS1ZNX1NFVF9ORVNURURfU1RBVEUuIElkZWFsbHksIEtWTSB3b3VsZCByZWplY3QgS1ZNX1JVTiBpZiBMMiBjb250YWluZWQgaW52YWxpZCBndWVzdCBzdGF0ZSwgYnV0IHRoYXQgY2FycmllcyB0aGUgcmlzayBvZiBhIGZhbHNlIHBvc2l0aXZlLCBlLmcuIGlmIFJTTSBsb2FkZWQgaW52YWxpZCBndWVzdCBzdGF0ZSBhbmQgS1ZNIGV4aXRlZCB0byB1c2Vyc3BhY2UuIFNldHRpbmcgYSBmbGFnL3JlcXVlc3QgdG8gZGV0ZWN0IHN1Y2ggYSBzY2VuYXJpbyBpcyB1bmRlc2lyYWJsZSBiZWNhdXNlIChhKSBpdCdzIGV4dHJlbWVseSB1bmxpa2VseSB0byBhZGQgdmFsdWUgdG8gS1ZNIGFzIGEgd2hvbGUsIGFuZCAoYikgS1ZNIHdvdWxkIG5lZWQgdG8gY29uc2lkZXIgaW9jdGwoKSBpbnRlcmFjdGlvbnMgd2l0aCBzdWNoIGEgZmxhZywgZS5nLiBpZiB1c2Vyc3BhY2UgbWlncmF0ZWQgdGhlIHZDUFUgd2hpbGUgdGhlIGZsYWcgd2VyZSBzZXQuIENjOiBzdGFibGVAdmdlci5rZXJuZWwub3JnIFNpZ25lZC1vZmYtYnk6IFNlYW4gQ2hyaXN0b3BoZXJzb24gPHNlYW5qYz4gTWVzc2FnZS1JZDogJmx0OzIwMjExMjA3MTkzMDA2LjEyMDk5Ny0zLXNlYW5qY0Bnb29nbGUuY29tJmd0OyBSZXZpZXdlZC1ieTogTWF4aW0gTGV2aXRza3kgPG1sZXZpdHNrPiBTaWduZWQtb2ZmLWJ5OiBQYW9sbyBCb256aW5pIDxwYm9uemluaT4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCBkODg0ZWVmZDc1Y2M1NDg4N2JjMmU5ZTcyNDIwNzQ0MzUyNWRmYjJjIEF1dGhvcjogU2VhbiBDaHJpc3RvcGhlcnNvbiA8c2VhbmpjPiBEYXRlOiBUdWUgRGVjIDE0IDAzOjM1OjI4IDIwMjEgKzAwMDAgS1ZNOiB4ODYvbW11OiBEb24ndCBhZHZhbmNlIGl0ZXJhdG9yIGFmdGVyIHJlc3RhcnQgZHVlIHRvIHlpZWxkaW5nIGNvbW1pdCAzYTBmNjRkZTQ3OWNhZTc1ZWZmYjYzMGEyZTBhMjM3Y2EwZDA2MjNjIHVwc3RyZWFtLiBBZnRlciBkcm9wcGluZyBtbXVfbG9jayBpbiB0aGUgVERQIE1NVSwgcmVzdGFydCB0aGUgaXRlcmF0b3IgZHVyaW5nIHRkcF9pdGVyX25leHQoKSBhbmQgZG8gbm90IGFkdmFuY2UgdGhlIGl0ZXJhdG9yLiBBZHZhbmNpbmcgdGhlIGl0ZXJhdG9yIHJlc3VsdHMgaW4gc2tpcHBpbmcgdGhlIHRvcC1sZXZlbCBTUFRFIGFuZCBhbGwgaXRzIGNoaWxkcmVuLCB3aGljaCBpcyBmYXRhbCBpZiBhbnkgb2YgdGhlIHNraXBwZWQgU1BURXMgd2VyZSBub3QgdmlzaXRlZCBiZWZvcmUgeWllbGRpbmcuIFdoZW4gemFwcGluZyBhbGwgU1BURXMsIGkuZS4gd2hlbiBtaW5fbGV2ZWwgPT0gcm9vdF9sZXZlbCwgcmVzdGFydGluZyB0aGUgaXRlciBhbmQgdGhlbiBpbnZva2luZyB0ZHBfaXRlcl9uZXh0KCkgaXMgYWx3YXlzIGZhdGFsIGlmIHRoZSBjdXJyZW50IGdmbiBoYXMgYXMgYSB2YWxpZCBTUFRFLCBhcyBhZHZhbmNpbmcgdGhlIGl0ZXJhdG9yIHJlc3VsdHMgaW4gdHJ5X3N0ZXBfc2lkZSgpIHNraXBwaW5nIHRoZSBjdXJyZW50IGdmbiwgd2hpY2ggd2Fzbid0IHZpc2l0ZWQgYmVmb3JlIHlpZWxkaW5nLiBTcHJpbmtsZSBXQVJOcyBvbiBpdGVyLSZndDt5aWVsZGVkIGJlaW5nIHRydWUgaW4gdmFyaW91cyBoZWxwZXJzIHRoYXQgYXJlIG9mdGVuIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB5aWVsZGluZywgYW5kIHRhZyB0aGUgaGVscGVyIHdpdGggX19tdXN0X2NoZWNrIHRvIHJlZHVjZSB0aGUgcHJvYmFiaWx5IG9mIGltcHJvcGVyIHVzYWdlLiBGYWlsaW5nIHRvIHphcCBhIHRvcC1sZXZlbCBTUFRFIG1hbmlmZXN0cyBpbiBvbmUgb2YgdHdvIHdheXMuIElmIGEgdmFsaWQgU1BURSBpcyBza2lwcGVkIGJ5IGJvdGgga3ZtX3RkcF9tbXVfemFwX2FsbCgpIGFuZCBrdm1fdGRwX21tdV9wdXRfcm9vdCgpLCB0aGUgc2hhZG93IHBhZ2Ugd2lsbCBiZSBsZWFrZWQgYW5kIEtWTSB3aWxsIFdBUk4gYWNjb3JkaW5nbHkuIFdBUk5JTkc6IENQVTogMSBQSUQ6IDM1MDkgYXQgYXJjaC94ODYva3ZtL21tdS90ZHBfbW11LmM6NDYgW2t2bV0gUklQOiAwMDEwOmt2bV9tbXVfdW5pbml0X3RkcF9tbXUrMHgzZS8weDUwIFtrdm1dIENhbGwgVHJhY2U6IDx0YXNrPiBrdm1fYXJjaF9kZXN0cm95X3ZtKzB4MTMwLzB4MWIwIFtrdm1dIGt2bV9kZXN0cm95X3ZtKzB4MTYyLzB4MmEwIFtrdm1dIGt2bV92Y3B1X3JlbGVhc2UrMHgzNC8weDYwIFtrdm1dIF9fZnB1dCsweDgyLzB4MjQwIHRhc2tfd29ya19ydW4rMHg1Yy8weDkwIGRvX2V4aXQrMHgzNjQvMHhhMTAgPyBmdXRleF91bnF1ZXVlKzB4MzgvMHg2MCBkb19ncm91cF9leGl0KzB4MzMvMHhhMCBnZXRfc2lnbmFsKzB4MTU1LzB4ODUwIGFyY2hfZG9fc2lnbmFsX29yX3Jlc3RhcnQrMHhlZC8weDc1MCBleGl0X3RvX3VzZXJfbW9kZV9wcmVwYXJlKzB4YzUvMHgxMjAgc3lzY2FsbF9leGl0X3RvX3VzZXJfbW9kZSsweDFkLzB4NDAgZG9fc3lzY2FsbF82NCsweDQ4LzB4YzAgZW50cnlfU1lTQ0FMTF82NF9hZnRlcl9od2ZyYW1lKzB4NDQvMHhhZSBJZiBrdm1fdGRwX21tdV96YXBfYWxsKCkgc2tpcHMgYSBnZm4vU1BURSBidXQgdGhhdCBTUFRFIGlzIHRoZW4gemFwcGVkIGJ5IGt2bV90ZHBfbW11X3B1dF9yb290KCksIEtWTSB0cmlnZ2VycyBhIHVzZS1hZnRlci1mcmVlIGluIHRoZSBmb3JtIG9mIG1hcmtpbmcgYSBzdHJ1Y3QgcGFnZSBhcyBkaXJ0eS9hY2Nlc3NlZCBhZnRlciBpdCBoYXMgYmVlbiBwdXQgYmFjayBvbiB0aGUgZnJlZSBsaXN0LiBUaGlzIGRpcmVjdGx5IHRyaWdnZXJzIGEgV0FSTiBkdWUgdG8gZW5jb3VudGVyaW5nIGEgcGFnZSB3aXRoIHBhZ2VfY291bnQoKSA9PSAwLCBidXQgaXQgY2FuIGFsc28gbGVhZCB0byBkYXRhIGNvcnJ1cHRpb24gYW5kIGFkZGl0aW9uYWwgZXJyb3JzIGluIHRoZSBrZXJuZWwuIFdBUk5JTkc6IENQVTogNyBQSUQ6IDE5OTU2NTggYXQgYXJjaC94ODYva3ZtLy4uLy4uLy4uL3ZpcnQva3ZtL2t2bV9tYWluLmM6MTcxIFJJUDogMDAxMDprdm1faXNfem9uZV9kZXZpY2VfcGZuLnBhcnQuMCsweDllLzB4ZDAgW2t2bV0gQ2FsbCBUcmFjZTogPHRhc2s+IGt2bV9zZXRfcGZuX2RpcnR5KzB4MTIwLzB4MWQwIFtrdm1dIF9faGFuZGxlX2NoYW5nZWRfc3B0ZSsweDkyZS8weGNhMCBba3ZtXSBfX2hhbmRsZV9jaGFuZ2VkX3NwdGUrMHg2M2MvMHhjYTAgW2t2bV0gX19oYW5kbGVfY2hhbmdlZF9zcHRlKzB4NjNjLzB4Y2EwIFtrdm1dIF9faGFuZGxlX2NoYW5nZWRfc3B0ZSsweDYzYy8weGNhMCBba3ZtXSB6YXBfZ2ZuX3JhbmdlKzB4NTQ5LzB4NjIwIFtrdm1dIGt2bV90ZHBfbW11X3B1dF9yb290KzB4MWI2LzB4MjcwIFtrdm1dIG1tdV9mcmVlX3Jvb3RfcGFnZSsweDIxOS8weDJjMCBba3ZtXSBrdm1fbW11X2ZyZWVfcm9vdHMrMHgxYjQvMHg0ZTAgW2t2bV0ga3ZtX21tdV91bmxvYWQrMHgxYy8weGEwIFtrdm1dIGt2bV9hcmNoX2Rlc3Ryb3lfdm0rMHgxZjIvMHg1YzAgW2t2bV0ga3ZtX3B1dF9rdm0rMHgzYjEvMHg4YjAgW2t2bV0ga3ZtX3ZjcHVfcmVsZWFzZSsweDRlLzB4NzAgW2t2bV0gX19mcHV0KzB4MWY3LzB4OGMwIHRhc2tfd29ya19ydW4rMHhmOC8weDFhMCBkb19leGl0KzB4OTdiLzB4MjIzMCBkb19ncm91cF9leGl0KzB4ZGEvMHgyYTAgZ2V0X3NpZ25hbCsweDNiZS8weDFlNTAgYXJjaF9kb19zaWduYWxfb3JfcmVzdGFydCsweDI0NC8weDE3ZjAgZXhpdF90b191c2VyX21vZGVfcHJlcGFyZSsweGNiLzB4MTIwIHN5c2NhbGxfZXhpdF90b191c2VyX21vZGUrMHgxZC8weDQwIGRvX3N5c2NhbGxfNjQrMHg0ZC8weDkwIGVudHJ5X1NZU0NBTExfNjRfYWZ0ZXJfaHdmcmFtZSsweDQ0LzB4YWUgTm90ZSwgdGhlIHVuZGVybHlpbmcgYnVnIGV4aXN0ZWQgZXZlbiBiZWZvcmUgY29tbWl0IDFhZjRhOTYwMjViMyAoIktWTTogeDg2L21tdTogWWllbGQgaW4gVERVIE1NVSBpdGVyIGV2ZW4gaWYgbm8gU1BURVMgY2hhbmdlZCIpIG1vdmVkIGNhbGxzIHRvIHRkcF9tbXVfaXRlcl9jb25kX3Jlc2NoZWQoKSB0byB0aGUgYmVnaW5uaW5nIG9mIGxvb3BzLCBhcyBLVk0gY291bGQgc3RpbGwgaW5jb3JyZWN0bHkgYWR2YW5jZSBwYXN0IGEgdG9wLWxldmVsIGVudHJ5IHdoZW4geWllbGRpbmcgb24gYSBsb3dlci1sZXZlbCBlbnRyeS4gQnV0IHdpdGggcmVzcGVjdCB0byBsZWFraW5nIHNoYWRvdyBwYWdlcywgdGhlIGJ1ZyB3YXMgaW50cm9kdWNlZCBieSB5aWVsZGluZyBiZWZvcmUgcHJvY2Vzc2luZyB0aGUgY3VycmVudCBnZm4uIEFsdGVybmF0aXZlbHksIHRkcF9tbXVfaXRlcl9jb25kX3Jlc2NoZWQoKSBjb3VsZCBzaW1wbHkgZmFsbCB0aHJvdWdoLCBvciBjYWxsZXJzIGNvdWxkIGp1bXAgdG8gdGhlaXIgInJldHJ5IiBsYWJlbC4gVGhlIGRvd25zaWRlIG9mIHRoYXQgYXBwcm9hY2ggaXMgdGhhdCB0ZHBfbW11X2l0ZXJfY29uZF9yZXNjaGVkKCkgX211c3RfIGJlIGNhbGxlZCBiZWZvcmUgYW55dGhpbmcgZWxzZSBpbiB0aGUgbG9vcCwgYW5kIHRoZXJlJ3Mgbm8gZWFzeSB3YXkgdG8gZW5mb3JuY2UgdGhhdCByZXF1aXJlbWVudC4gSWRlYWxseSwgS1ZNIHdvdWxkIGhhbmRsaW5nIHRoZSBjb25kX3Jlc2NoZWQoKSBmdWxseSB3aXRoaW4gdGhlIGl0ZXJhdG9yIG1hY3JvICh0aGUgY29kZSBpcyBhY3R1YWxseSBxdWl0ZSBjbGVhbikgYW5kIGF2b2lkIHRoaXMgZW50aXJlIGNsYXNzIG9mIGJ1Z3MsIGJ1dCB0aGF0IGlzIGV4dHJlbWVseSBkaWZmaWN1bHQgZG8gd2hpbGUgYWxzbyBzdXBwb3J0aW5nIHlpZWxkaW5nIGFmdGVyIHRkcF9tbXVfc2V0X3NwdGVfYXRvbWljKCkgZmFpbHMuIFlpZWxkaW5nIGFmdGVyIGZhaWxpbmcgdG8gc2V0IGEgU1BURSBpcyB2ZXJ5IGRlc2lyYWJsZSBhcyB0aGUgIm93bmVyIiBvZiB0aGUgUkVNT1ZFRF9TUFRFIGlzbid0IHN0cmljdGx5IGJvdW5kZWQsIGUuZy4gaWYgaXQncyB6YXBwaW5nIGEgaGlnaC1sZXZlbCBzaGFkb3cgcGFnZSwgdGhlIFJFTU9WRURfU1BURSBtYXkgYmxvY2sgb3BlcmF0aW9ucyBvbiB0aGUgU1BURSBmb3IgYSBzaWduaWZpY2FudCBhbW91bnQgb2YgdGltZS4gRml4ZXM6IGZhYWYwNWIwMGFlYyAoImt2bTogeDg2L21tdTogU3VwcG9ydCB6YXBwaW5nIFNQVEVzIGluIHRoZSBURFAgTU1VIikgRml4ZXM6IDFhZjRhOTYwMjViMyAoIktWTTogeDg2L21tdTogWWllbGQgaW4gVERVIE1NVSBpdGVyIGV2ZW4gaWYgbm8gU1BURVMgY2hhbmdlZCIpIFJlcG9ydGVkLWJ5OiBJZ25hdCBLb3JjaGFnaW4gPGlnbmF0PiBDYzogc3RhYmxlQHZnZXIua2VybmVsLm9yZyBTaWduZWQtb2ZmLWJ5OiBTZWFuIENocmlzdG9waGVyc29uIDxzZWFuamM+IE1lc3NhZ2UtSWQ6ICZsdDsyMDIxMTIxNDAzMzUyOC4xMjMyNjgtMS1zZWFuamNAZ29vZ2xlLmNvbSZndDsgU2lnbmVkLW9mZi1ieTogUGFvbG8gQm9uemluaSA8cGJvbnppbmk+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgNWRlYTc2ZjVkYTY1NWE1OTk4ZGE5YTA2ZTE2YzJiMGUzMTFlYmVmYyBBdXRob3I6IE1hcmMgT3JyIDxtYXJjb3JyPiBEYXRlOiBUaHUgRGVjIDkgMDc6NTI6NTcgMjAyMSAtMDgwMCBLVk06IHg4NjogQWx3YXlzIHNldCBrdm1fcnVuLSZndDtpZl9mbGFnIGNvbW1pdCBjNTA2MzU1MWJmY2FlNGU0OGZlYzg5MGI3YmYzNjk1OThiNzc1MjZiIHVwc3RyZWFtLiBUaGUga3ZtX3J1biBzdHJ1Y3QncyBpZl9mbGFnIGlzIGEgcGFydCBvZiB0aGUgdXNlcnNwYWNlL2tlcm5lbCBBUEkuIFRoZSBTRVYtRVMgcGF0Y2hlcyBmYWlsZWQgdG8gc2V0IHRoaXMgZmxhZyBiZWNhdXNlIGl0J3Mgbm8gbG9uZ2VyIG5lZWRlZCBieSBRRU1VIChhY2NvcmRpbmcgdG8gdGhlIGNvbW1lbnQgaW4gdGhlIHNvdXJjZSBjb2RlKS4gSG93ZXZlciwgb3RoZXIgaHlwZXJ2aXNvcnMgbWF5IG1ha2UgdXNlIG9mIHRoaXMgZmxhZy4gVGhlcmVmb3JlLCBzZXQgdGhlIGZsYWcgZm9yIGd1ZXN0cyB3aXRoIGVuY3J5cHRlZCByZWdpc3RlcnMgKGkuZS4sIHdpdGggZ3Vlc3Rfc3RhdGVfcHJvdGVjdGVkIHNldCkuIEZpeGVzOiBmMWM2MzY2ZTMwNDMgKCJLVk06IFNWTTogQWRkIHJlcXVpcmVkIGNoYW5nZXMgdG8gc3VwcG9ydCBpbnRlcmNlcHRzIHVuZGVyIFNFVi1FUyIpIFNpZ25lZC1vZmYtYnk6IE1hcmMgT3JyIDxtYXJjb3JyPiBNZXNzYWdlLUlkOiAmbHQ7MjAyMTEyMDkxNTUyNTcuMTI4NzQ3LTEtbWFyY29yckBnb29nbGUuY29tJmd0OyBDYzogc3RhYmxlQHZnZXIua2VybmVsLm9yZyBTaWduZWQtb2ZmLWJ5OiBQYW9sbyBCb256aW5pIDxwYm9uemluaT4gUmV2aWV3ZWQtYnk6IE1heGltIExldml0c2t5IDxtbGV2aXRzaz4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCA5Y2ExMzI0NzU1ZjFmODYyOWEzNzBhZjVjYzMxNWIxNzUzMzFmNWQxIEF1dGhvcjogSm9oYW4gSG92b2xkIDxqb2hhbj4gRGF0ZTogV2VkIERlYyAyMiAxMTo1MDoyMyAyMDIxICswMTAwIHBsYXRmb3JtL3g4NjogaW50ZWxfcG1jX2NvcmU6IGZpeCBtZW1sZWFrIG9uIHJlZ2lzdHJhdGlvbiBmYWlsdXJlIGNvbW1pdCAyNmE4YjA5NDM3ODA0ZmFiZmIxZGIwODBkNjc2Yjk2YzBkZTY4ZTdjIHVwc3RyZWFtLiBJbiBjYXNlIGRldmljZSByZWdpc3RyYXRpb24gZmFpbHMgZHVyaW5nIG1vZHVsZSBpbml0aWFsaXNhdGlvbiwgdGhlIHBsYXRmb3JtIGRldmljZSBzdHJ1Y3R1cmUgbmVlZHMgdG8gYmUgZnJlZWQgdXNpbmcgcGxhdGZvcm1fZGV2aWNlX3B1dCgpIHRvIHByb3Blcmx5IGZyZWUgYWxsIHJlc291cmNlcyAoZS5nLiB0aGUgZGV2aWNlIG5hbWUpLiBGaXhlczogOTM4ODM1YWE5MDNhICgicGxhdGZvcm0veDg2OiBpbnRlbF9wbWNfY29yZTogZG8gbm90IGNyZWF0ZSBhIHN0YXRpYyBzdHJ1Y3QgZGV2aWNlIikgQ2M6IHN0YWJsZUB2Z2VyLmtlcm5lbC5vcmcgIyA1LjkgU2lnbmVkLW9mZi1ieTogSm9oYW4gSG92b2xkIDxqb2hhbj4gUmV2aWV3ZWQtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMjIyMTA1MDIzLjYyMDUtMS1qb2hhbkBrZXJuZWwub3JnIFNpZ25lZC1vZmYtYnk6IEhhbnMgZGUgR29lZGUgPGhkZWdvZWRlPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGE0MmM0MWJlODMyNGEzNGIzN2MxZThlYjgxYzQ2OWNhYjg1ZTFmYzggQXV0aG9yOiBNYXJpbyBMaW1vbmNpZWxsbyA8bWFyaW8ubGltb25jaWVsbG8+IERhdGU6IEZyaSBEZWMgMTAgMDg6MzU6MjkgMjAyMSAtMDYwMCBwbGF0Zm9ybS94ODY6IGFtZC1wbWM6IG9ubHkgdXNlIGNhbGxiYWNrcyBmb3Igc3VzcGVuZCBjb21taXQgMDlmYzE0MDYxZjNlZDI4ODk5YzIzYjg3MTRjMDY2OTQ2ZmRiZDQzZSB1cHN0cmVhbS4gVGhpcyBkcml2ZXIgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBleGNsdXNpdmVseSBmb3Igc3VzcGVuZCB0byBpZGxlIHNvIGNhbGxiYWNrcyB0byBzZW5kIE9TX0hJTlQgZHVyaW5nIGhpYmVybmF0ZSBhbmQgUzUgd2lsbCBzZXQgT1NfSElOVCBhdCB0aGUgd3JvbmcgdGltZSBsZWFkaW5nIHRvIGFuIHVuZGVmaW5lZCBiZWhhdmlvci4gQ2M6IHN0YWJsZUB2Z2VyLmtlcm5lbC5vcmcgU2lnbmVkLW9mZi1ieTogTWFyaW8gTGltb25jaWVsbG8gPG1hcmlvLmxpbW9uY2llbGxvPiBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMjEwMTQzNTI5LjEwNTk0LTEtbWFyaW8ubGltb25jaWVsbG9AYW1kLmNvbSBSZXZpZXdlZC1ieTogSGFucyBkZSBHb2VkZSA8aGRlZ29lZGU+IFNpZ25lZC1vZmYtYnk6IEhhbnMgZGUgR29lZGUgPGhkZWdvZWRlPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDllZGUwN2M0YWYxNGE3MmY0NTJmMGNlZmM3ZWZlYzdhZjc2ZDA0YzggQXV0aG9yOiBBbmRyZXcgQ29vcGVyIDxhbmRyZXcuY29vcGVyMz4gRGF0ZTogVGh1IERlYyAxNiAwMDowODo1NiAyMDIxICswMDAwIHg4Ni9wa2V5OiBGaXggdW5kZWZpbmVkIGJlaGF2aW91ciB3aXRoIFBLUlVfV0RfQklUIGNvbW1pdCA1NzY5MDU1NGFiZTEzNWZlZTgxZDZhYzMzY2M5NGQ3NWE3ZTIyNGJiIHVwc3RyZWFtLiBCb3RoIF9fcGtydV9hbGxvd3Nfd3JpdGUoKSBhbmQgYXJjaF9zZXRfdXNlcl9wa2V5X2FjY2VzcygpIHNoaWZ0IFBLUlVfV0RfQklUIChhIHNpZ25lZCBjb25zdGFudCkgYnkgdXAgdG8gMzAgYml0cywgaGl0dGluZyB0aGUgc2lnbiBiaXQuIFVzZSB1bnNpZ25lZCBjb25zdGFudHMgaW5zdGVhZC4gQ2xlYXJseSBwa2V5IDE1IGhhcyBub3QgYmVlbiB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggVUJTQU4geWV0LiBOb3RpY2VkIGJ5IGNvZGUgaW5zcGVjdGlvbiBvbmx5LiBJIGNhbid0IGFjdHVhbGx5IHByb3Zva2UgdGhlIGNvbXBpbGVyIGludG8gZ2VuZXJhdGluZyBpbmNvcnJlY3QgbG9naWMgYXMgZmFyIGFzIHRoaXMgc2hpZnQgaXMgY29uY2VybmVkLiBbIGRoYW5zZW46IGFkZCBzdGFibGVAIHRhZywgcGx1cyBtaW5vciBjaGFuZ2Vsb2cgbWFzc2FnaW5nLCBGb3IgYW55b25lIGRvaW5nIGJhY2twb3J0cywgdGhlc2UgI2RlZmluZXMgd2VyZSBpbiBhcmNoL3g4Ni9pbmNsdWRlL2FzbS9wZ3RhYmxlLmggYmVmb3JlIDc4NGE0NjYxOGY2LiBdIEZpeGVzOiAzM2E3MDliMjVhNzYgKCJtbS9ndXAsIHg4Ni9tbS9wa2V5czogQ2hlY2sgVk1BcyBhbmQgUFRFcyBmb3IgcHJvdGVjdGlvbiBrZXlzIikgU2lnbmVkLW9mZi1ieTogQW5kcmV3IENvb3BlciA8YW5kcmV3LmNvb3BlcjM+IFNpZ25lZC1vZmYtYnk6IERhdmUgSGFuc2VuIDwvYW5kcmV3LmNvb3BlcjM+PC9hbmRyZXcuY29vcGVyMz48L2dyZWdraD48L2hkZWdvZWRlPjwvaGRlZ29lZGU+PC9tYXJpby5saW1vbmNpZWxsbz48L21hcmlvLmxpbW9uY2llbGxvPjwvZ3JlZ2toPjwvaGRlZ29lZGU+PC9ncmVna2g+PC9qb2hhbj48L2pvaGFuPjwvZ3JlZ2toPjwvbWxldml0c2s+PC9wYm9uemluaT48L21hcmNvcnI+PC9tYXJjb3JyPjwvZ3JlZ2toPjwvcGJvbnppbmk+PC9zZWFuamM+PC9pZ25hdD48L3Rhc2s+PC90YXNrPjwvc2VhbmpjPjwvZ3JlZ2toPjwvcGJvbnppbmk+PC9tbGV2aXRzaz48L3NlYW5qYz48L3NlYW5qYz48L2dyZWdraD48L3Bib256aW5pPjwvc2VhbmpjPjwvbWxldml0c2s+PC9zZWFuamM+PC9ncmVna2g+PC9wYm9uemluaT48L21sZXZpdHNrPjwvc2VhbmpjPjwvbG9uZ3BlbmcyPjwvc2VhbmpjPjwvZ3JlZ2toPjwvbGludXMud2FsbGVpaj48L2ZhYmllbi5kZXNzZW5uZT48L2NoZi5mcml0ej48L2ZhYmllbi5kZXNzZW5uZT48L2dyZWdraD48L2JyZ2w+PC9ub3JhbGY+PC9kYW5pZWwuYmFsdXRhPjwvc3RhYmxlPjwvbm9yYWxmPjwvZ3JlZ2toPjwvdWxmLmhhbnNzb24+PC9hZHJpYW4uaHVudGVyPjwvcHNoZXRlPjwvcHNoZXRlPjwvZ3JlZ2toPjwvdWxmLmhhbnNzb24+PC9tYXJ0aW4uYmx1bWVuc3RpbmdsPjwvbWFydGluLmJsdW1lbnN0aW5nbD48L2dyZWdraD48L3VsZi5oYW5zc29uPjwvYWRyaWFuLmh1bnRlcj48L2FsY29vcGVyeD48L3VsZi5oYW5zc29uPjwvZ3JlZ2toPjwvdWxmLmhhbnNzb24+PC9saW51cy53YWxsZWlqPjwveWFubi5nYXV0aWVyPjwvY2hyaXN0b3BoZS5rZXJlbGxvPjwveWFubi5nYXV0aWVyPjwvZ3JlZ2toPjwvcm1rPjwvYXJkYj48L3N0YWJsZT48L2FyZGI+PC9ncmVna2g+PC9zdGZyZW5jaD48L2Rhbi5jYXJwZW50ZXI+PC9saW5raW5qZW9uPjwvZGFuLmNhcnBlbnRlcj48L2dyZWdraD48L3N0ZnJlbmNoPjwvbGlua2luamVvbj48L2Rhbi5jYXJwZW50ZXI+PC9saW5raW5qZW9uPjwvZ3JlZ2toPjwvc3RmcmVuY2g+PC9tYXJjb3M+PC9saW5raW5qZW9uPjwvbWFyY29zPjwvZ3JlZ2toPjwvZGF2ZW0+PC9qb2hhbm5lcy5iZXJnPjwvam9oYW5uZXMuYmVyZz48L2dyZWdraD48L3RvcnZhbGRzPjwvYWtwbT48L3N0YWJsZT48L2FhcmNhbmdlPjwvcmllbnRqZXM+PC9tZ29ybWFuPjwvbWhvY2tvPjwvYXJibj48L251bWFpZi5oPjwvc3RkaW8uaD48L3N0ZGxpYi5oPjwvYXNzZXJ0Lmg+PC9mY250bC5oPjwvc3lzPjwvc3lzPjwvdW5pc3RkLmg+PC9hcmJuPjwvZ3JlZ2toPjwvdG9ydmFsZHM+PC9ha3BtPjwvc3RhYmxlPjwvbWlrZS5rcmF2ZXR6PjwvbHVvZmVpPjwvbmFveWEuaG9yaWd1Y2hpPjwvbmFveWEuaG9yaWd1Y2hpPjwvZ3JlZ2toPjwvdG9ydmFsZHM+PC9ha3BtPjwvc3RhYmxlPjwvbmFveWEuaG9yaWd1Y2hpPjwvb3NhbHZhZG9yPjwvaHVsa2NpPjwvbGl1c2hpeGluMj48L2xpdXNoaXhpbjI+PC9ncmVna2g+PC90b3J2YWxkcz48L2FrcG0+PC9zdGFibGU+PC9zaj48L3Nhbmd3b29iPjwvc2o+PC9ncmVna2g+PC9qZW5zLndpa2xhbmRlcj48L3R5aGlja3M+PC9zdW1pdC5nYXJnPjwvcGF0cmlrLmxhbnR6Pjwvc3VtaXQuZ2FyZz48L2dyZWdraD48L2phZWdldWs+PC9jaGFvPjwvd2VucWluZ2xpdTAxMjA+PC9jaGFvPjwvZ3JlZ2toPjwvamxheXRvbj48L2Rob3dlbGxzPjwvamVmZmxleHU+PC9qZWZmbGV4dT48L2dyZWdraD48L3Bib256aW5pPjwvbWxldml0c2s+PC9zZWFuamM+PC9zZWFuamM+PC9ncmVna2g+PC9zaGF3bmd1bz48L2xlb3lhbmcubGk+PC95aW5nLnpoYW5nMjI0NTU+PC95aW5nLnpoYW5nMjI0NTU+PC9ncmVna2g+PC90b3J2YWxkcz48L2FrcG0+PC95dWt1YWkzPjwvZHZ5dWtvdj48L2dsaWRlcj48L3dhbmdrZWZlbmcud2FuZz48L2VsdmVyPjwvaHVsa2NpPjwvbGliYW9rdW4xPjwvbGliYW9rdW4xPjwvZ3JlZ2toPjwvZG1pdHJ5LnRvcm9raG92PjwvamVmZj48L2xrcD48L2plZmY+PC9ncmVna2g+PC9kbWl0cnkudG9yb2tob3Y+PC9qb2hubnkuY2h1YW5nLmVtYz48L2pvaG5ueS5jaHVhbmcuZW1jPjwvZ3JlZ2toPjwvZG1pdHJ5LnRvcm9raG92PjwvaGRlZ29lZGU+PC9oZGVnb2VkZT48L2dyZWdraD48L2Jyb29uaWU+PC9wb3Zpaz48L3BvdmlrPjwvZ3JlZ2toPjwvYnJvb25pZT48L3BpZXJyZS1sb3Vpcy5ib3NzYXJ0Pjwva2FpLnZlaG1hbmVuPjwva2FpLnZlaG1hbmVuPjwvZ3JlZ2toPjwvYnJvb25pZT48L3BpZXJyZS1sb3Vpcy5ib3NzYXJ0Pjwva2FpLnZlaG1hbmVuPjwva2FpLnZlaG1hbmVuPjwvZ3JlZ2toPjwvYnJvb25pZT48L2RlcmVrLmZhbmc+PC9kZXJlay5mYW5nPjwvZ3JlZ2toPjwvbGludXMud2FsbGVpaj48L3dlbnN0PjwvemhpeW9uZy50YW8+PC9ndW9kb25nLmxpdT48L2d1b2RvbmcubGl1PjwvZ3JlZ2toPjwvbGludXg+PC9saW51eD48L2dyZWdraD48L2xpbnV4PjwvbGludXg+PC9ncmVna2g+PC9rdWJhPjwvaGF5ZXN3YW5nPjwvaGF5ZXN3YW5nPjwvZ3JlZ2toPjwvZGF2ZW0+PC9saW5tYT48L25hZ2k+PC9saW5tYT48L2dyZWdraD48L2RhdmVtPjwvbGlubWE+PC9saW5tYT48L2dyZWdraD48L2RhdmVtPjwvbGlubWE+PC9saW5tYT48L2dyZWdraD48L2t1YmE+PC9rdWJhPjwvZ2VvcmdlLmtlbm5lZHk+PC9zeXprYWxsZXI+PC90YXNrPjwvZ2VvcmdlLmtlbm5lZHk+PC9ncmVna2g+PC9kYXZlbT48L3JlbWk+PC9yZW1pPjwvZ3JlZ2toPjwvc2toYW4+PC9saW51eD48L2plZmZyaW4+PC9zdWRpcC5tdWtoZXJqZWU+PC9ydWRpPjwvbGtmdD48L2YuZmFpbmVsbGk+PC9ncmVna2g+PC9wPjwvYm9keT4='</script>

      </head>
        <body class="valid" valid="valid" title="valid: True, node: 1, tag: body, level: 1" node_number="1"><p class="valid" valid="valid" title="valid: True, node: 2, tag: p, level: 2" node_number="2">commit 25960cafa06e6fcd830e6c792e6a7de68c1e25ed Author: Greg Kroah-Hartman <gregkh class="valid" valid="valid" title="valid: True, node: 3, tag: gregkh, level: 3" node_number="3"> Date: Wed Dec 29 12:29:03 2021 +0100 Linux 5.15.12 Link: https://lore.kernel.org/r/20211227151331.502501367@linuxfoundation.org Tested-by: Florian Fainelli <f.fainelli class="valid" valid="valid" title="valid: True, node: 4, tag: f.fainelli, level: 4" node_number="4"> Tested-by: Linux Kernel Functional Testing <lkft class="valid" valid="valid" title="valid: True, node: 5, tag: lkft, level: 5" node_number="5"> Tested-by: Rudi Heitbaum <rudi class="valid" valid="valid" title="valid: True, node: 6, tag: rudi, level: 6" node_number="6"> Tested-by: Sudip Mukherjee <sudip.mukherjee class="valid" valid="valid" title="valid: True, node: 7, tag: sudip.mukherjee, level: 7" node_number="7"> Tested-by: Jeffrin Jose T <jeffrin class="valid" valid="valid" title="valid: True, node: 8, tag: jeffrin, level: 8" node_number="8"> Tested-by: Guenter Roeck <linux class="valid" valid="valid" title="valid: True, node: 9, tag: linux, level: 9" node_number="9"> Tested-by: Shuah Khan <skhan class="valid" valid="valid" title="valid: True, node: 10, tag: skhan, level: 10" node_number="10"> Signed-off-by: Greg Kroah-Hartman <gregkh class="valid" valid="valid" title="valid: True, node: 11, tag: gregkh, level: 11" node_number="11"> commit 53ccdc73eedaf0e922c45b569b797d2796fbaafa Author: R&#233;mi Denis-Courmont <remi class="valid" valid="valid" title="valid: True, node: 12, tag: remi, level: 12" node_number="12"> Date: Sun Dec 19 19:03:39 2021 +0200 phonet/pep: refuse to enable an unbound pipe commit 75a2f31520095600f650597c0ac41f48b5ba0068 upstream. This ioctl() implicitly assumed that the socket was already bound to a valid local socket name, i.e. Phonet object. If the socket was not bound, two separate problems would occur: 1) We'd send an pipe enablement request with an invalid source object. 2) Later socket calls could BUG on the socket unexpectedly being connected yet not bound to a valid object. Reported-by: syzbot+2dc91e7fc3dea88b1e8a@syzkaller.appspotmail.com Signed-off-by: R&#233;mi Denis-Courmont <remi class="valid" valid="valid" title="valid: True, node: 13, tag: remi, level: 13" node_number="13"> Signed-off-by: David S. Miller <davem class="valid" valid="valid" title="valid: True, node: 14, tag: davem, level: 14" node_number="14"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 15, tag: gregkh, level: 15" node_number="15"> commit 3cb5ae77799e8ed6ec3fec0b6b4cd07f01650cc5 Author: George Kennedy <george.kennedy title="valid: False, node: 16, tag: george.kennedy, level: 16" node_number="16"> Date: Thu Dec 16 13:25:32 2021 -0500 tun: avoid double free in tun_free_netdev commit 158b515f703e75e7d68289bf4d98c664e1d632df upstream. Avoid double free in tun_free_netdev() by moving the dev-&gt;tstats and tun-&gt;security allocs to a new ndo_init routine (tun_net_init()) that will be called by register_netdevice(). ndo_init is paired with the desctructor (tun_free_netdev()), so if there's an error in register_netdevice() the destructor will handle the frees. BUG: KASAN: double-free or invalid-free in selinux_tun_dev_free_security+0x1a/0x20 security/selinux/hooks.c:5605 CPU: 0 PID: 25750 Comm: syz-executor416 Not tainted 5.16.0-rc2-syzk #1 Hardware name: Red Hat KVM, BIOS Call Trace: <task title="valid: False, node: 17, tag: task, level: 17" node_number="17"> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x89/0xb5 lib/dump_stack.c:106 print_address_description.constprop.9+0x28/0x160 mm/kasan/report.c:247 kasan_report_invalid_free+0x55/0x80 mm/kasan/report.c:372 ____kasan_slab_free mm/kasan/common.c:346 [inline] __kasan_slab_free+0x107/0x120 mm/kasan/common.c:374 kasan_slab_free include/linux/kasan.h:235 [inline] slab_free_hook mm/slub.c:1723 [inline] slab_free_freelist_hook mm/slub.c:1749 [inline] slab_free mm/slub.c:3513 [inline] kfree+0xac/0x2d0 mm/slub.c:4561 selinux_tun_dev_free_security+0x1a/0x20 security/selinux/hooks.c:5605 security_tun_dev_free_security+0x4f/0x90 security/security.c:2342 tun_free_netdev+0xe6/0x150 drivers/net/tun.c:2215 netdev_run_todo+0x4df/0x840 net/core/dev.c:10627 rtnl_unlock+0x13/0x20 net/core/rtnetlink.c:112 __tun_chr_ioctl+0x80c/0x2870 drivers/net/tun.c:3302 tun_chr_ioctl+0x2f/0x40 drivers/net/tun.c:3311 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:874 [inline] __se_sys_ioctl fs/ioctl.c:860 [inline] __x64_sys_ioctl+0x19d/0x220 fs/ioctl.c:860 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3a/0x80 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x44/0xae Reported-by: syzkaller <syzkaller title="valid: False, node: 18, tag: syzkaller, level: 18" node_number="18"> Signed-off-by: George Kennedy <george.kennedy title="valid: False, node: 19, tag: george.kennedy, level: 19" node_number="19"> Suggested-by: Jakub Kicinski <kuba title="valid: False, node: 20, tag: kuba, level: 20" node_number="20"> Link: https://lore.kernel.org/r/1639679132-19884-1-git-send-email-george.kennedy@oracle.com Signed-off-by: Jakub Kicinski <kuba title="valid: False, node: 21, tag: kuba, level: 21" node_number="21"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 22, tag: gregkh, level: 22" node_number="22"> commit 03d00f7f1815ec00dab5035851b3de83afd054a8 Author: Lin Ma <linma title="valid: False, node: 23, tag: linma, level: 23" node_number="23"> Date: Fri Dec 17 10:13:56 2021 +0800 hamradio: improve the incomplete fix to avoid NPD commit b2f37aead1b82a770c48b5d583f35ec22aabb61e upstream. The previous commit 3e0588c291d6 ("hamradio: defer ax25 kfree after unregister_netdev") reorder the kfree operations and unregister_netdev operation to prevent UAF. This commit improves the previous one by also deferring the nullify of the ax-&gt;tty pointer. Otherwise, a NULL pointer dereference bug occurs. Partial of the stack trace is shown below. BUG: kernel NULL pointer dereference, address: 0000000000000538 RIP: 0010:ax_xmit+0x1f9/0x400 ... Call Trace: dev_hard_start_xmit+0xec/0x320 sch_direct_xmit+0xea/0x240 __qdisc_run+0x166/0x5c0 __dev_queue_xmit+0x2c7/0xaf0 ax25_std_establish_data_link+0x59/0x60 ax25_connect+0x3a0/0x500 ? security_socket_connect+0x2b/0x40 __sys_connect+0x96/0xc0 ? __hrtimer_init+0xc0/0xc0 ? common_nsleep+0x2e/0x50 ? switch_fpu_return+0x139/0x1a0 __x64_sys_connect+0x11/0x20 do_syscall_64+0x33/0x40 entry_SYSCALL_64_after_hwframe+0x44/0xa9 The crash point is shown as below static void ax_encaps(...) { ... set_bit(TTY_DO_WRITE_WAKEUP, ax-&gt;tty-&gt;flags); // ax-&gt;tty = NULL! ... } By placing the nullify action after the unregister_netdev, the ax-&gt;tty pointer won't be assigned as NULL net_device framework layer is well synchronized. Signed-off-by: Lin Ma <linma title="valid: False, node: 24, tag: linma, level: 24" node_number="24"> Signed-off-by: David S. Miller <davem title="valid: False, node: 25, tag: davem, level: 25" node_number="25"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 26, tag: gregkh, level: 26" node_number="26"> commit cb6c99aedd2c843056a598a8907a6128cb07603b Author: Lin Ma <linma title="valid: False, node: 27, tag: linma, level: 27" node_number="27"> Date: Mon Nov 8 18:37:21 2021 +0800 hamradio: defer ax25 kfree after unregister_netdev commit 3e0588c291d6ce225f2b891753ca41d45ba42469 upstream. There is a possible race condition (use-after-free) like below (USE) | (FREE) ax25_sendmsg | ax25_queue_xmit | dev_queue_xmit | __dev_queue_xmit | __dev_xmit_skb | sch_direct_xmit | ... xmit_one | netdev_start_xmit | tty_ldisc_kill __netdev_start_xmit | mkiss_close ax_xmit | kfree ax_encaps | | Even though there are two synchronization primitives before the kfree: 1. wait_for_completion(ax-&gt;dead). This can prevent the race with routines from mkiss_ioctl. However, it cannot stop the routine coming from upper layer, i.e., the ax25_sendmsg. 2. netif_stop_queue(ax-&gt;dev). It seems that this line of code aims to halt the transmit queue but it fails to stop the routine that already being xmit. This patch reorder the kfree after the unregister_netdev to avoid the possible UAF as the unregister_netdev() is well synchronized and won't return if there is a running routine. Signed-off-by: Lin Ma <linma title="valid: False, node: 28, tag: linma, level: 28" node_number="28"> Signed-off-by: David S. Miller <davem title="valid: False, node: 29, tag: davem, level: 29" node_number="29"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 30, tag: gregkh, level: 30" node_number="30"> commit a8e4a64cdc977cda02d7c95cd01004fd33978ab7 Author: Lin Ma <linma title="valid: False, node: 31, tag: linma, level: 31" node_number="31"> Date: Fri Dec 17 10:29:41 2021 +0800 ax25: NPD bug when detaching AX25 device commit 1ade48d0c27d5da1ccf4b583d8c5fc8b534a3ac8 upstream. The existing cleanup routine implementation is not well synchronized with the syscall routine. When a device is detaching, below race could occur. static int ax25_sendmsg(...) { ... lock_sock() ax25 = sk_to_ax25(sk); if (ax25-&gt;ax25_dev == NULL) // CHECK ... ax25_queue_xmit(skb, ax25-&gt;ax25_dev-&gt;dev); // USE ... } static void ax25_kill_by_device(...) { ... if (s-&gt;ax25_dev == ax25_dev) { s-&gt;ax25_dev = NULL; ... } Other syscall functions like ax25_getsockopt, ax25_getname, ax25_info_show also suffer from similar races. To fix them, this patch introduce lock_sock() into ax25_kill_by_device in order to guarantee that the nullify action in cleanup routine cannot proceed when another socket request is pending. Signed-off-by: Hanjie Wu <nagi title="valid: False, node: 32, tag: nagi, level: 32" node_number="32"> Signed-off-by: Lin Ma <linma title="valid: False, node: 33, tag: linma, level: 33" node_number="33"> Signed-off-by: David S. Miller <davem title="valid: False, node: 34, tag: davem, level: 34" node_number="34"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 35, tag: gregkh, level: 35" node_number="35"> commit f547b0f8f3ceb1eb544b7df1df0196c0f834580c Author: Hayes Wang <hayeswang title="valid: False, node: 36, tag: hayeswang, level: 36" node_number="36"> Date: Thu Dec 23 17:27:02 2021 +0800 r8152: sync ocp base commit b24edca309535c2d9af86aab95d64065f6ef1d26 upstream. There are some chances that the actual base of hardware is different from the value recorded by driver, so we have to reset the variable of ocp_base to sync it. Set ocp_base to -1. Then, it would be updated and the new base would be set to the hardware next time. Signed-off-by: Hayes Wang <hayeswang title="valid: False, node: 37, tag: hayeswang, level: 37" node_number="37"> Signed-off-by: Jakub Kicinski <kuba title="valid: False, node: 38, tag: kuba, level: 38" node_number="38"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 39, tag: gregkh, level: 39" node_number="39"> commit 5cc8813c496627bad3cef02f2cdfa1ba43a3a1e9 Author: Guenter Roeck <linux title="valid: False, node: 40, tag: linux, level: 40" node_number="40"> Date: Fri Dec 3 13:42:22 2021 -0800 hwmon: (lm90) Do not report 'busy' status bit as alarm commit cdc5287acad9ede121924a9c9313544b80d15842 upstream. Bit 7 of the status register indicates that the chip is busy doing a conversion. It does not indicate an alarm status. Stop reporting it as alarm status bit. Signed-off-by: Guenter Roeck <linux title="valid: False, node: 41, tag: linux, level: 41" node_number="41"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 42, tag: gregkh, level: 42" node_number="42"> commit 722fc45be049e8ac1712fcc8a281265db8e9e736 Author: Guenter Roeck <linux title="valid: False, node: 43, tag: linux, level: 43" node_number="43"> Date: Fri Nov 26 22:43:39 2021 -0800 hwmom: (lm90) Fix citical alarm status for MAX6680/MAX6681 commit da7dc0568491104c7acb632e9d41ddce9aaabbb1 upstream. Tests with a real chip and a closer look into the datasheet reveals that the local and remote critical alarm status bits are swapped for MAX6680/MAX6681. Signed-off-by: Guenter Roeck <linux title="valid: False, node: 44, tag: linux, level: 44" node_number="44"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 45, tag: gregkh, level: 45" node_number="45"> commit fb563baa3eb8e7a15f2cff3c2695e2cca0493e69 Author: Guodong Liu <guodong.liu title="valid: False, node: 46, tag: guodong.liu, level: 46" node_number="46"> Date: Wed Nov 10 15:19:00 2021 +0800 pinctrl: mediatek: fix global-out-of-bounds issue commit 2d5446da5acecf9c67db1c9d55ae2c3e5de01f8d upstream. When eint virtual eint number is greater than gpio number, it maybe produce 'desc[eint_n]' size globle-out-of-bounds issue. Signed-off-by: Guodong Liu <guodong.liu title="valid: False, node: 47, tag: guodong.liu, level: 47" node_number="47"> Signed-off-by: Zhiyong Tao <zhiyong.tao title="valid: False, node: 48, tag: zhiyong.tao, level: 48" node_number="48"> Reviewed-by: Chen-Yu Tsai <wenst title="valid: False, node: 49, tag: wenst, level: 49" node_number="49"> Link: https://lore.kernel.org/r/20211110071900.4490-2-zhiyong.tao@mediatek.com Signed-off-by: Linus Walleij <linus.walleij title="valid: False, node: 50, tag: linus.walleij, level: 50" node_number="50"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 51, tag: gregkh, level: 51" node_number="51"> commit aa50406f36a163676922b8edcbb2dac935e328ed Author: Derek Fang <derek.fang title="valid: False, node: 52, tag: derek.fang, level: 52" node_number="52"> Date: Tue Dec 14 18:50:33 2021 +0800 ASoC: rt5682: fix the wrong jack type detected commit 8deb34a90f06374fd26f722c2a79e15160f66be7 upstream. Some powers were changed during the jack insert detection and clk's enable/disable in CCF. If in parallel, the influence has a chance to detect the wrong jack type, so add a lock. Signed-off-by: Derek Fang <derek.fang title="valid: False, node: 53, tag: derek.fang, level: 53" node_number="53"> Link: https://lore.kernel.org/r/20211214105033.471-1-derek.fang@realtek.com Signed-off-by: Mark Brown Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 54, tag: gregkh, level: 54" node_number="54"> commit 46b3fe1eb2b73d5658d919c6a325e580230280d2 Author: Kai Vehmanen <kai.vehmanen title="valid: False, node: 55, tag: kai.vehmanen, level: 55" node_number="55"> Date: Fri Dec 3 19:15:41 2021 +0200 ASoC: SOF: Intel: pci-tgl: add ADL-N support commit cd57eb3c403cb864e5558874ecd57dd954a5a7f7 upstream. Add PCI DID for Intel AlderLake-N. Signed-off-by: Kai Vehmanen <kai.vehmanen title="valid: False, node: 56, tag: kai.vehmanen, level: 56" node_number="56"> Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart title="valid: False, node: 57, tag: pierre-louis.bossart, level: 57" node_number="57"> Link: https://lore.kernel.org/r/20211203171542.1021399-1-kai.vehmanen@linux.intel.com Signed-off-by: Mark Brown Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 58, tag: gregkh, level: 58" node_number="58"> commit d0fa8c252956df9d23fca001dd6a493d8353928d Author: Kai Vehmanen <kai.vehmanen title="valid: False, node: 59, tag: kai.vehmanen, level: 59" node_number="59"> Date: Fri Dec 3 19:15:42 2021 +0200 ASoC: SOF: Intel: pci-tgl: add new ADL-P variant commit de7dd9092cd38384f774d345cccafe81b4b866b0 upstream. Add a PCI DID for a variant of Intel AlderLake-P. Signed-off-by: Kai Vehmanen <kai.vehmanen title="valid: False, node: 60, tag: kai.vehmanen, level: 60" node_number="60"> Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart title="valid: False, node: 61, tag: pierre-louis.bossart, level: 61" node_number="61"> Link: https://lore.kernel.org/r/20211203171542.1021399-2-kai.vehmanen@linux.intel.com Signed-off-by: Mark Brown Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 62, tag: gregkh, level: 62" node_number="62"> commit d9ad0ae8bfa06e6b86a6cee863f5d031622c9052 Author: Martin Povi&#353;er <povik title="valid: False, node: 63, tag: povik, level: 63" node_number="63"> Date: Mon Dec 6 22:45:43 2021 +0000 ASoC: tas2770: Fix setting of high sample rates commit 80d5be1a057e05f01d66e986cfd34d71845e5190 upstream. Although the codec advertises support for 176.4 and 192 ksps, without this fix setting those sample rates fails with EINVAL at hw_params time. Signed-off-by: Martin Povi&#353;er <povik title="valid: False, node: 64, tag: povik, level: 64" node_number="64"> Link: https://lore.kernel.org/r/20211206224529.74656-1-povik@protonmail.com Signed-off-by: Mark Brown Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 65, tag: gregkh, level: 65" node_number="65"> commit cc71a723f3d88c55460144c204a1c67361c323c0 Author: Hans de Goede <hdegoede title="valid: False, node: 66, tag: hdegoede, level: 66" node_number="66"> Date: Mon Dec 6 23:29:27 2021 -0800 Input: goodix - add id-&gt;model mapping for the "9111" model commit 81e818869be522bc8fa6f7df1b92d7e76537926c upstream. Add d-&gt;model mapping for the "9111" model, this fixes uses using a wrong config_len of 240 bytes while the "9111" model uses only 186 bytes of config. Signed-off-by: Hans de Goede <hdegoede title="valid: False, node: 67, tag: hdegoede, level: 67" node_number="67"> Link: https://lore.kernel.org/r/20211206164747.197309-2-hdegoede@redhat.com Signed-off-by: Dmitry Torokhov <dmitry.torokhov title="valid: False, node: 68, tag: dmitry.torokhov, level: 68" node_number="68"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 69, tag: gregkh, level: 69" node_number="69"> commit efaa327b41462f7898f6a0577f9f94af28dbbaa3 Author: Johnny Chuang <johnny.chuang.emc title="valid: False, node: 70, tag: johnny.chuang.emc, level: 70" node_number="70"> Date: Mon Dec 20 00:28:45 2021 -0800 Input: elants_i2c - do not check Remark ID on eKTH3900/eKTH5312 commit 4ebfee2bbc1a9c343dd50565ba5ae249fac32267 upstream. The eKTH3900/eKTH5312 series do not support the firmware update rules of Remark ID. Exclude these two series from checking it when updating the firmware in touch controllers. Signed-off-by: Johnny Chuang <johnny.chuang.emc title="valid: False, node: 71, tag: johnny.chuang.emc, level: 71" node_number="71"> Link: https://lore.kernel.org/r/1639619603-20616-1-git-send-email-johnny.chuang.emc@gmail.com Signed-off-by: Dmitry Torokhov <dmitry.torokhov title="valid: False, node: 72, tag: dmitry.torokhov, level: 72" node_number="72"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 73, tag: gregkh, level: 73" node_number="73"> commit 70750056620b241dee3bf8f2e0f56bdf63bb4aca Author: Jeff LaBundy <jeff title="valid: False, node: 74, tag: jeff, level: 74" node_number="74"> Date: Sun Nov 28 23:41:42 2021 -0800 Input: iqs626a - prohibit inlining of channel parsing functions commit e1f5e848209a1b51ccae50721b27684c6f9d978f upstream. Some automated builds report a stack frame size in excess of 2 kB for iqs626_probe(); the culprit appears to be the call to iqs626_parse_prop(). To solve this problem, specify noinline_for_stack for all of the iqs626_parse_*() helper functions which are called inside a for loop within iqs626_parse_prop(). As a result, a build with '-Wframe-larger-than' as low as 512 is free of any such warnings. Reported-by: kernel test robot <lkp title="valid: False, node: 75, tag: lkp, level: 75" node_number="75"> Signed-off-by: Jeff LaBundy <jeff title="valid: False, node: 76, tag: jeff, level: 76" node_number="76"> Link: https://lore.kernel.org/r/20211129004104.453930-1-jeff@labundy.com Signed-off-by: Dmitry Torokhov <dmitry.torokhov title="valid: False, node: 77, tag: dmitry.torokhov, level: 77" node_number="77"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 78, tag: gregkh, level: 78" node_number="78"> commit 2f06c8293d27f6337f907042c602c9c953988c48 Author: Baokun Li <libaokun1 title="valid: False, node: 79, tag: libaokun1, level: 79" node_number="79"> Date: Fri Dec 24 21:12:32 2021 -0800 kfence: fix memory leak when cat kfence objects commit 0129ab1f268b6cf88825eae819b9b84aa0a85634 upstream. Hulk robot reported a kmemleak problem: unreferenced object 0xffff93d1d8cc02e8 (size 248): comm "cat", pid 23327, jiffies 4624670141 (age 495992.217s) hex dump (first 32 bytes): 00 40 85 19 d4 93 ff ff 00 10 00 00 00 00 00 00 .@.............. 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ backtrace: seq_open+0x2a/0x80 full_proxy_open+0x167/0x1e0 do_dentry_open+0x1e1/0x3a0 path_openat+0x961/0xa20 do_filp_open+0xae/0x120 do_sys_openat2+0x216/0x2f0 do_sys_open+0x57/0x80 do_syscall_64+0x33/0x40 entry_SYSCALL_64_after_hwframe+0x44/0xa9 unreferenced object 0xffff93d419854000 (size 4096): comm "cat", pid 23327, jiffies 4624670141 (age 495992.217s) hex dump (first 32 bytes): 6b 66 65 6e 63 65 2d 23 32 35 30 3a 20 30 78 30 kfence-#250: 0x0 30 30 30 30 30 30 30 37 35 34 62 64 61 31 32 2d 0000000754bda12- backtrace: seq_read_iter+0x313/0x440 seq_read+0x14b/0x1a0 full_proxy_read+0x56/0x80 vfs_read+0xa5/0x1b0 ksys_read+0xa0/0xf0 do_syscall_64+0x33/0x40 entry_SYSCALL_64_after_hwframe+0x44/0xa9 I find that we can easily reproduce this problem with the following commands: cat /sys/kernel/debug/kfence/objects echo scan &gt; /sys/kernel/debug/kmemleak cat /sys/kernel/debug/kmemleak The leaked memory is allocated in the stack below: do_syscall_64 do_sys_open do_dentry_open full_proxy_open seq_open ---&gt; alloc seq_file vfs_read full_proxy_read seq_read seq_read_iter traverse ---&gt; alloc seq_buf And it should have been released in the following process: do_syscall_64 syscall_exit_to_user_mode exit_to_user_mode_prepare task_work_run ____fput __fput full_proxy_release ---&gt; free here However, the release function corresponding to file_operations is not implemented in kfence. As a result, a memory leak occurs. Therefore, the solution to this problem is to implement the corresponding release function. Link: https://lkml.kernel.org/r/20211206133628.2822545-1-libaokun1@huawei.com Fixes: 0ce20dd84089 ("mm: add Kernel Electric-Fence infrastructure") Signed-off-by: Baokun Li <libaokun1 title="valid: False, node: 80, tag: libaokun1, level: 80" node_number="80"> Reported-by: Hulk Robot <hulkci title="valid: False, node: 81, tag: hulkci, level: 81" node_number="81"> Acked-by: Marco Elver <elver title="valid: False, node: 82, tag: elver, level: 82" node_number="82"> Reviewed-by: Kefeng Wang <wangkefeng.wang title="valid: False, node: 83, tag: wangkefeng.wang, level: 83" node_number="83"> Cc: Alexander Potapenko <glider title="valid: False, node: 84, tag: glider, level: 84" node_number="84"> Cc: Dmitry Vyukov <dvyukov title="valid: False, node: 85, tag: dvyukov, level: 85" node_number="85"> Cc: Yu Kuai <yukuai3 title="valid: False, node: 86, tag: yukuai3, level: 86" node_number="86"> Signed-off-by: Andrew Morton <akpm title="valid: False, node: 87, tag: akpm, level: 87" node_number="87"> Signed-off-by: Linus Torvalds <torvalds title="valid: False, node: 88, tag: torvalds, level: 88" node_number="88"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 89, tag: gregkh, level: 89" node_number="89"> commit ca38833c915ea1da85568a02d95d60ce4057a2a9 Author: Zhang Ying-22455 <ying.zhang22455 title="valid: False, node: 90, tag: ying.zhang22455, level: 90" node_number="90"> Date: Tue Dec 14 01:23:33 2021 -0600 arm64: dts: lx2160a: fix scl-gpios property name commit 849e087ba68ac6956c11016ce34f9f10a09a4186 upstream. Fix the typo in the property name. Fixes: d548c217c6a3c ("arm64: dts: add QorIQ LX2160A SoC support") Signed-off-by: Zhang Ying <ying.zhang22455 title="valid: False, node: 91, tag: ying.zhang22455, level: 91" node_number="91"> Signed-off-by: Li Yang <leoyang.li title="valid: False, node: 92, tag: leoyang.li, level: 92" node_number="92"> Signed-off-by: Shawn Guo <shawnguo title="valid: False, node: 93, tag: shawnguo, level: 93" node_number="93"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 94, tag: gregkh, level: 94" node_number="94"> commit 0ae519ecbbdb243aae1262f491e53b4aeda3f28d Author: Sean Christopherson <seanjc title="valid: False, node: 95, tag: seanjc, level: 95" node_number="95"> Date: Tue Dec 7 19:30:05 2021 +0000 KVM: VMX: Fix stale docs for kvm-intel.emulate_invalid_guest_state commit 0ff29701ffad9a5d5a24344d8b09f3af7b96ffda upstream. Update the documentation for kvm-intel's emulate_invalid_guest_state to rectify the description of KVM's default behavior, and to document that the behavior and thus parameter only applies to L1. Fixes: a27685c33acc ("KVM: VMX: Emulate invalid guest state by default") Signed-off-by: Sean Christopherson <seanjc title="valid: False, node: 96, tag: seanjc, level: 96" node_number="96"> Message-Id: &lt;20211207193006.120997-4-seanjc@google.com&gt; Reviewed-by: Maxim Levitsky <mlevitsk title="valid: False, node: 97, tag: mlevitsk, level: 97" node_number="97"> Signed-off-by: Paolo Bonzini <pbonzini title="valid: False, node: 98, tag: pbonzini, level: 98" node_number="98"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 99, tag: gregkh, level: 99" node_number="99"> commit 35f9ff45ee5c911996185758ae95937af35471ff Author: Jeffle Xu <jefflexu title="valid: False, node: 100, tag: jefflexu, level: 100" node_number="100"> Date: Tue Dec 7 11:14:49 2021 +0800 netfs: fix parameter of cleanup() commit 3cfef1b612e15a0c2f5b1c9d3f3f31ad72d56fcd upstream. The order of these two parameters is just reversed. gcc didn't warn on that, probably because 'void *' can be converted from or to other pointer types without warning. Cc: stable@vger.kernel.org Fixes: 3d3c95046742 ("netfs: Provide readahead and readpage netfs helpers") Fixes: e1b1240c1ff5 ("netfs: Add write_begin helper") Signed-off-by: Jeffle Xu <jefflexu title="valid: False, node: 101, tag: jefflexu, level: 101" node_number="101"> Signed-off-by: David Howells <dhowells title="valid: False, node: 102, tag: dhowells, level: 102" node_number="102"> Reviewed-by: Jeff Layton <jlayton title="valid: False, node: 103, tag: jlayton, level: 103" node_number="103"> Link: https://lore.kernel.org/r/20211207031449.100510-1-jefflexu@linux.alibaba.com/ # v1 Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 104, tag: gregkh, level: 104" node_number="104"> commit a8a9d753edd7f71e6a2edaa580d8182530b68791 Author: Chao Yu <chao title="valid: False, node: 105, tag: chao, level: 105" node_number="105"> Date: Sun Dec 12 17:16:30 2021 +0800 f2fs: fix to do sanity check on last xattr entry in __f2fs_setxattr() commit 5598b24efaf4892741c798b425d543e4bed357a1 upstream. As Wenqing Liu reported in bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=215235 - Overview page fault in f2fs_setxattr() when mount and operate on corrupted image - Reproduce tested on kernel 5.16-rc3, 5.15.X under root 1. unzip tmp7.zip 2. ./single.sh f2fs 7 Sometimes need to run the script several times - Kernel dump loop0: detected capacity change from 0 to 131072 F2FS-fs (loop0): Found nat_bits in checkpoint F2FS-fs (loop0): Mounted with checkpoint version = 7548c2ee BUG: unable to handle page fault for address: ffffe47bc7123f48 RIP: 0010:kfree+0x66/0x320 Call Trace: __f2fs_setxattr+0x2aa/0xc00 [f2fs] f2fs_setxattr+0xfa/0x480 [f2fs] __f2fs_set_acl+0x19b/0x330 [f2fs] __vfs_removexattr+0x52/0x70 __vfs_removexattr_locked+0xb1/0x140 vfs_removexattr+0x56/0x100 removexattr+0x57/0x80 path_removexattr+0xa3/0xc0 __x64_sys_removexattr+0x17/0x20 do_syscall_64+0x37/0xb0 entry_SYSCALL_64_after_hwframe+0x44/0xae The root cause is in __f2fs_setxattr(), we missed to do sanity check on last xattr entry, result in out-of-bound memory access during updating inconsistent xattr data of target inode. After the fix, it can detect such xattr inconsistency as below: F2FS-fs (loop11): inode (7) has invalid last xattr entry, entry_size: 60676 F2FS-fs (loop11): inode (8) has corrupted xattr F2FS-fs (loop11): inode (8) has corrupted xattr F2FS-fs (loop11): inode (8) has invalid last xattr entry, entry_size: 47736 Cc: stable@vger.kernel.org Reported-by: Wenqing Liu <wenqingliu0120 title="valid: False, node: 106, tag: wenqingliu0120, level: 106" node_number="106"> Signed-off-by: Chao Yu <chao title="valid: False, node: 107, tag: chao, level: 107" node_number="107"> Signed-off-by: Jaegeuk Kim <jaegeuk title="valid: False, node: 108, tag: jaegeuk, level: 108" node_number="108"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 109, tag: gregkh, level: 109" node_number="109"> commit 91e94e42f6fc49635f1a16d8ae3f79552bcfda29 Author: Sumit Garg <sumit.garg title="valid: False, node: 110, tag: sumit.garg, level: 110" node_number="110"> Date: Thu Dec 16 11:17:25 2021 +0530 tee: optee: Fix incorrect page free bug commit 18549bf4b21c739a9def39f27dcac53e27286ab5 upstream. Pointer to the allocated pages (struct page *page) has already progressed towards the end of allocation. It is incorrect to perform __free_pages(page, order) using this pointer as we would free any arbitrary pages. Fix this by stop modifying the page pointer. Fixes: ec185dd3ab25 ("optee: Fix memory leak when failing to register shm pages") Cc: stable@vger.kernel.org Reported-by: Patrik Lantz <patrik.lantz title="valid: False, node: 111, tag: patrik.lantz, level: 111" node_number="111"> Signed-off-by: Sumit Garg <sumit.garg title="valid: False, node: 112, tag: sumit.garg, level: 112" node_number="112"> Reviewed-by: Tyler Hicks <tyhicks title="valid: False, node: 113, tag: tyhicks, level: 113" node_number="113"> Signed-off-by: Jens Wiklander <jens.wiklander title="valid: False, node: 114, tag: jens.wiklander, level: 114" node_number="114"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 115, tag: gregkh, level: 115" node_number="115"> commit 330c6117a82c16a9a365a51cec5c9ab30b13245c Author: SeongJae Park <sj title="valid: False, node: 116, tag: sj, level: 116" node_number="116"> Date: Fri Dec 24 21:12:54 2021 -0800 mm/damon/dbgfs: protect targets destructions with kdamond_lock commit 34796417964b8d0aef45a99cf6c2d20cebe33733 upstream. DAMON debugfs interface iterates current monitoring targets in 'dbgfs_target_ids_read()' while holding the corresponding 'kdamond_lock'. However, it also destructs the monitoring targets in 'dbgfs_before_terminate()' without holding the lock. This can result in a use_after_free bug. This commit avoids the race by protecting the destruction with the corresponding 'kdamond_lock'. Link: https://lkml.kernel.org/r/20211221094447.2241-1-sj@kernel.org Reported-by: Sangwoo Bae <sangwoob title="valid: False, node: 117, tag: sangwoob, level: 117" node_number="117"> Fixes: 4bc05954d007 ("mm/damon: implement a debugfs-based user space interface") Signed-off-by: SeongJae Park <sj title="valid: False, node: 118, tag: sj, level: 118" node_number="118"> Cc: <stable title="valid: False, node: 119, tag: stable, level: 119" node_number="119"> [5.15.x] Signed-off-by: Andrew Morton <akpm title="valid: False, node: 120, tag: akpm, level: 120" node_number="120"> Signed-off-by: Linus Torvalds <torvalds title="valid: False, node: 121, tag: torvalds, level: 121" node_number="121"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 122, tag: gregkh, level: 122" node_number="122"> commit c691e7575eff76e563b0199c23ec46bd454f43e3 Author: Liu Shixin <liushixin2 title="valid: False, node: 123, tag: liushixin2, level: 123" node_number="123"> Date: Fri Dec 24 21:12:58 2021 -0800 mm/hwpoison: clear MF_COUNT_INCREASED before retrying get_any_page() commit 2a57d83c78f889bf3f54eede908d0643c40d5418 upstream. Hulk Robot reported a panic in put_page_testzero() when testing madvise() with MADV_SOFT_OFFLINE. The BUG() is triggered when retrying get_any_page(). This is because we keep MF_COUNT_INCREASED flag in second try but the refcnt is not increased. page dumped because: VM_BUG_ON_PAGE(page_ref_count(page) == 0) ------------[ cut here ]------------ kernel BUG at include/linux/mm.h:737! invalid opcode: 0000 [#1] PREEMPT SMP CPU: 5 PID: 2135 Comm: sshd Tainted: G B 5.16.0-rc6-dirty #373 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014 RIP: release_pages+0x53f/0x840 Call Trace: free_pages_and_swap_cache+0x64/0x80 tlb_flush_mmu+0x6f/0x220 unmap_page_range+0xe6c/0x12c0 unmap_single_vma+0x90/0x170 unmap_vmas+0xc4/0x180 exit_mmap+0xde/0x3a0 mmput+0xa3/0x250 do_exit+0x564/0x1470 do_group_exit+0x3b/0x100 __do_sys_exit_group+0x13/0x20 __x64_sys_exit_group+0x16/0x20 do_syscall_64+0x34/0x80 entry_SYSCALL_64_after_hwframe+0x44/0xae Modules linked in: ---[ end trace e99579b570fe0649 ]--- RIP: 0010:release_pages+0x53f/0x840 Link: https://lkml.kernel.org/r/20211221074908.3910286-1-liushixin2@huawei.com Fixes: b94e02822deb ("mm,hwpoison: try to narrow window race for free pages") Signed-off-by: Liu Shixin <liushixin2 title="valid: False, node: 124, tag: liushixin2, level: 124" node_number="124"> Reported-by: Hulk Robot <hulkci title="valid: False, node: 125, tag: hulkci, level: 125" node_number="125"> Reviewed-by: Oscar Salvador <osalvador title="valid: False, node: 126, tag: osalvador, level: 126" node_number="126"> Acked-by: Naoya Horiguchi <naoya.horiguchi title="valid: False, node: 127, tag: naoya.horiguchi, level: 127" node_number="127"> Cc: <stable title="valid: False, node: 128, tag: stable, level: 128" node_number="128"> Signed-off-by: Andrew Morton <akpm title="valid: False, node: 129, tag: akpm, level: 129" node_number="129"> Signed-off-by: Linus Torvalds <torvalds title="valid: False, node: 130, tag: torvalds, level: 130" node_number="130"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 131, tag: gregkh, level: 131" node_number="131"> commit 7a77e22fde6349d276f862a521d190ad932e711d Author: Naoya Horiguchi <naoya.horiguchi title="valid: False, node: 132, tag: naoya.horiguchi, level: 132" node_number="132"> Date: Fri Dec 24 21:12:45 2021 -0800 mm, hwpoison: fix condition in free hugetlb page path commit e37e7b0b3bd52ec4f8ab71b027bcec08f57f1b3b upstream. When a memory error hits a tail page of a free hugepage, __page_handle_poison() is expected to be called to isolate the error in 4kB unit, but it's not called due to the outdated if-condition in memory_failure_hugetlb(). This loses the chance to isolate the error in the finer unit, so it's not optimal. Drop the condition. This "(p != head TestSetPageHWPoison(head)" condition is based on the old semantics of PageHWPoison on hugepage (where PG_hwpoison flag was set on the subpage), so it's not necessray any more. By getting to set PG_hwpoison on head page for hugepages, concurrent error events on different subpages in a single hugepage can be prevented by TestSetPageHWPoison(head) at the beginning of memory_failure_hugetlb(). So dropping the condition should not reopen the race window originally mentioned in commit b985194c8c0a ("hwpoison, hugetlb: lock_page/unlock_page does not match for handling a free hugepage") [naoya.horiguchi@linux.dev: fix "HardwareCorrupted" counter] Link: https://lkml.kernel.org/r/20211220084851.GA1460264@u2004 Link: https://lkml.kernel.org/r/20211210110208.879740-1-naoya.horiguchi@linux.dev Signed-off-by: Naoya Horiguchi <naoya.horiguchi title="valid: False, node: 133, tag: naoya.horiguchi, level: 133" node_number="133"> Reported-by: Fei Luo <luofei title="valid: False, node: 134, tag: luofei, level: 134" node_number="134"> Reviewed-by: Mike Kravetz <mike.kravetz title="valid: False, node: 135, tag: mike.kravetz, level: 135" node_number="135"> Cc: <stable title="valid: False, node: 136, tag: stable, level: 136" node_number="136"> [5.14+] Signed-off-by: Andrew Morton <akpm title="valid: False, node: 137, tag: akpm, level: 137" node_number="137"> Signed-off-by: Linus Torvalds <torvalds title="valid: False, node: 138, tag: torvalds, level: 138" node_number="138"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 139, tag: gregkh, level: 139" node_number="139"> commit 6b2cdcc8f5552615c7bdfc0ba3fa45a5d0d15680 Author: Andrey Ryabinin <arbn title="valid: False, node: 140, tag: arbn, level: 140" node_number="140"> Date: Fri Dec 24 21:12:35 2021 -0800 mm: mempolicy: fix THP allocations escaping mempolicy restrictions commit 338635340669d5b317c7e8dcf4fff4a0f3651d87 upstream. alloc_pages_vma() may try to allocate THP page on the local NUMA node first: page = __alloc_pages_node(hpage_node, gfp | __GFP_THISNODE | __GFP_NORETRY, order); And if the allocation fails it retries allowing remote memory: if (!page (gfp __GFP_DIRECT_RECLAIM)) page = __alloc_pages_node(hpage_node, gfp, order); However, this retry allocation completely ignores memory policy nodemask allowing allocation to escape restrictions. The first appearance of this bug seems to be the commit ac5b2c18911f ("mm: thp: relax __GFP_THISNODE for MADV_HUGEPAGE mappings"). The bug disappeared later in the commit 89c83fb539f9 ("mm, thp: consolidate THP gfp handling into alloc_hugepage_direct_gfpmask") and reappeared again in slightly different form in the commit 76e654cc91bb ("mm, page_alloc: allow hugepage fallback to remote nodes when madvised") Fix this by passing correct nodemask to the __alloc_pages() call. The demonstration/reproducer of the problem: $ mount -oremount,size=4G,huge=always /dev/shm/ $ echo always &gt; /sys/kernel/mm/transparent_hugepage/defrag $ cat mbind_thp.c #include <unistd.h title="valid: False, node: 141, tag: unistd.h, level: 141" node_number="141"> #include <sys title="valid: False, node: 142, tag: sys, level: 142" node_number="142"> #include <sys title="valid: False, node: 143, tag: sys, level: 143" node_number="143"> #include <fcntl.h title="valid: False, node: 144, tag: fcntl.h, level: 144" node_number="144"> #include <assert.h title="valid: False, node: 145, tag: assert.h, level: 145" node_number="145"> #include <stdlib.h title="valid: False, node: 146, tag: stdlib.h, level: 146" node_number="146"> #include <stdio.h title="valid: False, node: 147, tag: stdio.h, level: 147" node_number="147"> #include <numaif.h title="valid: False, node: 148, tag: numaif.h, level: 148" node_number="148"> #define SIZE 2ULL &lt;&lt; 30 int main(int argc, char **argv) { int fd; unsigned long long i; char *addr; pid_t pid; char buf[100]; unsigned long nodemask = 1; fd = open("/dev/shm/test", O_RDWR|O_CREAT); assert(fd &gt; 0); assert(ftruncate(fd, SIZE) == 0); addr = mmap(NULL, SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); assert(mbind(addr, SIZE, MPOL_BIND, nodemask, 2, MPOL_MF_STRICT|MPOL_MF_MOVE)==0); for (i = 0; i &lt; SIZE; i+=4096) { addr[i] = 1; } pid = getpid(); snprintf(buf, sizeof(buf), "grep shm /proc/%d/numa_maps", pid); system(buf); sleep(10000); return 0; } $ gcc mbind_thp.c -o mbind_thp -lnuma $ numactl -H available: 2 nodes (0-1) node 0 cpus: 0 2 node 0 size: 1918 MB node 0 free: 1595 MB node 1 cpus: 1 3 node 1 size: 2014 MB node 1 free: 1731 MB node distances: node 0 1 0: 10 20 1: 20 10 $ rm -f /dev/shm/test; taskset -c 0 ./mbind_thp 7fd970a00000 bind:0 file=/dev/shm/test dirty=524288 active=0 N0=396800 N1=127488 kernelpagesize_kB=4 Link: https://lkml.kernel.org/r/20211208165343.22349-1-arbn@yandex-team.com Fixes: ac5b2c18911f ("mm: thp: relax __GFP_THISNODE for MADV_HUGEPAGE mappings") Signed-off-by: Andrey Ryabinin <arbn title="valid: False, node: 149, tag: arbn, level: 149" node_number="149"> Acked-by: Michal Hocko <mhocko title="valid: False, node: 150, tag: mhocko, level: 150" node_number="150"> Acked-by: Mel Gorman <mgorman title="valid: False, node: 151, tag: mgorman, level: 151" node_number="151"> Acked-by: David Rientjes <rientjes title="valid: False, node: 152, tag: rientjes, level: 152" node_number="152"> Cc: Andrea Arcangeli <aarcange title="valid: False, node: 153, tag: aarcange, level: 153" node_number="153"> Cc: <stable title="valid: False, node: 154, tag: stable, level: 154" node_number="154"> Signed-off-by: Andrew Morton <akpm title="valid: False, node: 155, tag: akpm, level: 155" node_number="155"> Signed-off-by: Linus Torvalds <torvalds title="valid: False, node: 156, tag: torvalds, level: 156" node_number="156"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 157, tag: gregkh, level: 157" node_number="157"> commit c1d1ec4db5f7264cfc21993e59e8f2dcecf4b44f Author: Johannes Berg <johannes.berg title="valid: False, node: 158, tag: johannes.berg, level: 158" node_number="158"> Date: Mon Dec 20 10:22:40 2021 +0100 mac80211: fix locking in ieee80211_start_ap error path commit 87a270625a89fc841f1a7e21aae6176543d8385c upstream. We need to hold the local-&gt;mtx to release the channel context, as even encoded by the lockdep_assert_held() there. Fix it. Cc: stable@vger.kernel.org Fixes: 295b02c4be74 ("mac80211: Add FILS discovery support") Reported-and-tested-by: syzbot+11c342e5e30e9539cabd@syzkaller.appspotmail.com Link: https://lore.kernel.org/r/20211220090836.cee3d59a1915.I36bba9b79dc2ff4d57c3c7aa30dff9a003fe8c5c@changeid Signed-off-by: Johannes Berg <johannes.berg title="valid: False, node: 159, tag: johannes.berg, level: 159" node_number="159"> Signed-off-by: David S. Miller <davem title="valid: False, node: 160, tag: davem, level: 160" node_number="160"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 161, tag: gregkh, level: 161" node_number="161"> commit a2c144d17623984fdafa4634ecf4ab64580d29bb Author: Marcos Del Sol Vives <marcos title="valid: False, node: 162, tag: marcos, level: 162" node_number="162"> Date: Thu Dec 16 11:37:22 2021 +0100 ksmbd: disable SMB2_GLOBAL_CAP_ENCRYPTION for SMB 3.1.1 commit 83912d6d55be10d65b5268d1871168b9ebe1ec4b upstream. According to the official Microsoft MS-SMB2 document section 3.3.5.4, this flag should be used only for 3.0 and 3.0.2 dialects. Setting it for 3.1.1 is a violation of the specification. This causes my Windows 10 client to detect an anomaly in the negotiation, and disable encryption entirely despite being explicitly enabled in ksmbd, causing all data transfers to go in plain text. Fixes: e2f34481b24d ("cifsd: add server-side procedures for SMB3") Cc: stable@vger.kernel.org # v5.15 Acked-by: Namjae Jeon Signed-off-by: Marcos Del Sol Vives <marcos title="valid: False, node: 163, tag: marcos, level: 163" node_number="163"> Signed-off-by: Steve French <stfrench title="valid: False, node: 164, tag: stfrench, level: 164" node_number="164"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 165, tag: gregkh, level: 165" node_number="165"> commit f43ba86a821194778fcb1c10c0d68909d6a72889 Author: Namjae Jeon Date: Wed Dec 1 10:12:39 2021 +0900 ksmbd: fix uninitialized symbol 'pntsd_size' commit f2e78affc48dee29b989c1d9b0d89b503dcd1204 upstream. No check for if "rc" is an error code for build_sec_desc(). This can cause problems with using uninitialized pntsd_size. Fixes: e2f34481b24d ("cifsd: add server-side procedures for SMB3") Cc: stable@vger.kernel.org # v5.15 Reported-by: Dan Carpenter <dan.carpenter title="valid: False, node: 166, tag: dan.carpenter, level: 166" node_number="166"> Signed-off-by: Namjae Jeon Signed-off-by: Steve French <stfrench title="valid: False, node: 167, tag: stfrench, level: 167" node_number="167"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 168, tag: gregkh, level: 168" node_number="168"> commit 89d0ffb4bb960d6ccfac4d01cbd5e0e4727c1ebc Author: Dan Carpenter <dan.carpenter title="valid: False, node: 169, tag: dan.carpenter, level: 169" node_number="169"> Date: Tue Nov 30 15:50:47 2021 +0300 ksmbd: fix error code in ndr_read_int32() commit ef399469d9ceb9f2171cdd79863f9434b9fa3edc upstream. This is a failure path and it should return -EINVAL instead of success. Otherwise it could result in the caller using uninitialized memory. Fixes: 303fff2b8c77 ("ksmbd: add validation for ndr read/write functions") Cc: stable@vger.kernel.org # v5.15 Acked-by: Namjae Jeon Signed-off-by: Dan Carpenter <dan.carpenter title="valid: False, node: 170, tag: dan.carpenter, level: 170" node_number="170"> Signed-off-by: Steve French <stfrench title="valid: False, node: 171, tag: stfrench, level: 171" node_number="171"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 172, tag: gregkh, level: 172" node_number="172"> commit c99513dffd361d5e2121d3c23c7e840a505db4e1 Author: Ard Biesheuvel <ardb title="valid: False, node: 173, tag: ardb, level: 173" node_number="173"> Date: Wed Dec 15 09:31:36 2021 +0100 ARM: 9169/1: entry: fix Thumb2 bug in iWMMXt exception handling commit 8536a5ef886005bc443c2da9b842d69fd3d7647f upstream. The Thumb2 version of the FP exception handling entry code treats the register holding the CP number (R8) differently, resulting in the iWMMXT CP number check to be incorrect. Fix this by unifying the ARM and Thumb2 code paths, and switch the order of the additions of the TI_USED_CP offset and the shifted CP index. Cc: <stable title="valid: False, node: 174, tag: stable, level: 174" node_number="174"> Fixes: b86040a59feb ("Thumb-2: Implementation of the unified start-up and exceptions code") Signed-off-by: Ard Biesheuvel <ardb title="valid: False, node: 175, tag: ardb, level: 175" node_number="175"> Signed-off-by: Russell King (Oracle) <rmk title="valid: False, node: 176, tag: rmk, level: 176" node_number="176"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 177, tag: gregkh, level: 177" node_number="177"> commit c7814569b387c1be884d6c5cd946f13f214b9bb6 Author: Yann Gautier <yann.gautier title="valid: False, node: 178, tag: yann.gautier, level: 178" node_number="178"> Date: Wed Dec 15 15:17:26 2021 +0100 mmc: mmci: stm32: clear DLYB_CR after sending tuning command commit ff31ee0a0f471776f67be5e5275c18d17736fc6b upstream. During test campaign, and especially after several unbind/bind sequences, it has been seen that the SD-card on SDMMC1 thread could freeze. The freeze always appear on a CMD23 following a CMD19. Checking SDMMC internal registers shows that the tuning command (CMD19) has failed. The freeze is then due to the delay block involved in the tuning sequence. To correct this, clear the delay block register DLYB_CR register after the tuning commands. Signed-off-by: Christophe Kerello <christophe.kerello title="valid: False, node: 179, tag: christophe.kerello, level: 179" node_number="179"> Signed-off-by: Yann Gautier <yann.gautier title="valid: False, node: 180, tag: yann.gautier, level: 180" node_number="180"> Reviewed-by: Linus Walleij <linus.walleij title="valid: False, node: 181, tag: linus.walleij, level: 181" node_number="181"> Fixes: 1103f807a3b9 ("mmc: mmci_sdmmc: Add execute tuning with delay block") Cc: stable@vger.kernel.org Link: https://lore.kernel.org/r/20211215141727.4901-4-yann.gautier@foss.st.com Signed-off-by: Ulf Hansson <ulf.hansson title="valid: False, node: 182, tag: ulf.hansson, level: 182" node_number="182"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 183, tag: gregkh, level: 183" node_number="183"> commit c0db06fd09937b3a80d554f2e935ac3452a5b6d8 Author: Ulf Hansson <ulf.hansson title="valid: False, node: 184, tag: ulf.hansson, level: 184" node_number="184"> Date: Fri Dec 3 15:15:54 2021 +0100 mmc: core: Disable card detect during shutdown commit 66c915d09b942fb3b2b0cb2f56562180901fba17 upstream. It's seems prone to problems by allowing card detect and its corresponding mmc_rescan() work to run, during platform shutdown. For example, we may end up turning off the power while initializing a card, which potentially could damage it. To avoid this scenario, let's add -&gt;shutdown_pre() callback for the mmc host class device and then turn of the card detect from there. Reported-by: Al Cooper <alcooperx title="valid: False, node: 185, tag: alcooperx, level: 185" node_number="185"> Suggested-by: Adrian Hunter <adrian.hunter title="valid: False, node: 186, tag: adrian.hunter, level: 186" node_number="186"> Signed-off-by: Ulf Hansson <ulf.hansson title="valid: False, node: 187, tag: ulf.hansson, level: 187" node_number="187"> Cc: stable@vger.kernel.org Link: https://lore.kernel.org/r/20211203141555.105351-1-ulf.hansson@linaro.org Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 188, tag: gregkh, level: 188" node_number="188"> commit 9d93c863d04fea78351187cb0031ce2cc3039429 Author: Martin Blumenstingl <martin.blumenstingl title="valid: False, node: 189, tag: martin.blumenstingl, level: 189" node_number="189"> Date: Sun Dec 19 16:34:41 2021 +0100 mmc: meson-mx-sdhc: Set MANUAL_STOP for multi-block SDIO commands commit f89b548ca66be7500dcd92ee8e61590f7d08ac91 upstream. The vendor driver implements special handling for multi-block SD_IO_RW_EXTENDED (and SD_IO_RW_DIRECT) commands which have data attached to them. It sets the MANUAL_STOP bit in the MESON_SDHC_MISC register for these commands. In all other cases this bit is cleared. Here we omit SD_IO_RW_DIRECT since that command never has any data attached to it. This fixes SDIO wifi using the brcmfmac driver which reported the following error without this change on a Netxeon S82 board using a Meson8 (S802) SoC: brcmf_fw_alloc_request: using brcm/brcmfmac43362-sdio for chip BCM43362/1 brcmf_sdiod_ramrw: membytes transfer failed brcmf_sdio_download_code_file: error -110 on writing 219557 membytes at 0x00000000 brcmf_sdio_download_firmware: dongle image file download failed And with this change: brcmf_fw_alloc_request: using brcm/brcmfmac43362-sdio for chip BCM43362/1 brcmf_c_process_clm_blob: no clm_blob available (err=-2), device may have limited channels available brcmf_c_preinit_dcmds: Firmware: BCM43362/1 wl0: Apr 22 2013 14:50:00 version 5.90.195.89.6 FWID 01-b30a427d Fixes: e4bf1b0970ef96 ("mmc: host: meson-mx-sdhc: new driver for the Amlogic Meson SDHC host") Signed-off-by: Martin Blumenstingl <martin.blumenstingl title="valid: False, node: 190, tag: martin.blumenstingl, level: 190" node_number="190"> Cc: stable@vger.kernel.org Link: https://lore.kernel.org/r/20211219153442.463863-2-martin.blumenstingl@googlemail.com Signed-off-by: Ulf Hansson <ulf.hansson title="valid: False, node: 191, tag: ulf.hansson, level: 191" node_number="191"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 192, tag: gregkh, level: 192" node_number="192"> commit 46e2fc260543bba2ec2ce3f72db2f62174329d20 Author: Prathamesh Shete <pshete title="valid: False, node: 193, tag: pshete, level: 193" node_number="193"> Date: Tue Dec 14 17:06:53 2021 +0530 mmc: sdhci-tegra: Fix switch to HS400ES mode commit 4fc7261dbab139d3c64c3b618262504e16cfe7ee upstream. When CMD13 is sent after switching to HS400ES mode, the bus is operating at either MMC_HIGH_26_MAX_DTR or MMC_HIGH_52_MAX_DTR. To meet Tegra SDHCI requirement at HS400ES mode, force SDHCI interface clock to MMC_HS200_MAX_DTR (200 MHz) so that host controller CAR clock and the interface clock are rate matched. Signed-off-by: Prathamesh Shete <pshete title="valid: False, node: 194, tag: pshete, level: 194" node_number="194"> Acked-by: Adrian Hunter <adrian.hunter title="valid: False, node: 195, tag: adrian.hunter, level: 195" node_number="195"> Fixes: dfc9700cef77 ("mmc: tegra: Implement HS400 enhanced strobe") Cc: stable@vger.kernel.org Link: https://lore.kernel.org/r/20211214113653.4631-1-pshete@nvidia.com Signed-off-by: Ulf Hansson <ulf.hansson title="valid: False, node: 196, tag: ulf.hansson, level: 196" node_number="196"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 197, tag: gregkh, level: 197" node_number="197"> commit e5dd3e61baed74d0abfc63d05d69dbff9e48d1bd Author: Noralf Tr&#248;nnes <noralf title="valid: False, node: 198, tag: noralf, level: 198" node_number="198"> Date: Mon Oct 18 13:22:01 2021 +0200 gpio: dln2: Fix interrupts when replugging the device commit 9a5875f14b0e3a13ae314883f1bb72b7f31fac07 upstream. When replugging the device the following message shows up: gpio gpiochip2: (dln2): detected irqchip that is shared with multiple gpiochips: please fix the driver. This also has the effect that interrupts won't work. The same problem would also show up if multiple devices where plugged in. Fix this by allocating the irq_chip data structure per instance like other drivers do. I don't know when this problem appeared, but it is present in 5.10. Cc: <stable title="valid: False, node: 199, tag: stable, level: 199" node_number="199"> # 5.10+ Cc: Daniel Baluta <daniel.baluta title="valid: False, node: 200, tag: daniel.baluta, level: 200" node_number="200"> Signed-off-by: Noralf Tr&#248;nnes <noralf title="valid: False, node: 201, tag: noralf, level: 201" node_number="201"> Signed-off-by: Bartosz Golaszewski Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 202, tag: gregkh, level: 202" node_number="202"> commit c1ce3c410038bb8c91b91a40e73facb981549236 Author: Fabien Dessenne <fabien.dessenne title="valid: False, node: 203, tag: fabien.dessenne, level: 203" node_number="203"> Date: Wed Dec 15 10:58:08 2021 +0100 pinctrl: stm32: consider the GPIO offset to expose all the GPIO lines commit b67210cc217f9ca1c576909454d846970c13dfd4 upstream. Consider the GPIO controller offset (from "gpio-ranges") to compute the maximum GPIO line number. This fixes an issue where gpio-ranges uses a non-null offset. e.g.: gpio-ranges = In that case the last valid GPIO line is not 9 but 15 (6 + 10 - 1) Cc: stable@vger.kernel.org Fixes: 67e2996f72c7 ("pinctrl: stm32: fix the reported number of GPIO lines per bank") Reported-by: Christoph Fritz <chf.fritz title="valid: False, node: 204, tag: chf.fritz, level: 204" node_number="204"> Signed-off-by: Fabien Dessenne <fabien.dessenne title="valid: False, node: 205, tag: fabien.dessenne, level: 205" node_number="205"> Link: https://lore.kernel.org/r/20211215095808.621716-1-fabien.dessenne@foss.st.com Signed-off-by: Linus Walleij <linus.walleij title="valid: False, node: 206, tag: linus.walleij, level: 206" node_number="206"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 207, tag: gregkh, level: 207" node_number="207"> commit b9d7c7a5bf6eff2e5002f33967d0b5ae12180229 Author: Sean Christopherson <seanjc title="valid: False, node: 208, tag: seanjc, level: 208" node_number="208"> Date: Tue Dec 21 10:37:00 2021 -0500 KVM: VMX: Wake vCPU when delivering posted IRQ even if vCPU == this vCPU commit fdba608f15e2427419997b0898750a49a735afcb upstream. Drop a check that guards triggering a posted interrupt on the currently running vCPU, and more importantly guards waking the target vCPU if triggering a posted interrupt fails because the vCPU isn't IN_GUEST_MODE. If a vIRQ is delivered from asynchronous context, the target vCPU can be the currently running vCPU and can also be blocking, in which case skipping kvm_vcpu_wake_up() is effectively dropping what is supposed to be a wake event for the vCPU. The "do nothing" logic when "vcpu == running_vcpu" mostly works only because the majority of calls to -&gt;deliver_posted_interrupt(), especially when using posted interrupts, come from synchronous KVM context. But if a device is exposed to the guest using vfio-pci passthrough, the VFIO IRQ and vCPU are bound to the same pCPU, and the IRQ is _not_ configured to use posted interrupts, wake events from the device will be delivered to KVM from IRQ context, e.g. vfio_msihandler() | |-&gt; eventfd_signal() | |-&gt; ... | |-&gt; irqfd_wakeup() | |-&gt;kvm_arch_set_irq_inatomic() | |-&gt; kvm_irq_delivery_to_apic_fast() | |-&gt; kvm_apic_set_irq() This also aligns the non-nested and nested usage of triggering posted interrupts, and will allow for additional cleanups. Fixes: 379a3c8ee444 ("KVM: VMX: Optimize posted-interrupt delivery for timer fastpath") Cc: stable@vger.kernel.org Reported-by: Longpeng (Mike) <longpeng2 title="valid: False, node: 209, tag: longpeng2, level: 209" node_number="209"> Signed-off-by: Sean Christopherson <seanjc title="valid: False, node: 210, tag: seanjc, level: 210" node_number="210"> Reviewed-by: Maxim Levitsky <mlevitsk title="valid: False, node: 211, tag: mlevitsk, level: 211" node_number="211"> Message-Id: &lt;20211208015236.1616697-18-seanjc@google.com&gt; Signed-off-by: Paolo Bonzini <pbonzini title="valid: False, node: 212, tag: pbonzini, level: 212" node_number="212"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 213, tag: gregkh, level: 213" node_number="213"> commit e4e4e7cb229821cd215031abc47efdab5486a67c Author: Sean Christopherson <seanjc title="valid: False, node: 214, tag: seanjc, level: 214" node_number="214"> Date: Tue Dec 7 19:30:03 2021 +0000 KVM: VMX: Always clear vmx-&gt;fail on emulation_required commit a80dfc025924024d2c61a4c1b8ef62b2fce76a04 upstream. Revert a relatively recent change that set vmx-&gt;fail if the vCPU is in L2 and emulation_required is true, as that behavior is completely bogus. Setting vmx-&gt;fail and synthesizing a VM-Exit is contradictory and wrong: (a) it's impossible to have both a VM-Fail and VM-Exit (b) vmcs.EXIT_REASON is not modified on VM-Fail (c) emulation_required refers to guest state and guest state checks are always VM-Exits, not VM-Fails. For KVM specifically, emulation_required is handled before nested exits in __vmx_handle_exit(), thus setting vmx-&gt;fail has no immediate effect, i.e. KVM calls into handle_invalid_guest_state() and vmx-&gt;fail is ignored. Setting vmx-&gt;fail can ultimately result in a WARN in nested_vmx_vmexit() firing when tearing down the VM as KVM never expects vmx-&gt;fail to be set when L2 is active, KVM always reflects those errors into L1. ------------[ cut here ]------------ WARNING: CPU: 0 PID: 21158 at arch/x86/kvm/vmx/nested.c:4548 nested_vmx_vmexit+0x16bd/0x17e0 arch/x86/kvm/vmx/nested.c:4547 Modules linked in: CPU: 0 PID: 21158 Comm: syz-executor.1 Not tainted 5.16.0-rc3-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 RIP: 0010:nested_vmx_vmexit+0x16bd/0x17e0 arch/x86/kvm/vmx/nested.c:4547 Code: &lt;0f&gt; 0b e9 2e f8 ff ff e8 57 b3 5d 00 0f 0b e9 00 f1 ff ff 89 e9 80 Call Trace: vmx_leave_nested arch/x86/kvm/vmx/nested.c:6220 [inline] nested_vmx_free_vcpu+0x83/0xc0 arch/x86/kvm/vmx/nested.c:330 vmx_free_vcpu+0x11f/0x2a0 arch/x86/kvm/vmx/vmx.c:6799 kvm_arch_vcpu_destroy+0x6b/0x240 arch/x86/kvm/x86.c:10989 kvm_vcpu_destroy+0x29/0x90 arch/x86/kvm/../../../virt/kvm/kvm_main.c:441 kvm_free_vcpus arch/x86/kvm/x86.c:11426 [inline] kvm_arch_destroy_vm+0x3ef/0x6b0 arch/x86/kvm/x86.c:11545 kvm_destroy_vm arch/x86/kvm/../../../virt/kvm/kvm_main.c:1189 [inline] kvm_put_kvm+0x751/0xe40 arch/x86/kvm/../../../virt/kvm/kvm_main.c:1220 kvm_vcpu_release+0x53/0x60 arch/x86/kvm/../../../virt/kvm/kvm_main.c:3489 __fput+0x3fc/0x870 fs/file_table.c:280 task_work_run+0x146/0x1c0 kernel/task_work.c:164 exit_task_work include/linux/task_work.h:32 [inline] do_exit+0x705/0x24f0 kernel/exit.c:832 do_group_exit+0x168/0x2d0 kernel/exit.c:929 get_signal+0x1740/0x2120 kernel/signal.c:2852 arch_do_signal_or_restart+0x9c/0x730 arch/x86/kernel/signal.c:868 handle_signal_work kernel/entry/common.c:148 [inline] exit_to_user_mode_loop kernel/entry/common.c:172 [inline] exit_to_user_mode_prepare+0x191/0x220 kernel/entry/common.c:207 __syscall_exit_to_user_mode_work kernel/entry/common.c:289 [inline] syscall_exit_to_user_mode+0x2e/0x70 kernel/entry/common.c:300 do_syscall_64+0x53/0xd0 arch/x86/entry/common.c:86 entry_SYSCALL_64_after_hwframe+0x44/0xae Fixes: c8607e4a086f ("KVM: x86: nVMX: don't fail nested VM entry on invalid guest state if !from_vmentry") Reported-by: syzbot+f1d2136db9c80d4733e8@syzkaller.appspotmail.com Reviewed-by: Maxim Levitsky <mlevitsk title="valid: False, node: 215, tag: mlevitsk, level: 215" node_number="215"> Cc: stable@vger.kernel.org Signed-off-by: Sean Christopherson <seanjc title="valid: False, node: 216, tag: seanjc, level: 216" node_number="216"> Message-Id: &lt;20211207193006.120997-2-seanjc@google.com&gt; Signed-off-by: Paolo Bonzini <pbonzini title="valid: False, node: 217, tag: pbonzini, level: 217" node_number="217"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 218, tag: gregkh, level: 218" node_number="218"> commit 543bfbcb5cf511477a143c71140d3e26b582684a Author: Sean Christopherson <seanjc title="valid: False, node: 219, tag: seanjc, level: 219" node_number="219"> Date: Tue Dec 7 19:30:04 2021 +0000 KVM: nVMX: Synthesize TRIPLE_FAULT for L2 if emulation is required commit cd0e615c49e5e5d69885af9ac3b4fa7bb3387f58 upstream. Synthesize a triple fault if L2 guest state is invalid at the time of VM-Enter, which can happen if L1 modifies SMRAM or if userspace stuffs guest state via ioctls(), e.g. KVM_SET_SREGS. KVM should never emulate invalid guest state, since from L1's perspective, it's architecturally impossible for L2 to have invalid state while L2 is running in hardware. E.g. attempts to set CR0 or CR4 to unsupported values will either VM-Exit or #GP. Modifying vCPU state via RSM+SMRAM and ioctl() are the only paths that can trigger this scenario, as nested VM-Enter correctly rejects any attempt to enter L2 with invalid state. RSM is a straightforward case as (a) KVM follows AMD's SMRAM layout and behavior, and (b) Intel's SDM states that loading reserved CR0/CR4 bits via RSM results in shutdown, i.e. there is precedent for KVM's behavior. Following AMD's SMRAM layout is important as AMD's layout saves/restores the descriptor cache information, including CS.RPL and SS.RPL, and also defines all the fields relevant to invalid guest state as read-only, i.e. so long as the vCPU had valid state before the SMI, which is guaranteed for L2, RSM will generate valid state unless SMRAM was modified. Intel's layout saves/restores only the selector, which means that scenarios where the selector and cached RPL don't match, e.g. conforming code segments, would yield invalid guest state. Intel CPUs fudge around this issued by stuffing SS.RPL and CS.RPL on RSM. Per Intel's SDM on the "Default Treatment of RSM", paraphrasing for brevity: IF internal storage indicates that the [CPU was post-VMXON] THEN enter VMX operation (root or non-root); restore VMX-critical state as defined in Section 34.14.1; set to their fixed values any bits in CR0 and CR4 whose values must be fixed in VMX operation [unless coming from an unrestricted guest]; IF RFLAGS.VM = 0 AND (in VMX root operation OR the &#8220;unrestricted guest&#8221; VM-execution control is 0) THEN CS.RPL := SS.DPL; SS.RPL := SS.DPL; FI; restore current VMCS pointer; FI; Note that Intel CPUs also overwrite the fixed CR0/CR4 bits, whereas KVM will sythesize TRIPLE_FAULT in this scenario. KVM's behavior is allowed as both Intel and AMD define CR0/CR4 SMRAM fields as read-only, i.e. the only way for CR0 and/or CR4 to have illegal values is if they were modified by the L1 SMM handler, and Intel's SDM "SMRAM State Save Map" section states "modifying these registers will result in unpredictable behavior". KVM's ioctl() behavior is less straightforward. Because KVM allows ioctls() to be executed in any order, rejecting an ioctl() if it would result in invalid L2 guest state is not an option as KVM cannot know if a future ioctl() would resolve the invalid state, e.g. KVM_SET_SREGS, or drop the vCPU out of L2, e.g. KVM_SET_NESTED_STATE. Ideally, KVM would reject KVM_RUN if L2 contained invalid guest state, but that carries the risk of a false positive, e.g. if RSM loaded invalid guest state and KVM exited to userspace. Setting a flag/request to detect such a scenario is undesirable because (a) it's extremely unlikely to add value to KVM as a whole, and (b) KVM would need to consider ioctl() interactions with such a flag, e.g. if userspace migrated the vCPU while the flag were set. Cc: stable@vger.kernel.org Signed-off-by: Sean Christopherson <seanjc title="valid: False, node: 220, tag: seanjc, level: 220" node_number="220"> Message-Id: &lt;20211207193006.120997-3-seanjc@google.com&gt; Reviewed-by: Maxim Levitsky <mlevitsk title="valid: False, node: 221, tag: mlevitsk, level: 221" node_number="221"> Signed-off-by: Paolo Bonzini <pbonzini title="valid: False, node: 222, tag: pbonzini, level: 222" node_number="222"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 223, tag: gregkh, level: 223" node_number="223"> commit d884eefd75cc54887bc2e9e724207443525dfb2c Author: Sean Christopherson <seanjc title="valid: False, node: 224, tag: seanjc, level: 224" node_number="224"> Date: Tue Dec 14 03:35:28 2021 +0000 KVM: x86/mmu: Don't advance iterator after restart due to yielding commit 3a0f64de479cae75effb630a2e0a237ca0d0623c upstream. After dropping mmu_lock in the TDP MMU, restart the iterator during tdp_iter_next() and do not advance the iterator. Advancing the iterator results in skipping the top-level SPTE and all its children, which is fatal if any of the skipped SPTEs were not visited before yielding. When zapping all SPTEs, i.e. when min_level == root_level, restarting the iter and then invoking tdp_iter_next() is always fatal if the current gfn has as a valid SPTE, as advancing the iterator results in try_step_side() skipping the current gfn, which wasn't visited before yielding. Sprinkle WARNs on iter-&gt;yielded being true in various helpers that are often used in conjunction with yielding, and tag the helper with __must_check to reduce the probabily of improper usage. Failing to zap a top-level SPTE manifests in one of two ways. If a valid SPTE is skipped by both kvm_tdp_mmu_zap_all() and kvm_tdp_mmu_put_root(), the shadow page will be leaked and KVM will WARN accordingly. WARNING: CPU: 1 PID: 3509 at arch/x86/kvm/mmu/tdp_mmu.c:46 [kvm] RIP: 0010:kvm_mmu_uninit_tdp_mmu+0x3e/0x50 [kvm] Call Trace: <task title="valid: False, node: 225, tag: task, level: 225" node_number="225"> kvm_arch_destroy_vm+0x130/0x1b0 [kvm] kvm_destroy_vm+0x162/0x2a0 [kvm] kvm_vcpu_release+0x34/0x60 [kvm] __fput+0x82/0x240 task_work_run+0x5c/0x90 do_exit+0x364/0xa10 ? futex_unqueue+0x38/0x60 do_group_exit+0x33/0xa0 get_signal+0x155/0x850 arch_do_signal_or_restart+0xed/0x750 exit_to_user_mode_prepare+0xc5/0x120 syscall_exit_to_user_mode+0x1d/0x40 do_syscall_64+0x48/0xc0 entry_SYSCALL_64_after_hwframe+0x44/0xae If kvm_tdp_mmu_zap_all() skips a gfn/SPTE but that SPTE is then zapped by kvm_tdp_mmu_put_root(), KVM triggers a use-after-free in the form of marking a struct page as dirty/accessed after it has been put back on the free list. This directly triggers a WARN due to encountering a page with page_count() == 0, but it can also lead to data corruption and additional errors in the kernel. WARNING: CPU: 7 PID: 1995658 at arch/x86/kvm/../../../virt/kvm/kvm_main.c:171 RIP: 0010:kvm_is_zone_device_pfn.part.0+0x9e/0xd0 [kvm] Call Trace: <task title="valid: False, node: 226, tag: task, level: 226" node_number="226"> kvm_set_pfn_dirty+0x120/0x1d0 [kvm] __handle_changed_spte+0x92e/0xca0 [kvm] __handle_changed_spte+0x63c/0xca0 [kvm] __handle_changed_spte+0x63c/0xca0 [kvm] __handle_changed_spte+0x63c/0xca0 [kvm] zap_gfn_range+0x549/0x620 [kvm] kvm_tdp_mmu_put_root+0x1b6/0x270 [kvm] mmu_free_root_page+0x219/0x2c0 [kvm] kvm_mmu_free_roots+0x1b4/0x4e0 [kvm] kvm_mmu_unload+0x1c/0xa0 [kvm] kvm_arch_destroy_vm+0x1f2/0x5c0 [kvm] kvm_put_kvm+0x3b1/0x8b0 [kvm] kvm_vcpu_release+0x4e/0x70 [kvm] __fput+0x1f7/0x8c0 task_work_run+0xf8/0x1a0 do_exit+0x97b/0x2230 do_group_exit+0xda/0x2a0 get_signal+0x3be/0x1e50 arch_do_signal_or_restart+0x244/0x17f0 exit_to_user_mode_prepare+0xcb/0x120 syscall_exit_to_user_mode+0x1d/0x40 do_syscall_64+0x4d/0x90 entry_SYSCALL_64_after_hwframe+0x44/0xae Note, the underlying bug existed even before commit 1af4a96025b3 ("KVM: x86/mmu: Yield in TDU MMU iter even if no SPTES changed") moved calls to tdp_mmu_iter_cond_resched() to the beginning of loops, as KVM could still incorrectly advance past a top-level entry when yielding on a lower-level entry. But with respect to leaking shadow pages, the bug was introduced by yielding before processing the current gfn. Alternatively, tdp_mmu_iter_cond_resched() could simply fall through, or callers could jump to their "retry" label. The downside of that approach is that tdp_mmu_iter_cond_resched() _must_ be called before anything else in the loop, and there's no easy way to enfornce that requirement. Ideally, KVM would handling the cond_resched() fully within the iterator macro (the code is actually quite clean) and avoid this entire class of bugs, but that is extremely difficult do while also supporting yielding after tdp_mmu_set_spte_atomic() fails. Yielding after failing to set a SPTE is very desirable as the "owner" of the REMOVED_SPTE isn't strictly bounded, e.g. if it's zapping a high-level shadow page, the REMOVED_SPTE may block operations on the SPTE for a significant amount of time. Fixes: faaf05b00aec ("kvm: x86/mmu: Support zapping SPTEs in the TDP MMU") Fixes: 1af4a96025b3 ("KVM: x86/mmu: Yield in TDU MMU iter even if no SPTES changed") Reported-by: Ignat Korchagin <ignat title="valid: False, node: 227, tag: ignat, level: 227" node_number="227"> Cc: stable@vger.kernel.org Signed-off-by: Sean Christopherson <seanjc title="valid: False, node: 228, tag: seanjc, level: 228" node_number="228"> Message-Id: &lt;20211214033528.123268-1-seanjc@google.com&gt; Signed-off-by: Paolo Bonzini <pbonzini title="valid: False, node: 229, tag: pbonzini, level: 229" node_number="229"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 230, tag: gregkh, level: 230" node_number="230"> commit 5dea76f5da655a5998da9a06e16c2b0e311ebefc Author: Marc Orr <marcorr title="valid: False, node: 231, tag: marcorr, level: 231" node_number="231"> Date: Thu Dec 9 07:52:57 2021 -0800 KVM: x86: Always set kvm_run-&gt;if_flag commit c5063551bfcae4e48fec890b7bf369598b77526b upstream. The kvm_run struct's if_flag is a part of the userspace/kernel API. The SEV-ES patches failed to set this flag because it's no longer needed by QEMU (according to the comment in the source code). However, other hypervisors may make use of this flag. Therefore, set the flag for guests with encrypted registers (i.e., with guest_state_protected set). Fixes: f1c6366e3043 ("KVM: SVM: Add required changes to support intercepts under SEV-ES") Signed-off-by: Marc Orr <marcorr title="valid: False, node: 232, tag: marcorr, level: 232" node_number="232"> Message-Id: &lt;20211209155257.128747-1-marcorr@google.com&gt; Cc: stable@vger.kernel.org Signed-off-by: Paolo Bonzini <pbonzini title="valid: False, node: 233, tag: pbonzini, level: 233" node_number="233"> Reviewed-by: Maxim Levitsky <mlevitsk title="valid: False, node: 234, tag: mlevitsk, level: 234" node_number="234"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 235, tag: gregkh, level: 235" node_number="235"> commit 9ca1324755f1f8629a370af5cc315b175331f5d1 Author: Johan Hovold <johan title="valid: False, node: 236, tag: johan, level: 236" node_number="236"> Date: Wed Dec 22 11:50:23 2021 +0100 platform/x86: intel_pmc_core: fix memleak on registration failure commit 26a8b09437804fabfb1db080d676b96c0de68e7c upstream. In case device registration fails during module initialisation, the platform device structure needs to be freed using platform_device_put() to properly free all resources (e.g. the device name). Fixes: 938835aa903a ("platform/x86: intel_pmc_core: do not create a static struct device") Cc: stable@vger.kernel.org # 5.9 Signed-off-by: Johan Hovold <johan title="valid: False, node: 237, tag: johan, level: 237" node_number="237"> Reviewed-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 238, tag: gregkh, level: 238" node_number="238"> Link: https://lore.kernel.org/r/20211222105023.6205-1-johan@kernel.org Signed-off-by: Hans de Goede <hdegoede title="valid: False, node: 239, tag: hdegoede, level: 239" node_number="239"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 240, tag: gregkh, level: 240" node_number="240"> commit a42c41be8324a34b37c1e8eb81c469cab85e1fc8 Author: Mario Limonciello <mario.limonciello title="valid: False, node: 241, tag: mario.limonciello, level: 241" node_number="241"> Date: Fri Dec 10 08:35:29 2021 -0600 platform/x86: amd-pmc: only use callbacks for suspend commit 09fc14061f3ed28899c23b8714c066946fdbd43e upstream. This driver is intended to be used exclusively for suspend to idle so callbacks to send OS_HINT during hibernate and S5 will set OS_HINT at the wrong time leading to an undefined behavior. Cc: stable@vger.kernel.org Signed-off-by: Mario Limonciello <mario.limonciello title="valid: False, node: 242, tag: mario.limonciello, level: 242" node_number="242"> Link: https://lore.kernel.org/r/20211210143529.10594-1-mario.limonciello@amd.com Reviewed-by: Hans de Goede <hdegoede title="valid: False, node: 243, tag: hdegoede, level: 243" node_number="243"> Signed-off-by: Hans de Goede <hdegoede title="valid: False, node: 244, tag: hdegoede, level: 244" node_number="244"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 245, tag: gregkh, level: 245" node_number="245"> commit 9ede07c4af14a72f452f0cefc7efec7af76d04c8 Author: Andrew Cooper <andrew.cooper3 title="valid: False, node: 246, tag: andrew.cooper3, level: 246" node_number="246"> Date: Thu Dec 16 00:08:56 2021 +0000 x86/pkey: Fix undefined behaviour with PKRU_WD_BIT commit 57690554abe135fee81d6ac33cc94d75a7e224bb upstream. Both __pkru_allows_write() and arch_set_user_pkey_access() shift PKRU_WD_BIT (a signed constant) by up to 30 bits, hitting the sign bit. Use unsigned constants instead. Clearly pkey 15 has not been used in combination with UBSAN yet. Noticed by code inspection only. I can't actually provoke the compiler into generating incorrect logic as far as this shift is concerned. [ dhansen: add stable@ tag, plus minor changelog massaging, For anyone doing backports, these #defines were in arch/x86/include/asm/pgtable.h before 784a46618f6. ] Fixes: 33a709b25a76 ("mm/gup, x86/mm/pkeys: Check VMAs and PTEs for protection keys") Signed-off-by: Andrew Cooper <andrew.cooper3 title="valid: False, node: 247, tag: andrew.cooper3, level: 247" node_number="247"> Signed-off-by: Dave Hansen </andrew.cooper3></andrew.cooper3></gregkh></hdegoede></hdegoede></mario.limonciello></mario.limonciello></gregkh></hdegoede></gregkh></johan></johan></gregkh></mlevitsk></pbonzini></marcorr></marcorr></gregkh></pbonzini></seanjc></ignat></task></task></seanjc></gregkh></pbonzini></mlevitsk></seanjc></seanjc></gregkh></pbonzini></seanjc></mlevitsk></seanjc></gregkh></pbonzini></mlevitsk></seanjc></longpeng2></seanjc></gregkh></linus.walleij></fabien.dessenne></chf.fritz></fabien.dessenne></gregkh></noralf></daniel.baluta></stable></noralf></gregkh></ulf.hansson></adrian.hunter></pshete></pshete></gregkh></ulf.hansson></martin.blumenstingl></martin.blumenstingl></gregkh></ulf.hansson></adrian.hunter></alcooperx></ulf.hansson></gregkh></ulf.hansson></linus.walleij></yann.gautier></christophe.kerello></yann.gautier></gregkh></rmk></ardb></stable></ardb></gregkh></stfrench></dan.carpenter></dan.carpenter></gregkh></stfrench></dan.carpenter></gregkh></stfrench></marcos></marcos></gregkh></davem></johannes.berg></johannes.berg></gregkh></torvalds></akpm></stable></aarcange></rientjes></mgorman></mhocko></arbn></numaif.h></stdio.h></stdlib.h></assert.h></fcntl.h></sys></sys></unistd.h></arbn></gregkh></torvalds></akpm></stable></mike.kravetz></luofei></naoya.horiguchi></naoya.horiguchi></gregkh></torvalds></akpm></stable></naoya.horiguchi></osalvador></hulkci></liushixin2></liushixin2></gregkh></torvalds></akpm></stable></sj></sangwoob></sj></gregkh></jens.wiklander></tyhicks></sumit.garg></patrik.lantz></sumit.garg></gregkh></jaegeuk></chao></wenqingliu0120></chao></gregkh></jlayton></dhowells></jefflexu></jefflexu></gregkh></pbonzini></mlevitsk></seanjc></seanjc></gregkh></shawnguo></leoyang.li></ying.zhang22455></ying.zhang22455></gregkh></torvalds></akpm></yukuai3></dvyukov></glider></wangkefeng.wang></elver></hulkci></libaokun1></libaokun1></gregkh></dmitry.torokhov></jeff></lkp></jeff></gregkh></dmitry.torokhov></johnny.chuang.emc></johnny.chuang.emc></gregkh></dmitry.torokhov></hdegoede></hdegoede></gregkh></povik></povik></gregkh></pierre-louis.bossart></kai.vehmanen></kai.vehmanen></gregkh></pierre-louis.bossart></kai.vehmanen></kai.vehmanen></gregkh></derek.fang></derek.fang></gregkh></linus.walleij></wenst></zhiyong.tao></guodong.liu></guodong.liu></gregkh></linux></linux></gregkh></linux></linux></gregkh></kuba></hayeswang></hayeswang></gregkh></davem></linma></nagi></linma></gregkh></davem></linma></linma></gregkh></davem></linma></linma></gregkh></kuba></kuba></george.kennedy></syzkaller></task></george.kennedy></gregkh></davem></remi></remi></gregkh></skhan></linux></jeffrin></sudip.mukherjee></rudi></lkft></f.fainelli></gregkh></p></body>
        <style tyle='text/css'>
body{
    position: relative;
    padding-left: 30px;
    top: 60px;
}
* {
    border: 1px solid #eee;
    padding: 5px 12px;
    margin: 3px 0;
    box-sizing: content-box;
    background-color: #fff;
    cursor: no-drop;
}
main:hover > *, section:hover > *, header:hover > *, nav:hover > *, a:hover > *, div:hover > *, p:hover > *, ul:hover > *, h1:hover > *, h2:hover > *, h3:hover > *, li:hover > *, span:hover > *{
    border: 2px solid green;
    background-color: #fffeee;
    padding: 5px 23px !important;
    margin: 1px 0;
    color: green;
}
main:hover, section:hover, header:hover, nav:hover, a:hover, div:hover, p:hover, ul:hover, h1:hover, h2:hover, h3:hover, li:hover, span:hover{
    border: 1px solid #fff;
    background-color: #eee;
}
a, span {
    display: block;
}
.selected {
    border: 2px solid orchid !important;
    opacity: 0.8;
    color: orchid !important;
}
.selected * {
    padding: 2px !important;
    color: orchid !important;
}
.valid {
  cursor: pointer;
}
.btn{
  cursor: pointer;
  font-weight: bolder;
  padding: 8px;
}
</style> 
        <script>function OpenOriginalLink($event){
    $event.stopPropagation();
    console.log(url);
}

function removeItem($event){
    $event.stopPropagation();
    console.log('Remove item: ', url)
    localStorage.removeItem(url)
}

function exportData($event){
    $event.stopPropagation();

    result = []
    for(let i=0; i<localStorage.length; i++) {
        let key = localStorage.key(i);
        result.push(localStorage.getItem(key))
    }
    const _url = URL.createObjectURL(new Blob([result.join("\n")], {type: 'text/plain'}))
    $event.target.href = _url;
    localStorage.clear()
}

var removeItemBtn = document.createElement("BUTTON");   // Create a <button> element
removeItemBtn.innerHTML = "Remove Item";
removeItemBtn.classList.add('btn');
removeItemBtn.style.position = "fixed";
removeItemBtn.style.left = '5px';
removeItemBtn.style.top = 0;
removeItemBtn.style.border = "1px solid";
removeItemBtn.style.boxShadow = "3px 3px #888";
removeItemBtn.onclick = removeItem;
document.body.appendChild(removeItemBtn);

var goToOriginLink = document.createElement("A");   // Create a <button> element
goToOriginLink.innerHTML = "GoToOrigin";
goToOriginLink.classList.add('btn');
goToOriginLink.style.position = "fixed"
goToOriginLink.style.left = '115px'
goToOriginLink.style.top = 0;
goToOriginLink.onclick = OpenOriginalLink;
goToOriginLink.setAttribute('href', decodeURIComponent(url));
goToOriginLink.target = '_blank';
document.body.appendChild(goToOriginLink);

var current = new Date
var exportDataLink = document.createElement("A");   // Create a <button> element
exportDataLink.innerHTML = "Export data";
exportDataLink.classList.add('btn');
exportDataLink.download = current.toISOString() + '.exported.txt';
exportDataLink.style.position = "fixed";
exportDataLink.style.right = '5px';
exportDataLink.style.top = 0;
exportDataLink.style.border = "1px solid #888";
exportDataLink.style.boxShadow = "3px 3px #888";
exportDataLink.onclick = exportData;
document.body.appendChild(exportDataLink);

data = {
    'title': null ,
    'article': null
}

var body = document.getElementsByTagName("body")[0];

body.onclick = function($e){
    var num = $e.target.getAttribute('node_number')
    var valid = $e.target.getAttribute('valid')

    if(!valid){
        console.log("Element is invalid")
        return
    }

    if(data.length > 2){
        data = data.splice(0, 2)
    }

    console.log("node:", $e.target)

    if(!data.title && !data.article){
        data.title = num;
        console.log("data:", data)
        $e.target.classList.add('selected')
    }else if (data.title && !data.article){
        data.article = num;
        console.log("data:", data)
        $e.target.classList.add('selected')
    }else{
        selected = Array.from(document.getElementsByClassName("selected"))
        selected.forEach(function(el){
            el.classList.remove('selected')
        })

        data.title = num;
        data.article = null;
        $e.target.classList.add('selected')

    }

    if(data.title && data.article){
        var obj = {
            url: url,
            text: body_html,
            title: data.title,
            article: data.article,
        }

        var datasetItem = JSON.stringify(obj)
        localStorage.setItem(url, datasetItem)
    }
}
</script> 
      </html>