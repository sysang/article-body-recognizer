<!DOCTYPE html>
<html>
<head>

      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

        <script> var url = encodeURIComponent('https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.10.89');</script>

        <script> var body_html = 'PGJvZHk+PHA+Y29tbWl0IGViOTY3ZTMyM2Y3ZmIwNzNjNTE0MDEwNzBmN2QyY2IzODFhMDAzZjcgQXV0aG9yOiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gRGF0ZTogV2VkIERlYyAyOSAxMjoyNjowOCAyMDIxICswMTAwIExpbnV4IDUuMTAuODkgTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8yMDIxMTIyNzE1MTMyNC42OTQ2NjE2MjNAbGludXhmb3VuZGF0aW9uLm9yZyBUZXN0ZWQtYnk6IEZsb3JpYW4gRmFpbmVsbGkgPGYuZmFpbmVsbGk+IFRlc3RlZC1ieTogTGludXggS2VybmVsIEZ1bmN0aW9uYWwgVGVzdGluZyA8bGtmdD4gVGVzdGVkLWJ5OiBTdWRpcCBNdWtoZXJqZWUgPHN1ZGlwLm11a2hlcmplZT4gVGVzdGVkLWJ5OiBHdWVudGVyIFJvZWNrIDxsaW51eD4gVGVzdGVkLWJ5OiBTaHVhaCBLaGFuIDxza2hhbj4gVGVzdGVkLWJ5OiBIdWxrIFJvYm90IDxodWxrcm9ib3Q+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgNTJhZDVkYThlMzE2ZmExMWUzYTUwYjNmMDg5YWE2M2U0MDg5YmY1MiBBdXRob3I6IFLDqW1pIERlbmlzLUNvdXJtb250IDxyZW1pPiBEYXRlOiBTdW4gRGVjIDE5IDE5OjAzOjM5IDIwMjEgKzAyMDAgcGhvbmV0L3BlcDogcmVmdXNlIHRvIGVuYWJsZSBhbiB1bmJvdW5kIHBpcGUgY29tbWl0IDc1YTJmMzE1MjAwOTU2MDBmNjUwNTk3YzBhYzQxZjQ4YjViYTAwNjggdXBzdHJlYW0uIFRoaXMgaW9jdGwoKSBpbXBsaWNpdGx5IGFzc3VtZWQgdGhhdCB0aGUgc29ja2V0IHdhcyBhbHJlYWR5IGJvdW5kIHRvIGEgdmFsaWQgbG9jYWwgc29ja2V0IG5hbWUsIGkuZS4gUGhvbmV0IG9iamVjdC4gSWYgdGhlIHNvY2tldCB3YXMgbm90IGJvdW5kLCB0d28gc2VwYXJhdGUgcHJvYmxlbXMgd291bGQgb2NjdXI6IDEpIFdlJ2Qgc2VuZCBhbiBwaXBlIGVuYWJsZW1lbnQgcmVxdWVzdCB3aXRoIGFuIGludmFsaWQgc291cmNlIG9iamVjdC4gMikgTGF0ZXIgc29ja2V0IGNhbGxzIGNvdWxkIEJVRyBvbiB0aGUgc29ja2V0IHVuZXhwZWN0ZWRseSBiZWluZyBjb25uZWN0ZWQgeWV0IG5vdCBib3VuZCB0byBhIHZhbGlkIG9iamVjdC4gUmVwb3J0ZWQtYnk6IHN5emJvdCsyZGM5MWU3ZmMzZGVhODhiMWU4YUBzeXprYWxsZXIuYXBwc3BvdG1haWwuY29tIFNpZ25lZC1vZmYtYnk6IFLDqW1pIERlbmlzLUNvdXJtb250IDxyZW1pPiBTaWduZWQtb2ZmLWJ5OiBEYXZpZCBTLiBNaWxsZXIgPGRhdmVtPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDdkZDUyYWYxZWI1Nzk4ZjU5MGQ5ZDllMWM1NmVkOGY1NzQ0ZWUwY2EgQXV0aG9yOiBMaW4gTWEgPGxpbm1hPiBEYXRlOiBGcmkgRGVjIDE3IDEwOjEzOjU2IDIwMjEgKzA4MDAgaGFtcmFkaW86IGltcHJvdmUgdGhlIGluY29tcGxldGUgZml4IHRvIGF2b2lkIE5QRCBjb21taXQgYjJmMzdhZWFkMWI4MmE3NzBjNDhiNWQ1ODNmMzVlYzIyYWFiYjYxZSB1cHN0cmVhbS4gVGhlIHByZXZpb3VzIGNvbW1pdCAzZTA1ODhjMjkxZDYgKCJoYW1yYWRpbzogZGVmZXIgYXgyNSBrZnJlZSBhZnRlciB1bnJlZ2lzdGVyX25ldGRldiIpIHJlb3JkZXIgdGhlIGtmcmVlIG9wZXJhdGlvbnMgYW5kIHVucmVnaXN0ZXJfbmV0ZGV2IG9wZXJhdGlvbiB0byBwcmV2ZW50IFVBRi4gVGhpcyBjb21taXQgaW1wcm92ZXMgdGhlIHByZXZpb3VzIG9uZSBieSBhbHNvIGRlZmVycmluZyB0aGUgbnVsbGlmeSBvZiB0aGUgYXgtJmd0O3R0eSBwb2ludGVyLiBPdGhlcndpc2UsIGEgTlVMTCBwb2ludGVyIGRlcmVmZXJlbmNlIGJ1ZyBvY2N1cnMuIFBhcnRpYWwgb2YgdGhlIHN0YWNrIHRyYWNlIGlzIHNob3duIGJlbG93LiBCVUc6IGtlcm5lbCBOVUxMIHBvaW50ZXIgZGVyZWZlcmVuY2UsIGFkZHJlc3M6IDAwMDAwMDAwMDAwMDA1MzggUklQOiAwMDEwOmF4X3htaXQrMHgxZjkvMHg0MDAgLi4uIENhbGwgVHJhY2U6IGRldl9oYXJkX3N0YXJ0X3htaXQrMHhlYy8weDMyMCBzY2hfZGlyZWN0X3htaXQrMHhlYS8weDI0MCBfX3FkaXNjX3J1bisweDE2Ni8weDVjMCBfX2Rldl9xdWV1ZV94bWl0KzB4MmM3LzB4YWYwIGF4MjVfc3RkX2VzdGFibGlzaF9kYXRhX2xpbmsrMHg1OS8weDYwIGF4MjVfY29ubmVjdCsweDNhMC8weDUwMCA/IHNlY3VyaXR5X3NvY2tldF9jb25uZWN0KzB4MmIvMHg0MCBfX3N5c19jb25uZWN0KzB4OTYvMHhjMCA/IF9faHJ0aW1lcl9pbml0KzB4YzAvMHhjMCA/IGNvbW1vbl9uc2xlZXArMHgyZS8weDUwID8gc3dpdGNoX2ZwdV9yZXR1cm4rMHgxMzkvMHgxYTAgX194NjRfc3lzX2Nvbm5lY3QrMHgxMS8weDIwIGRvX3N5c2NhbGxfNjQrMHgzMy8weDQwIGVudHJ5X1NZU0NBTExfNjRfYWZ0ZXJfaHdmcmFtZSsweDQ0LzB4YTkgVGhlIGNyYXNoIHBvaW50IGlzIHNob3duIGFzIGJlbG93IHN0YXRpYyB2b2lkIGF4X2VuY2FwcyguLi4pIHsgLi4uIHNldF9iaXQoVFRZX0RPX1dSSVRFX1dBS0VVUCwgYXgtJmd0O3R0eS0mZ3Q7ZmxhZ3MpOyAvLyBheC0mZ3Q7dHR5ID0gTlVMTCEgLi4uIH0gQnkgcGxhY2luZyB0aGUgbnVsbGlmeSBhY3Rpb24gYWZ0ZXIgdGhlIHVucmVnaXN0ZXJfbmV0ZGV2LCB0aGUgYXgtJmd0O3R0eSBwb2ludGVyIHdvbid0IGJlIGFzc2lnbmVkIGFzIE5VTEwgbmV0X2RldmljZSBmcmFtZXdvcmsgbGF5ZXIgaXMgd2VsbCBzeW5jaHJvbml6ZWQuIFNpZ25lZC1vZmYtYnk6IExpbiBNYSA8bGlubWE+IFNpZ25lZC1vZmYtYnk6IERhdmlkIFMuIE1pbGxlciA8ZGF2ZW0+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgNDUwMTIxMDc1YTZhNmYxZDUwZjk3MjI1ZDMzOTYzMTUzMDlkNjFhMSBBdXRob3I6IExpbiBNYSA8bGlubWE+IERhdGU6IE1vbiBOb3YgOCAxODozNzoyMSAyMDIxICswODAwIGhhbXJhZGlvOiBkZWZlciBheDI1IGtmcmVlIGFmdGVyIHVucmVnaXN0ZXJfbmV0ZGV2IGNvbW1pdCAzZTA1ODhjMjkxZDZjZTIyNWYyYjg5MTc1M2NhNDFkNDViYTQyNDY5IHVwc3RyZWFtLiBUaGVyZSBpcyBhIHBvc3NpYmxlIHJhY2UgY29uZGl0aW9uICh1c2UtYWZ0ZXItZnJlZSkgbGlrZSBiZWxvdyAoVVNFKSB8IChGUkVFKSBheDI1X3NlbmRtc2cgfCBheDI1X3F1ZXVlX3htaXQgfCBkZXZfcXVldWVfeG1pdCB8IF9fZGV2X3F1ZXVlX3htaXQgfCBfX2Rldl94bWl0X3NrYiB8IHNjaF9kaXJlY3RfeG1pdCB8IC4uLiB4bWl0X29uZSB8IG5ldGRldl9zdGFydF94bWl0IHwgdHR5X2xkaXNjX2tpbGwgX19uZXRkZXZfc3RhcnRfeG1pdCB8IG1raXNzX2Nsb3NlIGF4X3htaXQgfCBrZnJlZSBheF9lbmNhcHMgfCB8IEV2ZW4gdGhvdWdoIHRoZXJlIGFyZSB0d28gc3luY2hyb25pemF0aW9uIHByaW1pdGl2ZXMgYmVmb3JlIHRoZSBrZnJlZTogMS4gd2FpdF9mb3JfY29tcGxldGlvbihheC0mZ3Q7ZGVhZCkuIFRoaXMgY2FuIHByZXZlbnQgdGhlIHJhY2Ugd2l0aCByb3V0aW5lcyBmcm9tIG1raXNzX2lvY3RsLiBIb3dldmVyLCBpdCBjYW5ub3Qgc3RvcCB0aGUgcm91dGluZSBjb21pbmcgZnJvbSB1cHBlciBsYXllciwgaS5lLiwgdGhlIGF4MjVfc2VuZG1zZy4gMi4gbmV0aWZfc3RvcF9xdWV1ZShheC0mZ3Q7ZGV2KS4gSXQgc2VlbXMgdGhhdCB0aGlzIGxpbmUgb2YgY29kZSBhaW1zIHRvIGhhbHQgdGhlIHRyYW5zbWl0IHF1ZXVlIGJ1dCBpdCBmYWlscyB0byBzdG9wIHRoZSByb3V0aW5lIHRoYXQgYWxyZWFkeSBiZWluZyB4bWl0LiBUaGlzIHBhdGNoIHJlb3JkZXIgdGhlIGtmcmVlIGFmdGVyIHRoZSB1bnJlZ2lzdGVyX25ldGRldiB0byBhdm9pZCB0aGUgcG9zc2libGUgVUFGIGFzIHRoZSB1bnJlZ2lzdGVyX25ldGRldigpIGlzIHdlbGwgc3luY2hyb25pemVkIGFuZCB3b24ndCByZXR1cm4gaWYgdGhlcmUgaXMgYSBydW5uaW5nIHJvdXRpbmUuIFNpZ25lZC1vZmYtYnk6IExpbiBNYSA8bGlubWE+IFNpZ25lZC1vZmYtYnk6IERhdmlkIFMuIE1pbGxlciA8ZGF2ZW0+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgOGUzNGQwN2RkNGQ5Zjc4MTFkOGFlMzVhZGVlMjRlNzhhNDU3Njg0NCBBdXRob3I6IExpbiBNYSA8bGlubWE+IERhdGU6IEZyaSBEZWMgMTcgMTA6Mjk6NDEgMjAyMSArMDgwMCBheDI1OiBOUEQgYnVnIHdoZW4gZGV0YWNoaW5nIEFYMjUgZGV2aWNlIGNvbW1pdCAxYWRlNDhkMGMyN2Q1ZGExY2NmNGI1ODNkOGM1ZmM4YjUzNGEzYWM4IHVwc3RyZWFtLiBUaGUgZXhpc3RpbmcgY2xlYW51cCByb3V0aW5lIGltcGxlbWVudGF0aW9uIGlzIG5vdCB3ZWxsIHN5bmNocm9uaXplZCB3aXRoIHRoZSBzeXNjYWxsIHJvdXRpbmUuIFdoZW4gYSBkZXZpY2UgaXMgZGV0YWNoaW5nLCBiZWxvdyByYWNlIGNvdWxkIG9jY3VyLiBzdGF0aWMgaW50IGF4MjVfc2VuZG1zZyguLi4pIHsgLi4uIGxvY2tfc29jaygpIGF4MjUgPSBza190b19heDI1KHNrKTsgaWYgKGF4MjUtJmd0O2F4MjVfZGV2ID09IE5VTEwpIC8vIENIRUNLIC4uLiBheDI1X3F1ZXVlX3htaXQoc2tiLCBheDI1LSZndDtheDI1X2Rldi0mZ3Q7ZGV2KTsgLy8gVVNFIC4uLiB9IHN0YXRpYyB2b2lkIGF4MjVfa2lsbF9ieV9kZXZpY2UoLi4uKSB7IC4uLiBpZiAocy0mZ3Q7YXgyNV9kZXYgPT0gYXgyNV9kZXYpIHsgcy0mZ3Q7YXgyNV9kZXYgPSBOVUxMOyAuLi4gfSBPdGhlciBzeXNjYWxsIGZ1bmN0aW9ucyBsaWtlIGF4MjVfZ2V0c29ja29wdCwgYXgyNV9nZXRuYW1lLCBheDI1X2luZm9fc2hvdyBhbHNvIHN1ZmZlciBmcm9tIHNpbWlsYXIgcmFjZXMuIFRvIGZpeCB0aGVtLCB0aGlzIHBhdGNoIGludHJvZHVjZSBsb2NrX3NvY2soKSBpbnRvIGF4MjVfa2lsbF9ieV9kZXZpY2UgaW4gb3JkZXIgdG8gZ3VhcmFudGVlIHRoYXQgdGhlIG51bGxpZnkgYWN0aW9uIGluIGNsZWFudXAgcm91dGluZSBjYW5ub3QgcHJvY2VlZCB3aGVuIGFub3RoZXIgc29ja2V0IHJlcXVlc3QgaXMgcGVuZGluZy4gU2lnbmVkLW9mZi1ieTogSGFuamllIFd1IDxuYWdpPiBTaWduZWQtb2ZmLWJ5OiBMaW4gTWEgPGxpbm1hPiBTaWduZWQtb2ZmLWJ5OiBEYXZpZCBTLiBNaWxsZXIgPGRhdmVtPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDUwZjc4NDg2ZjkwYjkxNDg0MDAxYmZjY2M2NTJkNjZmYzMwODI1NWEgQXV0aG9yOiBHdWVudGVyIFJvZWNrIDxsaW51eD4gRGF0ZTogRnJpIERlYyAzIDEzOjQyOjIyIDIwMjEgLTA4MDAgaHdtb246IChsbTkwKSBEbyBub3QgcmVwb3J0ICdidXN5JyBzdGF0dXMgYml0IGFzIGFsYXJtIGNvbW1pdCBjZGM1Mjg3YWNhZDllZGUxMjE5MjRhOWM5MzEzNTQ0YjgwZDE1ODQyIHVwc3RyZWFtLiBCaXQgNyBvZiB0aGUgc3RhdHVzIHJlZ2lzdGVyIGluZGljYXRlcyB0aGF0IHRoZSBjaGlwIGlzIGJ1c3kgZG9pbmcgYSBjb252ZXJzaW9uLiBJdCBkb2VzIG5vdCBpbmRpY2F0ZSBhbiBhbGFybSBzdGF0dXMuIFN0b3AgcmVwb3J0aW5nIGl0IGFzIGFsYXJtIHN0YXR1cyBiaXQuIFNpZ25lZC1vZmYtYnk6IEd1ZW50ZXIgUm9lY2sgPGxpbnV4PiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGVjMWQyMjJkMzdlYWY2YjJkMmRiZGNmMmM0ZWI3OTAzZmQ3NGZjMWUgQXV0aG9yOiBHdWVudGVyIFJvZWNrIDxsaW51eD4gRGF0ZTogRnJpIE5vdiAyNiAyMjo0MzozOSAyMDIxIC0wODAwIGh3bW9tOiAobG05MCkgRml4IGNpdGljYWwgYWxhcm0gc3RhdHVzIGZvciBNQVg2NjgwL01BWDY2ODEgY29tbWl0IGRhN2RjMDU2ODQ5MTEwNGM3YWNiNjMyZTlkNDFkZGNlOWFhYWJiYjEgdXBzdHJlYW0uIFRlc3RzIHdpdGggYSByZWFsIGNoaXAgYW5kIGEgY2xvc2VyIGxvb2sgaW50byB0aGUgZGF0YXNoZWV0IHJldmVhbHMgdGhhdCB0aGUgbG9jYWwgYW5kIHJlbW90ZSBjcml0aWNhbCBhbGFybSBzdGF0dXMgYml0cyBhcmUgc3dhcHBlZCBmb3IgTUFYNjY4MC9NQVg2NjgxLiBTaWduZWQtb2ZmLWJ5OiBHdWVudGVyIFJvZWNrIDxsaW51eD4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCA0NDFkMzg3MzY2NGQxNzA5ODI5MjJjNWQyZmMwMWZhODlkOTQzOWVkIEF1dGhvcjogR3VvZG9uZyBMaXUgPGd1b2RvbmcubGl1PiBEYXRlOiBXZWQgTm92IDEwIDE1OjE5OjAwIDIwMjEgKzA4MDAgcGluY3RybDogbWVkaWF0ZWs6IGZpeCBnbG9iYWwtb3V0LW9mLWJvdW5kcyBpc3N1ZSBjb21taXQgMmQ1NDQ2ZGE1YWNlY2Y5YzY3ZGIxYzlkNTVhZTJjM2U1ZGUwMWY4ZCB1cHN0cmVhbS4gV2hlbiBlaW50IHZpcnR1YWwgZWludCBudW1iZXIgaXMgZ3JlYXRlciB0aGFuIGdwaW8gbnVtYmVyLCBpdCBtYXliZSBwcm9kdWNlICdkZXNjW2VpbnRfbl0nIHNpemUgZ2xvYmxlLW91dC1vZi1ib3VuZHMgaXNzdWUuIFNpZ25lZC1vZmYtYnk6IEd1b2RvbmcgTGl1IDxndW9kb25nLmxpdT4gU2lnbmVkLW9mZi1ieTogWmhpeW9uZyBUYW8gPHpoaXlvbmcudGFvPiBSZXZpZXdlZC1ieTogQ2hlbi1ZdSBUc2FpIDx3ZW5zdD4gTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8yMDIxMTExMDA3MTkwMC40NDkwLTItemhpeW9uZy50YW9AbWVkaWF0ZWsuY29tIFNpZ25lZC1vZmYtYnk6IExpbnVzIFdhbGxlaWogPGxpbnVzLndhbGxlaWo+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgOWM3NWE5NjU3YmRjNjQzZTc4NzE5ZWNiMTM5ZWJmZjRkNWFlZmU1MyBBdXRob3I6IERlcmVrIEZhbmcgPGRlcmVrLmZhbmc+IERhdGU6IFR1ZSBEZWMgMTQgMTg6NTA6MzMgMjAyMSArMDgwMCBBU29DOiBydDU2ODI6IGZpeCB0aGUgd3JvbmcgamFjayB0eXBlIGRldGVjdGVkIGNvbW1pdCA4ZGViMzRhOTBmMDYzNzRmZDI2ZjcyMmMyYTc5ZTE1MTYwZjY2YmU3IHVwc3RyZWFtLiBTb21lIHBvd2VycyB3ZXJlIGNoYW5nZWQgZHVyaW5nIHRoZSBqYWNrIGluc2VydCBkZXRlY3Rpb24gYW5kIGNsaydzIGVuYWJsZS9kaXNhYmxlIGluIENDRi4gSWYgaW4gcGFyYWxsZWwsIHRoZSBpbmZsdWVuY2UgaGFzIGEgY2hhbmNlIHRvIGRldGVjdCB0aGUgd3JvbmcgamFjayB0eXBlLCBzbyBhZGQgYSBsb2NrLiBTaWduZWQtb2ZmLWJ5OiBEZXJlayBGYW5nIDxkZXJlay5mYW5nPiBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMjE0MTA1MDMzLjQ3MS0xLWRlcmVrLmZhbmdAcmVhbHRlay5jb20gU2lnbmVkLW9mZi1ieTogTWFyayBCcm93biBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDk0Y2FhYjVhZjE5YTI5NWNiZWMxZDdmYTZlOGI3MzEwZjA1ODMxN2YgQXV0aG9yOiBNYXJ0aW4gUG92acWhZXIgPHBvdmlrPiBEYXRlOiBNb24gRGVjIDYgMjI6NDU6NDMgMjAyMSArMDAwMCBBU29DOiB0YXMyNzcwOiBGaXggc2V0dGluZyBvZiBoaWdoIHNhbXBsZSByYXRlcyBjb21taXQgODBkNWJlMWEwNTdlMDVmMDFkNjZlOTg2Y2ZkMzRkNzE4NDVlNTE5MCB1cHN0cmVhbS4gQWx0aG91Z2ggdGhlIGNvZGVjIGFkdmVydGlzZXMgc3VwcG9ydCBmb3IgMTc2LjQgYW5kIDE5MiBrc3BzLCB3aXRob3V0IHRoaXMgZml4IHNldHRpbmcgdGhvc2Ugc2FtcGxlIHJhdGVzIGZhaWxzIHdpdGggRUlOVkFMIGF0IGh3X3BhcmFtcyB0aW1lLiBTaWduZWQtb2ZmLWJ5OiBNYXJ0aW4gUG92acWhZXIgPHBvdmlrPiBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMjA2MjI0NTI5Ljc0NjU2LTEtcG92aWtAcHJvdG9ubWFpbC5jb20gU2lnbmVkLW9mZi1ieTogTWFyayBCcm93biBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGM3MjgyNzkwYzc4MmY1MjE2YzUwYjZiODNiODE1ZjAzYzQ4ZTczYWQgQXV0aG9yOiBIYW5zIGRlIEdvZWRlIDxoZGVnb2VkZT4gRGF0ZTogTW9uIERlYyA2IDIzOjI5OjI3IDIwMjEgLTA4MDAgSW5wdXQ6IGdvb2RpeCAtIGFkZCBpZC0mZ3Q7bW9kZWwgbWFwcGluZyBmb3IgdGhlICI5MTExIiBtb2RlbCBjb21taXQgODFlODE4ODY5YmU1MjJiYzhmYTZmN2RmMWI5MmQ3ZTc2NTM3OTI2YyB1cHN0cmVhbS4gQWRkIGQtJmd0O21vZGVsIG1hcHBpbmcgZm9yIHRoZSAiOTExMSIgbW9kZWwsIHRoaXMgZml4ZXMgdXNlcyB1c2luZyBhIHdyb25nIGNvbmZpZ19sZW4gb2YgMjQwIGJ5dGVzIHdoaWxlIHRoZSAiOTExMSIgbW9kZWwgdXNlcyBvbmx5IDE4NiBieXRlcyBvZiBjb25maWcuIFNpZ25lZC1vZmYtYnk6IEhhbnMgZGUgR29lZGUgPGhkZWdvZWRlPiBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMjA2MTY0NzQ3LjE5NzMwOS0yLWhkZWdvZWRlQHJlZGhhdC5jb20gU2lnbmVkLW9mZi1ieTogRG1pdHJ5IFRvcm9raG92IDxkbWl0cnkudG9yb2tob3Y+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgM2JiM2JmNTBkNjlmN2ZhYjU3YzVhZjI5M2M3NDViNTg2OTQ1ZjcwZCBBdXRob3I6IEpvaG5ueSBDaHVhbmcgPGpvaG5ueS5jaHVhbmcuZW1jPiBEYXRlOiBNb24gRGVjIDIwIDAwOjI4OjQ1IDIwMjEgLTA4MDAgSW5wdXQ6IGVsYW50c19pMmMgLSBkbyBub3QgY2hlY2sgUmVtYXJrIElEIG9uIGVLVEgzOTAwL2VLVEg1MzEyIGNvbW1pdCA0ZWJmZWUyYmJjMWE5YzM0M2RkNTA1NjViYTVhZTI0OWZhYzMyMjY3IHVwc3RyZWFtLiBUaGUgZUtUSDM5MDAvZUtUSDUzMTIgc2VyaWVzIGRvIG5vdCBzdXBwb3J0IHRoZSBmaXJtd2FyZSB1cGRhdGUgcnVsZXMgb2YgUmVtYXJrIElELiBFeGNsdWRlIHRoZXNlIHR3byBzZXJpZXMgZnJvbSBjaGVja2luZyBpdCB3aGVuIHVwZGF0aW5nIHRoZSBmaXJtd2FyZSBpbiB0b3VjaCBjb250cm9sbGVycy4gU2lnbmVkLW9mZi1ieTogSm9obm55IENodWFuZyA8am9obm55LmNodWFuZy5lbWM+IExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMTYzOTYxOTYwMy0yMDYxNi0xLWdpdC1zZW5kLWVtYWlsLWpvaG5ueS5jaHVhbmcuZW1jQGdtYWlsLmNvbSBTaWduZWQtb2ZmLWJ5OiBEbWl0cnkgVG9yb2tob3YgPGRtaXRyeS50b3Jva2hvdj4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCBlZTZmMzQyMTVjNWRmYTIyNTcyOThjYzM2MmNkNzllMTRhZjVhMjVhIEF1dGhvcjogQW5kcmV5IFJ5YWJpbmluIDxhcmJuPiBEYXRlOiBGcmkgRGVjIDI0IDIxOjEyOjM1IDIwMjEgLTA4MDAgbW06IG1lbXBvbGljeTogZml4IFRIUCBhbGxvY2F0aW9ucyBlc2NhcGluZyBtZW1wb2xpY3kgcmVzdHJpY3Rpb25zIGNvbW1pdCAzMzg2MzUzNDA2NjlkNWIzMTdjN2U4ZGNmNGZmZjRhMGYzNjUxZDg3IHVwc3RyZWFtLiBhbGxvY19wYWdlc192bWEoKSBtYXkgdHJ5IHRvIGFsbG9jYXRlIFRIUCBwYWdlIG9uIHRoZSBsb2NhbCBOVU1BIG5vZGUgZmlyc3Q6IHBhZ2UgPSBfX2FsbG9jX3BhZ2VzX25vZGUoaHBhZ2Vfbm9kZSwgZ2ZwIHwgX19HRlBfVEhJU05PREUgfCBfX0dGUF9OT1JFVFJZLCBvcmRlcik7IEFuZCBpZiB0aGUgYWxsb2NhdGlvbiBmYWlscyBpdCByZXRyaWVzIGFsbG93aW5nIHJlbW90ZSBtZW1vcnk6IGlmICghcGFnZSAoZ2ZwIF9fR0ZQX0RJUkVDVF9SRUNMQUlNKSkgcGFnZSA9IF9fYWxsb2NfcGFnZXNfbm9kZShocGFnZV9ub2RlLCBnZnAsIG9yZGVyKTsgSG93ZXZlciwgdGhpcyByZXRyeSBhbGxvY2F0aW9uIGNvbXBsZXRlbHkgaWdub3JlcyBtZW1vcnkgcG9saWN5IG5vZGVtYXNrIGFsbG93aW5nIGFsbG9jYXRpb24gdG8gZXNjYXBlIHJlc3RyaWN0aW9ucy4gVGhlIGZpcnN0IGFwcGVhcmFuY2Ugb2YgdGhpcyBidWcgc2VlbXMgdG8gYmUgdGhlIGNvbW1pdCBhYzViMmMxODkxMWYgKCJtbTogdGhwOiByZWxheCBfX0dGUF9USElTTk9ERSBmb3IgTUFEVl9IVUdFUEFHRSBtYXBwaW5ncyIpLiBUaGUgYnVnIGRpc2FwcGVhcmVkIGxhdGVyIGluIHRoZSBjb21taXQgODljODNmYjUzOWY5ICgibW0sIHRocDogY29uc29saWRhdGUgVEhQIGdmcCBoYW5kbGluZyBpbnRvIGFsbG9jX2h1Z2VwYWdlX2RpcmVjdF9nZnBtYXNrIikgYW5kIHJlYXBwZWFyZWQgYWdhaW4gaW4gc2xpZ2h0bHkgZGlmZmVyZW50IGZvcm0gaW4gdGhlIGNvbW1pdCA3NmU2NTRjYzkxYmIgKCJtbSwgcGFnZV9hbGxvYzogYWxsb3cgaHVnZXBhZ2UgZmFsbGJhY2sgdG8gcmVtb3RlIG5vZGVzIHdoZW4gbWFkdmlzZWQiKSBGaXggdGhpcyBieSBwYXNzaW5nIGNvcnJlY3Qgbm9kZW1hc2sgdG8gdGhlIF9fYWxsb2NfcGFnZXMoKSBjYWxsLiBUaGUgZGVtb25zdHJhdGlvbi9yZXByb2R1Y2VyIG9mIHRoZSBwcm9ibGVtOiAkIG1vdW50IC1vcmVtb3VudCxzaXplPTRHLGh1Z2U9YWx3YXlzIC9kZXYvc2htLyAkIGVjaG8gYWx3YXlzICZndDsgL3N5cy9rZXJuZWwvbW0vdHJhbnNwYXJlbnRfaHVnZXBhZ2UvZGVmcmFnICQgY2F0IG1iaW5kX3RocC5jICNpbmNsdWRlIDx1bmlzdGQuaD4gI2luY2x1ZGUgPHN5cz4gI2luY2x1ZGUgPHN5cz4gI2luY2x1ZGUgPGZjbnRsLmg+ICNpbmNsdWRlIDxhc3NlcnQuaD4gI2luY2x1ZGUgPHN0ZGxpYi5oPiAjaW5jbHVkZSA8c3RkaW8uaD4gI2luY2x1ZGUgPG51bWFpZi5oPiAjZGVmaW5lIFNJWkUgMlVMTCAmbHQ7Jmx0OyAzMCBpbnQgbWFpbihpbnQgYXJnYywgY2hhciAqKmFyZ3YpIHsgaW50IGZkOyB1bnNpZ25lZCBsb25nIGxvbmcgaTsgY2hhciAqYWRkcjsgcGlkX3QgcGlkOyBjaGFyIGJ1ZlsxMDBdOyB1bnNpZ25lZCBsb25nIG5vZGVtYXNrID0gMTsgZmQgPSBvcGVuKCIvZGV2L3NobS90ZXN0IiwgT19SRFdSfE9fQ1JFQVQpOyBhc3NlcnQoZmQgJmd0OyAwKTsgYXNzZXJ0KGZ0cnVuY2F0ZShmZCwgU0laRSkgPT0gMCk7IGFkZHIgPSBtbWFwKE5VTEwsIFNJWkUsIFBST1RfUkVBRHxQUk9UX1dSSVRFLCBNQVBfU0hBUkVELCBmZCwgMCk7IGFzc2VydChtYmluZChhZGRyLCBTSVpFLCBNUE9MX0JJTkQsIG5vZGVtYXNrLCAyLCBNUE9MX01GX1NUUklDVHxNUE9MX01GX01PVkUpPT0wKTsgZm9yIChpID0gMDsgaSAmbHQ7IFNJWkU7IGkrPTQwOTYpIHsgYWRkcltpXSA9IDE7IH0gcGlkID0gZ2V0cGlkKCk7IHNucHJpbnRmKGJ1Ziwgc2l6ZW9mKGJ1ZiksICJncmVwIHNobSAvcHJvYy8lZC9udW1hX21hcHMiLCBwaWQpOyBzeXN0ZW0oYnVmKTsgc2xlZXAoMTAwMDApOyByZXR1cm4gMDsgfSAkIGdjYyBtYmluZF90aHAuYyAtbyBtYmluZF90aHAgLWxudW1hICQgbnVtYWN0bCAtSCBhdmFpbGFibGU6IDIgbm9kZXMgKDAtMSkgbm9kZSAwIGNwdXM6IDAgMiBub2RlIDAgc2l6ZTogMTkxOCBNQiBub2RlIDAgZnJlZTogMTU5NSBNQiBub2RlIDEgY3B1czogMSAzIG5vZGUgMSBzaXplOiAyMDE0IE1CIG5vZGUgMSBmcmVlOiAxNzMxIE1CIG5vZGUgZGlzdGFuY2VzOiBub2RlIDAgMSAwOiAxMCAyMCAxOiAyMCAxMCAkIHJtIC1mIC9kZXYvc2htL3Rlc3Q7IHRhc2tzZXQgLWMgMCAuL21iaW5kX3RocCA3ZmQ5NzBhMDAwMDAgYmluZDowIGZpbGU9L2Rldi9zaG0vdGVzdCBkaXJ0eT01MjQyODggYWN0aXZlPTAgTjA9Mzk2ODAwIE4xPTEyNzQ4OCBrZXJuZWxwYWdlc2l6ZV9rQj00IExpbms6IGh0dHBzOi8vbGttbC5rZXJuZWwub3JnL3IvMjAyMTEyMDgxNjUzNDMuMjIzNDktMS1hcmJuQHlhbmRleC10ZWFtLmNvbSBGaXhlczogYWM1YjJjMTg5MTFmICgibW06IHRocDogcmVsYXggX19HRlBfVEhJU05PREUgZm9yIE1BRFZfSFVHRVBBR0UgbWFwcGluZ3MiKSBTaWduZWQtb2ZmLWJ5OiBBbmRyZXkgUnlhYmluaW4gPGFyYm4+IEFja2VkLWJ5OiBNaWNoYWwgSG9ja28gPG1ob2Nrbz4gQWNrZWQtYnk6IE1lbCBHb3JtYW4gPG1nb3JtYW4+IEFja2VkLWJ5OiBEYXZpZCBSaWVudGplcyA8cmllbnRqZXM+IENjOiBBbmRyZWEgQXJjYW5nZWxpIDxhYXJjYW5nZT4gQ2M6IDxzdGFibGU+IFNpZ25lZC1vZmYtYnk6IEFuZHJldyBNb3J0b24gPGFrcG0+IFNpZ25lZC1vZmYtYnk6IExpbnVzIFRvcnZhbGRzIDx0b3J2YWxkcz4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCA4MDA4ZmMxZDBiZTFjMzgxYWE4MDc3ZGZhYjJkOTgwMTg4NjExYWUyIEF1dGhvcjogU2VhbiBDaHJpc3RvcGhlcnNvbiA8c2VhbmpjPiBEYXRlOiBUdWUgRGVjIDcgMTk6MzA6MDUgMjAyMSArMDAwMCBLVk06IFZNWDogRml4IHN0YWxlIGRvY3MgZm9yIGt2bS1pbnRlbC5lbXVsYXRlX2ludmFsaWRfZ3Vlc3Rfc3RhdGUgY29tbWl0IDBmZjI5NzAxZmZhZDlhNWQ1YTI0MzQ0ZDhiMDlmM2FmN2I5NmZmZGEgdXBzdHJlYW0uIFVwZGF0ZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3Iga3ZtLWludGVsJ3MgZW11bGF0ZV9pbnZhbGlkX2d1ZXN0X3N0YXRlIHRvIHJlY3RpZnkgdGhlIGRlc2NyaXB0aW9uIG9mIEtWTSdzIGRlZmF1bHQgYmVoYXZpb3IsIGFuZCB0byBkb2N1bWVudCB0aGF0IHRoZSBiZWhhdmlvciBhbmQgdGh1cyBwYXJhbWV0ZXIgb25seSBhcHBsaWVzIHRvIEwxLiBGaXhlczogYTI3Njg1YzMzYWNjICgiS1ZNOiBWTVg6IEVtdWxhdGUgaW52YWxpZCBndWVzdCBzdGF0ZSBieSBkZWZhdWx0IikgU2lnbmVkLW9mZi1ieTogU2VhbiBDaHJpc3RvcGhlcnNvbiA8c2VhbmpjPiBNZXNzYWdlLUlkOiAmbHQ7MjAyMTEyMDcxOTMwMDYuMTIwOTk3LTQtc2VhbmpjQGdvb2dsZS5jb20mZ3Q7IFJldmlld2VkLWJ5OiBNYXhpbSBMZXZpdHNreSA8bWxldml0c2s+IFNpZ25lZC1vZmYtYnk6IFBhb2xvIEJvbnppbmkgPHBib256aW5pPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGQ5MWVkMjUxZmQ3MDY1YjU3ZDZjNjA5NjRkMTU1NjJmYzRlNzNmN2QgQXV0aG9yOiBNYXJpYW4gUG9zdGV2Y2EgPHBvc3RldWNhPiBEYXRlOiBTYXQgRGVjIDQgMjM6NDk6MTIgMjAyMSArMDIwMCB1c2I6IGdhZGdldDogdV9ldGhlcjogZml4IHJhY2UgaW4gc2V0dGluZyBNQUMgYWRkcmVzcyBpbiBzZXR1cCBwaGFzZSBjb21taXQgODkwZDViNDA5MDhiZmQxYTc5YmUwMThkMmQyOTdjZjlkZjYwZjRlZSB1cHN0cmVhbS4gV2hlbiBsaXN0ZW5pbmcgZm9yIG5vdGlmaWNhdGlvbnMgdGhyb3VnaCBuZXRsaW5rIG9mIGEgbmV3IGludGVyZmFjZSBiZWluZyByZWdpc3RlcmVkLCBzcG9yYWRpY2FsbHksIGl0IGlzIHBvc3NpYmxlIGZvciB0aGUgTUFDIHRvIGJlIHJlYWQgYXMgemVyby4gVGhlIHplcm8gTUFDIGFkZHJlc3MgbGFzdHMgYSBzaG9ydCBwZXJpb2Qgb2YgdGltZSBhbmQgdGhlbiBzd2l0Y2hlcyB0byBhIHZhbGlkIHJhbmRvbSBNQUMgYWRkcmVzcy4gVGhpcyBjYXVzZXMgcHJvYmxlbXMgZm9yIG5ldGQgaW4gQW5kcm9pZCwgd2hpY2ggYXNzdW1lcyB0aGF0IHRoZSBpbnRlcmZhY2UgaXMgbWFsZnVuY3Rpb25pbmcgYW5kIHdpbGwgbm90IHVzZSBpdC4gSW4gdGhlIGdvb2QgY2FzZSB3ZSBnZXQgdGhpcyBsb2c6IEludGVyZmFjZUNvbnRyb2xsZXI6OmdldENmZygpIGlmTmFtZSB1c2IwIGh3QWRkciA5MjphODpmMDo3Mzo3OTo1YiBpcHY0QWRkciAwLjAuMC4wIGZsYWdzIDB4MTAwMiBJbiB0aGUgZXJyb3IgY2FzZSB3ZSBnZXQgdGhlc2UgbG9nczogSW50ZXJmYWNlQ29udHJvbGxlcjo6Z2V0Q2ZnKCkgaWZOYW1lIHVzYjAgaHdBZGRyIDAwOjAwOjAwOjAwOjAwOjAwIGlwdjRBZGRyIDAuMC4wLjAgZmxhZ3MgMHgxMDAyIG5ldGQgOiBpbnRlcmZhY2VHZXRDZmcoInVzYjAiKSBuZXRkIDogaW50ZXJmYWNlU2V0Q2ZnKCkgLSZndDsgU2VydmljZVNwZWNpZmljRXhjZXB0aW9uICg5OSwgIltDYW5ub3QgYXNzaWduIHJlcXVlc3RlZCBhZGRyZXNzXSA6IGlvY3RsKCkgZmFpbGVkIikgVGhlIHJlYXNvbiBmb3IgdGhlIGlzc3VlIGlzIHRoZSBvcmRlciBpbiB3aGljaCB0aGUgaW50ZXJmYWNlIGlzIHNldHVwLCBpdCBpcyBmaXJzdCByZWdpc3RlcmVkIHRocm91Z2ggcmVnaXN0ZXJfbmV0ZGV2KCkgYW5kIGFmdGVyIHRoZSBNQUMgYWRkcmVzcyBpcyBzZXQuIEZpeGVkIGJ5IGZpcnN0IHNldHRpbmcgdGhlIE1BQyBhZGRyZXNzIG9mIHRoZSBuZXRfZGV2aWNlIGFuZCBhZnRlciB0aGF0IGNhbGxpbmcgcmVnaXN0ZXJfbmV0ZGV2KCkuIEZpeGVzOiBiY2Q0YTFjNDBiZWU4ODVlICgidXNiOiBnYWRnZXQ6IHVfZXRoZXI6IGNvbnN0cnVjdCB3aXRoIGRlZmF1bHQgdmFsdWVzIGFuZCBhZGQgc2V0dGVycy9nZXR0ZXJzIikgQ2M6IHN0YWJsZUB2Z2VyLmtlcm5lbC5vcmcgU2lnbmVkLW9mZi1ieTogTWFyaWFuIFBvc3RldmNhIDxwb3N0ZXVjYT4gTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8yMDIxMTIwNDIxNDkxMi4xNzYyNy0xLXBvc3RldWNhQG11dGV4Lm9uZSBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDY2OTdmMjliZjU2YjZiZDA3ZGRmMTIxOGYyZjhhNDg2MDFhNGI3NWYgQXV0aG9yOiBDaHJpc3RpYW4gQnJhdW5lciA8Y2hyaXN0aWFuLmJyYXVuZXI+IERhdGU6IE1vbiBOb3YgMjkgMTI6MTY6MzkgMjAyMSArMDEwMCBjZXBoOiBmaXggdXAgbm9uLWRpcmVjdG9yeSBjcmVhdGlvbiBpbiBTR0lEIGRpcmVjdG9yaWVzIGNvbW1pdCBmZDg0YmZkZGRkMTY5YzIxOWMzYTYzNzg4OWE4Yjg3ZjcwYTA3MmMyIHVwc3RyZWFtLiBDZXBoIGFsd2F5cyBpbmhlcml0cyB0aGUgU0dJRCBiaXQgaWYgaXQgaXMgc2V0IG9uIHRoZSBwYXJlbnQgaW5vZGUsIHdoaWxlIHRoZSBnZW5lcmljIGlub2RlX2luaXRfb3duZXIgZG9lcyBub3QgZG8gdGhpcyBpbiBhIGZldyBjYXNlcyB3aGVyZSBpdCBjYW4gY3JlYXRlIGEgcG9zc2libGUgc2VjdXJpdHkgcHJvYmxlbSAoY2YuIFsxXSkuIFVwZGF0ZSBjZXBoIHRvIHN0cmlwIHRoZSBTR0lEIGJpdCBqdXN0IGFzIGlub2RlX2luaXRfb3duZXIgd291bGQuIFRoaXMgYnVnIHdhcyBkZXRlY3RlZCBieSB0aGUgbWFwcGVkIG1vdW50IHRlc3RzdWl0ZSBpbiBbM10uIFRoZSB0ZXN0c3VpdGUgdGVzdHMgYWxsIGNvcmUgVkZTIGZ1bmN0aW9uYWxpdHkgYW5kIHNlbWFudGljcyB3aXRoIGFuZCB3aXRob3V0IG1hcHBlZCBtb3VudHMuIFRoYXQgaXMgdG8gc2F5IGl0IGZ1bmN0aW9ucyBhcyBhIGdlbmVyaWMgVkZTIHRlc3RzdWl0ZSBpbiBhZGRpdGlvbiB0byBhIG1hcHBlZCBtb3VudCB0ZXN0c3VpdGUuIFdoaWxlIHdvcmtpbmcgb24gbWFwcGVkIG1vdW50IHN1cHBvcnQgZm9yIGNlcGgsIFNJR0QgaW5oZXJpdGFuY2Ugd2FzIHRoZSBvbmx5IGZhaWxpbmcgdGVzdCBmb3IgY2VwaCBhZnRlciB0aGUgcG9ydC4gVGhlIHNhbWUgYnVnIHdhcyBkZXRlY3RlZCBieSB0aGUgbWFwcGVkIG1vdW50IHRlc3RzdWl0ZSBpbiBYRlMgaW4gSmFudWFyeSAyMDIxIChjZi4gWzJdKS4gWzFdOiBjb21taXQgMGZhM2VjZDg3ODQ4ICgiRml4IHVwIG5vbi1kaXJlY3RvcnkgY3JlYXRpb24gaW4gU0dJRCBkaXJlY3RvcmllcyIpIFsyXTogY29tbWl0IDAxZWExNzNlMTAzZSAoInhmczogZml4IHVwIG5vbi1kaXJlY3RvcnkgY3JlYXRpb24gaW4gU0dJRCBkaXJlY3RvcmllcyIpIFszXTogaHR0cHM6Ly9naXQua2VybmVsLm9yZy9mcy94ZnMveGZzdGVzdHMtZGV2LmdpdCBDYzogc3RhYmxlQHZnZXIua2VybmVsLm9yZyBTaWduZWQtb2ZmLWJ5OiBDaHJpc3RpYW4gQnJhdW5lciA8Y2hyaXN0aWFuLmJyYXVuZXI+IFJldmlld2VkLWJ5OiBKZWZmIExheXRvbiA8amxheXRvbj4gU2lnbmVkLW9mZi1ieTogSWx5YSBEcnlvbW92IDxpZHJ5b21vdj4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCBmZmZiNjU4MWEyM2FkZDQxNjIzOWRmY2Y3ZTdmMzk4MGM2YjkxM2RhIEF1dGhvcjogQ2hhbyBZdSA8Y2hhbz4gRGF0ZTogU3VuIERlYyAxMiAxNzoxNjozMCAyMDIxICswODAwIGYyZnM6IGZpeCB0byBkbyBzYW5pdHkgY2hlY2sgb24gbGFzdCB4YXR0ciBlbnRyeSBpbiBfX2YyZnNfc2V0eGF0dHIoKSBjb21taXQgNTU5OGIyNGVmYWY0ODkyNzQxYzc5OGI0MjVkNTQzZTRiZWQzNTdhMSB1cHN0cmVhbS4gQXMgV2VucWluZyBMaXUgcmVwb3J0ZWQgaW4gYnVnemlsbGE6IGh0dHBzOi8vYnVnemlsbGEua2VybmVsLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjE1MjM1IC0gT3ZlcnZpZXcgcGFnZSBmYXVsdCBpbiBmMmZzX3NldHhhdHRyKCkgd2hlbiBtb3VudCBhbmQgb3BlcmF0ZSBvbiBjb3JydXB0ZWQgaW1hZ2UgLSBSZXByb2R1Y2UgdGVzdGVkIG9uIGtlcm5lbCA1LjE2LXJjMywgNS4xNS5YIHVuZGVyIHJvb3QgMS4gdW56aXAgdG1wNy56aXAgMi4gLi9zaW5nbGUuc2ggZjJmcyA3IFNvbWV0aW1lcyBuZWVkIHRvIHJ1biB0aGUgc2NyaXB0IHNldmVyYWwgdGltZXMgLSBLZXJuZWwgZHVtcCBsb29wMDogZGV0ZWN0ZWQgY2FwYWNpdHkgY2hhbmdlIGZyb20gMCB0byAxMzEwNzIgRjJGUy1mcyAobG9vcDApOiBGb3VuZCBuYXRfYml0cyBpbiBjaGVja3BvaW50IEYyRlMtZnMgKGxvb3AwKTogTW91bnRlZCB3aXRoIGNoZWNrcG9pbnQgdmVyc2lvbiA9IDc1NDhjMmVlIEJVRzogdW5hYmxlIHRvIGhhbmRsZSBwYWdlIGZhdWx0IGZvciBhZGRyZXNzOiBmZmZmZTQ3YmM3MTIzZjQ4IFJJUDogMDAxMDprZnJlZSsweDY2LzB4MzIwIENhbGwgVHJhY2U6IF9fZjJmc19zZXR4YXR0cisweDJhYS8weGMwMCBbZjJmc10gZjJmc19zZXR4YXR0cisweGZhLzB4NDgwIFtmMmZzXSBfX2YyZnNfc2V0X2FjbCsweDE5Yi8weDMzMCBbZjJmc10gX192ZnNfcmVtb3ZleGF0dHIrMHg1Mi8weDcwIF9fdmZzX3JlbW92ZXhhdHRyX2xvY2tlZCsweGIxLzB4MTQwIHZmc19yZW1vdmV4YXR0cisweDU2LzB4MTAwIHJlbW92ZXhhdHRyKzB4NTcvMHg4MCBwYXRoX3JlbW92ZXhhdHRyKzB4YTMvMHhjMCBfX3g2NF9zeXNfcmVtb3ZleGF0dHIrMHgxNy8weDIwIGRvX3N5c2NhbGxfNjQrMHgzNy8weGIwIGVudHJ5X1NZU0NBTExfNjRfYWZ0ZXJfaHdmcmFtZSsweDQ0LzB4YWUgVGhlIHJvb3QgY2F1c2UgaXMgaW4gX19mMmZzX3NldHhhdHRyKCksIHdlIG1pc3NlZCB0byBkbyBzYW5pdHkgY2hlY2sgb24gbGFzdCB4YXR0ciBlbnRyeSwgcmVzdWx0IGluIG91dC1vZi1ib3VuZCBtZW1vcnkgYWNjZXNzIGR1cmluZyB1cGRhdGluZyBpbmNvbnNpc3RlbnQgeGF0dHIgZGF0YSBvZiB0YXJnZXQgaW5vZGUuIEFmdGVyIHRoZSBmaXgsIGl0IGNhbiBkZXRlY3Qgc3VjaCB4YXR0ciBpbmNvbnNpc3RlbmN5IGFzIGJlbG93OiBGMkZTLWZzIChsb29wMTEpOiBpbm9kZSAoNykgaGFzIGludmFsaWQgbGFzdCB4YXR0ciBlbnRyeSwgZW50cnlfc2l6ZTogNjA2NzYgRjJGUy1mcyAobG9vcDExKTogaW5vZGUgKDgpIGhhcyBjb3JydXB0ZWQgeGF0dHIgRjJGUy1mcyAobG9vcDExKTogaW5vZGUgKDgpIGhhcyBjb3JydXB0ZWQgeGF0dHIgRjJGUy1mcyAobG9vcDExKTogaW5vZGUgKDgpIGhhcyBpbnZhbGlkIGxhc3QgeGF0dHIgZW50cnksIGVudHJ5X3NpemU6IDQ3NzM2IENjOiBzdGFibGVAdmdlci5rZXJuZWwub3JnIFJlcG9ydGVkLWJ5OiBXZW5xaW5nIExpdSA8d2VucWluZ2xpdTAxMjA+IFNpZ25lZC1vZmYtYnk6IENoYW8gWXUgPGNoYW8+IFNpZ25lZC1vZmYtYnk6IEphZWdldWsgS2ltIDxqYWVnZXVrPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGFkMzM4ZDgyNWUzZjdiOTZlZTU0MmJmMzEzNzI4YWYyZDE5ZmU5YWQgQXV0aG9yOiBTdW1pdCBHYXJnIDxzdW1pdC5nYXJnPiBEYXRlOiBUaHUgRGVjIDE2IDExOjE3OjI1IDIwMjEgKzA1MzAgdGVlOiBvcHRlZTogRml4IGluY29ycmVjdCBwYWdlIGZyZWUgYnVnIGNvbW1pdCAxODU0OWJmNGIyMWM3MzlhOWRlZjM5ZjI3ZGNhYzUzZTI3Mjg2YWI1IHVwc3RyZWFtLiBQb2ludGVyIHRvIHRoZSBhbGxvY2F0ZWQgcGFnZXMgKHN0cnVjdCBwYWdlICpwYWdlKSBoYXMgYWxyZWFkeSBwcm9ncmVzc2VkIHRvd2FyZHMgdGhlIGVuZCBvZiBhbGxvY2F0aW9uLiBJdCBpcyBpbmNvcnJlY3QgdG8gcGVyZm9ybSBfX2ZyZWVfcGFnZXMocGFnZSwgb3JkZXIpIHVzaW5nIHRoaXMgcG9pbnRlciBhcyB3ZSB3b3VsZCBmcmVlIGFueSBhcmJpdHJhcnkgcGFnZXMuIEZpeCB0aGlzIGJ5IHN0b3AgbW9kaWZ5aW5nIHRoZSBwYWdlIHBvaW50ZXIuIEZpeGVzOiBlYzE4NWRkM2FiMjUgKCJvcHRlZTogRml4IG1lbW9yeSBsZWFrIHdoZW4gZmFpbGluZyB0byByZWdpc3RlciBzaG0gcGFnZXMiKSBDYzogc3RhYmxlQHZnZXIua2VybmVsLm9yZyBSZXBvcnRlZC1ieTogUGF0cmlrIExhbnR6IDxwYXRyaWsubGFudHo+IFNpZ25lZC1vZmYtYnk6IFN1bWl0IEdhcmcgPHN1bWl0Lmdhcmc+IFJldmlld2VkLWJ5OiBUeWxlciBIaWNrcyA8dHloaWNrcz4gU2lnbmVkLW9mZi1ieTogSmVucyBXaWtsYW5kZXIgPGplbnMud2lrbGFuZGVyPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDFmMjA3MDc2NzQwMTAxZmVkODcwNzRhNmJjOTI0ZGJlODA2ZjA4YTUgQXV0aG9yOiBMaXUgU2hpeGluIDxsaXVzaGl4aW4yPiBEYXRlOiBGcmkgRGVjIDI0IDIxOjEyOjU4IDIwMjEgLTA4MDAgbW0vaHdwb2lzb246IGNsZWFyIE1GX0NPVU5UX0lOQ1JFQVNFRCBiZWZvcmUgcmV0cnlpbmcgZ2V0X2FueV9wYWdlKCkgY29tbWl0IDJhNTdkODNjNzhmODg5YmYzZjU0ZWVkZTkwOGQwNjQzYzQwZDU0MTggdXBzdHJlYW0uIEh1bGsgUm9ib3QgcmVwb3J0ZWQgYSBwYW5pYyBpbiBwdXRfcGFnZV90ZXN0emVybygpIHdoZW4gdGVzdGluZyBtYWR2aXNlKCkgd2l0aCBNQURWX1NPRlRfT0ZGTElORS4gVGhlIEJVRygpIGlzIHRyaWdnZXJlZCB3aGVuIHJldHJ5aW5nIGdldF9hbnlfcGFnZSgpLiBUaGlzIGlzIGJlY2F1c2Ugd2Uga2VlcCBNRl9DT1VOVF9JTkNSRUFTRUQgZmxhZyBpbiBzZWNvbmQgdHJ5IGJ1dCB0aGUgcmVmY250IGlzIG5vdCBpbmNyZWFzZWQuIHBhZ2UgZHVtcGVkIGJlY2F1c2U6IFZNX0JVR19PTl9QQUdFKHBhZ2VfcmVmX2NvdW50KHBhZ2UpID09IDApIC0tLS0tLS0tLS0tLVsgY3V0IGhlcmUgXS0tLS0tLS0tLS0tLSBrZXJuZWwgQlVHIGF0IGluY2x1ZGUvbGludXgvbW0uaDo3MzchIGludmFsaWQgb3Bjb2RlOiAwMDAwIFsjMV0gUFJFRU1QVCBTTVAgQ1BVOiA1IFBJRDogMjEzNSBDb21tOiBzc2hkIFRhaW50ZWQ6IEcgQiA1LjE2LjAtcmM2LWRpcnR5ICMzNzMgSGFyZHdhcmUgbmFtZTogUUVNVSBTdGFuZGFyZCBQQyAoaTQ0MEZYICsgUElJWCwgMTk5NiksIEJJT1MgMS4xMy4wLTF1YnVudHUxLjEgMDQvMDEvMjAxNCBSSVA6IHJlbGVhc2VfcGFnZXMrMHg1M2YvMHg4NDAgQ2FsbCBUcmFjZTogZnJlZV9wYWdlc19hbmRfc3dhcF9jYWNoZSsweDY0LzB4ODAgdGxiX2ZsdXNoX21tdSsweDZmLzB4MjIwIHVubWFwX3BhZ2VfcmFuZ2UrMHhlNmMvMHgxMmMwIHVubWFwX3NpbmdsZV92bWErMHg5MC8weDE3MCB1bm1hcF92bWFzKzB4YzQvMHgxODAgZXhpdF9tbWFwKzB4ZGUvMHgzYTAgbW1wdXQrMHhhMy8weDI1MCBkb19leGl0KzB4NTY0LzB4MTQ3MCBkb19ncm91cF9leGl0KzB4M2IvMHgxMDAgX19kb19zeXNfZXhpdF9ncm91cCsweDEzLzB4MjAgX194NjRfc3lzX2V4aXRfZ3JvdXArMHgxNi8weDIwIGRvX3N5c2NhbGxfNjQrMHgzNC8weDgwIGVudHJ5X1NZU0NBTExfNjRfYWZ0ZXJfaHdmcmFtZSsweDQ0LzB4YWUgTW9kdWxlcyBsaW5rZWQgaW46IC0tLVsgZW5kIHRyYWNlIGU5OTU3OWI1NzBmZTA2NDkgXS0tLSBSSVA6IDAwMTA6cmVsZWFzZV9wYWdlcysweDUzZi8weDg0MCBMaW5rOiBodHRwczovL2xrbWwua2VybmVsLm9yZy9yLzIwMjExMjIxMDc0OTA4LjM5MTAyODYtMS1saXVzaGl4aW4yQGh1YXdlaS5jb20gRml4ZXM6IGI5NGUwMjgyMmRlYiAoIm1tLGh3cG9pc29uOiB0cnkgdG8gbmFycm93IHdpbmRvdyByYWNlIGZvciBmcmVlIHBhZ2VzIikgU2lnbmVkLW9mZi1ieTogTGl1IFNoaXhpbiA8bGl1c2hpeGluMj4gUmVwb3J0ZWQtYnk6IEh1bGsgUm9ib3QgPGh1bGtjaT4gUmV2aWV3ZWQtYnk6IE9zY2FyIFNhbHZhZG9yIDxvc2FsdmFkb3I+IEFja2VkLWJ5OiBOYW95YSBIb3JpZ3VjaGkgPG5hb3lhLmhvcmlndWNoaT4gQ2M6IDxzdGFibGU+IFNpZ25lZC1vZmYtYnk6IEFuZHJldyBNb3J0b24gPGFrcG0+IFNpZ25lZC1vZmYtYnk6IExpbnVzIFRvcnZhbGRzIDx0b3J2YWxkcz4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCBhYzYxYjljNmMwNTQ5YWFlYjk4MTk0Y2Y0MjlkOTNjNDFiZmU1Zjc5IEF1dGhvcjogSm9oYW5uZXMgQmVyZyA8am9oYW5uZXMuYmVyZz4gRGF0ZTogTW9uIERlYyAyMCAxMDoyMjo0MCAyMDIxICswMTAwIG1hYzgwMjExOiBmaXggbG9ja2luZyBpbiBpZWVlODAyMTFfc3RhcnRfYXAgZXJyb3IgcGF0aCBjb21taXQgODdhMjcwNjI1YTg5ZmM4NDFmMWE3ZTIxYWFlNjE3NjU0M2Q4Mzg1YyB1cHN0cmVhbS4gV2UgbmVlZCB0byBob2xkIHRoZSBsb2NhbC0mZ3Q7bXR4IHRvIHJlbGVhc2UgdGhlIGNoYW5uZWwgY29udGV4dCwgYXMgZXZlbiBlbmNvZGVkIGJ5IHRoZSBsb2NrZGVwX2Fzc2VydF9oZWxkKCkgdGhlcmUuIEZpeCBpdC4gQ2M6IHN0YWJsZUB2Z2VyLmtlcm5lbC5vcmcgRml4ZXM6IDI5NWIwMmM0YmU3NCAoIm1hYzgwMjExOiBBZGQgRklMUyBkaXNjb3Zlcnkgc3VwcG9ydCIpIFJlcG9ydGVkLWFuZC10ZXN0ZWQtYnk6IHN5emJvdCsxMWMzNDJlNWUzMGU5NTM5Y2FiZEBzeXprYWxsZXIuYXBwc3BvdG1haWwuY29tIExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMjAyMTEyMjAwOTA4MzYuY2VlM2Q1OWExOTE1LkkzNmJiYTliNzlkYzJmZjRkNTdjM2M3YWEzMGRmZjlhMDAzZmU4YzVjQGNoYW5nZWlkIFNpZ25lZC1vZmYtYnk6IEpvaGFubmVzIEJlcmcgPGpvaGFubmVzLmJlcmc+IFNpZ25lZC1vZmYtYnk6IERhdmlkIFMuIE1pbGxlciA8ZGF2ZW0+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgODk4NzZkMTA4MzBkYjZhYzU1YWU0Mzc5NzY0YzllOWRkMTI2ODI3NyBBdXRob3I6IEFyZCBCaWVzaGV1dmVsIDxhcmRiPiBEYXRlOiBXZWQgRGVjIDE1IDA5OjMxOjM2IDIwMjEgKzAxMDAgQVJNOiA5MTY5LzE6IGVudHJ5OiBmaXggVGh1bWIyIGJ1ZyBpbiBpV01NWHQgZXhjZXB0aW9uIGhhbmRsaW5nIGNvbW1pdCA4NTM2YTVlZjg4NjAwNWJjNDQzYzJkYTliODQyZDY5ZmQzZDc2NDdmIHVwc3RyZWFtLiBUaGUgVGh1bWIyIHZlcnNpb24gb2YgdGhlIEZQIGV4Y2VwdGlvbiBoYW5kbGluZyBlbnRyeSBjb2RlIHRyZWF0cyB0aGUgcmVnaXN0ZXIgaG9sZGluZyB0aGUgQ1AgbnVtYmVyIChSOCkgZGlmZmVyZW50bHksIHJlc3VsdGluZyBpbiB0aGUgaVdNTVhUIENQIG51bWJlciBjaGVjayB0byBiZSBpbmNvcnJlY3QuIEZpeCB0aGlzIGJ5IHVuaWZ5aW5nIHRoZSBBUk0gYW5kIFRodW1iMiBjb2RlIHBhdGhzLCBhbmQgc3dpdGNoIHRoZSBvcmRlciBvZiB0aGUgYWRkaXRpb25zIG9mIHRoZSBUSV9VU0VEX0NQIG9mZnNldCBhbmQgdGhlIHNoaWZ0ZWQgQ1AgaW5kZXguIENjOiA8c3RhYmxlPiBGaXhlczogYjg2MDQwYTU5ZmViICgiVGh1bWItMjogSW1wbGVtZW50YXRpb24gb2YgdGhlIHVuaWZpZWQgc3RhcnQtdXAgYW5kIGV4Y2VwdGlvbnMgY29kZSIpIFNpZ25lZC1vZmYtYnk6IEFyZCBCaWVzaGV1dmVsIDxhcmRiPiBTaWduZWQtb2ZmLWJ5OiBSdXNzZWxsIEtpbmcgKE9yYWNsZSkgPHJtaz4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCBjMzI1M2QzYTM4YmMxZjYwY2FhZTZkMDY1MDZjZmMzYjcyYjBiYTExIEF1dGhvcjogWWFubiBHYXV0aWVyIDx5YW5uLmdhdXRpZXI+IERhdGU6IFdlZCBEZWMgMTUgMTU6MTc6MjYgMjAyMSArMDEwMCBtbWM6IG1tY2k6IHN0bTMyOiBjbGVhciBETFlCX0NSIGFmdGVyIHNlbmRpbmcgdHVuaW5nIGNvbW1hbmQgY29tbWl0IGZmMzFlZTBhMGY0NzE3NzZmNjdiZTVlNTI3NWMxOGQxNzczNmZjNmIgdXBzdHJlYW0uIER1cmluZyB0ZXN0IGNhbXBhaWduLCBhbmQgZXNwZWNpYWxseSBhZnRlciBzZXZlcmFsIHVuYmluZC9iaW5kIHNlcXVlbmNlcywgaXQgaGFzIGJlZW4gc2VlbiB0aGF0IHRoZSBTRC1jYXJkIG9uIFNETU1DMSB0aHJlYWQgY291bGQgZnJlZXplLiBUaGUgZnJlZXplIGFsd2F5cyBhcHBlYXIgb24gYSBDTUQyMyBmb2xsb3dpbmcgYSBDTUQxOS4gQ2hlY2tpbmcgU0RNTUMgaW50ZXJuYWwgcmVnaXN0ZXJzIHNob3dzIHRoYXQgdGhlIHR1bmluZyBjb21tYW5kIChDTUQxOSkgaGFzIGZhaWxlZC4gVGhlIGZyZWV6ZSBpcyB0aGVuIGR1ZSB0byB0aGUgZGVsYXkgYmxvY2sgaW52b2x2ZWQgaW4gdGhlIHR1bmluZyBzZXF1ZW5jZS4gVG8gY29ycmVjdCB0aGlzLCBjbGVhciB0aGUgZGVsYXkgYmxvY2sgcmVnaXN0ZXIgRExZQl9DUiByZWdpc3RlciBhZnRlciB0aGUgdHVuaW5nIGNvbW1hbmRzLiBTaWduZWQtb2ZmLWJ5OiBDaHJpc3RvcGhlIEtlcmVsbG8gPGNocmlzdG9waGUua2VyZWxsbz4gU2lnbmVkLW9mZi1ieTogWWFubiBHYXV0aWVyIDx5YW5uLmdhdXRpZXI+IFJldmlld2VkLWJ5OiBMaW51cyBXYWxsZWlqIDxsaW51cy53YWxsZWlqPiBGaXhlczogMTEwM2Y4MDdhM2I5ICgibW1jOiBtbWNpX3NkbW1jOiBBZGQgZXhlY3V0ZSB0dW5pbmcgd2l0aCBkZWxheSBibG9jayIpIENjOiBzdGFibGVAdmdlci5rZXJuZWwub3JnIExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMjAyMTEyMTUxNDE3MjcuNDkwMS00LXlhbm4uZ2F1dGllckBmb3NzLnN0LmNvbSBTaWduZWQtb2ZmLWJ5OiBVbGYgSGFuc3NvbiA8dWxmLmhhbnNzb24+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgMGQ2NmIzOTUyMTBjNTA4NGMyYjczMjQ5NDUwNjJjMWQxZjk1NDg3YSBBdXRob3I6IFVsZiBIYW5zc29uIDx1bGYuaGFuc3Nvbj4gRGF0ZTogRnJpIERlYyAzIDE1OjE1OjU0IDIwMjEgKzAxMDAgbW1jOiBjb3JlOiBEaXNhYmxlIGNhcmQgZGV0ZWN0IGR1cmluZyBzaHV0ZG93biBjb21taXQgNjZjOTE1ZDA5Yjk0MmZiM2IyYjBjYjJmNTY1NjIxODA5MDFmYmExNyB1cHN0cmVhbS4gSXQncyBzZWVtcyBwcm9uZSB0byBwcm9ibGVtcyBieSBhbGxvd2luZyBjYXJkIGRldGVjdCBhbmQgaXRzIGNvcnJlc3BvbmRpbmcgbW1jX3Jlc2NhbigpIHdvcmsgdG8gcnVuLCBkdXJpbmcgcGxhdGZvcm0gc2h1dGRvd24uIEZvciBleGFtcGxlLCB3ZSBtYXkgZW5kIHVwIHR1cm5pbmcgb2ZmIHRoZSBwb3dlciB3aGlsZSBpbml0aWFsaXppbmcgYSBjYXJkLCB3aGljaCBwb3RlbnRpYWxseSBjb3VsZCBkYW1hZ2UgaXQuIFRvIGF2b2lkIHRoaXMgc2NlbmFyaW8sIGxldCdzIGFkZCAtJmd0O3NodXRkb3duX3ByZSgpIGNhbGxiYWNrIGZvciB0aGUgbW1jIGhvc3QgY2xhc3MgZGV2aWNlIGFuZCB0aGVuIHR1cm4gb2YgdGhlIGNhcmQgZGV0ZWN0IGZyb20gdGhlcmUuIFJlcG9ydGVkLWJ5OiBBbCBDb29wZXIgPGFsY29vcGVyeD4gU3VnZ2VzdGVkLWJ5OiBBZHJpYW4gSHVudGVyIDxhZHJpYW4uaHVudGVyPiBTaWduZWQtb2ZmLWJ5OiBVbGYgSGFuc3NvbiA8dWxmLmhhbnNzb24+IENjOiBzdGFibGVAdmdlci5rZXJuZWwub3JnIExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMjAyMTEyMDMxNDE1NTUuMTA1MzUxLTEtdWxmLmhhbnNzb25AbGluYXJvLm9yZyBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGM4ZTM2NmEwMWMyMDAxOWE2MzFkMWFhMTUxYTkxOGQ2Nzc1N2FiOGQgQXV0aG9yOiBNYXJ0aW4gQmx1bWVuc3RpbmdsIDxtYXJ0aW4uYmx1bWVuc3RpbmdsPiBEYXRlOiBTdW4gRGVjIDE5IDE2OjM0OjQxIDIwMjEgKzAxMDAgbW1jOiBtZXNvbi1teC1zZGhjOiBTZXQgTUFOVUFMX1NUT1AgZm9yIG11bHRpLWJsb2NrIFNESU8gY29tbWFuZHMgY29tbWl0IGY4OWI1NDhjYTY2YmU3NTAwZGNkOTJlZThlNjE1OTBmN2QwOGFjOTEgdXBzdHJlYW0uIFRoZSB2ZW5kb3IgZHJpdmVyIGltcGxlbWVudHMgc3BlY2lhbCBoYW5kbGluZyBmb3IgbXVsdGktYmxvY2sgU0RfSU9fUldfRVhURU5ERUQgKGFuZCBTRF9JT19SV19ESVJFQ1QpIGNvbW1hbmRzIHdoaWNoIGhhdmUgZGF0YSBhdHRhY2hlZCB0byB0aGVtLiBJdCBzZXRzIHRoZSBNQU5VQUxfU1RPUCBiaXQgaW4gdGhlIE1FU09OX1NESENfTUlTQyByZWdpc3RlciBmb3IgdGhlc2UgY29tbWFuZHMuIEluIGFsbCBvdGhlciBjYXNlcyB0aGlzIGJpdCBpcyBjbGVhcmVkLiBIZXJlIHdlIG9taXQgU0RfSU9fUldfRElSRUNUIHNpbmNlIHRoYXQgY29tbWFuZCBuZXZlciBoYXMgYW55IGRhdGEgYXR0YWNoZWQgdG8gaXQuIFRoaXMgZml4ZXMgU0RJTyB3aWZpIHVzaW5nIHRoZSBicmNtZm1hYyBkcml2ZXIgd2hpY2ggcmVwb3J0ZWQgdGhlIGZvbGxvd2luZyBlcnJvciB3aXRob3V0IHRoaXMgY2hhbmdlIG9uIGEgTmV0eGVvbiBTODIgYm9hcmQgdXNpbmcgYSBNZXNvbjggKFM4MDIpIFNvQzogYnJjbWZfZndfYWxsb2NfcmVxdWVzdDogdXNpbmcgYnJjbS9icmNtZm1hYzQzMzYyLXNkaW8gZm9yIGNoaXAgQkNNNDMzNjIvMSBicmNtZl9zZGlvZF9yYW1ydzogbWVtYnl0ZXMgdHJhbnNmZXIgZmFpbGVkIGJyY21mX3NkaW9fZG93bmxvYWRfY29kZV9maWxlOiBlcnJvciAtMTEwIG9uIHdyaXRpbmcgMjE5NTU3IG1lbWJ5dGVzIGF0IDB4MDAwMDAwMDAgYnJjbWZfc2Rpb19kb3dubG9hZF9maXJtd2FyZTogZG9uZ2xlIGltYWdlIGZpbGUgZG93bmxvYWQgZmFpbGVkIEFuZCB3aXRoIHRoaXMgY2hhbmdlOiBicmNtZl9md19hbGxvY19yZXF1ZXN0OiB1c2luZyBicmNtL2JyY21mbWFjNDMzNjItc2RpbyBmb3IgY2hpcCBCQ000MzM2Mi8xIGJyY21mX2NfcHJvY2Vzc19jbG1fYmxvYjogbm8gY2xtX2Jsb2IgYXZhaWxhYmxlIChlcnI9LTIpLCBkZXZpY2UgbWF5IGhhdmUgbGltaXRlZCBjaGFubmVscyBhdmFpbGFibGUgYnJjbWZfY19wcmVpbml0X2RjbWRzOiBGaXJtd2FyZTogQkNNNDMzNjIvMSB3bDA6IEFwciAyMiAyMDEzIDE0OjUwOjAwIHZlcnNpb24gNS45MC4xOTUuODkuNiBGV0lEIDAxLWIzMGE0MjdkIEZpeGVzOiBlNGJmMWIwOTcwZWY5NiAoIm1tYzogaG9zdDogbWVzb24tbXgtc2RoYzogbmV3IGRyaXZlciBmb3IgdGhlIEFtbG9naWMgTWVzb24gU0RIQyBob3N0IikgU2lnbmVkLW9mZi1ieTogTWFydGluIEJsdW1lbnN0aW5nbCA8bWFydGluLmJsdW1lbnN0aW5nbD4gQ2M6IHN0YWJsZUB2Z2VyLmtlcm5lbC5vcmcgTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8yMDIxMTIxOTE1MzQ0Mi40NjM4NjMtMi1tYXJ0aW4uYmx1bWVuc3RpbmdsQGdvb2dsZW1haWwuY29tIFNpZ25lZC1vZmYtYnk6IFVsZiBIYW5zc29uIDx1bGYuaGFuc3Nvbj4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCA0YWY3OTE1MzYxN2JkMTQ2NzdhNjliNGY0YzZiYjEzZTNlY2UyNzA4IEF1dGhvcjogUHJhdGhhbWVzaCBTaGV0ZSA8cHNoZXRlPiBEYXRlOiBUdWUgRGVjIDE0IDE3OjA2OjUzIDIwMjEgKzA1MzAgbW1jOiBzZGhjaS10ZWdyYTogRml4IHN3aXRjaCB0byBIUzQwMEVTIG1vZGUgY29tbWl0IDRmYzcyNjFkYmFiMTM5ZDNjNjRjM2I2MTgyNjI1MDRlMTZjZmU3ZWUgdXBzdHJlYW0uIFdoZW4gQ01EMTMgaXMgc2VudCBhZnRlciBzd2l0Y2hpbmcgdG8gSFM0MDBFUyBtb2RlLCB0aGUgYnVzIGlzIG9wZXJhdGluZyBhdCBlaXRoZXIgTU1DX0hJR0hfMjZfTUFYX0RUUiBvciBNTUNfSElHSF81Ml9NQVhfRFRSLiBUbyBtZWV0IFRlZ3JhIFNESENJIHJlcXVpcmVtZW50IGF0IEhTNDAwRVMgbW9kZSwgZm9yY2UgU0RIQ0kgaW50ZXJmYWNlIGNsb2NrIHRvIE1NQ19IUzIwMF9NQVhfRFRSICgyMDAgTUh6KSBzbyB0aGF0IGhvc3QgY29udHJvbGxlciBDQVIgY2xvY2sgYW5kIHRoZSBpbnRlcmZhY2UgY2xvY2sgYXJlIHJhdGUgbWF0Y2hlZC4gU2lnbmVkLW9mZi1ieTogUHJhdGhhbWVzaCBTaGV0ZSA8cHNoZXRlPiBBY2tlZC1ieTogQWRyaWFuIEh1bnRlciA8YWRyaWFuLmh1bnRlcj4gRml4ZXM6IGRmYzk3MDBjZWY3NyAoIm1tYzogdGVncmE6IEltcGxlbWVudCBIUzQwMCBlbmhhbmNlZCBzdHJvYmUiKSBDYzogc3RhYmxlQHZnZXIua2VybmVsLm9yZyBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMjE0MTEzNjUzLjQ2MzEtMS1wc2hldGVAbnZpZGlhLmNvbSBTaWduZWQtb2ZmLWJ5OiBVbGYgSGFuc3NvbiA8dWxmLmhhbnNzb24+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgOWE3ZWM3OTc5Nzg1ZTk3YjMzYTZiYmQ3OWI5NWZhYTIwZTQ4ODJiYiBBdXRob3I6IE5vcmFsZiBUcsO4bm5lcyA8bm9yYWxmPiBEYXRlOiBNb24gT2N0IDE4IDEzOjIyOjAxIDIwMjEgKzAyMDAgZ3BpbzogZGxuMjogRml4IGludGVycnVwdHMgd2hlbiByZXBsdWdnaW5nIHRoZSBkZXZpY2UgY29tbWl0IDlhNTg3NWYxNGIwZTNhMTNhZTMxNDg4M2YxYmI3MmI3ZjMxZmFjMDcgdXBzdHJlYW0uIFdoZW4gcmVwbHVnZ2luZyB0aGUgZGV2aWNlIHRoZSBmb2xsb3dpbmcgbWVzc2FnZSBzaG93cyB1cDogZ3BpbyBncGlvY2hpcDI6IChkbG4yKTogZGV0ZWN0ZWQgaXJxY2hpcCB0aGF0IGlzIHNoYXJlZCB3aXRoIG11bHRpcGxlIGdwaW9jaGlwczogcGxlYXNlIGZpeCB0aGUgZHJpdmVyLiBUaGlzIGFsc28gaGFzIHRoZSBlZmZlY3QgdGhhdCBpbnRlcnJ1cHRzIHdvbid0IHdvcmsuIFRoZSBzYW1lIHByb2JsZW0gd291bGQgYWxzbyBzaG93IHVwIGlmIG11bHRpcGxlIGRldmljZXMgd2hlcmUgcGx1Z2dlZCBpbi4gRml4IHRoaXMgYnkgYWxsb2NhdGluZyB0aGUgaXJxX2NoaXAgZGF0YSBzdHJ1Y3R1cmUgcGVyIGluc3RhbmNlIGxpa2Ugb3RoZXIgZHJpdmVycyBkby4gSSBkb24ndCBrbm93IHdoZW4gdGhpcyBwcm9ibGVtIGFwcGVhcmVkLCBidXQgaXQgaXMgcHJlc2VudCBpbiA1LjEwLiBDYzogPHN0YWJsZT4gIyA1LjEwKyBDYzogRGFuaWVsIEJhbHV0YSA8ZGFuaWVsLmJhbHV0YT4gU2lnbmVkLW9mZi1ieTogTm9yYWxmIFRyw7hubmVzIDxub3JhbGY+IFNpZ25lZC1vZmYtYnk6IEJhcnRvc3ogR29sYXN6ZXdza2kgU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCBmNWIwMjkxMmUyZGQ4OWZlMjM4NmMxOWVkZDJjNmYzZTEyOTZmYzJiIEF1dGhvcjogRmFiaWVuIERlc3Nlbm5lIDxmYWJpZW4uZGVzc2VubmU+IERhdGU6IFdlZCBEZWMgMTUgMTA6NTg6MDggMjAyMSArMDEwMCBwaW5jdHJsOiBzdG0zMjogY29uc2lkZXIgdGhlIEdQSU8gb2Zmc2V0IHRvIGV4cG9zZSBhbGwgdGhlIEdQSU8gbGluZXMgY29tbWl0IGI2NzIxMGNjMjE3ZjljYTFjNTc2OTA5NDU0ZDg0Njk3MGMxM2RmZDQgdXBzdHJlYW0uIENvbnNpZGVyIHRoZSBHUElPIGNvbnRyb2xsZXIgb2Zmc2V0IChmcm9tICJncGlvLXJhbmdlcyIpIHRvIGNvbXB1dGUgdGhlIG1heGltdW0gR1BJTyBsaW5lIG51bWJlci4gVGhpcyBmaXhlcyBhbiBpc3N1ZSB3aGVyZSBncGlvLXJhbmdlcyB1c2VzIGEgbm9uLW51bGwgb2Zmc2V0LiBlLmcuOiBncGlvLXJhbmdlcyA9IEluIHRoYXQgY2FzZSB0aGUgbGFzdCB2YWxpZCBHUElPIGxpbmUgaXMgbm90IDkgYnV0IDE1ICg2ICsgMTAgLSAxKSBDYzogc3RhYmxlQHZnZXIua2VybmVsLm9yZyBGaXhlczogNjdlMjk5NmY3MmM3ICgicGluY3RybDogc3RtMzI6IGZpeCB0aGUgcmVwb3J0ZWQgbnVtYmVyIG9mIEdQSU8gbGluZXMgcGVyIGJhbmsiKSBSZXBvcnRlZC1ieTogQ2hyaXN0b3BoIEZyaXR6IDxjaGYuZnJpdHo+IFNpZ25lZC1vZmYtYnk6IEZhYmllbiBEZXNzZW5uZSA8ZmFiaWVuLmRlc3Nlbm5lPiBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMjE1MDk1ODA4LjYyMTcxNi0xLWZhYmllbi5kZXNzZW5uZUBmb3NzLnN0LmNvbSBTaWduZWQtb2ZmLWJ5OiBMaW51cyBXYWxsZWlqIDxsaW51cy53YWxsZWlqPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDI4NjI2ZTc2YmFmNTBlNmIzN2Q4YTkyNTY0ODQ0ZDg3M2FhNmI1MWYgQXV0aG9yOiBTZWFuIENocmlzdG9waGVyc29uIDxzZWFuamM+IERhdGU6IFR1ZSBEZWMgMjEgMTA6Mzc6MDAgMjAyMSAtMDUwMCBLVk06IFZNWDogV2FrZSB2Q1BVIHdoZW4gZGVsaXZlcmluZyBwb3N0ZWQgSVJRIGV2ZW4gaWYgdkNQVSA9PSB0aGlzIHZDUFUgY29tbWl0IGZkYmE2MDhmMTVlMjQyNzQxOTk5N2IwODk4NzUwYTQ5YTczNWFmY2IgdXBzdHJlYW0uIERyb3AgYSBjaGVjayB0aGF0IGd1YXJkcyB0cmlnZ2VyaW5nIGEgcG9zdGVkIGludGVycnVwdCBvbiB0aGUgY3VycmVudGx5IHJ1bm5pbmcgdkNQVSwgYW5kIG1vcmUgaW1wb3J0YW50bHkgZ3VhcmRzIHdha2luZyB0aGUgdGFyZ2V0IHZDUFUgaWYgdHJpZ2dlcmluZyBhIHBvc3RlZCBpbnRlcnJ1cHQgZmFpbHMgYmVjYXVzZSB0aGUgdkNQVSBpc24ndCBJTl9HVUVTVF9NT0RFLiBJZiBhIHZJUlEgaXMgZGVsaXZlcmVkIGZyb20gYXN5bmNocm9ub3VzIGNvbnRleHQsIHRoZSB0YXJnZXQgdkNQVSBjYW4gYmUgdGhlIGN1cnJlbnRseSBydW5uaW5nIHZDUFUgYW5kIGNhbiBhbHNvIGJlIGJsb2NraW5nLCBpbiB3aGljaCBjYXNlIHNraXBwaW5nIGt2bV92Y3B1X3dha2VfdXAoKSBpcyBlZmZlY3RpdmVseSBkcm9wcGluZyB3aGF0IGlzIHN1cHBvc2VkIHRvIGJlIGEgd2FrZSBldmVudCBmb3IgdGhlIHZDUFUuIFRoZSAiZG8gbm90aGluZyIgbG9naWMgd2hlbiAidmNwdSA9PSBydW5uaW5nX3ZjcHUiIG1vc3RseSB3b3JrcyBvbmx5IGJlY2F1c2UgdGhlIG1ham9yaXR5IG9mIGNhbGxzIHRvIC0mZ3Q7ZGVsaXZlcl9wb3N0ZWRfaW50ZXJydXB0KCksIGVzcGVjaWFsbHkgd2hlbiB1c2luZyBwb3N0ZWQgaW50ZXJydXB0cywgY29tZSBmcm9tIHN5bmNocm9ub3VzIEtWTSBjb250ZXh0LiBCdXQgaWYgYSBkZXZpY2UgaXMgZXhwb3NlZCB0byB0aGUgZ3Vlc3QgdXNpbmcgdmZpby1wY2kgcGFzc3Rocm91Z2gsIHRoZSBWRklPIElSUSBhbmQgdkNQVSBhcmUgYm91bmQgdG8gdGhlIHNhbWUgcENQVSwgYW5kIHRoZSBJUlEgaXMgX25vdF8gY29uZmlndXJlZCB0byB1c2UgcG9zdGVkIGludGVycnVwdHMsIHdha2UgZXZlbnRzIGZyb20gdGhlIGRldmljZSB3aWxsIGJlIGRlbGl2ZXJlZCB0byBLVk0gZnJvbSBJUlEgY29udGV4dCwgZS5nLiB2ZmlvX21zaWhhbmRsZXIoKSB8IHwtJmd0OyBldmVudGZkX3NpZ25hbCgpIHwgfC0mZ3Q7IC4uLiB8IHwtJmd0OyBpcnFmZF93YWtldXAoKSB8IHwtJmd0O2t2bV9hcmNoX3NldF9pcnFfaW5hdG9taWMoKSB8IHwtJmd0OyBrdm1faXJxX2RlbGl2ZXJ5X3RvX2FwaWNfZmFzdCgpIHwgfC0mZ3Q7IGt2bV9hcGljX3NldF9pcnEoKSBUaGlzIGFsc28gYWxpZ25zIHRoZSBub24tbmVzdGVkIGFuZCBuZXN0ZWQgdXNhZ2Ugb2YgdHJpZ2dlcmluZyBwb3N0ZWQgaW50ZXJydXB0cywgYW5kIHdpbGwgYWxsb3cgZm9yIGFkZGl0aW9uYWwgY2xlYW51cHMuIEZpeGVzOiAzNzlhM2M4ZWU0NDQgKCJLVk06IFZNWDogT3B0aW1pemUgcG9zdGVkLWludGVycnVwdCBkZWxpdmVyeSBmb3IgdGltZXIgZmFzdHBhdGgiKSBDYzogc3RhYmxlQHZnZXIua2VybmVsLm9yZyBSZXBvcnRlZC1ieTogTG9uZ3BlbmcgKE1pa2UpIDxsb25ncGVuZzI+IFNpZ25lZC1vZmYtYnk6IFNlYW4gQ2hyaXN0b3BoZXJzb24gPHNlYW5qYz4gUmV2aWV3ZWQtYnk6IE1heGltIExldml0c2t5IDxtbGV2aXRzaz4gTWVzc2FnZS1JZDogJmx0OzIwMjExMjA4MDE1MjM2LjE2MTY2OTctMTgtc2VhbmpjQGdvb2dsZS5jb20mZ3Q7IFNpZ25lZC1vZmYtYnk6IFBhb2xvIEJvbnppbmkgPHBib256aW5pPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDdhMzdmMmUzNzA2OTllMmZlY2EzZGNhNmM4MTc4YzcxY2VlZTdlOGEgQXV0aG9yOiBKb2hhbiBIb3ZvbGQgPGpvaGFuPiBEYXRlOiBXZWQgRGVjIDIyIDExOjUwOjIzIDIwMjEgKzAxMDAgcGxhdGZvcm0veDg2OiBpbnRlbF9wbWNfY29yZTogZml4IG1lbWxlYWsgb24gcmVnaXN0cmF0aW9uIGZhaWx1cmUgY29tbWl0IDI2YThiMDk0Mzc4MDRmYWJmYjFkYjA4MGQ2NzZiOTZjMGRlNjhlN2MgdXBzdHJlYW0uIEluIGNhc2UgZGV2aWNlIHJlZ2lzdHJhdGlvbiBmYWlscyBkdXJpbmcgbW9kdWxlIGluaXRpYWxpc2F0aW9uLCB0aGUgcGxhdGZvcm0gZGV2aWNlIHN0cnVjdHVyZSBuZWVkcyB0byBiZSBmcmVlZCB1c2luZyBwbGF0Zm9ybV9kZXZpY2VfcHV0KCkgdG8gcHJvcGVybHkgZnJlZSBhbGwgcmVzb3VyY2VzIChlLmcuIHRoZSBkZXZpY2UgbmFtZSkuIEZpeGVzOiA5Mzg4MzVhYTkwM2EgKCJwbGF0Zm9ybS94ODY6IGludGVsX3BtY19jb3JlOiBkbyBub3QgY3JlYXRlIGEgc3RhdGljIHN0cnVjdCBkZXZpY2UiKSBDYzogc3RhYmxlQHZnZXIua2VybmVsLm9yZyAjIDUuOSBTaWduZWQtb2ZmLWJ5OiBKb2hhbiBIb3ZvbGQgPGpvaGFuPiBSZXZpZXdlZC1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMjAyMTEyMjIxMDUwMjMuNjIwNS0xLWpvaGFuQGtlcm5lbC5vcmcgU2lnbmVkLW9mZi1ieTogSGFucyBkZSBHb2VkZSA8aGRlZ29lZGU+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgYjU3YWZkMTI0MDQ2MDY1YmU3ZjRjYTM2YmFjNjEwZjA1OWFkMjIyYSBBdXRob3I6IEFuZHJldyBDb29wZXIgPGFuZHJldy5jb29wZXIzPiBEYXRlOiBUaHUgRGVjIDE2IDAwOjA4OjU2IDIwMjEgKzAwMDAgeDg2L3BrZXk6IEZpeCB1bmRlZmluZWQgYmVoYXZpb3VyIHdpdGggUEtSVV9XRF9CSVQgY29tbWl0IDU3NjkwNTU0YWJlMTM1ZmVlODFkNmFjMzNjYzk0ZDc1YTdlMjI0YmIgdXBzdHJlYW0uIEJvdGggX19wa3J1X2FsbG93c193cml0ZSgpIGFuZCBhcmNoX3NldF91c2VyX3BrZXlfYWNjZXNzKCkgc2hpZnQgUEtSVV9XRF9CSVQgKGEgc2lnbmVkIGNvbnN0YW50KSBieSB1cCB0byAzMCBiaXRzLCBoaXR0aW5nIHRoZSBzaWduIGJpdC4gVXNlIHVuc2lnbmVkIGNvbnN0YW50cyBpbnN0ZWFkLiBDbGVhcmx5IHBrZXkgMTUgaGFzIG5vdCBiZWVuIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBVQlNBTiB5ZXQuIE5vdGljZWQgYnkgY29kZSBpbnNwZWN0aW9uIG9ubHkuIEkgY2FuJ3QgYWN0dWFsbHkgcHJvdm9rZSB0aGUgY29tcGlsZXIgaW50byBnZW5lcmF0aW5nIGluY29ycmVjdCBsb2dpYyBhcyBmYXIgYXMgdGhpcyBzaGlmdCBpcyBjb25jZXJuZWQuIFsgZGhhbnNlbjogYWRkIHN0YWJsZUAgdGFnLCBwbHVzIG1pbm9yIGNoYW5nZWxvZyBtYXNzYWdpbmcsIEZvciBhbnlvbmUgZG9pbmcgYmFja3BvcnRzLCB0aGVzZSAjZGVmaW5lcyB3ZXJlIGluIGFyY2gveDg2L2luY2x1ZGUvYXNtL3BndGFibGUuaCBiZWZvcmUgNzg0YTQ2NjE4ZjYuIF0gRml4ZXM6IDMzYTcwOWIyNWE3NiAoIm1tL2d1cCwgeDg2L21tL3BrZXlzOiBDaGVjayBWTUFzIGFuZCBQVEVzIGZvciBwcm90ZWN0aW9uIGtleXMiKSBTaWduZWQtb2ZmLWJ5OiBBbmRyZXcgQ29vcGVyIDxhbmRyZXcuY29vcGVyMz4gU2lnbmVkLW9mZi1ieTogRGF2ZSBIYW5zZW4gPGRhdmUuaGFuc2VuPiBTaWduZWQtb2ZmLWJ5OiBCb3Jpc2xhdiBQZXRrb3YgPGJwPiBDYzogc3RhYmxlQHZnZXIua2VybmVsLm9yZyBMaW5rOiBodHRwczovL2xrbWwua2VybmVsLm9yZy9yLzIwMjExMjE2MDAwODU2LjQ0ODAtMS1hbmRyZXcuY29vcGVyM0BjaXRyaXguY29tIFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgYzA1ZDhmNjZlYzM0NzBlNTIxMmM0ZDA4YzQ2ZDZjYjU3MzhkNjAwZCBBdXRob3I6IEplbnMgV2lrbGFuZGVyIDxqZW5zLndpa2xhbmRlcj4gRGF0ZTogVGh1IERlYyA5IDE1OjU5OjM3IDIwMjEgKzAxMDAgdGVlOiBoYW5kbGUgbG9va3VwIG9mIHNobSB3aXRoIHJlZmVyZW5jZSBjb3VudCAwIGNvbW1pdCBkZmQwNzQzZjFkOWVhNzY5MzE1MTBlZDE1MDMzNGQ1NzFmYmFiNDlkIHVwc3RyZWFtLiBTaW5jZSB0aGUgdGVlIHN1YnN5c3RlbSBkb2VzIG5vdCBrZWVwIGEgc3Ryb25nIHJlZmVyZW5jZSB0byBpdHMgaWRsZSBzaGFyZWQgbWVtb3J5IGJ1ZmZlcnMsIGl0IHJhY2VzIHdpdGggb3RoZXIgdGhyZWFkcyB0aGF0IHRyeSB0byBkZXN0cm95IGEgc2hhcmVkIG1lbW9yeSB0aHJvdWdoIGEgY2xvc2Ugb2YgaXRzIGRtYS1idWYgZmQgb3IgYnkgdW5tYXBwaW5nIHRoZSBtZW1vcnkuIEluIHRlZV9zaG1fZ2V0X2Zyb21faWQoKSB3aGVuIGEgbG9va3VwIGluIHRlZWRldi0mZ3Q7aWRyIGhhcyBiZWVuIHN1Y2Nlc3NmdWwsIGl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlIHRlZV9zaG0gaXMgaW4gdGhlIGRtYS1idWYgdGVhcmRvd24gcGF0aCwgYnV0IHRoYXQgcGF0aCBpcyBibG9ja2VkIGJ5IHRoZSB0ZWVkZXYgbXV0ZXguIFNpbmNlIHdlIGRvbid0IGhhdmUgYW4gQVBJIHRvIHRlbGwgaWYgdGhlIHRlZV9zaG0gaXMgaW4gdGhlIGRtYS1idWYgdGVhcmRvd24gcGF0aCBvciBub3Qgd2UgbXVzdCBmaW5kIGFub3RoZXIgd2F5IG9mIGRldGVjdGluZyB0aGlzIGNvbmRpdGlvbi4gRml4IHRoaXMgYnkgZG9pbmcgdGhlIHJlZmVyZW5jZSBjb3VudGluZyBkaXJlY3RseSBvbiB0aGUgdGVlX3NobSB1c2luZyBhIG5ldyByZWZjb3VudF90IHJlZmNvdW50IGZpZWxkLiBkbWEtYnVmIGlzIHJlcGxhY2VkIGJ5IHVzaW5nIGFub25faW5vZGVfZ2V0ZmQoKSBpbnN0ZWFkLCB0aGlzIHNlcGFyYXRlcyB0aGUgbGlmZS1jeWNsZSBvZiB0aGUgdW5kZXJseWluZyBmaWxlIGZyb20gdGhlIHRlZV9zaG0uIHRlZV9zaG1fcHV0KCkgaXMgdXBkYXRlZCB0byBob2xkIHRoZSBtdXRleCB3aGVuIGRlY3JlYXNpbmcgdGhlIHJlZmNvdW50IHRvIDAgYW5kIHRoZW4gcmVtb3ZlIHRoZSB0ZWVfc2htIGZyb20gdGVlZGV2LSZndDtpZHIgYmVmb3JlIHJlbGVhc2luZyB0aGUgbXV0ZXguIFRoaXMgbWVhbnMgdGhhdCB0aGUgdGVlX3NobSBjYW4gbmV2ZXIgYmUgZm91bmQgdW5sZXNzIGl0IGhhcyBhIHJlZmNvdW50IGxhcmdlciB0aGFuIDAuIEZpeGVzOiA5NjdjOWNjYTJjYzUgKCJ0ZWU6IGdlbmVyaWMgVEVFIHN1YnN5c3RlbSIpIENjOiBzdGFibGVAdmdlci5rZXJuZWwub3JnIFJldmlld2VkLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gUmV2aWV3ZWQtYnk6IExhcnMgUGVyc3NvbiA8bGFycGVyPiBSZXZpZXdlZC1ieTogU3VtaXQgR2FyZyA8c3VtaXQuZ2FyZz4gUmVwb3J0ZWQtYnk6IFBhdHJpayBMYW50eiA8cGF0cmlrLmxhbnR6PiBTaWduZWQtb2ZmLWJ5OiBKZW5zIFdpa2xhbmRlciA8amVucy53aWtsYW5kZXI+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgMGZmYjlmODNlNGY2ZTZhOGI2OGY5MjYxNzNhOGQwNjQ2YjU3YmVkZiBBdXRob3I6IEpvaG4gRGF2aWQgQW5nbGluIDxkYXZlLmFuZ2xpbj4gRGF0ZTogVHVlIERlYyAyMSAxMzozMzoxNiAyMDIxIC0wNTAwIHBhcmlzYzogRml4IG1hc2sgdXNlZCB0byBzZWxlY3QgZnV0ZXggc3BpbmxvY2sgY29tbWl0IGQzYTVhNjhjZmY0N2Y2ZWVhZDg0NTA0YzNjMjgzNzZiODUwNTMyNDIgdXBzdHJlYW0uIFRoZSBhZGRyZXNzIGJpdHMgdXNlZCB0byBzZWxlY3QgdGhlIGZ1dGV4IHNwaW5sb2NrIG5lZWQgdG8gbWF0Y2ggdGhvc2UgdXNlZCBpbiB0aGUgTFdTIGNvZGUgaW4gc3lzY2FsbC5TLiBUaGUgbWFzayAweDNmOCBvbmx5IHNlbGVjdHMgNyBiaXRzLiBJdCBzaG91bGQgc2VsZWN0IDggYml0cy4gVGhpcyBjaGFuZ2UgZml4ZXMgdGhlIGdsaWJjIG5wdGwvdHN0LWNvbmQyNCBhbmQgbnB0bC90c3QtY29uZDI1IHRlc3RzLiBTaWduZWQtb2ZmLWJ5OiBKb2huIERhdmlkIEFuZ2xpbiA8ZGF2ZS5hbmdsaW4+IEZpeGVzOiA1M2E0MmI2MzI0YjggKCJwYXJpc2M6IFN3aXRjaCB0byBtb3JlIGZpbmUgZ3JhaW5lZCBsd3MgbG9ja3MiKSBDYzogc3RhYmxlQHZnZXIua2VybmVsLm9yZyAjIDUuMTArIFNpZ25lZC1vZmYtYnk6IEhlbGdlIERlbGxlciBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDVkZWViOWFkNTk4YjJiM2I3OWM4ZDE0NTVhMjc2YjNkOWE4YmFjMzEgQXV0aG9yOiBKb2huIERhdmlkIEFuZ2xpbiA8ZGF2ZS5hbmdsaW4+IERhdGU6IFR1ZSBEZWMgMjEgMTM6MjE6MjIgMjAyMSAtMDUwMCBwYXJpc2M6IENvcnJlY3QgY29tcGxldGVyIGluIGx3cyBzdGFydCBjb21taXQgOGY2NmZjZTBmNDY1NjBiOWU5MTA3ODdmZjdhZDA5NzQ0NDFjNGY5YyB1cHN0cmVhbS4gVGhlIGNvbXBsZXRlciBpbiB0aGUgIm9yLGV2ICVyMSwlcjMwLCVyMzAiIGluc3RydWN0aW9uIGlzIHJldmVyc2VkLCBzbyB3ZSBhcmUgbm90IGNsaXBwaW5nIHRoZSBMV1MgbnVtYmVyIHdoZW4gd2UgYXJlIGNhbGxlZCBmcm9tIGEgMzItYml0IHByb2Nlc3MgKFc9MCkuIFdlIG5lZWQgdG8gbnVsaWZ5IHRoZSBmb2xsb3dpbmcgZGVwZGkgaW5zdHJ1Y3Rpb24gd2hlbiB0aGUgbGVhc3Qtc2lnbmlmaWNhbnQgYml0IG9mICVyMzAgaXMgMS4gSWYgdGhlICVyMjAgcmVnaXN0ZXIgaXMgbm90IGNsaXBwZWQsIGEgdXNlciBwcm9jZXNzIGNvdWxkIHBlcmZvcm0gYSBMV1MgY2FsbCB0aGF0IHdvdWxkIGJyYW5jaCB0byBhbiB1bmRlZmluZWQgbG9jYXRpb24gaW4gdGhlIGtlcm5lbCBhbmQgcG90ZW50aWFsbHkgY3Jhc2ggdGhlIG1hY2hpbmUuIFNpZ25lZC1vZmYtYnk6IEpvaG4gRGF2aWQgQW5nbGluIDxkYXZlLmFuZ2xpbj4gQ2M6IHN0YWJsZUB2Z2VyLmtlcm5lbC5vcmcgIyA0LjE5KyBTaWduZWQtb2ZmLWJ5OiBIZWxnZSBEZWxsZXIgU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCA4Yjc0NTYxNmJhOGYyZGIzODlhNTllNTY3OGZkYmUyOGFkNTg4M2JmIEF1dGhvcjogVGhhZGV1IExpbWEgZGUgU291emEgQ2FzY2FyZG8gPGNhc2NhcmRvPiBEYXRlOiBGcmkgRGVjIDE3IDEyOjQ0OjEwIDIwMjEgLTAzMDAgaXBtaTogZml4IGluaXRpYWxpemF0aW9uIHdoZW4gd29ya3F1ZXVlIGFsbG9jYXRpb24gZmFpbHMgY29tbWl0IDc1ZDcwZDc2Y2I3YjkyN2NhY2UyY2IzNDI2NWQ2OGViYjMzMDZiMTMgdXBzdHJlYW0uIElmIHRoZSB3b3JrcXVldWUgYWxsb2NhdGlvbiBmYWlscywgdGhlIGRyaXZlciBpcyBtYXJrZWQgYXMgbm90IGluaXRpYWxpemVkLCBhbmQgdGltZXIgYW5kIHBhbmljX25vdGlmaWVyIHdpbGwgYmUgbGVmdCByZWdpc3RlcmVkLiBJbnN0ZWFkIG9mIHJlbW92aW5nIHRob3NlIHdoZW4gd29ya3F1ZXVlIGFsbG9jYXRpb24gZmFpbHMsIGRvIHRoZSB3b3JrcXVldWUgaW5pdGlhbGl6YXRpb24gYmVmb3JlIGRvaW5nIGl0LCBhbmQgY2xlYW51cCBzcmN1X3N0cnVjdCBpZiBpdCBmYWlscy4gRml4ZXM6IDFkNDllYjkxZTg2ZSAoImlwbWk6IE1vdmUgcmVtb3ZlX3dvcmsgdG8gZGVkaWNhdGVkIHdvcmtxdWV1ZSIpIFNpZ25lZC1vZmYtYnk6IFRoYWRldSBMaW1hIGRlIFNvdXphIENhc2NhcmRvIDxjYXNjYXJkbz4gQ2M6IENvcmV5IE1pbnlhcmQgPGNtaW55YXJkPiBDYzogSW9hbm5hIEFsaWZpZXJha2kgPGlvYW5uYS1tYXJpYS5hbGlmaWVyYWtpPiBDYzogc3RhYmxlQHZnZXIua2VybmVsLm9yZyBNZXNzYWdlLUlkOiAmbHQ7MjAyMTEyMTcxNTQ0MTAuMTIyODY3My0yLWNhc2NhcmRvQGNhbm9uaWNhbC5jb20mZ3Q7IFNpZ25lZC1vZmYtYnk6IENvcmV5IE1pbnlhcmQgPGNtaW55YXJkPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDFmNmFiODQ3NDYxY2U3ZGQ4OWFlOWRiMmRkNDY1OGM5OTMzNTVkN2MgQXV0aG9yOiBNaWFuIFlvdXNhZiBLYXVrYWIgPHlrYXVrYWI+IERhdGU6IFdlZCBEZWMgOCAxMDozMjozOSAyMDIxICswMTAwIGlwbWk6IHNzaWY6IGluaXRpYWxpemUgc3NpZl9pbmZvLSZndDtjbGllbnQgZWFybHkgY29tbWl0IDM0ZjM1ZjhmMTRiYzQwNmVmYzA2ZWU0ZmY3MzIwMmM2ZmQyNDVkMTUgdXBzdHJlYW0uIER1cmluZyBwcm9iZSBzc2lmX2luZm8tJmd0O2NsaWVudCBpcyBkZXJlZmVyZW5jZWQgaW4gZXJyb3IgcGF0aC4gSG93ZXZlciwgaXQgaXMgc2V0IHdoZW4gc29tZSBvZiB0aGUgZXJyb3IgY2hlY2tpbmcgaGFzIGFscmVhZHkgYmVlbiBkb25lLiBUaGlzIGNhdXNlcyBmb2xsb3dpbmcga2VybmVsIGNyYXNoIGlmIGFuIGVycm9yIHBhdGggaXMgdGFrZW46IFsgMzAuNjQ1NTkzXVsgVDY3NF0gaXBtaV9zc2lmIDAtMDAwZTogaXBtaV9zc2lmOiBOb3QgcHJvYmluZywgSW50ZXJmYWNlIGFscmVhZHkgcHJlc2VudCBbIDMwLjY1NzYxNl1bIFQ2NzRdIFVuYWJsZSB0byBoYW5kbGUga2VybmVsIE5VTEwgcG9pbnRlciBkZXJlZmVyZW5jZSBhdCB2aXJ0dWFsIGFkZHJlc3MgMDAwMDAwMDAwMDAwMDA4OCAuLi4gWyAzMC42NTc3MjNdWyBUNjc0XSBwYyA6IF9fZGV2X3ByaW50aysweDI4LzB4YTAgWyAzMC42NTc3MzJdWyBUNjc0XSBsciA6IF9kZXZfZXJyKzB4N2MvMHhhMCAuLi4gWyAzMC42NTc3NzJdWyBUNjc0XSBDYWxsIHRyYWNlOiBbIDMwLjY1Nzc3NV1bIFQ2NzRdIF9fZGV2X3ByaW50aysweDI4LzB4YTAgWyAzMC42NTc3NzhdWyBUNjc0XSBfZGV2X2VycisweDdjLzB4YTAgWyAzMC42NTc3ODFdWyBUNjc0XSBzc2lmX3Byb2JlKzB4NTQ4LzB4OTAwIFtpcG1pX3NzaWYgNjJjZTRiMDhiYWRjMTQ1OGZkODk2MjA2ZDllZjY5YTNjMzFmM2QzZV0gWyAzMC42NTc3OTFdWyBUNjc0XSBpMmNfZGV2aWNlX3Byb2JlKzB4MzdjLzB4M2MwIC4uLiBJbml0aWFsaXplIHNzaWZfaW5mby0mZ3Q7Y2xpZW50IGJlZm9yZSBhbnkgZXJyb3IgcGF0aCBjYW4gYmUgdGFrZW4uIENsZWFyIGkyY19jbGllbnQgZGF0YSBpbiB0aGUgZXJyb3IgcGF0aCB0byBwcmV2ZW50IHRoZSBkYW5nbGluZyBwb2ludGVyIGZyb20gbGVha2luZy4gRml4ZXM6IGM0NDM2YzkxNDljNSAoImlwbWlfc3NpZjogYXZvaWQgcmVnaXN0ZXJpbmcgZHVwbGljYXRlIHNzaWYgaW50ZXJmYWNlIikgQ2M6IHN0YWJsZUB2Z2VyLmtlcm5lbC5vcmcgIyA1LjQueCBTdWdnZXN0ZWQtYnk6IFRha2FzaGkgSXdhaSA8dGl3YWk+IFNpZ25lZC1vZmYtYnk6IE1pYW4gWW91c2FmIEthdWthYiA8eWthdWthYj4gTWVzc2FnZS1JZDogJmx0OzIwMjExMjA4MDkzMjM5LjQ0MzItMS15a2F1a2FiQHN1c2UuZGUmZ3Q7IFNpZ25lZC1vZmYtYnk6IENvcmV5IE1pbnlhcmQgPGNtaW55YXJkPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGE1MTkyZjMxMTYwYzE3MzllZjY1MjVlZDc3ZDZhYWZhOGU2NTY1ZGQgQXV0aG9yOiBUaGFkZXUgTGltYSBkZSBTb3V6YSBDYXNjYXJkbyA8Y2FzY2FyZG8+IERhdGU6IEZyaSBEZWMgMTcgMTI6NDQ6MDkgMjAyMSAtMDMwMCBpcG1pOiBiYWlsIG91dCBpZiBpbml0X3NyY3Vfc3RydWN0IGZhaWxzIGNvbW1pdCAyYjUxNjBiMTIwOTEyODVjNWFjYTQ1OTgwZjEwMGE5Mjk0YWY3YjA0IHVwc3RyZWFtLiBJbiBjYXNlLCBpbml0X3NyY3Vfc3RydWN0IGZhaWxzIChiZWNhdXNlIG9mIG1lbW9yeSBhbGxvY2F0aW9uIGZhaWx1cmUpLCB3ZSBtaWdodCBwcm9jZWVkIHdpdGggdGhlIGRyaXZlciBpbml0aWFsaXphdGlvbiBkZXNwaXRlIHNyY3Vfc3RydWN0IG5vdCBiZWluZyBlbnRpcmVseSBpbml0aWFsaXplZC4gRml4ZXM6IDkxM2E4OWYwMDlkOSAoImlwbWk6IERvbid0IGluaXRpYWxpemUgYW55dGhpbmcgaW4gdGhlIGNvcmUgdW50aWwgc29tZXRoaW5nIHVzZXMgaXQiKSBTaWduZWQtb2ZmLWJ5OiBUaGFkZXUgTGltYSBkZSBTb3V6YSBDYXNjYXJkbyA8Y2FzY2FyZG8+IENjOiBDb3JleSBNaW55YXJkIDxjbWlueWFyZD4gQ2M6IHN0YWJsZUB2Z2VyLmtlcm5lbC5vcmcgTWVzc2FnZS1JZDogJmx0OzIwMjExMjE3MTU0NDEwLjEyMjg2NzMtMS1jYXNjYXJkb0BjYW5vbmljYWwuY29tJmd0OyBTaWduZWQtb2ZmLWJ5OiBDb3JleSBNaW55YXJkIDxjbWlueWFyZD4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCBiYzY3NGYxYjIxMTlmY2YzNmNhMjhhNWY4MTcwMzA3YmU3MGRlMzMzIEF1dGhvcjogSm9zw6kgRXhww7NzaXRvIDxqb3NlLmV4cG9zaXRvODk+IERhdGU6IFN1biBEZWMgMTIgMjE6MDE6NDkgMjAyMSAtMDgwMCBJbnB1dDogYXRtZWxfbXh0X3RzIC0gZml4IGRvdWJsZSBmcmVlIGluIG14dF9yZWFkX2luZm9fYmxvY2sgY29tbWl0IDEyZjI0N2FiNTkwYTA4ODU2NDQxZWZkYmQzNTFjZjJjYzhmNjBhMmQgdXBzdHJlYW0uIFRoZSAiaWRfYnVmIiBidWZmZXIgaXMgc3RvcmVkIGluICJkYXRhLSZndDtyYXdfaW5mb19ibG9jayIgYW5kIGZyZWVkIGJ5ICJteHRfZnJlZV9vYmplY3RfdGFibGUiIGluIGNhc2Ugb2YgZXJyb3IuIFJldHVybiBpbnN0ZWFkIG9mIGp1bXBpbmcgdG8gYXZvaWQgYSBkb3VibGUgZnJlZS4gQWRkcmVzc2VzLUNvdmVyaXR5LUlEOiAxNDc0NTgyICgiRG91YmxlIGZyZWUiKSBGaXhlczogMDY4YmRiNjdlZjc0ICgiSW5wdXQ6IGF0bWVsX214dF90cyAtIGZpeCB0aGUgZmlybXdhcmUgdXBkYXRlIikgU2lnbmVkLW9mZi1ieTogSm9zw6kgRXhww7NzaXRvIDxqb3NlLmV4cG9zaXRvODk+IExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMjAyMTEyMTIxOTQyNTcuNjg4NzktMS1qb3NlLmV4cG9zaXRvODlAZ21haWwuY29tIENjOiBzdGFibGVAdmdlci5rZXJuZWwub3JnIFNpZ25lZC1vZmYtYnk6IERtaXRyeSBUb3Jva2hvdiA8ZG1pdHJ5LnRvcm9raG92PiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IDMwMTQwZTI1MmZkYjc0ODg0ZDVlZjM0ZjVlNDhkMmZjNmE3OWE0MzMgQXV0aG9yOiBNYXJ0aW4gQmx1bWVuc3RpbmdsIDxtYXJ0aW4uYmx1bWVuc3RpbmdsPiBEYXRlOiBNb24gRGVjIDYgMjI6MDg6MDQgMjAyMSArMDEwMCBBU29DOiBtZXNvbjogYWl1OiBNb3ZlIEFJVV9JMlNfTUlTQyBob2xkIHNldHRpbmcgdG8gYWl1LWZpZm8taTJzIGNvbW1pdCBlZTkwN2FmYjBjMzlhNDFlZTc0Yjg2Mjg4MmNmZTEyODIwYzc0Yjk4IHVwc3RyZWFtLiBUaGUgb3V0LW9mLXRyZWUgdmVuZG9yIGRyaXZlciB1c2VzIHRoZSBmb2xsb3dpbmcgYXBwcm9hY2ggdG8gc2V0IHRoZSBBSVVfSTJTX01JU0MgcmVnaXN0ZXI6IDEpIHdyaXRlIEFJVV9NRU1fSTJTX1NUQVJUX1BUUiBhbmQgQUlVX01FTV9JMlNfUkRfUFRSIDIpIGNvbmZpZ3VyZSBBSVVfSTJTX01VVEVfU1dBUFsxNTowXSAzKSB3cml0ZSBBSVVfTUVNX0kyU19FTkRfUFRSIDQpIHNldCBBSVVfSTJTX01JU0NbMl0gdG8gMSAoZG9jdW1lbnRlZCBhczogInB1dCBJMlMgaW50ZXJmYWNlIGluIGhvbGQgbW9kZSIpIDUpIHNldCBBSVVfSTJTX01JU0NbNF0gdG8gMSAoZGVwZW5kaW5nIG9uIHRoZSBkcml2ZXIgcmV2aXNpb24gaXQgYWx3YXlzIHN0YXlzIGF0IDEgd2hpbGUgZm9yIG9sZGVyIGRyaXZlcnMgdGhpcyBiaXQgaXMgdW5zZXQgaW4gc3RlcCA0KSA2KSBzZXQgQUlVX0kyU19NSVNDWzJdIHRvIDAgNykgd3JpdGUgQUlVX01FTV9JMlNfTUFTS1MgOCkgdG9nZ2xlIEFJVV9NRU1fSTJTX0NPTlRST0xbMF0gOSkgdG9nZ2xlIEFJVV9NRU1fSTJTX0JVRl9DTlRMWzBdIE1vdmUgc2V0dGluZyB0aGUgQUlVX0kyU19NSVNDWzJdIGJpdCB0byBhaXVfZmlmb19pMnNfaHdfcGFyYW1zKCkgc28gaXQgcmVzZW1ibGVzIHRoZSBmbG93IGluIHRoZSB2ZW5kb3Iga2VybmVsIG1vcmUgY2xvc2VseS4gV2hpbGUgaGVyZSBhbHNvIGNvbmZpZ3VyZSBBSVVfSTJTX01JU0NbNF0gKGRvY3VtZW50ZWQgYXM6ICJmb3JjZSBlYWNoIGF1ZGlvIGRhdGEgdG8gbGVmdCBvciByaWdodCBhY2NvcmRpbmcgdG8gdGhlIGJpdCBhdHRhY2hlZCB3aXRoIHRoZSBhdWRpbyBkYXRhIikgc2ltaWxhciB0byBob3cgdGhlIHZlbmRvciBkcml2ZXIgZG9lcyB0aGlzLiBUaGlzIGZpeGVzIHRoZSBpbmZhbW91cyBhbmQgbG9uZy1zdGFuZGluZyAibWFjaGluZSBndW4gbm9pc2UiIGlzc3VlIChhIGJ1ZmZlciB1bmRlcnJ1biBpc3N1ZSkuIEZpeGVzOiA2YWU5Y2E5Y2U5ODZiZiAoIkFTb0M6IG1lc29uOiBhaXU6IGFkZCBpMnMgYW5kIHNwZGlmIHN1cHBvcnQiKSBSZXBvcnRlZC1ieTogQ2hyaXN0aWFuIEhld2l0dCA8Y2hyaXN0aWFuc2hld2l0dD4gUmVwb3J0ZWQtYnk6IEdlcmFsZG8gTmFzY2ltZW50byA8Z2VyYWxkb2dhYnJpZWw+IFRlc3RlZC1ieTogQ2hyaXN0aWFuIEhld2l0dCA8Y2hyaXN0aWFuc2hld2l0dD4gVGVzdGVkLWJ5OiBHZXJhbGRvIE5hc2NpbWVudG8gPGdlcmFsZG9nYWJyaWVsPiBBY2tlZC1ieTogSmVyb21lIEJydW5ldCA8amJydW5ldD4gQ2M6IHN0YWJsZUB2Z2VyLmtlcm5lbC5vcmcgU2lnbmVkLW9mZi1ieTogTWFydGluIEJsdW1lbnN0aW5nbCA8bWFydGluLmJsdW1lbnN0aW5nbD4gTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8yMDIxMTIwNjIxMDgwNC4yNTEyOTk5LTMtbWFydGluLmJsdW1lbnN0aW5nbEBnb29nbGVtYWlsLmNvbSBTaWduZWQtb2ZmLWJ5OiBNYXJrIEJyb3duIFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgMmI0YzAyMGI3MGNjOTQzZjVkM2FlN2NkNTkwNTllN2IyZTBjYjBhYiBBdXRob3I6IFdlcm5lciBTZW1iYWNoIDx3c2U+IERhdGU6IFdlZCBEZWMgMTUgMjA6MTY6NDYgMjAyMSArMDEwMCBBTFNBOiBoZGEvcmVhbHRlazogRml4IHF1aXJrIGZvciBDbGV2byBOSjUxQ1UgY29tbWl0IGVkY2E3Y2M0YjBhY2NmYTY5ZGMwMzI0NDJmZTA2ODRlNTljNjkxYjggdXBzdHJlYW0uIFRoZSBDbGV2byBOSjUxQ1UgY29tZXMgZWl0aGVyIHdpdGggdGhlIEFMQzI5MyBvciB0aGUgQUxDMjU2IGNvZGVjLCBidXQgdXNlcyB0aGUgMHg4Njg2IHN1YnByb2R1Y3QgaWQgaW4gYm90aCBjYXNlcy4gVGhlIEFMQzI1NiBjb2RlYyBuZWVkcyBhIGRpZmZlcmVudCBxdWlyayBmb3IgdGhlIGhlYWRzZXQgbWljcm9waG9uZSB3b3JraW5nIGFuZCBhbmQgZWRkaXRpb25hbCBxdWlyayBmb3Igc291bmQgd29ya2luZyBhZnRlciBzdXNwZW5kIGFuZCByZXN1bWUuIFdoZW4gd2FraW5nIHVwIGZyb20gczMgc3VzcGVuZCB0aGUgQ29lZiAweDEwIGlzIHNldCB0byAweDAyMjAgaW5zdGVhZCBvZiAweDAwMjAgb24gdGhlIEFMQzI1NiBjb2RlYy4gU2V0dGluZyB0aGUgdmFsdWUgbWFudWFsbHkgbWFrZXMgdGhlIHNvdW5kIHdvcmsgYWdhaW4uIFRoaXMgcGF0Y2ggZG9lcyB0aGlzIGF1dG9tYXRpY2FsbHkuIFsgbWlub3IgY29kaW5nIHN0eWxlIGZpeCBieSB0aXdhaSBdIFNpZ25lZC1vZmYtYnk6IFdlcm5lciBTZW1iYWNoIDx3c2U+IEZpeGVzOiBiNWFjZmUxNTJhYmFhICgiQUxTQTogaGRhL3JlYWx0ZWs6IEFkZCBzb21lIENsb3ZlIFNTSUQgaW4gdGhlIEFMQzI5MyhBTEMxMjIwKSIpIENjOiA8c3RhYmxlPiBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMjE1MTkxNjQ2Ljg0NDY0NC0xLXdzZUB0dXhlZG9jb21wdXRlcnMuY29tIFNpZ25lZC1vZmYtYnk6IFRha2FzaGkgSXdhaSA8dGl3YWk+IFNpZ25lZC1vZmYtYnk6IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ2toPiBjb21taXQgNzQ3MDc4MGYzYjBjMmE4ZWY1MzU2MmVkOTJmYmIxMGIwMzAyNGU0NyBBdXRob3I6IEJyYWRsZXkgU2NvdHQgPGJzY290dD4gRGF0ZTogTW9uIERlYyAxMyAxMToyMjo0NyAyMDIxIC0wNTAwIEFMU0E6IGhkYS9yZWFsdGVrOiBBZGQgbmV3IGFsYzI4NS1ocC1hbXAtaW5pdCBtb2RlbCBjb21taXQgYWE3MjM5NDY2N2U1Y2VhMzU0N2U0YzQxZGRmZjdjYThjNjMyZDc2NCB1cHN0cmVhbS4gQWRkcyBhIG5ldyAiYWxjMjg1LWhwLWFtcC1pbml0IiBtb2RlbCB0aGF0IGNhbiBiZSB1c2VkIHRvIGFwcGx5IHRoZSBBTEMyODUgSFAgc3BlYWtlciBhbXBsaWZpZXIgaW5pdGlhbGl6YXRpb24gZml4dXAgdG8gZGV2aWNlcyB0aGF0IGFyZSBub3QgYWxyZWFkeSBrbm93biBieSBwYXNzaW5nICJoZGFfbW9kZWw9YWxjMjg1LWhwLWFtcC1pbml0IiB0byB0aGUgc25kLXNvZi1pbnRlbC1oZGEtY29tbW9uIG1vZHVsZSBvciAibW9kZWw9YWxjMjg1LWhwLWFtcC1pbml0IiB0byB0aGUgc25kLWhkYS1pbnRlbCBtb2R1bGUsIGRlcGVuZGluZyBvbiB3aGljaCBpcyBiZWluZyB1c2VkLiBTaWduZWQtb2ZmLWJ5OiBCcmFkbGV5IFNjb3R0IDxic2NvdHQ+IENjOiA8c3RhYmxlPiBMaW5rOiBodHRwczovL2xvcmUua2VybmVsLm9yZy9yLzIwMjExMjEzMTYyMjQ2LjUwNjgzOC0xLWJzY290dEB0ZWtzYXZ2eS5jb20gU2lnbmVkLW9mZi1ieTogVGFrYXNoaSBJd2FpIDx0aXdhaT4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCA0Y2I3ZGMyZTMwNzQ5OGY4ZTUwZWFjNDM4ZDFiZWNlODRmZDg1M2M2IEF1dGhvcjogQnJhZGxleSBTY290dCBEYXRlOiBNb24gRGVjIDEzIDEwOjQ5OjM5IDIwMjEgLTA1MDAgQUxTQTogaGRhL3JlYWx0ZWs6IEFtcCBpbml0IGZpeHVwIGZvciBIUCBaQm9vayAxNSBHNiBjb21taXQgZDI5NmE3NGI3YjU5ZmY5MTE2MjM2YzE3ZWRiMjVmMjY5MzVkYmY3MCB1cHN0cmVhbS4gSFAgWkJvb2sgMTUgRzYgKFNTSUQgMTAzYzo4NjBmKSBuZWVkcyB0aGUgc2FtZSBzcGVha2VyIGFtcGxpZmllciBpbml0aWFsaXphdGlvbiBhcyB1c2VkIG9uIHNldmVyYWwgb3RoZXIgSFAgbGFwdG9wcyB1c2luZyBBTEMyODUuIFNpZ25lZC1vZmYtYnk6IEJyYWRsZXkgU2NvdHQgQ2M6IDxzdGFibGU+IExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMjAyMTEyMTMxNTQ5MzguNTAzMjAxLTEtQnJhZGxleS5TY290dEB6ZWJyYS5jb20gU2lnbmVkLW9mZi1ieTogVGFrYXNoaSBJd2FpIDx0aXdhaT4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCA2OWU0OTIxNjFjN2I1NjM2ODRjYWYwZmFkMDEzODIyNzljMDY1MjEzIEF1dGhvcjogQ29saW4gSWFuIEtpbmcgPGNvbGluLmtpbmc+IERhdGU6IFN1biBEZWMgMTIgMTc6MjA6MjUgMjAyMSArMDAwMCBBTFNBOiBkcml2ZXJzOiBvcGwzOiBGaXggaW5jb3JyZWN0IHVzZSBvZiB2cC0mZ3Q7c3RhdGUgY29tbWl0IDJkZWU1NGIyODlmYmM4MTA2NjlhMWIyYjhhMDg4N2ZhMWM5YTE0ZDcgdXBzdHJlYW0uIFN0YXRpYyBhbmFseXNpcyB3aXRoIHNjYW4tYnVpbGQgaGFzIGZvdW5kIGFuIGFzc2lnbm1lbnQgdG8gdnAyIHRoYXQgaXMgbmV2ZXIgdXNlZC4gSXQgc2VlbXMgdGhhdCB0aGUgY2hlY2sgb24gdnAtJmd0O3N0YXRlICZndDsgMCBzaG91bGQgYmUgYWN0dWFsbHkgb24gdnAyLSZndDtzdGF0ZSBpbnN0ZWFkLiBGaXggdGhpcy4gVGhpcyBkYXRlcyBiYWNrIHRvIDIwMDIsIEkgZm91bmQgdGhlIG9mZmVuZGluZyBjb21taXQgZnJvbSB0aGUgZ2l0IGhpc3RvcnkgZ2l0Oi8vZ2l0Lmtlcm5lbC5vcmcvcHViL3NjbS9saW51eC9rZXJuZWwvZ2l0L3RnbHgvaGlzdG9yeS5naXQsIGNvbW1pdCA5MWUzOTUyMWJiZjYgKCJbUEFUQ0hdIEFMU0EgcGF0Y2ggZm9yIDIuNS40IikgU2lnbmVkLW9mZi1ieTogQ29saW4gSWFuIEtpbmcgPGNvbGluLmkua2luZz4gQ2M6IDxzdGFibGU+IExpbms6IGh0dHBzOi8vbG9yZS5rZXJuZWwub3JnL3IvMjAyMTEyMTIxNzIwMjUuNDcwMzY3LTEtY29saW4uaS5raW5nQGdtYWlsLmNvbSBTaWduZWQtb2ZmLWJ5OiBUYWthc2hpIEl3YWkgPHRpd2FpPiBTaWduZWQtb2ZmLWJ5OiBHcmVnIEtyb2FoLUhhcnRtYW4gPGdyZWdraD4gY29tbWl0IGE5NmMwOGUwYjQxZTAyMmI0NDBlZTljODMyN2IxNGRkNmViMDk0ZjcgQXV0aG9yOiBYaWFva2UgV2FuZyA8eGtlcm5lbC53YW5nPiBEYXRlOiBNb24gRGVjIDEzIDE1OjM5OjMxIDIwMjEgKzA4MDAgQUxTQTogamFjazogQ2hlY2sgdGhlIHJldHVybiB2YWx1ZSBvZiBrc3RyZHVwKCkgY29tbWl0IGMwMWMxZGIxZGM2MzJlZGFmYjBkZmYzMmQ0MGRhZjRmOWMxYTRlMTkgdXBzdHJlYW0uIGtzdHJkdXAoKSBjYW4gcmV0dXJuIE5VTEwsIGl0IGlzIGJldHRlciB0byBjaGVjayB0aGUgcmV0dXJuIHZhbHVlIG9mIGl0LiBTaWduZWQtb2ZmLWJ5OiBYaWFva2UgV2FuZyA8eGtlcm5lbC53YW5nPiBDYzogPHN0YWJsZT4gTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci90ZW5jZW50XzA5NDgxNkYzNTIyRTBEQzcwNDA1NkM3ODkzNTJFQkJGMDYwNkBxcS5jb20gU2lnbmVkLW9mZi1ieTogVGFrYXNoaSBJd2FpIDx0aXdhaT4gU2lnbmVkLW9mZi1ieTogR3JlZyBLcm9haC1IYXJ0bWFuIDxncmVna2g+IGNvbW1pdCA1MWM3YjJhN2I4NmE5MjNjYzQxMDg4MmYzYjhiZGUwOWJhNDEyZjNjIEF1dGhvcjogR3VlbnRlciBSb2VjayA8bGludXg+IERhdGU6IFNhdCBOb3YgMTMgMDg6NTU6MDYgMjAyMSAtMDgwMCBod21vbjogKGxtOTApIERyb3AgY3JpdGljYWwgYXR0cmlidXRlIHN1cHBvcnQgZm9yIE1BWDY2NTQgWyBVcHN0cmVhbSBjb21taXQgMTZiYTUxYjVkY2QzZjZkZGUyZTUxZDVjY2M4NjMxMzExOWRjZjg4OSBdIFRlc3RzIHdpdGggYSByZWFsIGNoaXAgYW5kIGEgY2xvc2VyIGxvb2sgaW50byB0aGUgZGF0YXNoZWV0IHNob3cgdGhhdCBNQVg2NjU0IGRvZXMgbm90IHN1cHBvcnQgQ1JJVC9USEVSTS9PVkVSVEVNUCBsaW1pdHMsIHNvIGRyb3Agc3VwcG9ydCBvZiB0aGUgcmVzcGVjdGl2ZSBhdHRyaWJ1dGVzIGZvciB0aGlzIGNoaXAuIEludHJvZHVjZSBMTTkwX0hBVkVfQ1JJVCBmbGFnIGFuZCB1c2UgaXQgdG8gaW5zdGFudGlhdGUgY3JpdGljYWwgbGltaXQgYXR0cmlidXRlcyB0byBzb2x2ZSB0aGUgcHJvYmxlbS4gQ2M6IEpvc2ggTGVoYW4gPGtyZWxsYW4+IEZpeGVzOiAyMjlkNDk1ZDgxODkgKCJod21vbjogKGxtOTApIEFkZCBtYXg2NjU0IHN1cHBvcnQgdG8gbG05MCBkcml2ZXIiKSBTaWduZWQtb2ZmLWJ5OiBHdWVudGVyIFJvZWNrIDxsaW51eD4gU2lnbmVkLW9mZi1ieTogU2FzaGEgTGV2aW4gPHNhc2hhbD4gY29tbWl0IDI0NjQ3MzhkMGVlNGVjNTdiZDZmNTYxYWNjM2IxNzhjNzk3MDNjMzggQXV0aG9yOiBHdWVudGVyIFJvZWNrIDxsaW51eD4gRGF0ZTogVGh1IE9jdCAyMSAwMTo0OTo1MCAyMDIxIC0wNzAwIGh3bW9uOiAobG05MCkgSW50cm9kdWNlIGZsYWcgaW5kaWNhdGluZyBleHRlbmRlZCB0ZW1wZXJhdHVyZSBzdXBwb3J0IFsgVXBzdHJlYW0gY29tbWl0IGYzNDdlMjQ5ZmNmOTIwYWQ2OTc0Y2JkODk4ZTJlYzBiMzY2YTFjMzQgXSBBIGZsYWcgaW5kaWNhdGluZyBleHRlbmRlZCB0ZW1wZXJhdHVyZSBzdXBwb3J0IG1ha2VzIGl0IGVhc2llciB0byBhZGQgc3VwcG9ydCBmb3IgYWRkaXRpb25hbCBjaGlwcyB3aXRoIHRoaXMgZnVuY3Rpb25hbGl0eS4gQ2M6IERhdmlkIFQuIFdpbHNvbiA8ZGF2aWQud2lsc29uPiBTaWduZWQtb2ZmLWJ5OiBHdWVudGVyIFJvZWNrIDxsaW51eD4gU2lnbmVkLW9mZi1ieTogU2FzaGEgTGV2aW4gPHNhc2hhbD4gY29tbWl0IDE5NmRmNTZjM2RjOGJiMzZjYWYwYmRhMjVjMjYwNTZhODM4ZWQyNzMgQXV0aG9yOiBHdWVudGVyIFJvZWNrIDxsaW51eD4gRGF0ZTogTW9uIE9jdCAxOCAyMDowMzozMiAyMDIxIC0wNzAwIGh3bW9uOiAobG05MCkgQWRkIGJhc2ljIHN1cHBvcnQgZm9yIFRJIFRNUDQ2MSBbIFVwc3RyZWFtIGNvbW1pdCBmODM0NGY3NjkzYTI1ZDkwMjVhNTlkMTY0NDUwYjUwYzZmNWFhM2MwIF0gVE1QNDYxIGlzIGFsbW9zdCBpZGVudGljYWwgdG8gVE1QNDUxIGFuZCB3YXMgYWN0dWFsbHkgZGV0ZWN0ZWQgYXMgVE1QNDUxIHdpdGggdGhlIGV4aXN0aW5nIGxtOTAgZHJpdmVyIGlmIGl0cyBJMkMgYWRkcmVzcyBpcyAweDRjLiBBZGQgc3VwcG9ydCBmb3IgaXQgdG8gdGhlIGxtOTAgZHJpdmVyLiBBdCB0aGUgc2FtZSB0aW1lLCBpbXByb3ZlIHRoZSBjaGlwIGRldGVjdGlvbiBmdW5jdGlvbiB0byBhdCBsZWFzdCB0cnkgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBUTVA0NTEgYW5kIFRNUDQ2MS4gQXMgYSBzaWRlIGVmZmVjdCwgdGhpcyBmaXhlcyBjb21taXQgMjQzMzNhYzI2ZDAxICgiaHdtb246ICh0bXA0MDEpIHVzZSBzbWIgd29yZCBvcGVyYXRpb25zIGluc3RlYWQgb2YgMiBzbWIgYnl0ZSBvcGVyYXRpb25zIikuIFRNUDQ2MSBkb2VzIG5vdCBzdXBwb3J0IHdvcmQgb3BlcmF0aW9ucyBvbiB0ZW1wZXJhdHVyZSByZWdpc3RlcnMsIHdoaWNoIGNhdXNlcyBiYWQgdGVtcGVyYXR1cmUgcmVhZGluZ3Mgd2l0aCB0aGUgdG1wNDAxIGRyaXZlci4gVGhlIGxtOTAgZHJpdmVyIGRvZXMgbm90IHBlcmZvcm0gd29yZCBvcGVyYXRpb25zIG9uIHRlbXBlcmF0dXJlIHJlZ2lzdGVycyBhbmQgdGh1cyBkb2VzIG5vdCBoYXZlIHRoaXMgcHJvYmxlbS4gU3VwcG9ydCBpcyBsaXN0ZWQgYXMgYmFzaWMgYmVjYXVzZSBUTVA0NjEgc3VwcG9ydHMgYSBzZW5zb3IgcmVzb2x1dGlvbiBvZiAwLjA2MjUgZGVncmVlcyBDLCB3aGlsZSB0aGUgbG05MCBkcml2ZXIgYXNzdW1lcyBhIHJlc29sdXRpb24gb2YgMC4xMjUgZGVncmVlcyBDLiBBbHNvLCB0aGUgVE1QNDYxIHN1cHBvcnRzIG5lZ2F0aXZlIHRlbXBlcmF0dXJlcyB3aXRoIGl0cyBkZWZhdWx0IHRlbXBlcmF0dXJlIHJhbmdlLCB3aGljaCBpcyBub3QgdGhlIGNhc2UgZm9yIHNpbWlsYXIgY2hpcHMgc3VwcG9ydGVkIGJ5IHRoZSBsbTkwIGFuZCB0aGUgdG1wNDAxIGRyaXZlcnMuIFRob3NlIGxpbWl0YXRpb25zIHdpbGwgYmUgYWRkcmVzc2VkIHdpdGggZm9sbG93LXVwIHBhdGNoZXMuIEZpeGVzOiAyNDMzM2FjMjZkMDEgKCJod21vbjogKHRtcDQwMSkgdXNlIHNtYiB3b3JkIG9wZXJhdGlvbnMgaW5zdGVhZCBvZiAyIHNtYiBieXRlIG9wZXJhdGlvbnMiKSBSZXBvcnRlZC1ieTogRGF2aWQgVC4gV2lsc29uIDxkYXZpZC53aWxzb24+IENjOiBEYXZpZCBULiBXaWxzb24gPGRhdmlkLndpbHNvbj4gU2lnbmVkLW9mZi1ieTogR3VlbnRlciBSb2VjayA8bGludXg+IFNpZ25lZC1vZmYtYnk6IFNhc2hhIExldmluIDxzYXNoYWw+IGNvbW1pdCBmYTJlMTQ5MjYwYmY5MGJiYmU4M2RiYzFlZDljOTExM2QxM2QzYWZkIEF1dGhvcjogR3VlbnRlciBSb2VjayA8bGludXg+IERhdGU6IFNhdCBOb3YgNiAxMDowMjo0NCAyMDIxIC0wNzAwIGh3bW9uOiAobG05MCkgRml4IHVzYWdlIG9mIENPTkZJRzIgcmVnaXN0ZXIgaW4gZGV0ZWN0IGZ1bmN0aW9uIFsgVXBzdHJlYW0gY29tbWl0IGZjZTE1YzQ1ZDNmYmQ5ZmMxZmVhYWYzMjEwZDhlM2Y4YjMzZGZkM2EgXSBUaGUgZGV0ZWN0IGZ1bmN0aW9uIGhhZCBhIGNvbW1lbnQgIk1ha2UgY29tcGlsZXIgaGFwcHkiIHdoZW4gaWQgZGlkIG5vdCByZWFkIHRoZSBzZWNvbmQgY29uZmlndXJhdGlvbiByZWdpc3Rlci4gQXMgaXQgdHVybnMgb3V0LCB0aGUgY29kZSB3YXMgY2hlY2tpbmcgdGhlIGNvbnRlbnRzIG9mIHRoaXMgcmVnaXN0ZXIgZm9yIG1hbnVmYWN0dXJlciBJRCAweEExIChOWFAgU2VtaWNvbmR1Y3Rvci9QaGlsaXBzKSwgYnV0IG5ldmVyIGFjdHVhbGx5IHJlYWQgdGhlIHJlZ2lzdGVyLiBTbyBpdCB3YXNuJ3Qgc3VycHJpc2luZyB0aGF0IHRoZSBjb21waWxlciBjb21wbGFpbmVkLCBhbmQgaXQgaW5kZWVkIGhhZCBhIHBvaW50LiBGaXggdGhlIGNvZGUgdG8gcmVhZCB0aGUgcmVnaXN0ZXIgY29udGVudHMgZm9yIG1hbnVmYWN0dXJlciBJRCAweGExLiBBdCB0aGUgc2FtZSB0aW1lLCB0aGUgY29kZSB3YXMgcmVhZGluZyB0aGUgcmVnaXN0ZXIgZm9yIG1hbnVmYWN0dXJlciBJRCAweDQxIChBbmFsb2cgRGV2aWNlcyksIGJ1dCBpdCB3YXMgbm90IHVzaW5nIHRoZSByZXN1bHRzLiBJbiBlZmZlY3QgaXQgd2FzIGp1c3QgY2hlY2tpbmcgaWYgcmVhZGluZyB0aGUgcmVnaXN0ZXIgcmV0dXJuZWQgYW4gZXJyb3IuIFRoYXQgZG9lc24ndCByZWFsbHkgYWRkIG11Y2ggaWYgYW55IHZhbHVlLCBzbyBzdG9wIGRvaW5nIHRoYXQuIEZpeGVzOiBmOTBiZTQyZmIzODMgKCJod21vbjogKGxtOTApIFJlZmFjdG9yIHJlYWRpbmcgb2YgY29uZmlnMiByZWdpc3RlciIpIFNpZ25lZC1vZmYtYnk6IEd1ZW50ZXIgUm9lY2sgPGxpbnV4PiBTaWduZWQtb2ZmLWJ5OiBTYXNoYSBMZXZpbiA8c2FzaGFsPiBjb21taXQgYmE2OTZiNDcwODM5ZDcwYzZiODI5MGMxZjc5OGJhYzdmYjJhNTg0YyBBdXRob3I6IFBoaWwgRWx3ZWxsIDxwaGlsPiBEYXRlOiBNb24gRGVjIDYgMDk6MjI6MzYgMjAyMSArMDAwMCBwaW5jdHJsOiBiY20yODM1OiBDaGFuZ2UgaW5pdCBvcmRlciBmb3IgZ3BpbyBob2dzIFsgVXBzdHJlYW0gY29tbWl0IDI2NjQyM2U2MGVhMWI5NTNmY2MwY2Q5N2YzZGFkODU4NTdlNDM0ZDEgXSAuLi5hbmQgZ3Bpby1yYW5nZXMgcGluY3RybC1iY20yODM1IGlzIGEgY29tYmluZWQgcGluY3RybC9ncGlvIGRyaXZlci4gQ3VycmVudGx5IHRoZSBncGlvIHNpZGUgaXMgcmVnaXN0ZXJlZCBmaXJzdCwgYnV0IHRoaXMgYnJlYWtzIGdwaW8gaG9ncyAod2hpY2ggYXJlIGNvbmZpZ3VyZWQgZHVyaW5nIGdwaW9jaGlwX2FkZF9kYXRhKS4gUGFydCBvZiB0aGUgaG9nIGluaXRpYWxpc2F0aW9uIGlzIGEgY2FsbCB0byBwaW5jdHJsX2dwaW9fcmVxdWVzdCwgYW5kIHNpbmNlIHRoZSBwaW5jdHJsIGRyaXZlciBoYXNuJ3QgeWV0IGJlZW4gcmVnaXN0ZXJlZCB0aGlzIHJlc3VsdHMgaW4gYW4gLUVQUk9CRV9ERUZFUiBmcm9tIHdoaWNoIGl0IGNhbiBuZXZlciByZWNvdmVyLiBDaGFuZ2UgdGhlIGluaXRpYWxpc2F0aW9uIHNlcXVlbmNlIHRvIHJlZ2lzdGVyIHRoZSBwaW5jdHJsIGRyaXZlciBmaXJzdC4gVGhpcyBhbHNvIHNvbHZlcyBhIHNpbWlsYXIgcHJvYmxlbSB3aXRoIHRoZSBncGlvLXJhbmdlcyBwcm9wZXJ0eSwgd2hpY2ggaXMgcmVxdWlyZWQgaW4gb3JkZXIgZm9yIHJlbGVhc2VkIHBpbnMgdG8gYmUgcmV0dXJuZWQgdG8gaW5wdXRzLiBGaXhlczogNzMzNDVhMThkNDY0YiAoInBpbmN0cmw6IGJjbTI4MzU6IFBhc3MgaXJxY2hpcCB3aGVuIGFkZGluZyBncGlvY2hpcCIpIFNpZ25lZC1vZmYtYnk6IFBoaWwgRWx3ZWxsIDxwaGlsPiBSZXZpZXdlZC1ieTogRmxvcmlhbiBGYWluZWxsaSA8Zi5mYWluZWxsaT4gTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8yMDIxMTIwNjA5MjIzNy40MTA1ODk1LTItcGhpbEByYXNwYmVycnlwaS5jb20gU2lnbmVkLW9mZi1ieTogTGludXMgV2FsbGVpaiA8bGludXMud2FsbGVpaj4gU2lnbmVkLW9mZi1ieTogU2FzaGEgTGV2aW4gPHNhc2hhbD4gY29tbWl0IDY3NmM1NzI0MzllNThiN2VlNmI3Y2EzZjFlNTU5NTM4MjkyMTA0NWMgQXV0aG9yOiBBbmRyZWEgUmlnaGkgPGFuZHJlYS5yaWdoaT4gRGF0ZTogTW9uIE5vdiAyOSAwMDowODoxMyAyMDIxIC0wODAwIElucHV0OiBlbGFudGVjaCAtIGZpeCBzdGFjayBvdXQgb2YgYm91bmQgYWNjZXNzIGluIGVsYW50ZWNoX2NoYW5nZV9yZXBvcnRfaWQoKSBbIFVwc3RyZWFtIGNvbW1pdCAxZDcyZDlmOTYwY2NmMTA1MmEwNjMwYTY4YzNkMzU4NzkxZGJkYWFhIF0gVGhlIGFycmF5IHBhcmFtW10gaW4gZWxhbnRlY2hfY2hhbmdlX3JlcG9ydF9pZCgpIG11c3QgYmUgYXQgbGVhc3QgMyBieXRlcywgYmVjYXVzZSBlbGFudGVjaF9yZWFkX3JlZ19wYXJhbXMoKSBpcyBjYWxsaW5nIHBzMl9jb21tYW5kKCkgd2l0aCBQU01PVVNFX0NNRF9HRVRJTkZPLCB0aGF0IGlzIGdvaW5nIHRvIGFjY2VzcyAzIGJ5dGVzIGZyb20gcGFyYW1bXSwgYnV0IGl0J3MgZGVmaW5lZCBpbiB0aGUgc3RhY2sgYXMgYW4gYXJyYXkgb2YgMiBieXRlcywgdGhlcmVmb3JlIHdlIGhhdmUgYSBwb3RlbnRpYWwgc3RhY2sgb3V0LW9mLWJvdW5kcyBhY2Nlc3MgaGVyZSwgYWxzbyBjb25maXJtZWQgYnkgS0FTQU46IFsgNi41MTIzNzRdIEJVRzogS0FTQU46IHN0YWNrLW91dC1vZi1ib3VuZHMgaW4gX19wczJfY29tbWFuZCsweDM3Mi8weDdlMCBbIDYuNTEyMzk3XSBSZWFkIG9mIHNpemUgMSBhdCBhZGRyIGZmZmY4ODgxMDI0ZDc3YzIgYnkgdGFzayBrd29ya2VyLzI6MS8xMTggWyA2LjUxMjQxNl0gQ1BVOiAyIFBJRDogMTE4IENvbW06IGt3b3JrZXIvMjoxIE5vdCB0YWludGVkIDUuMTMuMC0yMi1nZW5lcmljICMyMithcmlnaGkyMDIxMTExMCBbIDYuNTEyNDI4XSBIYXJkd2FyZSBuYW1lOiBMRU5PVk8gMjBUODAwMFFHRS8yMFQ4MDAwUUdFLCBCSU9TIFIxQUVUMzJXICgxLjA4ICkgMDgvMTQvMjAyMCBbIDYuNTEyNDM2XSBXb3JrcXVldWU6IGV2ZW50c19sb25nIHNlcmlvX2hhbmRsZV9ldmVudCBbIDYuNTEyNDUzXSBDYWxsIFRyYWNlOiBbIDYuNTEyNDYyXSBzaG93X3N0YWNrKzB4NTIvMHg1OCBbIDYuNTEyNDc0XSBkdW1wX3N0YWNrKzB4YTEvMHhkMyBbIDYuNTEyNDg3XSBwcmludF9hZGRyZXNzX2Rlc2NyaXB0aW9uLmNvbnN0cHJvcC4wKzB4MWQvMHgxNDAgWyA2LjUxMjUwMl0gPyBfX3BzMl9jb21tYW5kKzB4MzcyLzB4N2UwIFsgNi41MTI1MTZdIF9fa2FzYW5fcmVwb3J0LmNvbGQrMHg3ZC8weDExMiBbIDYuNTEyNTI3XSA/IF9yYXdfd3JpdGVfbG9ja19pcnErMHgyMC8weGQwIFsgNi41MTI1MzldID8gX19wczJfY29tbWFuZCsweDM3Mi8weDdlMCBbIDYuNTEyNTUyXSBrYXNhbl9yZXBvcnQrMHgzYy8weDUwIFsgNi41MTI1NjRdIF9fYXNhbl9sb2FkMSsweDZhLzB4NzAgWyA2LjUxMjU3NV0gX19wczJfY29tbWFuZCsweDM3Mi8weDdlMCBbIDYuNTEyNTg5XSA/IHBzMl9kcmFpbisweDI0MC8weDI0MCBbIDYuNTEyNjAxXSA/IGRldl9wcmludGtfZW1pdCsweGEyLzB4ZDMgWyA2LjUxMjYxMl0gPyBkZXZfdnByaW50a19lbWl0KzB4YzUvMHhjNSBbIDYuNTEyNjIxXSA/IF9fa2FzYW5fY2hlY2tfd3JpdGUrMHgxNC8weDIwIFsgNi41MTI2MzRdID8gbXV0ZXhfbG9jaysweDhmLzB4ZTAgWyA2LjUxMjY0M10gPyBfX211dGV4X2xvY2tfc2xvd3BhdGgrMHgyMC8weDIwIFsgNi41MTI2NTVdIHBzMl9jb21tYW5kKzB4NTIvMHg5MCBbIDYuNTEyNjcwXSBlbGFudGVjaF9wczJfY29tbWFuZCsweDRmLzB4YzAgW3BzbW91c2VdIFsgNi41MTI3MzRdIGVsYW50ZWNoX2NoYW5nZV9yZXBvcnRfaWQrMHgxZTYvMHgyNTYgW3BzbW91c2VdIFsgNi41MTI3OTldID8gZWxhbnRlY2hfcmVwb3J0X3RyYWNrcG9pbnQuY29uc3Rwcm9wLjAuY29sZCsweGQvMHhkIFtwc21vdXNlXSBbIDYuNTEyODYzXSA/IHBzMl9jb21tYW5kKzB4N2YvMHg5MCBbIDYuNTEyODc3XSBlbGFudGVjaF9xdWVyeV9pbmZvLmNvbGQrMHg2YmQvMHg5ZWQgW3BzbW91c2VdIFsgNi41MTI5NDNdID8gZWxhbnRlY2hfc2V0dXBfcHMyKzB4NDYwLzB4NDYwIFtwc21vdXNlXSBbIDYuNTEzMDA1XSA/IHBzbW91c2VfcmVzZXQrMHg2OS8weGIwIFtwc21vdXNlXSBbIDYuNTEzMDY0XSA/IHBzbW91c2VfYXR0cl9zZXRfaGVscGVyKzB4MmEwLzB4MmEwIFtwc21vdXNlXSBbIDYuNTEzMTIyXSA/IHBoeXNfcG1kX2luaXQrMHgzMGUvMHg1MjEgWyA2LjUxMzEzN10gZWxhbnRlY2hfaW5pdCsweDhhLzB4MjAwIFtwc21vdXNlXSBbIDYuNTEzMjAwXSA/IGVsYW50ZWNoX2luaXRfcHMyKzB4ZjAvMHhmMCBbcHNtb3VzZV0gWyA2LjUxMzI0OV0gPyBlbGFudGVjaF9xdWVyeV9pbmZvKzB4NDQwLzB4NDQwIFtwc21vdXNlXSBbIDYuNTEzMjk2XSA/IHN5bmFwdGljc19zZW5kX2NtZCsweDYwLzB4NjAgW3BzbW91c2VdIFsgNi41MTMzNDJdID8gZWxhbnRlY2hfcXVlcnlfaW5mbysweDQ0MC8weDQ0MCBbcHNtb3VzZV0gWyA2LjUxMzM4OF0gPyBwc21vdXNlX3RyeV9wcm90b2NvbCsweDExZS8weDE3MCBbcHNtb3VzZV0gWyA2LjUxMzQzMl0gcHNtb3VzZV9leHRlbnNpb25zKzB4NjVkLzB4NmUwIFtwc21vdXNlXSBbIDYuNTEzNDc2XSA/IHBzbW91c2VfdHJ5X3Byb3RvY29sKzB4MTcwLzB4MTcwIFtwc21vdXNlXSBbIDYuNTEzNTE5XSA/IG11dGV4X3VubG9jaysweDIyLzB4NDAgWyA2LjUxMzUyNl0gPyBwczJfY29tbWFuZCsweDdmLzB4OTAgWyA2LjUxMzUzNl0gPyBwc21vdXNlX3Byb2JlKzB4YTMvMHhmMCBbcHNtb3VzZV0gWyA2LjUxMzU4MF0gcHNtb3VzZV9zd2l0Y2hfcHJvdG9jb2wrMHgyN2QvMHgyZTAgW3BzbW91c2VdIFsgNi41MTM2MjRdIHBzbW91c2VfY29ubmVjdCsweDI3Mi8weDUzMCBbcHNtb3VzZV0gWyA2LjUxMzY2OV0gc2VyaW9fZHJpdmVyX3Byb2JlKzB4NTUvMHg3MCBbIDYuNTEzNjc5XSByZWFsbHlfcHJvYmUrMHgxOTAvMHg3MjAgWyA2LjUxMzY4OV0gZHJpdmVyX3Byb2JlX2RldmljZSsweDE2MC8weDFmMCBbIDYuNTEzNjk3XSBkZXZpY2VfZHJpdmVyX2F0dGFjaCsweDExOS8weDEzMCBbIDYuNTEzNzA1XSA/IGRldmljZV9kcml2ZXJfYXR0YWNoKzB4MTMwLzB4MTMwIFsgNi41MTM3MTNdIF9fZHJpdmVyX2F0dGFjaCsweGU3LzB4MWEwIFsgNi41MTM3MjBdID8gZGV2aWNlX2RyaXZlcl9hdHRhY2grMHgxMzAvMHgxMzAgWyA2LjUxMzcyOF0gYnVzX2Zvcl9lYWNoX2RldisweGZiLzB4MTUwIFsgNi41MTM3MzhdID8gc3Vic3lzX2Rldl9pdGVyX2V4aXQrMHgxMC8weDEwIFsgNi41MTM3NDhdID8gX3Jhd193cml0ZV91bmxvY2tfYmgrMHgzMC8weDMwIFsgNi41MTM3NTddIGRyaXZlcl9hdHRhY2grMHgyZC8weDQwIFsgNi41MTM3NjRdIHNlcmlvX2hhbmRsZV9ldmVudCsweDE5OS8weDNkMCBbIDYuNTEzNzc1XSBwcm9jZXNzX29uZV93b3JrKzB4NDcxLzB4NzQwIFsgNi41MTM3ODVdIHdvcmtlcl90aHJlYWQrMHgyZDIvMHg3OTAgWyA2LjUxMzc5NF0gPyBwcm9jZXNzX29uZV93b3JrKzB4NzQwLzB4NzQwIFsgNi41MTM4MDJdIGt0aHJlYWQrMHgxYjQvMHgxZTAgWyA2LjUxMzgwOV0gPyBzZXRfa3RocmVhZF9zdHJ1Y3QrMHg4MC8weDgwIFsgNi41MTM4MTZdIHJldF9mcm9tX2ZvcmsrMHgyMi8weDMwIFsgNi41MTM4MzJdIFRoZSBidWdneSBhZGRyZXNzIGJlbG9uZ3MgdG8gdGhlIHBhZ2U6IFsgNi41MTM4MzhdIHBhZ2U6MDAwMDAwMDBiYzM1ZTE4OSByZWZjb3VudDowIG1hcGNvdW50OjAgbWFwcGluZzowMDAwMDAwMDAwMDAwMDAwIGluZGV4OjB4MCBwZm46MHgxMDI0ZDcgWyA2LjUxMzg0N10gZmxhZ3M6IDB4MTdmZmZmYzAwMDAwMDAobm9kZT0wfHpvbmU9MnxsYXN0Y3B1cGlkPTB4MWZmZmZmKSBbIDYuNTEzODYwXSByYXc6IDAwMTdmZmZmYzAwMDAwMDAgZGVhZDAwMDAwMDAwMDEwMCBkZWFkMDAwMDAwMDAwMTIyIDAwMDAwMDAwMDAwMDAwMDAgWyA2LjUxMzg2N10gcmF3OiAwMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDBmZmZmZmZmZiAwMDAwMDAwMDAwMDAwMDAwIFsgNi41MTM4NzJdIHBhZ2UgZHVtcGVkIGJlY2F1c2U6IGthc2FuOiBiYWQgYWNjZXNzIGRldGVjdGVkIFsgNi41MTM4NzldIGFkZHIgZmZmZjg4ODEwMjRkNzdjMiBpcyBsb2NhdGVkIGluIHN0YWNrIG9mIHRhc2sga3dvcmtlci8yOjEvMTE4IGF0IG9mZnNldCAzNCBpbiBmcmFtZTogWyA2LjUxMzg4N10gZWxhbnRlY2hfY2hhbmdlX3JlcG9ydF9pZCsweDAvMHgyNTYgW3BzbW91c2VdIFsgNi41MTM5NDFdIHRoaXMgZnJhbWUgaGFzIDEgb2JqZWN0OiBbIDYuNTEzOTQ3XSBbMzIsIDM0KSAncGFyYW0nIFsgNi41MTM5NTZdIE1lbW9yeSBzdGF0ZSBhcm91bmQgdGhlIGJ1Z2d5IGFkZHJlc3M6IFsgNi41MTM5NjJdIGZmZmY4ODgxMDI0ZDc2ODA6IGYyIGYyIGYyIGYyIGYyIDAwIDAwIGYzIGYzIDAwIDAwIDAwIDAwIDAwIDAwIDAwIFsgNi41MTM5NjldIGZmZmY4ODgxMDI0ZDc3MDA6IDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIFsgNi41MTM5NzZdICZndDtmZmZmODg4MTAyNGQ3NzgwOiAwMCAwMCAwMCAwMCBmMSBmMSBmMSBmMSAwMiBmMyBmMyBmMyAwMCAwMCAwMCAwMCBbIDYuNTEzOTgyXSBeIFsgNi41MTM5ODhdIGZmZmY4ODgxMDI0ZDc4MDA6IDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIFsgNi41MTM5OTVdIGZmZmY4ODgxMDI0ZDc4ODA6IDAwIGYxIGYxIGYxIGYxIDAzIGYyIDAzIGYyIDAzIGYzIGYzIGYzIDAwIDAwIDAwIFsgNi41MTQwMDBdID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSBEZWZpbmUgcGFyYW1bXSBpbiBlbGFudGVjaF9jaGFuZ2VfcmVwb3J0X2lkKCkgYXMgYW4gYXJyYXkgb2YgMyBieXRlcyB0byBwcmV2ZW50IHRoZSBvdXQtb2YtYm91bmRzIGFjY2VzcyBpbiB0aGUgc3RhY2suIEZpeGVzOiBlNGM5MDYyNzE3ZmUgKCJJbnB1dDogZWxhbnRlY2ggLSBmaXggcHJvdG9jb2wgZXJyb3JzIGZvciBzb21lIHRyYWNrcG9pbnRzIGluIFNNQnVzIG1vZGUiKSBCdWdMaW5rOiBodHRwczovL2J1Z3MubGF1bmNocGFkLm5ldC9idWdzLzE5NDU1OTAgU2lnbmVkLW9mZi1ieTogQW5kcmVhIFJpZ2hpIDxhbmRyZWEucmlnaGk+IFJldmlld2VkLWJ5OiBXb2xmcmFtIFNhbmcgPHdzYT4gTGluazogaHR0cHM6Ly9sb3JlLmtlcm5lbC5vcmcvci8yMDIxMTExNjA5NTU1OS4yNDM5NS0xLWFuZHJlYS5yaWdoaUBjYW5vbmljYWwuY29tIFNpZ25lZC1vZmYtYnk6IERtaXRyeSBUb3Jva2hvdiA8ZG1pdHJ5LnRvcm9raG92PiBTaWduZWQtb2ZmLWJ5OiBTYXNoYSBMZXZpbiA8L2RtaXRyeS50b3Jva2hvdj48L3dzYT48L2FuZHJlYS5yaWdoaT48L2FuZHJlYS5yaWdoaT48L3Nhc2hhbD48L2xpbnVzLndhbGxlaWo+PC9mLmZhaW5lbGxpPjwvcGhpbD48L3BoaWw+PC9zYXNoYWw+PC9saW51eD48L2xpbnV4Pjwvc2FzaGFsPjwvbGludXg+PC9kYXZpZC53aWxzb24+PC9kYXZpZC53aWxzb24+PC9saW51eD48L3Nhc2hhbD48L2xpbnV4PjwvZGF2aWQud2lsc29uPjwvbGludXg+PC9zYXNoYWw+PC9saW51eD48L2tyZWxsYW4+PC9saW51eD48L2dyZWdraD48L3Rpd2FpPjwvc3RhYmxlPjwveGtlcm5lbC53YW5nPjwveGtlcm5lbC53YW5nPjwvZ3JlZ2toPjwvdGl3YWk+PC9zdGFibGU+PC9jb2xpbi5pLmtpbmc+PC9jb2xpbi5raW5nPjwvZ3JlZ2toPjwvdGl3YWk+PC9zdGFibGU+PC9icmFkbGV5LnNjb3R0PjwvYnJhZGxleS5zY290dD48L2dyZWdraD48L3Rpd2FpPjwvc3RhYmxlPjwvYnNjb3R0PjwvYnNjb3R0PjwvZ3JlZ2toPjwvdGl3YWk+PC9zdGFibGU+PC93c2U+PC93c2U+PC9ncmVna2g+PC9icm9vbmllPjwvbWFydGluLmJsdW1lbnN0aW5nbD48L2picnVuZXQ+PC9nZXJhbGRvZ2FicmllbD48L2NocmlzdGlhbnNoZXdpdHQ+PC9nZXJhbGRvZ2FicmllbD48L2NocmlzdGlhbnNoZXdpdHQ+PC9tYXJ0aW4uYmx1bWVuc3RpbmdsPjwvZ3JlZ2toPjwvZG1pdHJ5LnRvcm9raG92Pjwvam9zZS5leHBvc2l0bzg5Pjwvam9zZS5leHBvc2l0bzg5PjwvZ3JlZ2toPjwvY21pbnlhcmQ+PC9jbWlueWFyZD48L2Nhc2NhcmRvPjwvY2FzY2FyZG8+PC9ncmVna2g+PC9jbWlueWFyZD48L3lrYXVrYWI+PC90aXdhaT48L3lrYXVrYWI+PC9ncmVna2g+PC9jbWlueWFyZD48L2lvYW5uYS1tYXJpYS5hbGlmaWVyYWtpPjwvY21pbnlhcmQ+PC9jYXNjYXJkbz48L2Nhc2NhcmRvPjwvZ3JlZ2toPjwvZGF2ZS5hbmdsaW4+PC9kYXZlLmFuZ2xpbj48L2dyZWdraD48L2RhdmUuYW5nbGluPjwvZGF2ZS5hbmdsaW4+PC9ncmVna2g+PC9qZW5zLndpa2xhbmRlcj48L3BhdHJpay5sYW50ej48L3N1bWl0Lmdhcmc+PC9sYXJwZXI+PC9ncmVna2g+PC9qZW5zLndpa2xhbmRlcj48L2dyZWdraD48L2JwPjwvZGF2ZS5oYW5zZW4+PC9hbmRyZXcuY29vcGVyMz48L2FuZHJldy5jb29wZXIzPjwvZ3JlZ2toPjwvaGRlZ29lZGU+PC9ncmVna2g+PC9qb2hhbj48L2pvaGFuPjwvZ3JlZ2toPjwvcGJvbnppbmk+PC9tbGV2aXRzaz48L3NlYW5qYz48L2xvbmdwZW5nMj48L3NlYW5qYz48L2dyZWdraD48L2xpbnVzLndhbGxlaWo+PC9mYWJpZW4uZGVzc2VubmU+PC9jaGYuZnJpdHo+PC9mYWJpZW4uZGVzc2VubmU+PC9ncmVna2g+PC9icmdsPjwvbm9yYWxmPjwvZGFuaWVsLmJhbHV0YT48L3N0YWJsZT48L25vcmFsZj48L2dyZWdraD48L3VsZi5oYW5zc29uPjwvYWRyaWFuLmh1bnRlcj48L3BzaGV0ZT48L3BzaGV0ZT48L2dyZWdraD48L3VsZi5oYW5zc29uPjwvbWFydGluLmJsdW1lbnN0aW5nbD48L21hcnRpbi5ibHVtZW5zdGluZ2w+PC9ncmVna2g+PC91bGYuaGFuc3Nvbj48L2Fkcmlhbi5odW50ZXI+PC9hbGNvb3Blcng+PC91bGYuaGFuc3Nvbj48L2dyZWdraD48L3VsZi5oYW5zc29uPjwvbGludXMud2FsbGVpaj48L3lhbm4uZ2F1dGllcj48L2NocmlzdG9waGUua2VyZWxsbz48L3lhbm4uZ2F1dGllcj48L2dyZWdraD48L3Jtaz48L2FyZGI+PC9zdGFibGU+PC9hcmRiPjwvZ3JlZ2toPjwvZGF2ZW0+PC9qb2hhbm5lcy5iZXJnPjwvam9oYW5uZXMuYmVyZz48L2dyZWdraD48L3RvcnZhbGRzPjwvYWtwbT48L3N0YWJsZT48L25hb3lhLmhvcmlndWNoaT48L29zYWx2YWRvcj48L2h1bGtjaT48L2xpdXNoaXhpbjI+PC9saXVzaGl4aW4yPjwvZ3JlZ2toPjwvamVucy53aWtsYW5kZXI+PC90eWhpY2tzPjwvc3VtaXQuZ2FyZz48L3BhdHJpay5sYW50ej48L3N1bWl0Lmdhcmc+PC9ncmVna2g+PC9qYWVnZXVrPjwvY2hhbz48L3dlbnFpbmdsaXUwMTIwPjwvY2hhbz48L2dyZWdraD48L2lkcnlvbW92PjwvamxheXRvbj48L2NocmlzdGlhbi5icmF1bmVyPjwvY2hyaXN0aWFuLmJyYXVuZXI+PC9ncmVna2g+PC9wb3N0ZXVjYT48L3Bvc3RldWNhPjwvZ3JlZ2toPjwvcGJvbnppbmk+PC9tbGV2aXRzaz48L3NlYW5qYz48L3NlYW5qYz48L2dyZWdraD48L3RvcnZhbGRzPjwvYWtwbT48L3N0YWJsZT48L2FhcmNhbmdlPjwvcmllbnRqZXM+PC9tZ29ybWFuPjwvbWhvY2tvPjwvYXJibj48L251bWFpZi5oPjwvc3RkaW8uaD48L3N0ZGxpYi5oPjwvYXNzZXJ0Lmg+PC9mY250bC5oPjwvc3lzPjwvc3lzPjwvdW5pc3RkLmg+PC9hcmJuPjwvZ3JlZ2toPjwvZG1pdHJ5LnRvcm9raG92Pjwvam9obm55LmNodWFuZy5lbWM+PC9qb2hubnkuY2h1YW5nLmVtYz48L2dyZWdraD48L2RtaXRyeS50b3Jva2hvdj48L2hkZWdvZWRlPjwvaGRlZ29lZGU+PC9ncmVna2g+PC9icm9vbmllPjwvcG92aWs+PC9wb3Zpaz48L2dyZWdraD48L2Jyb29uaWU+PC9kZXJlay5mYW5nPjwvZGVyZWsuZmFuZz48L2dyZWdraD48L2xpbnVzLndhbGxlaWo+PC93ZW5zdD48L3poaXlvbmcudGFvPjwvZ3VvZG9uZy5saXU+PC9ndW9kb25nLmxpdT48L2dyZWdraD48L2xpbnV4PjwvbGludXg+PC9ncmVna2g+PC9saW51eD48L2xpbnV4PjwvZ3JlZ2toPjwvZGF2ZW0+PC9saW5tYT48L25hZ2k+PC9saW5tYT48L2dyZWdraD48L2RhdmVtPjwvbGlubWE+PC9saW5tYT48L2dyZWdraD48L2RhdmVtPjwvbGlubWE+PC9saW5tYT48L2dyZWdraD48L2RhdmVtPjwvcmVtaT48L3JlbWk+PC9ncmVna2g+PC9odWxrcm9ib3Q+PC9za2hhbj48L2xpbnV4Pjwvc3VkaXAubXVraGVyamVlPjwvbGtmdD48L2YuZmFpbmVsbGk+PC9ncmVna2g+PC9wPjwvYm9keT4='</script>

      </head>
        <body class="valid" valid="valid" title="valid: True, node: 1, tag: body, level: 1" node_number="1"><p class="valid" valid="valid" title="valid: True, node: 2, tag: p, level: 2" node_number="2">commit eb967e323f7fb073c51401070f7d2cb381a003f7 Author: Greg Kroah-Hartman <gregkh class="valid" valid="valid" title="valid: True, node: 3, tag: gregkh, level: 3" node_number="3"> Date: Wed Dec 29 12:26:08 2021 +0100 Linux 5.10.89 Link: https://lore.kernel.org/r/20211227151324.694661623@linuxfoundation.org Tested-by: Florian Fainelli <f.fainelli class="valid" valid="valid" title="valid: True, node: 4, tag: f.fainelli, level: 4" node_number="4"> Tested-by: Linux Kernel Functional Testing <lkft class="valid" valid="valid" title="valid: True, node: 5, tag: lkft, level: 5" node_number="5"> Tested-by: Sudip Mukherjee <sudip.mukherjee class="valid" valid="valid" title="valid: True, node: 6, tag: sudip.mukherjee, level: 6" node_number="6"> Tested-by: Guenter Roeck <linux class="valid" valid="valid" title="valid: True, node: 7, tag: linux, level: 7" node_number="7"> Tested-by: Shuah Khan <skhan class="valid" valid="valid" title="valid: True, node: 8, tag: skhan, level: 8" node_number="8"> Tested-by: Hulk Robot <hulkrobot class="valid" valid="valid" title="valid: True, node: 9, tag: hulkrobot, level: 9" node_number="9"> Signed-off-by: Greg Kroah-Hartman <gregkh class="valid" valid="valid" title="valid: True, node: 10, tag: gregkh, level: 10" node_number="10"> commit 52ad5da8e316fa11e3a50b3f089aa63e4089bf52 Author: R&#233;mi Denis-Courmont <remi class="valid" valid="valid" title="valid: True, node: 11, tag: remi, level: 11" node_number="11"> Date: Sun Dec 19 19:03:39 2021 +0200 phonet/pep: refuse to enable an unbound pipe commit 75a2f31520095600f650597c0ac41f48b5ba0068 upstream. This ioctl() implicitly assumed that the socket was already bound to a valid local socket name, i.e. Phonet object. If the socket was not bound, two separate problems would occur: 1) We'd send an pipe enablement request with an invalid source object. 2) Later socket calls could BUG on the socket unexpectedly being connected yet not bound to a valid object. Reported-by: syzbot+2dc91e7fc3dea88b1e8a@syzkaller.appspotmail.com Signed-off-by: R&#233;mi Denis-Courmont <remi class="valid" valid="valid" title="valid: True, node: 12, tag: remi, level: 12" node_number="12"> Signed-off-by: David S. Miller <davem class="valid" valid="valid" title="valid: True, node: 13, tag: davem, level: 13" node_number="13"> Signed-off-by: Greg Kroah-Hartman <gregkh class="valid" valid="valid" title="valid: True, node: 14, tag: gregkh, level: 14" node_number="14"> commit 7dd52af1eb5798f590d9d9e1c56ed8f5744ee0ca Author: Lin Ma <linma title="valid: False, node: 15, tag: linma, level: 15" node_number="15"> Date: Fri Dec 17 10:13:56 2021 +0800 hamradio: improve the incomplete fix to avoid NPD commit b2f37aead1b82a770c48b5d583f35ec22aabb61e upstream. The previous commit 3e0588c291d6 ("hamradio: defer ax25 kfree after unregister_netdev") reorder the kfree operations and unregister_netdev operation to prevent UAF. This commit improves the previous one by also deferring the nullify of the ax-&gt;tty pointer. Otherwise, a NULL pointer dereference bug occurs. Partial of the stack trace is shown below. BUG: kernel NULL pointer dereference, address: 0000000000000538 RIP: 0010:ax_xmit+0x1f9/0x400 ... Call Trace: dev_hard_start_xmit+0xec/0x320 sch_direct_xmit+0xea/0x240 __qdisc_run+0x166/0x5c0 __dev_queue_xmit+0x2c7/0xaf0 ax25_std_establish_data_link+0x59/0x60 ax25_connect+0x3a0/0x500 ? security_socket_connect+0x2b/0x40 __sys_connect+0x96/0xc0 ? __hrtimer_init+0xc0/0xc0 ? common_nsleep+0x2e/0x50 ? switch_fpu_return+0x139/0x1a0 __x64_sys_connect+0x11/0x20 do_syscall_64+0x33/0x40 entry_SYSCALL_64_after_hwframe+0x44/0xa9 The crash point is shown as below static void ax_encaps(...) { ... set_bit(TTY_DO_WRITE_WAKEUP, ax-&gt;tty-&gt;flags); // ax-&gt;tty = NULL! ... } By placing the nullify action after the unregister_netdev, the ax-&gt;tty pointer won't be assigned as NULL net_device framework layer is well synchronized. Signed-off-by: Lin Ma <linma title="valid: False, node: 16, tag: linma, level: 16" node_number="16"> Signed-off-by: David S. Miller <davem title="valid: False, node: 17, tag: davem, level: 17" node_number="17"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 18, tag: gregkh, level: 18" node_number="18"> commit 450121075a6a6f1d50f97225d3396315309d61a1 Author: Lin Ma <linma title="valid: False, node: 19, tag: linma, level: 19" node_number="19"> Date: Mon Nov 8 18:37:21 2021 +0800 hamradio: defer ax25 kfree after unregister_netdev commit 3e0588c291d6ce225f2b891753ca41d45ba42469 upstream. There is a possible race condition (use-after-free) like below (USE) | (FREE) ax25_sendmsg | ax25_queue_xmit | dev_queue_xmit | __dev_queue_xmit | __dev_xmit_skb | sch_direct_xmit | ... xmit_one | netdev_start_xmit | tty_ldisc_kill __netdev_start_xmit | mkiss_close ax_xmit | kfree ax_encaps | | Even though there are two synchronization primitives before the kfree: 1. wait_for_completion(ax-&gt;dead). This can prevent the race with routines from mkiss_ioctl. However, it cannot stop the routine coming from upper layer, i.e., the ax25_sendmsg. 2. netif_stop_queue(ax-&gt;dev). It seems that this line of code aims to halt the transmit queue but it fails to stop the routine that already being xmit. This patch reorder the kfree after the unregister_netdev to avoid the possible UAF as the unregister_netdev() is well synchronized and won't return if there is a running routine. Signed-off-by: Lin Ma <linma title="valid: False, node: 20, tag: linma, level: 20" node_number="20"> Signed-off-by: David S. Miller <davem title="valid: False, node: 21, tag: davem, level: 21" node_number="21"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 22, tag: gregkh, level: 22" node_number="22"> commit 8e34d07dd4d9f7811d8ae35adee24e78a4576844 Author: Lin Ma <linma title="valid: False, node: 23, tag: linma, level: 23" node_number="23"> Date: Fri Dec 17 10:29:41 2021 +0800 ax25: NPD bug when detaching AX25 device commit 1ade48d0c27d5da1ccf4b583d8c5fc8b534a3ac8 upstream. The existing cleanup routine implementation is not well synchronized with the syscall routine. When a device is detaching, below race could occur. static int ax25_sendmsg(...) { ... lock_sock() ax25 = sk_to_ax25(sk); if (ax25-&gt;ax25_dev == NULL) // CHECK ... ax25_queue_xmit(skb, ax25-&gt;ax25_dev-&gt;dev); // USE ... } static void ax25_kill_by_device(...) { ... if (s-&gt;ax25_dev == ax25_dev) { s-&gt;ax25_dev = NULL; ... } Other syscall functions like ax25_getsockopt, ax25_getname, ax25_info_show also suffer from similar races. To fix them, this patch introduce lock_sock() into ax25_kill_by_device in order to guarantee that the nullify action in cleanup routine cannot proceed when another socket request is pending. Signed-off-by: Hanjie Wu <nagi title="valid: False, node: 24, tag: nagi, level: 24" node_number="24"> Signed-off-by: Lin Ma <linma title="valid: False, node: 25, tag: linma, level: 25" node_number="25"> Signed-off-by: David S. Miller <davem title="valid: False, node: 26, tag: davem, level: 26" node_number="26"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 27, tag: gregkh, level: 27" node_number="27"> commit 50f78486f90b91484001bfccc652d66fc308255a Author: Guenter Roeck <linux title="valid: False, node: 28, tag: linux, level: 28" node_number="28"> Date: Fri Dec 3 13:42:22 2021 -0800 hwmon: (lm90) Do not report 'busy' status bit as alarm commit cdc5287acad9ede121924a9c9313544b80d15842 upstream. Bit 7 of the status register indicates that the chip is busy doing a conversion. It does not indicate an alarm status. Stop reporting it as alarm status bit. Signed-off-by: Guenter Roeck <linux title="valid: False, node: 29, tag: linux, level: 29" node_number="29"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 30, tag: gregkh, level: 30" node_number="30"> commit ec1d222d37eaf6b2d2dbdcf2c4eb7903fd74fc1e Author: Guenter Roeck <linux title="valid: False, node: 31, tag: linux, level: 31" node_number="31"> Date: Fri Nov 26 22:43:39 2021 -0800 hwmom: (lm90) Fix citical alarm status for MAX6680/MAX6681 commit da7dc0568491104c7acb632e9d41ddce9aaabbb1 upstream. Tests with a real chip and a closer look into the datasheet reveals that the local and remote critical alarm status bits are swapped for MAX6680/MAX6681. Signed-off-by: Guenter Roeck <linux title="valid: False, node: 32, tag: linux, level: 32" node_number="32"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 33, tag: gregkh, level: 33" node_number="33"> commit 441d3873664d170982922c5d2fc01fa89d9439ed Author: Guodong Liu <guodong.liu title="valid: False, node: 34, tag: guodong.liu, level: 34" node_number="34"> Date: Wed Nov 10 15:19:00 2021 +0800 pinctrl: mediatek: fix global-out-of-bounds issue commit 2d5446da5acecf9c67db1c9d55ae2c3e5de01f8d upstream. When eint virtual eint number is greater than gpio number, it maybe produce 'desc[eint_n]' size globle-out-of-bounds issue. Signed-off-by: Guodong Liu <guodong.liu title="valid: False, node: 35, tag: guodong.liu, level: 35" node_number="35"> Signed-off-by: Zhiyong Tao <zhiyong.tao title="valid: False, node: 36, tag: zhiyong.tao, level: 36" node_number="36"> Reviewed-by: Chen-Yu Tsai <wenst title="valid: False, node: 37, tag: wenst, level: 37" node_number="37"> Link: https://lore.kernel.org/r/20211110071900.4490-2-zhiyong.tao@mediatek.com Signed-off-by: Linus Walleij <linus.walleij title="valid: False, node: 38, tag: linus.walleij, level: 38" node_number="38"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 39, tag: gregkh, level: 39" node_number="39"> commit 9c75a9657bdc643e78719ecb139ebff4d5aefe53 Author: Derek Fang <derek.fang title="valid: False, node: 40, tag: derek.fang, level: 40" node_number="40"> Date: Tue Dec 14 18:50:33 2021 +0800 ASoC: rt5682: fix the wrong jack type detected commit 8deb34a90f06374fd26f722c2a79e15160f66be7 upstream. Some powers were changed during the jack insert detection and clk's enable/disable in CCF. If in parallel, the influence has a chance to detect the wrong jack type, so add a lock. Signed-off-by: Derek Fang <derek.fang title="valid: False, node: 41, tag: derek.fang, level: 41" node_number="41"> Link: https://lore.kernel.org/r/20211214105033.471-1-derek.fang@realtek.com Signed-off-by: Mark Brown Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 42, tag: gregkh, level: 42" node_number="42"> commit 94caab5af19a295cbec1d7fa6e8b7310f058317f Author: Martin Povi&#353;er <povik title="valid: False, node: 43, tag: povik, level: 43" node_number="43"> Date: Mon Dec 6 22:45:43 2021 +0000 ASoC: tas2770: Fix setting of high sample rates commit 80d5be1a057e05f01d66e986cfd34d71845e5190 upstream. Although the codec advertises support for 176.4 and 192 ksps, without this fix setting those sample rates fails with EINVAL at hw_params time. Signed-off-by: Martin Povi&#353;er <povik title="valid: False, node: 44, tag: povik, level: 44" node_number="44"> Link: https://lore.kernel.org/r/20211206224529.74656-1-povik@protonmail.com Signed-off-by: Mark Brown Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 45, tag: gregkh, level: 45" node_number="45"> commit c7282790c782f5216c50b6b83b815f03c48e73ad Author: Hans de Goede <hdegoede title="valid: False, node: 46, tag: hdegoede, level: 46" node_number="46"> Date: Mon Dec 6 23:29:27 2021 -0800 Input: goodix - add id-&gt;model mapping for the "9111" model commit 81e818869be522bc8fa6f7df1b92d7e76537926c upstream. Add d-&gt;model mapping for the "9111" model, this fixes uses using a wrong config_len of 240 bytes while the "9111" model uses only 186 bytes of config. Signed-off-by: Hans de Goede <hdegoede title="valid: False, node: 47, tag: hdegoede, level: 47" node_number="47"> Link: https://lore.kernel.org/r/20211206164747.197309-2-hdegoede@redhat.com Signed-off-by: Dmitry Torokhov <dmitry.torokhov title="valid: False, node: 48, tag: dmitry.torokhov, level: 48" node_number="48"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 49, tag: gregkh, level: 49" node_number="49"> commit 3bb3bf50d69f7fab57c5af293c745b586945f70d Author: Johnny Chuang <johnny.chuang.emc title="valid: False, node: 50, tag: johnny.chuang.emc, level: 50" node_number="50"> Date: Mon Dec 20 00:28:45 2021 -0800 Input: elants_i2c - do not check Remark ID on eKTH3900/eKTH5312 commit 4ebfee2bbc1a9c343dd50565ba5ae249fac32267 upstream. The eKTH3900/eKTH5312 series do not support the firmware update rules of Remark ID. Exclude these two series from checking it when updating the firmware in touch controllers. Signed-off-by: Johnny Chuang <johnny.chuang.emc title="valid: False, node: 51, tag: johnny.chuang.emc, level: 51" node_number="51"> Link: https://lore.kernel.org/r/1639619603-20616-1-git-send-email-johnny.chuang.emc@gmail.com Signed-off-by: Dmitry Torokhov <dmitry.torokhov title="valid: False, node: 52, tag: dmitry.torokhov, level: 52" node_number="52"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 53, tag: gregkh, level: 53" node_number="53"> commit ee6f34215c5dfa2257298cc362cd79e14af5a25a Author: Andrey Ryabinin <arbn title="valid: False, node: 54, tag: arbn, level: 54" node_number="54"> Date: Fri Dec 24 21:12:35 2021 -0800 mm: mempolicy: fix THP allocations escaping mempolicy restrictions commit 338635340669d5b317c7e8dcf4fff4a0f3651d87 upstream. alloc_pages_vma() may try to allocate THP page on the local NUMA node first: page = __alloc_pages_node(hpage_node, gfp | __GFP_THISNODE | __GFP_NORETRY, order); And if the allocation fails it retries allowing remote memory: if (!page (gfp __GFP_DIRECT_RECLAIM)) page = __alloc_pages_node(hpage_node, gfp, order); However, this retry allocation completely ignores memory policy nodemask allowing allocation to escape restrictions. The first appearance of this bug seems to be the commit ac5b2c18911f ("mm: thp: relax __GFP_THISNODE for MADV_HUGEPAGE mappings"). The bug disappeared later in the commit 89c83fb539f9 ("mm, thp: consolidate THP gfp handling into alloc_hugepage_direct_gfpmask") and reappeared again in slightly different form in the commit 76e654cc91bb ("mm, page_alloc: allow hugepage fallback to remote nodes when madvised") Fix this by passing correct nodemask to the __alloc_pages() call. The demonstration/reproducer of the problem: $ mount -oremount,size=4G,huge=always /dev/shm/ $ echo always &gt; /sys/kernel/mm/transparent_hugepage/defrag $ cat mbind_thp.c #include <unistd.h title="valid: False, node: 55, tag: unistd.h, level: 55" node_number="55"> #include <sys title="valid: False, node: 56, tag: sys, level: 56" node_number="56"> #include <sys title="valid: False, node: 57, tag: sys, level: 57" node_number="57"> #include <fcntl.h title="valid: False, node: 58, tag: fcntl.h, level: 58" node_number="58"> #include <assert.h title="valid: False, node: 59, tag: assert.h, level: 59" node_number="59"> #include <stdlib.h title="valid: False, node: 60, tag: stdlib.h, level: 60" node_number="60"> #include <stdio.h title="valid: False, node: 61, tag: stdio.h, level: 61" node_number="61"> #include <numaif.h title="valid: False, node: 62, tag: numaif.h, level: 62" node_number="62"> #define SIZE 2ULL &lt;&lt; 30 int main(int argc, char **argv) { int fd; unsigned long long i; char *addr; pid_t pid; char buf[100]; unsigned long nodemask = 1; fd = open("/dev/shm/test", O_RDWR|O_CREAT); assert(fd &gt; 0); assert(ftruncate(fd, SIZE) == 0); addr = mmap(NULL, SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); assert(mbind(addr, SIZE, MPOL_BIND, nodemask, 2, MPOL_MF_STRICT|MPOL_MF_MOVE)==0); for (i = 0; i &lt; SIZE; i+=4096) { addr[i] = 1; } pid = getpid(); snprintf(buf, sizeof(buf), "grep shm /proc/%d/numa_maps", pid); system(buf); sleep(10000); return 0; } $ gcc mbind_thp.c -o mbind_thp -lnuma $ numactl -H available: 2 nodes (0-1) node 0 cpus: 0 2 node 0 size: 1918 MB node 0 free: 1595 MB node 1 cpus: 1 3 node 1 size: 2014 MB node 1 free: 1731 MB node distances: node 0 1 0: 10 20 1: 20 10 $ rm -f /dev/shm/test; taskset -c 0 ./mbind_thp 7fd970a00000 bind:0 file=/dev/shm/test dirty=524288 active=0 N0=396800 N1=127488 kernelpagesize_kB=4 Link: https://lkml.kernel.org/r/20211208165343.22349-1-arbn@yandex-team.com Fixes: ac5b2c18911f ("mm: thp: relax __GFP_THISNODE for MADV_HUGEPAGE mappings") Signed-off-by: Andrey Ryabinin <arbn title="valid: False, node: 63, tag: arbn, level: 63" node_number="63"> Acked-by: Michal Hocko <mhocko title="valid: False, node: 64, tag: mhocko, level: 64" node_number="64"> Acked-by: Mel Gorman <mgorman title="valid: False, node: 65, tag: mgorman, level: 65" node_number="65"> Acked-by: David Rientjes <rientjes title="valid: False, node: 66, tag: rientjes, level: 66" node_number="66"> Cc: Andrea Arcangeli <aarcange title="valid: False, node: 67, tag: aarcange, level: 67" node_number="67"> Cc: <stable title="valid: False, node: 68, tag: stable, level: 68" node_number="68"> Signed-off-by: Andrew Morton <akpm title="valid: False, node: 69, tag: akpm, level: 69" node_number="69"> Signed-off-by: Linus Torvalds <torvalds title="valid: False, node: 70, tag: torvalds, level: 70" node_number="70"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 71, tag: gregkh, level: 71" node_number="71"> commit 8008fc1d0be1c381aa8077dfab2d980188611ae2 Author: Sean Christopherson <seanjc title="valid: False, node: 72, tag: seanjc, level: 72" node_number="72"> Date: Tue Dec 7 19:30:05 2021 +0000 KVM: VMX: Fix stale docs for kvm-intel.emulate_invalid_guest_state commit 0ff29701ffad9a5d5a24344d8b09f3af7b96ffda upstream. Update the documentation for kvm-intel's emulate_invalid_guest_state to rectify the description of KVM's default behavior, and to document that the behavior and thus parameter only applies to L1. Fixes: a27685c33acc ("KVM: VMX: Emulate invalid guest state by default") Signed-off-by: Sean Christopherson <seanjc title="valid: False, node: 73, tag: seanjc, level: 73" node_number="73"> Message-Id: &lt;20211207193006.120997-4-seanjc@google.com&gt; Reviewed-by: Maxim Levitsky <mlevitsk title="valid: False, node: 74, tag: mlevitsk, level: 74" node_number="74"> Signed-off-by: Paolo Bonzini <pbonzini title="valid: False, node: 75, tag: pbonzini, level: 75" node_number="75"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 76, tag: gregkh, level: 76" node_number="76"> commit d91ed251fd7065b57d6c60964d15562fc4e73f7d Author: Marian Postevca <posteuca title="valid: False, node: 77, tag: posteuca, level: 77" node_number="77"> Date: Sat Dec 4 23:49:12 2021 +0200 usb: gadget: u_ether: fix race in setting MAC address in setup phase commit 890d5b40908bfd1a79be018d2d297cf9df60f4ee upstream. When listening for notifications through netlink of a new interface being registered, sporadically, it is possible for the MAC to be read as zero. The zero MAC address lasts a short period of time and then switches to a valid random MAC address. This causes problems for netd in Android, which assumes that the interface is malfunctioning and will not use it. In the good case we get this log: InterfaceController::getCfg() ifName usb0 hwAddr 92:a8:f0:73:79:5b ipv4Addr 0.0.0.0 flags 0x1002 In the error case we get these logs: InterfaceController::getCfg() ifName usb0 hwAddr 00:00:00:00:00:00 ipv4Addr 0.0.0.0 flags 0x1002 netd : interfaceGetCfg("usb0") netd : interfaceSetCfg() -&gt; ServiceSpecificException (99, "[Cannot assign requested address] : ioctl() failed") The reason for the issue is the order in which the interface is setup, it is first registered through register_netdev() and after the MAC address is set. Fixed by first setting the MAC address of the net_device and after that calling register_netdev(). Fixes: bcd4a1c40bee885e ("usb: gadget: u_ether: construct with default values and add setters/getters") Cc: stable@vger.kernel.org Signed-off-by: Marian Postevca <posteuca title="valid: False, node: 78, tag: posteuca, level: 78" node_number="78"> Link: https://lore.kernel.org/r/20211204214912.17627-1-posteuca@mutex.one Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 79, tag: gregkh, level: 79" node_number="79"> commit 6697f29bf56b6bd07ddf1218f2f8a48601a4b75f Author: Christian Brauner <christian.brauner title="valid: False, node: 80, tag: christian.brauner, level: 80" node_number="80"> Date: Mon Nov 29 12:16:39 2021 +0100 ceph: fix up non-directory creation in SGID directories commit fd84bfdddd169c219c3a637889a8b87f70a072c2 upstream. Ceph always inherits the SGID bit if it is set on the parent inode, while the generic inode_init_owner does not do this in a few cases where it can create a possible security problem (cf. [1]). Update ceph to strip the SGID bit just as inode_init_owner would. This bug was detected by the mapped mount testsuite in [3]. The testsuite tests all core VFS functionality and semantics with and without mapped mounts. That is to say it functions as a generic VFS testsuite in addition to a mapped mount testsuite. While working on mapped mount support for ceph, SIGD inheritance was the only failing test for ceph after the port. The same bug was detected by the mapped mount testsuite in XFS in January 2021 (cf. [2]). [1]: commit 0fa3ecd87848 ("Fix up non-directory creation in SGID directories") [2]: commit 01ea173e103e ("xfs: fix up non-directory creation in SGID directories") [3]: https://git.kernel.org/fs/xfs/xfstests-dev.git Cc: stable@vger.kernel.org Signed-off-by: Christian Brauner <christian.brauner title="valid: False, node: 81, tag: christian.brauner, level: 81" node_number="81"> Reviewed-by: Jeff Layton <jlayton title="valid: False, node: 82, tag: jlayton, level: 82" node_number="82"> Signed-off-by: Ilya Dryomov <idryomov title="valid: False, node: 83, tag: idryomov, level: 83" node_number="83"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 84, tag: gregkh, level: 84" node_number="84"> commit fffb6581a23add416239dfcf7e7f3980c6b913da Author: Chao Yu <chao title="valid: False, node: 85, tag: chao, level: 85" node_number="85"> Date: Sun Dec 12 17:16:30 2021 +0800 f2fs: fix to do sanity check on last xattr entry in __f2fs_setxattr() commit 5598b24efaf4892741c798b425d543e4bed357a1 upstream. As Wenqing Liu reported in bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=215235 - Overview page fault in f2fs_setxattr() when mount and operate on corrupted image - Reproduce tested on kernel 5.16-rc3, 5.15.X under root 1. unzip tmp7.zip 2. ./single.sh f2fs 7 Sometimes need to run the script several times - Kernel dump loop0: detected capacity change from 0 to 131072 F2FS-fs (loop0): Found nat_bits in checkpoint F2FS-fs (loop0): Mounted with checkpoint version = 7548c2ee BUG: unable to handle page fault for address: ffffe47bc7123f48 RIP: 0010:kfree+0x66/0x320 Call Trace: __f2fs_setxattr+0x2aa/0xc00 [f2fs] f2fs_setxattr+0xfa/0x480 [f2fs] __f2fs_set_acl+0x19b/0x330 [f2fs] __vfs_removexattr+0x52/0x70 __vfs_removexattr_locked+0xb1/0x140 vfs_removexattr+0x56/0x100 removexattr+0x57/0x80 path_removexattr+0xa3/0xc0 __x64_sys_removexattr+0x17/0x20 do_syscall_64+0x37/0xb0 entry_SYSCALL_64_after_hwframe+0x44/0xae The root cause is in __f2fs_setxattr(), we missed to do sanity check on last xattr entry, result in out-of-bound memory access during updating inconsistent xattr data of target inode. After the fix, it can detect such xattr inconsistency as below: F2FS-fs (loop11): inode (7) has invalid last xattr entry, entry_size: 60676 F2FS-fs (loop11): inode (8) has corrupted xattr F2FS-fs (loop11): inode (8) has corrupted xattr F2FS-fs (loop11): inode (8) has invalid last xattr entry, entry_size: 47736 Cc: stable@vger.kernel.org Reported-by: Wenqing Liu <wenqingliu0120 title="valid: False, node: 86, tag: wenqingliu0120, level: 86" node_number="86"> Signed-off-by: Chao Yu <chao title="valid: False, node: 87, tag: chao, level: 87" node_number="87"> Signed-off-by: Jaegeuk Kim <jaegeuk title="valid: False, node: 88, tag: jaegeuk, level: 88" node_number="88"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 89, tag: gregkh, level: 89" node_number="89"> commit ad338d825e3f7b96ee542bf313728af2d19fe9ad Author: Sumit Garg <sumit.garg title="valid: False, node: 90, tag: sumit.garg, level: 90" node_number="90"> Date: Thu Dec 16 11:17:25 2021 +0530 tee: optee: Fix incorrect page free bug commit 18549bf4b21c739a9def39f27dcac53e27286ab5 upstream. Pointer to the allocated pages (struct page *page) has already progressed towards the end of allocation. It is incorrect to perform __free_pages(page, order) using this pointer as we would free any arbitrary pages. Fix this by stop modifying the page pointer. Fixes: ec185dd3ab25 ("optee: Fix memory leak when failing to register shm pages") Cc: stable@vger.kernel.org Reported-by: Patrik Lantz <patrik.lantz title="valid: False, node: 91, tag: patrik.lantz, level: 91" node_number="91"> Signed-off-by: Sumit Garg <sumit.garg title="valid: False, node: 92, tag: sumit.garg, level: 92" node_number="92"> Reviewed-by: Tyler Hicks <tyhicks title="valid: False, node: 93, tag: tyhicks, level: 93" node_number="93"> Signed-off-by: Jens Wiklander <jens.wiklander title="valid: False, node: 94, tag: jens.wiklander, level: 94" node_number="94"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 95, tag: gregkh, level: 95" node_number="95"> commit 1f207076740101fed87074a6bc924dbe806f08a5 Author: Liu Shixin <liushixin2 title="valid: False, node: 96, tag: liushixin2, level: 96" node_number="96"> Date: Fri Dec 24 21:12:58 2021 -0800 mm/hwpoison: clear MF_COUNT_INCREASED before retrying get_any_page() commit 2a57d83c78f889bf3f54eede908d0643c40d5418 upstream. Hulk Robot reported a panic in put_page_testzero() when testing madvise() with MADV_SOFT_OFFLINE. The BUG() is triggered when retrying get_any_page(). This is because we keep MF_COUNT_INCREASED flag in second try but the refcnt is not increased. page dumped because: VM_BUG_ON_PAGE(page_ref_count(page) == 0) ------------[ cut here ]------------ kernel BUG at include/linux/mm.h:737! invalid opcode: 0000 [#1] PREEMPT SMP CPU: 5 PID: 2135 Comm: sshd Tainted: G B 5.16.0-rc6-dirty #373 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014 RIP: release_pages+0x53f/0x840 Call Trace: free_pages_and_swap_cache+0x64/0x80 tlb_flush_mmu+0x6f/0x220 unmap_page_range+0xe6c/0x12c0 unmap_single_vma+0x90/0x170 unmap_vmas+0xc4/0x180 exit_mmap+0xde/0x3a0 mmput+0xa3/0x250 do_exit+0x564/0x1470 do_group_exit+0x3b/0x100 __do_sys_exit_group+0x13/0x20 __x64_sys_exit_group+0x16/0x20 do_syscall_64+0x34/0x80 entry_SYSCALL_64_after_hwframe+0x44/0xae Modules linked in: ---[ end trace e99579b570fe0649 ]--- RIP: 0010:release_pages+0x53f/0x840 Link: https://lkml.kernel.org/r/20211221074908.3910286-1-liushixin2@huawei.com Fixes: b94e02822deb ("mm,hwpoison: try to narrow window race for free pages") Signed-off-by: Liu Shixin <liushixin2 title="valid: False, node: 97, tag: liushixin2, level: 97" node_number="97"> Reported-by: Hulk Robot <hulkci title="valid: False, node: 98, tag: hulkci, level: 98" node_number="98"> Reviewed-by: Oscar Salvador <osalvador title="valid: False, node: 99, tag: osalvador, level: 99" node_number="99"> Acked-by: Naoya Horiguchi <naoya.horiguchi title="valid: False, node: 100, tag: naoya.horiguchi, level: 100" node_number="100"> Cc: <stable title="valid: False, node: 101, tag: stable, level: 101" node_number="101"> Signed-off-by: Andrew Morton <akpm title="valid: False, node: 102, tag: akpm, level: 102" node_number="102"> Signed-off-by: Linus Torvalds <torvalds title="valid: False, node: 103, tag: torvalds, level: 103" node_number="103"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 104, tag: gregkh, level: 104" node_number="104"> commit ac61b9c6c0549aaeb98194cf429d93c41bfe5f79 Author: Johannes Berg <johannes.berg title="valid: False, node: 105, tag: johannes.berg, level: 105" node_number="105"> Date: Mon Dec 20 10:22:40 2021 +0100 mac80211: fix locking in ieee80211_start_ap error path commit 87a270625a89fc841f1a7e21aae6176543d8385c upstream. We need to hold the local-&gt;mtx to release the channel context, as even encoded by the lockdep_assert_held() there. Fix it. Cc: stable@vger.kernel.org Fixes: 295b02c4be74 ("mac80211: Add FILS discovery support") Reported-and-tested-by: syzbot+11c342e5e30e9539cabd@syzkaller.appspotmail.com Link: https://lore.kernel.org/r/20211220090836.cee3d59a1915.I36bba9b79dc2ff4d57c3c7aa30dff9a003fe8c5c@changeid Signed-off-by: Johannes Berg <johannes.berg title="valid: False, node: 106, tag: johannes.berg, level: 106" node_number="106"> Signed-off-by: David S. Miller <davem title="valid: False, node: 107, tag: davem, level: 107" node_number="107"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 108, tag: gregkh, level: 108" node_number="108"> commit 89876d10830db6ac55ae4379764c9e9dd1268277 Author: Ard Biesheuvel <ardb title="valid: False, node: 109, tag: ardb, level: 109" node_number="109"> Date: Wed Dec 15 09:31:36 2021 +0100 ARM: 9169/1: entry: fix Thumb2 bug in iWMMXt exception handling commit 8536a5ef886005bc443c2da9b842d69fd3d7647f upstream. The Thumb2 version of the FP exception handling entry code treats the register holding the CP number (R8) differently, resulting in the iWMMXT CP number check to be incorrect. Fix this by unifying the ARM and Thumb2 code paths, and switch the order of the additions of the TI_USED_CP offset and the shifted CP index. Cc: <stable title="valid: False, node: 110, tag: stable, level: 110" node_number="110"> Fixes: b86040a59feb ("Thumb-2: Implementation of the unified start-up and exceptions code") Signed-off-by: Ard Biesheuvel <ardb title="valid: False, node: 111, tag: ardb, level: 111" node_number="111"> Signed-off-by: Russell King (Oracle) <rmk title="valid: False, node: 112, tag: rmk, level: 112" node_number="112"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 113, tag: gregkh, level: 113" node_number="113"> commit c3253d3a38bc1f60caae6d06506cfc3b72b0ba11 Author: Yann Gautier <yann.gautier title="valid: False, node: 114, tag: yann.gautier, level: 114" node_number="114"> Date: Wed Dec 15 15:17:26 2021 +0100 mmc: mmci: stm32: clear DLYB_CR after sending tuning command commit ff31ee0a0f471776f67be5e5275c18d17736fc6b upstream. During test campaign, and especially after several unbind/bind sequences, it has been seen that the SD-card on SDMMC1 thread could freeze. The freeze always appear on a CMD23 following a CMD19. Checking SDMMC internal registers shows that the tuning command (CMD19) has failed. The freeze is then due to the delay block involved in the tuning sequence. To correct this, clear the delay block register DLYB_CR register after the tuning commands. Signed-off-by: Christophe Kerello <christophe.kerello title="valid: False, node: 115, tag: christophe.kerello, level: 115" node_number="115"> Signed-off-by: Yann Gautier <yann.gautier title="valid: False, node: 116, tag: yann.gautier, level: 116" node_number="116"> Reviewed-by: Linus Walleij <linus.walleij title="valid: False, node: 117, tag: linus.walleij, level: 117" node_number="117"> Fixes: 1103f807a3b9 ("mmc: mmci_sdmmc: Add execute tuning with delay block") Cc: stable@vger.kernel.org Link: https://lore.kernel.org/r/20211215141727.4901-4-yann.gautier@foss.st.com Signed-off-by: Ulf Hansson <ulf.hansson title="valid: False, node: 118, tag: ulf.hansson, level: 118" node_number="118"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 119, tag: gregkh, level: 119" node_number="119"> commit 0d66b395210c5084c2b7324945062c1d1f95487a Author: Ulf Hansson <ulf.hansson title="valid: False, node: 120, tag: ulf.hansson, level: 120" node_number="120"> Date: Fri Dec 3 15:15:54 2021 +0100 mmc: core: Disable card detect during shutdown commit 66c915d09b942fb3b2b0cb2f56562180901fba17 upstream. It's seems prone to problems by allowing card detect and its corresponding mmc_rescan() work to run, during platform shutdown. For example, we may end up turning off the power while initializing a card, which potentially could damage it. To avoid this scenario, let's add -&gt;shutdown_pre() callback for the mmc host class device and then turn of the card detect from there. Reported-by: Al Cooper <alcooperx title="valid: False, node: 121, tag: alcooperx, level: 121" node_number="121"> Suggested-by: Adrian Hunter <adrian.hunter title="valid: False, node: 122, tag: adrian.hunter, level: 122" node_number="122"> Signed-off-by: Ulf Hansson <ulf.hansson title="valid: False, node: 123, tag: ulf.hansson, level: 123" node_number="123"> Cc: stable@vger.kernel.org Link: https://lore.kernel.org/r/20211203141555.105351-1-ulf.hansson@linaro.org Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 124, tag: gregkh, level: 124" node_number="124"> commit c8e366a01c20019a631d1aa151a918d67757ab8d Author: Martin Blumenstingl <martin.blumenstingl title="valid: False, node: 125, tag: martin.blumenstingl, level: 125" node_number="125"> Date: Sun Dec 19 16:34:41 2021 +0100 mmc: meson-mx-sdhc: Set MANUAL_STOP for multi-block SDIO commands commit f89b548ca66be7500dcd92ee8e61590f7d08ac91 upstream. The vendor driver implements special handling for multi-block SD_IO_RW_EXTENDED (and SD_IO_RW_DIRECT) commands which have data attached to them. It sets the MANUAL_STOP bit in the MESON_SDHC_MISC register for these commands. In all other cases this bit is cleared. Here we omit SD_IO_RW_DIRECT since that command never has any data attached to it. This fixes SDIO wifi using the brcmfmac driver which reported the following error without this change on a Netxeon S82 board using a Meson8 (S802) SoC: brcmf_fw_alloc_request: using brcm/brcmfmac43362-sdio for chip BCM43362/1 brcmf_sdiod_ramrw: membytes transfer failed brcmf_sdio_download_code_file: error -110 on writing 219557 membytes at 0x00000000 brcmf_sdio_download_firmware: dongle image file download failed And with this change: brcmf_fw_alloc_request: using brcm/brcmfmac43362-sdio for chip BCM43362/1 brcmf_c_process_clm_blob: no clm_blob available (err=-2), device may have limited channels available brcmf_c_preinit_dcmds: Firmware: BCM43362/1 wl0: Apr 22 2013 14:50:00 version 5.90.195.89.6 FWID 01-b30a427d Fixes: e4bf1b0970ef96 ("mmc: host: meson-mx-sdhc: new driver for the Amlogic Meson SDHC host") Signed-off-by: Martin Blumenstingl <martin.blumenstingl title="valid: False, node: 126, tag: martin.blumenstingl, level: 126" node_number="126"> Cc: stable@vger.kernel.org Link: https://lore.kernel.org/r/20211219153442.463863-2-martin.blumenstingl@googlemail.com Signed-off-by: Ulf Hansson <ulf.hansson title="valid: False, node: 127, tag: ulf.hansson, level: 127" node_number="127"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 128, tag: gregkh, level: 128" node_number="128"> commit 4af79153617bd14677a69b4f4c6bb13e3ece2708 Author: Prathamesh Shete <pshete title="valid: False, node: 129, tag: pshete, level: 129" node_number="129"> Date: Tue Dec 14 17:06:53 2021 +0530 mmc: sdhci-tegra: Fix switch to HS400ES mode commit 4fc7261dbab139d3c64c3b618262504e16cfe7ee upstream. When CMD13 is sent after switching to HS400ES mode, the bus is operating at either MMC_HIGH_26_MAX_DTR or MMC_HIGH_52_MAX_DTR. To meet Tegra SDHCI requirement at HS400ES mode, force SDHCI interface clock to MMC_HS200_MAX_DTR (200 MHz) so that host controller CAR clock and the interface clock are rate matched. Signed-off-by: Prathamesh Shete <pshete title="valid: False, node: 130, tag: pshete, level: 130" node_number="130"> Acked-by: Adrian Hunter <adrian.hunter title="valid: False, node: 131, tag: adrian.hunter, level: 131" node_number="131"> Fixes: dfc9700cef77 ("mmc: tegra: Implement HS400 enhanced strobe") Cc: stable@vger.kernel.org Link: https://lore.kernel.org/r/20211214113653.4631-1-pshete@nvidia.com Signed-off-by: Ulf Hansson <ulf.hansson title="valid: False, node: 132, tag: ulf.hansson, level: 132" node_number="132"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 133, tag: gregkh, level: 133" node_number="133"> commit 9a7ec7979785e97b33a6bbd79b95faa20e4882bb Author: Noralf Tr&#248;nnes <noralf title="valid: False, node: 134, tag: noralf, level: 134" node_number="134"> Date: Mon Oct 18 13:22:01 2021 +0200 gpio: dln2: Fix interrupts when replugging the device commit 9a5875f14b0e3a13ae314883f1bb72b7f31fac07 upstream. When replugging the device the following message shows up: gpio gpiochip2: (dln2): detected irqchip that is shared with multiple gpiochips: please fix the driver. This also has the effect that interrupts won't work. The same problem would also show up if multiple devices where plugged in. Fix this by allocating the irq_chip data structure per instance like other drivers do. I don't know when this problem appeared, but it is present in 5.10. Cc: <stable title="valid: False, node: 135, tag: stable, level: 135" node_number="135"> # 5.10+ Cc: Daniel Baluta <daniel.baluta title="valid: False, node: 136, tag: daniel.baluta, level: 136" node_number="136"> Signed-off-by: Noralf Tr&#248;nnes <noralf title="valid: False, node: 137, tag: noralf, level: 137" node_number="137"> Signed-off-by: Bartosz Golaszewski Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 138, tag: gregkh, level: 138" node_number="138"> commit f5b02912e2dd89fe2386c19edd2c6f3e1296fc2b Author: Fabien Dessenne <fabien.dessenne title="valid: False, node: 139, tag: fabien.dessenne, level: 139" node_number="139"> Date: Wed Dec 15 10:58:08 2021 +0100 pinctrl: stm32: consider the GPIO offset to expose all the GPIO lines commit b67210cc217f9ca1c576909454d846970c13dfd4 upstream. Consider the GPIO controller offset (from "gpio-ranges") to compute the maximum GPIO line number. This fixes an issue where gpio-ranges uses a non-null offset. e.g.: gpio-ranges = In that case the last valid GPIO line is not 9 but 15 (6 + 10 - 1) Cc: stable@vger.kernel.org Fixes: 67e2996f72c7 ("pinctrl: stm32: fix the reported number of GPIO lines per bank") Reported-by: Christoph Fritz <chf.fritz title="valid: False, node: 140, tag: chf.fritz, level: 140" node_number="140"> Signed-off-by: Fabien Dessenne <fabien.dessenne title="valid: False, node: 141, tag: fabien.dessenne, level: 141" node_number="141"> Link: https://lore.kernel.org/r/20211215095808.621716-1-fabien.dessenne@foss.st.com Signed-off-by: Linus Walleij <linus.walleij title="valid: False, node: 142, tag: linus.walleij, level: 142" node_number="142"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 143, tag: gregkh, level: 143" node_number="143"> commit 28626e76baf50e6b37d8a92564844d873aa6b51f Author: Sean Christopherson <seanjc title="valid: False, node: 144, tag: seanjc, level: 144" node_number="144"> Date: Tue Dec 21 10:37:00 2021 -0500 KVM: VMX: Wake vCPU when delivering posted IRQ even if vCPU == this vCPU commit fdba608f15e2427419997b0898750a49a735afcb upstream. Drop a check that guards triggering a posted interrupt on the currently running vCPU, and more importantly guards waking the target vCPU if triggering a posted interrupt fails because the vCPU isn't IN_GUEST_MODE. If a vIRQ is delivered from asynchronous context, the target vCPU can be the currently running vCPU and can also be blocking, in which case skipping kvm_vcpu_wake_up() is effectively dropping what is supposed to be a wake event for the vCPU. The "do nothing" logic when "vcpu == running_vcpu" mostly works only because the majority of calls to -&gt;deliver_posted_interrupt(), especially when using posted interrupts, come from synchronous KVM context. But if a device is exposed to the guest using vfio-pci passthrough, the VFIO IRQ and vCPU are bound to the same pCPU, and the IRQ is _not_ configured to use posted interrupts, wake events from the device will be delivered to KVM from IRQ context, e.g. vfio_msihandler() | |-&gt; eventfd_signal() | |-&gt; ... | |-&gt; irqfd_wakeup() | |-&gt;kvm_arch_set_irq_inatomic() | |-&gt; kvm_irq_delivery_to_apic_fast() | |-&gt; kvm_apic_set_irq() This also aligns the non-nested and nested usage of triggering posted interrupts, and will allow for additional cleanups. Fixes: 379a3c8ee444 ("KVM: VMX: Optimize posted-interrupt delivery for timer fastpath") Cc: stable@vger.kernel.org Reported-by: Longpeng (Mike) <longpeng2 title="valid: False, node: 145, tag: longpeng2, level: 145" node_number="145"> Signed-off-by: Sean Christopherson <seanjc title="valid: False, node: 146, tag: seanjc, level: 146" node_number="146"> Reviewed-by: Maxim Levitsky <mlevitsk title="valid: False, node: 147, tag: mlevitsk, level: 147" node_number="147"> Message-Id: &lt;20211208015236.1616697-18-seanjc@google.com&gt; Signed-off-by: Paolo Bonzini <pbonzini title="valid: False, node: 148, tag: pbonzini, level: 148" node_number="148"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 149, tag: gregkh, level: 149" node_number="149"> commit 7a37f2e370699e2feca3dca6c8178c71ceee7e8a Author: Johan Hovold <johan title="valid: False, node: 150, tag: johan, level: 150" node_number="150"> Date: Wed Dec 22 11:50:23 2021 +0100 platform/x86: intel_pmc_core: fix memleak on registration failure commit 26a8b09437804fabfb1db080d676b96c0de68e7c upstream. In case device registration fails during module initialisation, the platform device structure needs to be freed using platform_device_put() to properly free all resources (e.g. the device name). Fixes: 938835aa903a ("platform/x86: intel_pmc_core: do not create a static struct device") Cc: stable@vger.kernel.org # 5.9 Signed-off-by: Johan Hovold <johan title="valid: False, node: 151, tag: johan, level: 151" node_number="151"> Reviewed-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 152, tag: gregkh, level: 152" node_number="152"> Link: https://lore.kernel.org/r/20211222105023.6205-1-johan@kernel.org Signed-off-by: Hans de Goede <hdegoede title="valid: False, node: 153, tag: hdegoede, level: 153" node_number="153"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 154, tag: gregkh, level: 154" node_number="154"> commit b57afd124046065be7f4ca36bac610f059ad222a Author: Andrew Cooper <andrew.cooper3 title="valid: False, node: 155, tag: andrew.cooper3, level: 155" node_number="155"> Date: Thu Dec 16 00:08:56 2021 +0000 x86/pkey: Fix undefined behaviour with PKRU_WD_BIT commit 57690554abe135fee81d6ac33cc94d75a7e224bb upstream. Both __pkru_allows_write() and arch_set_user_pkey_access() shift PKRU_WD_BIT (a signed constant) by up to 30 bits, hitting the sign bit. Use unsigned constants instead. Clearly pkey 15 has not been used in combination with UBSAN yet. Noticed by code inspection only. I can't actually provoke the compiler into generating incorrect logic as far as this shift is concerned. [ dhansen: add stable@ tag, plus minor changelog massaging, For anyone doing backports, these #defines were in arch/x86/include/asm/pgtable.h before 784a46618f6. ] Fixes: 33a709b25a76 ("mm/gup, x86/mm/pkeys: Check VMAs and PTEs for protection keys") Signed-off-by: Andrew Cooper <andrew.cooper3 title="valid: False, node: 156, tag: andrew.cooper3, level: 156" node_number="156"> Signed-off-by: Dave Hansen <dave.hansen title="valid: False, node: 157, tag: dave.hansen, level: 157" node_number="157"> Signed-off-by: Borislav Petkov <bp title="valid: False, node: 158, tag: bp, level: 158" node_number="158"> Cc: stable@vger.kernel.org Link: https://lkml.kernel.org/r/20211216000856.4480-1-andrew.cooper3@citrix.com Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 159, tag: gregkh, level: 159" node_number="159"> commit c05d8f66ec3470e5212c4d08c46d6cb5738d600d Author: Jens Wiklander <jens.wiklander title="valid: False, node: 160, tag: jens.wiklander, level: 160" node_number="160"> Date: Thu Dec 9 15:59:37 2021 +0100 tee: handle lookup of shm with reference count 0 commit dfd0743f1d9ea76931510ed150334d571fbab49d upstream. Since the tee subsystem does not keep a strong reference to its idle shared memory buffers, it races with other threads that try to destroy a shared memory through a close of its dma-buf fd or by unmapping the memory. In tee_shm_get_from_id() when a lookup in teedev-&gt;idr has been successful, it is possible that the tee_shm is in the dma-buf teardown path, but that path is blocked by the teedev mutex. Since we don't have an API to tell if the tee_shm is in the dma-buf teardown path or not we must find another way of detecting this condition. Fix this by doing the reference counting directly on the tee_shm using a new refcount_t refcount field. dma-buf is replaced by using anon_inode_getfd() instead, this separates the life-cycle of the underlying file from the tee_shm. tee_shm_put() is updated to hold the mutex when decreasing the refcount to 0 and then remove the tee_shm from teedev-&gt;idr before releasing the mutex. This means that the tee_shm can never be found unless it has a refcount larger than 0. Fixes: 967c9cca2cc5 ("tee: generic TEE subsystem") Cc: stable@vger.kernel.org Reviewed-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 161, tag: gregkh, level: 161" node_number="161"> Reviewed-by: Lars Persson <larper title="valid: False, node: 162, tag: larper, level: 162" node_number="162"> Reviewed-by: Sumit Garg <sumit.garg title="valid: False, node: 163, tag: sumit.garg, level: 163" node_number="163"> Reported-by: Patrik Lantz <patrik.lantz title="valid: False, node: 164, tag: patrik.lantz, level: 164" node_number="164"> Signed-off-by: Jens Wiklander <jens.wiklander title="valid: False, node: 165, tag: jens.wiklander, level: 165" node_number="165"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 166, tag: gregkh, level: 166" node_number="166"> commit 0ffb9f83e4f6e6a8b68f926173a8d0646b57bedf Author: John David Anglin <dave.anglin title="valid: False, node: 167, tag: dave.anglin, level: 167" node_number="167"> Date: Tue Dec 21 13:33:16 2021 -0500 parisc: Fix mask used to select futex spinlock commit d3a5a68cff47f6eead84504c3c28376b85053242 upstream. The address bits used to select the futex spinlock need to match those used in the LWS code in syscall.S. The mask 0x3f8 only selects 7 bits. It should select 8 bits. This change fixes the glibc nptl/tst-cond24 and nptl/tst-cond25 tests. Signed-off-by: John David Anglin <dave.anglin title="valid: False, node: 168, tag: dave.anglin, level: 168" node_number="168"> Fixes: 53a42b6324b8 ("parisc: Switch to more fine grained lws locks") Cc: stable@vger.kernel.org # 5.10+ Signed-off-by: Helge Deller Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 169, tag: gregkh, level: 169" node_number="169"> commit 5deeb9ad598b2b3b79c8d1455a276b3d9a8bac31 Author: John David Anglin <dave.anglin title="valid: False, node: 170, tag: dave.anglin, level: 170" node_number="170"> Date: Tue Dec 21 13:21:22 2021 -0500 parisc: Correct completer in lws start commit 8f66fce0f46560b9e910787ff7ad0974441c4f9c upstream. The completer in the "or,ev %r1,%r30,%r30" instruction is reversed, so we are not clipping the LWS number when we are called from a 32-bit process (W=0). We need to nulify the following depdi instruction when the least-significant bit of %r30 is 1. If the %r20 register is not clipped, a user process could perform a LWS call that would branch to an undefined location in the kernel and potentially crash the machine. Signed-off-by: John David Anglin <dave.anglin title="valid: False, node: 171, tag: dave.anglin, level: 171" node_number="171"> Cc: stable@vger.kernel.org # 4.19+ Signed-off-by: Helge Deller Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 172, tag: gregkh, level: 172" node_number="172"> commit 8b745616ba8f2db389a59e5678fdbe28ad5883bf Author: Thadeu Lima de Souza Cascardo <cascardo title="valid: False, node: 173, tag: cascardo, level: 173" node_number="173"> Date: Fri Dec 17 12:44:10 2021 -0300 ipmi: fix initialization when workqueue allocation fails commit 75d70d76cb7b927cace2cb34265d68ebb3306b13 upstream. If the workqueue allocation fails, the driver is marked as not initialized, and timer and panic_notifier will be left registered. Instead of removing those when workqueue allocation fails, do the workqueue initialization before doing it, and cleanup srcu_struct if it fails. Fixes: 1d49eb91e86e ("ipmi: Move remove_work to dedicated workqueue") Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo title="valid: False, node: 174, tag: cascardo, level: 174" node_number="174"> Cc: Corey Minyard <cminyard title="valid: False, node: 175, tag: cminyard, level: 175" node_number="175"> Cc: Ioanna Alifieraki <ioanna-maria.alifieraki title="valid: False, node: 176, tag: ioanna-maria.alifieraki, level: 176" node_number="176"> Cc: stable@vger.kernel.org Message-Id: &lt;20211217154410.1228673-2-cascardo@canonical.com&gt; Signed-off-by: Corey Minyard <cminyard title="valid: False, node: 177, tag: cminyard, level: 177" node_number="177"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 178, tag: gregkh, level: 178" node_number="178"> commit 1f6ab847461ce7dd89ae9db2dd4658c993355d7c Author: Mian Yousaf Kaukab <ykaukab title="valid: False, node: 179, tag: ykaukab, level: 179" node_number="179"> Date: Wed Dec 8 10:32:39 2021 +0100 ipmi: ssif: initialize ssif_info-&gt;client early commit 34f35f8f14bc406efc06ee4ff73202c6fd245d15 upstream. During probe ssif_info-&gt;client is dereferenced in error path. However, it is set when some of the error checking has already been done. This causes following kernel crash if an error path is taken: [ 30.645593][ T674] ipmi_ssif 0-000e: ipmi_ssif: Not probing, Interface already present [ 30.657616][ T674] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000088 ... [ 30.657723][ T674] pc : __dev_printk+0x28/0xa0 [ 30.657732][ T674] lr : _dev_err+0x7c/0xa0 ... [ 30.657772][ T674] Call trace: [ 30.657775][ T674] __dev_printk+0x28/0xa0 [ 30.657778][ T674] _dev_err+0x7c/0xa0 [ 30.657781][ T674] ssif_probe+0x548/0x900 [ipmi_ssif 62ce4b08badc1458fd896206d9ef69a3c31f3d3e] [ 30.657791][ T674] i2c_device_probe+0x37c/0x3c0 ... Initialize ssif_info-&gt;client before any error path can be taken. Clear i2c_client data in the error path to prevent the dangling pointer from leaking. Fixes: c4436c9149c5 ("ipmi_ssif: avoid registering duplicate ssif interface") Cc: stable@vger.kernel.org # 5.4.x Suggested-by: Takashi Iwai <tiwai title="valid: False, node: 180, tag: tiwai, level: 180" node_number="180"> Signed-off-by: Mian Yousaf Kaukab <ykaukab title="valid: False, node: 181, tag: ykaukab, level: 181" node_number="181"> Message-Id: &lt;20211208093239.4432-1-ykaukab@suse.de&gt; Signed-off-by: Corey Minyard <cminyard title="valid: False, node: 182, tag: cminyard, level: 182" node_number="182"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 183, tag: gregkh, level: 183" node_number="183"> commit a5192f31160c1739ef6525ed77d6aafa8e6565dd Author: Thadeu Lima de Souza Cascardo <cascardo title="valid: False, node: 184, tag: cascardo, level: 184" node_number="184"> Date: Fri Dec 17 12:44:09 2021 -0300 ipmi: bail out if init_srcu_struct fails commit 2b5160b12091285c5aca45980f100a9294af7b04 upstream. In case, init_srcu_struct fails (because of memory allocation failure), we might proceed with the driver initialization despite srcu_struct not being entirely initialized. Fixes: 913a89f009d9 ("ipmi: Don't initialize anything in the core until something uses it") Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo title="valid: False, node: 185, tag: cascardo, level: 185" node_number="185"> Cc: Corey Minyard <cminyard title="valid: False, node: 186, tag: cminyard, level: 186" node_number="186"> Cc: stable@vger.kernel.org Message-Id: &lt;20211217154410.1228673-1-cascardo@canonical.com&gt; Signed-off-by: Corey Minyard <cminyard title="valid: False, node: 187, tag: cminyard, level: 187" node_number="187"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 188, tag: gregkh, level: 188" node_number="188"> commit bc674f1b2119fcf36ca28a5f8170307be70de333 Author: Jos&#233; Exp&#243;sito <jose.exposito89 title="valid: False, node: 189, tag: jose.exposito89, level: 189" node_number="189"> Date: Sun Dec 12 21:01:49 2021 -0800 Input: atmel_mxt_ts - fix double free in mxt_read_info_block commit 12f247ab590a08856441efdbd351cf2cc8f60a2d upstream. The "id_buf" buffer is stored in "data-&gt;raw_info_block" and freed by "mxt_free_object_table" in case of error. Return instead of jumping to avoid a double free. Addresses-Coverity-ID: 1474582 ("Double free") Fixes: 068bdb67ef74 ("Input: atmel_mxt_ts - fix the firmware update") Signed-off-by: Jos&#233; Exp&#243;sito <jose.exposito89 title="valid: False, node: 190, tag: jose.exposito89, level: 190" node_number="190"> Link: https://lore.kernel.org/r/20211212194257.68879-1-jose.exposito89@gmail.com Cc: stable@vger.kernel.org Signed-off-by: Dmitry Torokhov <dmitry.torokhov title="valid: False, node: 191, tag: dmitry.torokhov, level: 191" node_number="191"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 192, tag: gregkh, level: 192" node_number="192"> commit 30140e252fdb74884d5ef34f5e48d2fc6a79a433 Author: Martin Blumenstingl <martin.blumenstingl title="valid: False, node: 193, tag: martin.blumenstingl, level: 193" node_number="193"> Date: Mon Dec 6 22:08:04 2021 +0100 ASoC: meson: aiu: Move AIU_I2S_MISC hold setting to aiu-fifo-i2s commit ee907afb0c39a41ee74b862882cfe12820c74b98 upstream. The out-of-tree vendor driver uses the following approach to set the AIU_I2S_MISC register: 1) write AIU_MEM_I2S_START_PTR and AIU_MEM_I2S_RD_PTR 2) configure AIU_I2S_MUTE_SWAP[15:0] 3) write AIU_MEM_I2S_END_PTR 4) set AIU_I2S_MISC[2] to 1 (documented as: "put I2S interface in hold mode") 5) set AIU_I2S_MISC[4] to 1 (depending on the driver revision it always stays at 1 while for older drivers this bit is unset in step 4) 6) set AIU_I2S_MISC[2] to 0 7) write AIU_MEM_I2S_MASKS 8) toggle AIU_MEM_I2S_CONTROL[0] 9) toggle AIU_MEM_I2S_BUF_CNTL[0] Move setting the AIU_I2S_MISC[2] bit to aiu_fifo_i2s_hw_params() so it resembles the flow in the vendor kernel more closely. While here also configure AIU_I2S_MISC[4] (documented as: "force each audio data to left or right according to the bit attached with the audio data") similar to how the vendor driver does this. This fixes the infamous and long-standing "machine gun noise" issue (a buffer underrun issue). Fixes: 6ae9ca9ce986bf ("ASoC: meson: aiu: add i2s and spdif support") Reported-by: Christian Hewitt <christianshewitt title="valid: False, node: 194, tag: christianshewitt, level: 194" node_number="194"> Reported-by: Geraldo Nascimento <geraldogabriel title="valid: False, node: 195, tag: geraldogabriel, level: 195" node_number="195"> Tested-by: Christian Hewitt <christianshewitt title="valid: False, node: 196, tag: christianshewitt, level: 196" node_number="196"> Tested-by: Geraldo Nascimento <geraldogabriel title="valid: False, node: 197, tag: geraldogabriel, level: 197" node_number="197"> Acked-by: Jerome Brunet <jbrunet title="valid: False, node: 198, tag: jbrunet, level: 198" node_number="198"> Cc: stable@vger.kernel.org Signed-off-by: Martin Blumenstingl <martin.blumenstingl title="valid: False, node: 199, tag: martin.blumenstingl, level: 199" node_number="199"> Link: https://lore.kernel.org/r/20211206210804.2512999-3-martin.blumenstingl@googlemail.com Signed-off-by: Mark Brown Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 200, tag: gregkh, level: 200" node_number="200"> commit 2b4c020b70cc943f5d3ae7cd59059e7b2e0cb0ab Author: Werner Sembach <wse title="valid: False, node: 201, tag: wse, level: 201" node_number="201"> Date: Wed Dec 15 20:16:46 2021 +0100 ALSA: hda/realtek: Fix quirk for Clevo NJ51CU commit edca7cc4b0accfa69dc032442fe0684e59c691b8 upstream. The Clevo NJ51CU comes either with the ALC293 or the ALC256 codec, but uses the 0x8686 subproduct id in both cases. The ALC256 codec needs a different quirk for the headset microphone working and and edditional quirk for sound working after suspend and resume. When waking up from s3 suspend the Coef 0x10 is set to 0x0220 instead of 0x0020 on the ALC256 codec. Setting the value manually makes the sound work again. This patch does this automatically. [ minor coding style fix by tiwai ] Signed-off-by: Werner Sembach <wse title="valid: False, node: 202, tag: wse, level: 202" node_number="202"> Fixes: b5acfe152abaa ("ALSA: hda/realtek: Add some Clove SSID in the ALC293(ALC1220)") Cc: <stable title="valid: False, node: 203, tag: stable, level: 203" node_number="203"> Link: https://lore.kernel.org/r/20211215191646.844644-1-wse@tuxedocomputers.com Signed-off-by: Takashi Iwai <tiwai title="valid: False, node: 204, tag: tiwai, level: 204" node_number="204"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 205, tag: gregkh, level: 205" node_number="205"> commit 7470780f3b0c2a8ef53562ed92fbb10b03024e47 Author: Bradley Scott <bscott title="valid: False, node: 206, tag: bscott, level: 206" node_number="206"> Date: Mon Dec 13 11:22:47 2021 -0500 ALSA: hda/realtek: Add new alc285-hp-amp-init model commit aa72394667e5cea3547e4c41ddff7ca8c632d764 upstream. Adds a new "alc285-hp-amp-init" model that can be used to apply the ALC285 HP speaker amplifier initialization fixup to devices that are not already known by passing "hda_model=alc285-hp-amp-init" to the snd-sof-intel-hda-common module or "model=alc285-hp-amp-init" to the snd-hda-intel module, depending on which is being used. Signed-off-by: Bradley Scott <bscott title="valid: False, node: 207, tag: bscott, level: 207" node_number="207"> Cc: <stable title="valid: False, node: 208, tag: stable, level: 208" node_number="208"> Link: https://lore.kernel.org/r/20211213162246.506838-1-bscott@teksavvy.com Signed-off-by: Takashi Iwai <tiwai title="valid: False, node: 209, tag: tiwai, level: 209" node_number="209"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 210, tag: gregkh, level: 210" node_number="210"> commit 4cb7dc2e307498f8e50eac438d1bece84fd853c6 Author: Bradley Scott Date: Mon Dec 13 10:49:39 2021 -0500 ALSA: hda/realtek: Amp init fixup for HP ZBook 15 G6 commit d296a74b7b59ff9116236c17edb25f26935dbf70 upstream. HP ZBook 15 G6 (SSID 103c:860f) needs the same speaker amplifier initialization as used on several other HP laptops using ALC285. Signed-off-by: Bradley Scott Cc: <stable title="valid: False, node: 211, tag: stable, level: 211" node_number="211"> Link: https://lore.kernel.org/r/20211213154938.503201-1-Bradley.Scott@zebra.com Signed-off-by: Takashi Iwai <tiwai title="valid: False, node: 212, tag: tiwai, level: 212" node_number="212"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 213, tag: gregkh, level: 213" node_number="213"> commit 69e492161c7b563684caf0fad01382279c065213 Author: Colin Ian King <colin.king title="valid: False, node: 214, tag: colin.king, level: 214" node_number="214"> Date: Sun Dec 12 17:20:25 2021 +0000 ALSA: drivers: opl3: Fix incorrect use of vp-&gt;state commit 2dee54b289fbc810669a1b2b8a0887fa1c9a14d7 upstream. Static analysis with scan-build has found an assignment to vp2 that is never used. It seems that the check on vp-&gt;state &gt; 0 should be actually on vp2-&gt;state instead. Fix this. This dates back to 2002, I found the offending commit from the git history git://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git, commit 91e39521bbf6 ("[PATCH] ALSA patch for 2.5.4") Signed-off-by: Colin Ian King <colin.i.king title="valid: False, node: 215, tag: colin.i.king, level: 215" node_number="215"> Cc: <stable title="valid: False, node: 216, tag: stable, level: 216" node_number="216"> Link: https://lore.kernel.org/r/20211212172025.470367-1-colin.i.king@gmail.com Signed-off-by: Takashi Iwai <tiwai title="valid: False, node: 217, tag: tiwai, level: 217" node_number="217"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 218, tag: gregkh, level: 218" node_number="218"> commit a96c08e0b41e022b440ee9c8327b14dd6eb094f7 Author: Xiaoke Wang <xkernel.wang title="valid: False, node: 219, tag: xkernel.wang, level: 219" node_number="219"> Date: Mon Dec 13 15:39:31 2021 +0800 ALSA: jack: Check the return value of kstrdup() commit c01c1db1dc632edafb0dff32d40daf4f9c1a4e19 upstream. kstrdup() can return NULL, it is better to check the return value of it. Signed-off-by: Xiaoke Wang <xkernel.wang title="valid: False, node: 220, tag: xkernel.wang, level: 220" node_number="220"> Cc: <stable title="valid: False, node: 221, tag: stable, level: 221" node_number="221"> Link: https://lore.kernel.org/r/tencent_094816F3522E0DC704056C789352EBBF0606@qq.com Signed-off-by: Takashi Iwai <tiwai title="valid: False, node: 222, tag: tiwai, level: 222" node_number="222"> Signed-off-by: Greg Kroah-Hartman <gregkh title="valid: False, node: 223, tag: gregkh, level: 223" node_number="223"> commit 51c7b2a7b86a923cc410882f3b8bde09ba412f3c Author: Guenter Roeck <linux title="valid: False, node: 224, tag: linux, level: 224" node_number="224"> Date: Sat Nov 13 08:55:06 2021 -0800 hwmon: (lm90) Drop critical attribute support for MAX6654 [ Upstream commit 16ba51b5dcd3f6dde2e51d5ccc86313119dcf889 ] Tests with a real chip and a closer look into the datasheet show that MAX6654 does not support CRIT/THERM/OVERTEMP limits, so drop support of the respective attributes for this chip. Introduce LM90_HAVE_CRIT flag and use it to instantiate critical limit attributes to solve the problem. Cc: Josh Lehan <krellan title="valid: False, node: 225, tag: krellan, level: 225" node_number="225"> Fixes: 229d495d8189 ("hwmon: (lm90) Add max6654 support to lm90 driver") Signed-off-by: Guenter Roeck <linux title="valid: False, node: 226, tag: linux, level: 226" node_number="226"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 227, tag: sashal, level: 227" node_number="227"> commit 2464738d0ee4ec57bd6f561acc3b178c79703c38 Author: Guenter Roeck <linux title="valid: False, node: 228, tag: linux, level: 228" node_number="228"> Date: Thu Oct 21 01:49:50 2021 -0700 hwmon: (lm90) Introduce flag indicating extended temperature support [ Upstream commit f347e249fcf920ad6974cbd898e2ec0b366a1c34 ] A flag indicating extended temperature support makes it easier to add support for additional chips with this functionality. Cc: David T. Wilson <david.wilson title="valid: False, node: 229, tag: david.wilson, level: 229" node_number="229"> Signed-off-by: Guenter Roeck <linux title="valid: False, node: 230, tag: linux, level: 230" node_number="230"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 231, tag: sashal, level: 231" node_number="231"> commit 196df56c3dc8bb36caf0bda25c26056a838ed273 Author: Guenter Roeck <linux title="valid: False, node: 232, tag: linux, level: 232" node_number="232"> Date: Mon Oct 18 20:03:32 2021 -0700 hwmon: (lm90) Add basic support for TI TMP461 [ Upstream commit f8344f7693a25d9025a59d164450b50c6f5aa3c0 ] TMP461 is almost identical to TMP451 and was actually detected as TMP451 with the existing lm90 driver if its I2C address is 0x4c. Add support for it to the lm90 driver. At the same time, improve the chip detection function to at least try to distinguish between TMP451 and TMP461. As a side effect, this fixes commit 24333ac26d01 ("hwmon: (tmp401) use smb word operations instead of 2 smb byte operations"). TMP461 does not support word operations on temperature registers, which causes bad temperature readings with the tmp401 driver. The lm90 driver does not perform word operations on temperature registers and thus does not have this problem. Support is listed as basic because TMP461 supports a sensor resolution of 0.0625 degrees C, while the lm90 driver assumes a resolution of 0.125 degrees C. Also, the TMP461 supports negative temperatures with its default temperature range, which is not the case for similar chips supported by the lm90 and the tmp401 drivers. Those limitations will be addressed with follow-up patches. Fixes: 24333ac26d01 ("hwmon: (tmp401) use smb word operations instead of 2 smb byte operations") Reported-by: David T. Wilson <david.wilson title="valid: False, node: 233, tag: david.wilson, level: 233" node_number="233"> Cc: David T. Wilson <david.wilson title="valid: False, node: 234, tag: david.wilson, level: 234" node_number="234"> Signed-off-by: Guenter Roeck <linux title="valid: False, node: 235, tag: linux, level: 235" node_number="235"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 236, tag: sashal, level: 236" node_number="236"> commit fa2e149260bf90bbbe83dbc1ed9c9113d13d3afd Author: Guenter Roeck <linux title="valid: False, node: 237, tag: linux, level: 237" node_number="237"> Date: Sat Nov 6 10:02:44 2021 -0700 hwmon: (lm90) Fix usage of CONFIG2 register in detect function [ Upstream commit fce15c45d3fbd9fc1feaaf3210d8e3f8b33dfd3a ] The detect function had a comment "Make compiler happy" when id did not read the second configuration register. As it turns out, the code was checking the contents of this register for manufacturer ID 0xA1 (NXP Semiconductor/Philips), but never actually read the register. So it wasn't surprising that the compiler complained, and it indeed had a point. Fix the code to read the register contents for manufacturer ID 0xa1. At the same time, the code was reading the register for manufacturer ID 0x41 (Analog Devices), but it was not using the results. In effect it was just checking if reading the register returned an error. That doesn't really add much if any value, so stop doing that. Fixes: f90be42fb383 ("hwmon: (lm90) Refactor reading of config2 register") Signed-off-by: Guenter Roeck <linux title="valid: False, node: 238, tag: linux, level: 238" node_number="238"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 239, tag: sashal, level: 239" node_number="239"> commit ba696b470839d70c6b8290c1f798bac7fb2a584c Author: Phil Elwell <phil title="valid: False, node: 240, tag: phil, level: 240" node_number="240"> Date: Mon Dec 6 09:22:36 2021 +0000 pinctrl: bcm2835: Change init order for gpio hogs [ Upstream commit 266423e60ea1b953fcc0cd97f3dad85857e434d1 ] ...and gpio-ranges pinctrl-bcm2835 is a combined pinctrl/gpio driver. Currently the gpio side is registered first, but this breaks gpio hogs (which are configured during gpiochip_add_data). Part of the hog initialisation is a call to pinctrl_gpio_request, and since the pinctrl driver hasn't yet been registered this results in an -EPROBE_DEFER from which it can never recover. Change the initialisation sequence to register the pinctrl driver first. This also solves a similar problem with the gpio-ranges property, which is required in order for released pins to be returned to inputs. Fixes: 73345a18d464b ("pinctrl: bcm2835: Pass irqchip when adding gpiochip") Signed-off-by: Phil Elwell <phil title="valid: False, node: 241, tag: phil, level: 241" node_number="241"> Reviewed-by: Florian Fainelli <f.fainelli title="valid: False, node: 242, tag: f.fainelli, level: 242" node_number="242"> Link: https://lore.kernel.org/r/20211206092237.4105895-2-phil@raspberrypi.com Signed-off-by: Linus Walleij <linus.walleij title="valid: False, node: 243, tag: linus.walleij, level: 243" node_number="243"> Signed-off-by: Sasha Levin <sashal title="valid: False, node: 244, tag: sashal, level: 244" node_number="244"> commit 676c572439e58b7ee6b7ca3f1e5595382921045c Author: Andrea Righi <andrea.righi title="valid: False, node: 245, tag: andrea.righi, level: 245" node_number="245"> Date: Mon Nov 29 00:08:13 2021 -0800 Input: elantech - fix stack out of bound access in elantech_change_report_id() [ Upstream commit 1d72d9f960ccf1052a0630a68c3d358791dbdaaa ] The array param[] in elantech_change_report_id() must be at least 3 bytes, because elantech_read_reg_params() is calling ps2_command() with PSMOUSE_CMD_GETINFO, that is going to access 3 bytes from param[], but it's defined in the stack as an array of 2 bytes, therefore we have a potential stack out-of-bounds access here, also confirmed by KASAN: [ 6.512374] BUG: KASAN: stack-out-of-bounds in __ps2_command+0x372/0x7e0 [ 6.512397] Read of size 1 at addr ffff8881024d77c2 by task kworker/2:1/118 [ 6.512416] CPU: 2 PID: 118 Comm: kworker/2:1 Not tainted 5.13.0-22-generic #22+arighi20211110 [ 6.512428] Hardware name: LENOVO 20T8000QGE/20T8000QGE, BIOS R1AET32W (1.08 ) 08/14/2020 [ 6.512436] Workqueue: events_long serio_handle_event [ 6.512453] Call Trace: [ 6.512462] show_stack+0x52/0x58 [ 6.512474] dump_stack+0xa1/0xd3 [ 6.512487] print_address_description.constprop.0+0x1d/0x140 [ 6.512502] ? __ps2_command+0x372/0x7e0 [ 6.512516] __kasan_report.cold+0x7d/0x112 [ 6.512527] ? _raw_write_lock_irq+0x20/0xd0 [ 6.512539] ? __ps2_command+0x372/0x7e0 [ 6.512552] kasan_report+0x3c/0x50 [ 6.512564] __asan_load1+0x6a/0x70 [ 6.512575] __ps2_command+0x372/0x7e0 [ 6.512589] ? ps2_drain+0x240/0x240 [ 6.512601] ? dev_printk_emit+0xa2/0xd3 [ 6.512612] ? dev_vprintk_emit+0xc5/0xc5 [ 6.512621] ? __kasan_check_write+0x14/0x20 [ 6.512634] ? mutex_lock+0x8f/0xe0 [ 6.512643] ? __mutex_lock_slowpath+0x20/0x20 [ 6.512655] ps2_command+0x52/0x90 [ 6.512670] elantech_ps2_command+0x4f/0xc0 [psmouse] [ 6.512734] elantech_change_report_id+0x1e6/0x256 [psmouse] [ 6.512799] ? elantech_report_trackpoint.constprop.0.cold+0xd/0xd [psmouse] [ 6.512863] ? ps2_command+0x7f/0x90 [ 6.512877] elantech_query_info.cold+0x6bd/0x9ed [psmouse] [ 6.512943] ? elantech_setup_ps2+0x460/0x460 [psmouse] [ 6.513005] ? psmouse_reset+0x69/0xb0 [psmouse] [ 6.513064] ? psmouse_attr_set_helper+0x2a0/0x2a0 [psmouse] [ 6.513122] ? phys_pmd_init+0x30e/0x521 [ 6.513137] elantech_init+0x8a/0x200 [psmouse] [ 6.513200] ? elantech_init_ps2+0xf0/0xf0 [psmouse] [ 6.513249] ? elantech_query_info+0x440/0x440 [psmouse] [ 6.513296] ? synaptics_send_cmd+0x60/0x60 [psmouse] [ 6.513342] ? elantech_query_info+0x440/0x440 [psmouse] [ 6.513388] ? psmouse_try_protocol+0x11e/0x170 [psmouse] [ 6.513432] psmouse_extensions+0x65d/0x6e0 [psmouse] [ 6.513476] ? psmouse_try_protocol+0x170/0x170 [psmouse] [ 6.513519] ? mutex_unlock+0x22/0x40 [ 6.513526] ? ps2_command+0x7f/0x90 [ 6.513536] ? psmouse_probe+0xa3/0xf0 [psmouse] [ 6.513580] psmouse_switch_protocol+0x27d/0x2e0 [psmouse] [ 6.513624] psmouse_connect+0x272/0x530 [psmouse] [ 6.513669] serio_driver_probe+0x55/0x70 [ 6.513679] really_probe+0x190/0x720 [ 6.513689] driver_probe_device+0x160/0x1f0 [ 6.513697] device_driver_attach+0x119/0x130 [ 6.513705] ? device_driver_attach+0x130/0x130 [ 6.513713] __driver_attach+0xe7/0x1a0 [ 6.513720] ? device_driver_attach+0x130/0x130 [ 6.513728] bus_for_each_dev+0xfb/0x150 [ 6.513738] ? subsys_dev_iter_exit+0x10/0x10 [ 6.513748] ? _raw_write_unlock_bh+0x30/0x30 [ 6.513757] driver_attach+0x2d/0x40 [ 6.513764] serio_handle_event+0x199/0x3d0 [ 6.513775] process_one_work+0x471/0x740 [ 6.513785] worker_thread+0x2d2/0x790 [ 6.513794] ? process_one_work+0x740/0x740 [ 6.513802] kthread+0x1b4/0x1e0 [ 6.513809] ? set_kthread_struct+0x80/0x80 [ 6.513816] ret_from_fork+0x22/0x30 [ 6.513832] The buggy address belongs to the page: [ 6.513838] page:00000000bc35e189 refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1024d7 [ 6.513847] flags: 0x17ffffc0000000(node=0|zone=2|lastcpupid=0x1fffff) [ 6.513860] raw: 0017ffffc0000000 dead000000000100 dead000000000122 0000000000000000 [ 6.513867] raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000 [ 6.513872] page dumped because: kasan: bad access detected [ 6.513879] addr ffff8881024d77c2 is located in stack of task kworker/2:1/118 at offset 34 in frame: [ 6.513887] elantech_change_report_id+0x0/0x256 [psmouse] [ 6.513941] this frame has 1 object: [ 6.513947] [32, 34) 'param' [ 6.513956] Memory state around the buggy address: [ 6.513962] ffff8881024d7680: f2 f2 f2 f2 f2 00 00 f3 f3 00 00 00 00 00 00 00 [ 6.513969] ffff8881024d7700: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 6.513976] &gt;ffff8881024d7780: 00 00 00 00 f1 f1 f1 f1 02 f3 f3 f3 00 00 00 00 [ 6.513982] ^ [ 6.513988] ffff8881024d7800: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 6.513995] ffff8881024d7880: 00 f1 f1 f1 f1 03 f2 03 f2 03 f3 f3 f3 00 00 00 [ 6.514000] ================================================================== Define param[] in elantech_change_report_id() as an array of 3 bytes to prevent the out-of-bounds access in the stack. Fixes: e4c9062717fe ("Input: elantech - fix protocol errors for some trackpoints in SMBus mode") BugLink: https://bugs.launchpad.net/bugs/1945590 Signed-off-by: Andrea Righi <andrea.righi title="valid: False, node: 246, tag: andrea.righi, level: 246" node_number="246"> Reviewed-by: Wolfram Sang <wsa title="valid: False, node: 247, tag: wsa, level: 247" node_number="247"> Link: https://lore.kernel.org/r/20211116095559.24395-1-andrea.righi@canonical.com Signed-off-by: Dmitry Torokhov <dmitry.torokhov title="valid: False, node: 248, tag: dmitry.torokhov, level: 248" node_number="248"> Signed-off-by: Sasha Levin </dmitry.torokhov></wsa></andrea.righi></andrea.righi></sashal></linus.walleij></f.fainelli></phil></phil></sashal></linux></linux></sashal></linux></david.wilson></david.wilson></linux></sashal></linux></david.wilson></linux></sashal></linux></krellan></linux></gregkh></tiwai></stable></xkernel.wang></xkernel.wang></gregkh></tiwai></stable></colin.i.king></colin.king></gregkh></tiwai></stable></gregkh></tiwai></stable></bscott></bscott></gregkh></tiwai></stable></wse></wse></gregkh></martin.blumenstingl></jbrunet></geraldogabriel></christianshewitt></geraldogabriel></christianshewitt></martin.blumenstingl></gregkh></dmitry.torokhov></jose.exposito89></jose.exposito89></gregkh></cminyard></cminyard></cascardo></cascardo></gregkh></cminyard></ykaukab></tiwai></ykaukab></gregkh></cminyard></ioanna-maria.alifieraki></cminyard></cascardo></cascardo></gregkh></dave.anglin></dave.anglin></gregkh></dave.anglin></dave.anglin></gregkh></jens.wiklander></patrik.lantz></sumit.garg></larper></gregkh></jens.wiklander></gregkh></bp></dave.hansen></andrew.cooper3></andrew.cooper3></gregkh></hdegoede></gregkh></johan></johan></gregkh></pbonzini></mlevitsk></seanjc></longpeng2></seanjc></gregkh></linus.walleij></fabien.dessenne></chf.fritz></fabien.dessenne></gregkh></noralf></daniel.baluta></stable></noralf></gregkh></ulf.hansson></adrian.hunter></pshete></pshete></gregkh></ulf.hansson></martin.blumenstingl></martin.blumenstingl></gregkh></ulf.hansson></adrian.hunter></alcooperx></ulf.hansson></gregkh></ulf.hansson></linus.walleij></yann.gautier></christophe.kerello></yann.gautier></gregkh></rmk></ardb></stable></ardb></gregkh></davem></johannes.berg></johannes.berg></gregkh></torvalds></akpm></stable></naoya.horiguchi></osalvador></hulkci></liushixin2></liushixin2></gregkh></jens.wiklander></tyhicks></sumit.garg></patrik.lantz></sumit.garg></gregkh></jaegeuk></chao></wenqingliu0120></chao></gregkh></idryomov></jlayton></christian.brauner></christian.brauner></gregkh></posteuca></posteuca></gregkh></pbonzini></mlevitsk></seanjc></seanjc></gregkh></torvalds></akpm></stable></aarcange></rientjes></mgorman></mhocko></arbn></numaif.h></stdio.h></stdlib.h></assert.h></fcntl.h></sys></sys></unistd.h></arbn></gregkh></dmitry.torokhov></johnny.chuang.emc></johnny.chuang.emc></gregkh></dmitry.torokhov></hdegoede></hdegoede></gregkh></povik></povik></gregkh></derek.fang></derek.fang></gregkh></linus.walleij></wenst></zhiyong.tao></guodong.liu></guodong.liu></gregkh></linux></linux></gregkh></linux></linux></gregkh></davem></linma></nagi></linma></gregkh></davem></linma></linma></gregkh></davem></linma></linma></gregkh></davem></remi></remi></gregkh></hulkrobot></skhan></linux></sudip.mukherjee></lkft></f.fainelli></gregkh></p></body>
        <style tyle='text/css'>
body{
    position: relative;
    padding-left: 30px;
    top: 60px;
}
* {
    border: 1px solid #eee;
    padding: 5px 12px;
    margin: 3px 0;
    box-sizing: content-box;
    background-color: #fff;
    cursor: no-drop;
}
main:hover > *, section:hover > *, header:hover > *, nav:hover > *, a:hover > *, div:hover > *, p:hover > *, ul:hover > *, h1:hover > *, h2:hover > *, h3:hover > *, li:hover > *, span:hover > *{
    border: 2px solid green;
    background-color: #fffeee;
    padding: 5px 23px !important;
    margin: 1px 0;
    color: green;
}
main:hover, section:hover, header:hover, nav:hover, a:hover, div:hover, p:hover, ul:hover, h1:hover, h2:hover, h3:hover, li:hover, span:hover{
    border: 1px solid #fff;
    background-color: #eee;
}
a, span {
    display: block;
}
.selected {
    border: 2px solid orchid !important;
    opacity: 0.8;
    color: orchid !important;
}
.selected * {
    padding: 2px !important;
    color: orchid !important;
}
.valid {
  cursor: pointer;
}
.btn{
  cursor: pointer;
  font-weight: bolder;
  padding: 8px;
}
</style> 
        <script>function OpenOriginalLink($event){
    $event.stopPropagation();
    console.log(url);
}

function removeItem($event){
    $event.stopPropagation();
    console.log('Remove item: ', url)
    localStorage.removeItem(url)
}

function exportData($event){
    $event.stopPropagation();

    result = []
    for(let i=0; i<localStorage.length; i++) {
        let key = localStorage.key(i);
        result.push(localStorage.getItem(key))
    }
    const _url = URL.createObjectURL(new Blob([result.join("\n")], {type: 'text/plain'}))
    $event.target.href = _url;
    localStorage.clear()
}

var removeItemBtn = document.createElement("BUTTON");   // Create a <button> element
removeItemBtn.innerHTML = "Remove Item";
removeItemBtn.classList.add('btn');
removeItemBtn.style.position = "fixed";
removeItemBtn.style.left = '5px';
removeItemBtn.style.top = 0;
removeItemBtn.style.border = "1px solid";
removeItemBtn.style.boxShadow = "3px 3px #888";
removeItemBtn.onclick = removeItem;
document.body.appendChild(removeItemBtn);

var goToOriginLink = document.createElement("A");   // Create a <button> element
goToOriginLink.innerHTML = "GoToOrigin";
goToOriginLink.classList.add('btn');
goToOriginLink.style.position = "fixed"
goToOriginLink.style.left = '115px'
goToOriginLink.style.top = 0;
goToOriginLink.onclick = OpenOriginalLink;
goToOriginLink.setAttribute('href', decodeURIComponent(url));
goToOriginLink.target = '_blank';
document.body.appendChild(goToOriginLink);

var current = new Date
var exportDataLink = document.createElement("A");   // Create a <button> element
exportDataLink.innerHTML = "Export data";
exportDataLink.classList.add('btn');
exportDataLink.download = current.toISOString() + '.exported.txt';
exportDataLink.style.position = "fixed";
exportDataLink.style.right = '5px';
exportDataLink.style.top = 0;
exportDataLink.style.border = "1px solid #888";
exportDataLink.style.boxShadow = "3px 3px #888";
exportDataLink.onclick = exportData;
document.body.appendChild(exportDataLink);

data = {
    'title': null ,
    'article': null
}

var body = document.getElementsByTagName("body")[0];

body.onclick = function($e){
    var num = $e.target.getAttribute('node_number')
    var valid = $e.target.getAttribute('valid')

    if(!valid){
        console.log("Element is invalid")
        return
    }

    if(data.length > 2){
        data = data.splice(0, 2)
    }

    console.log("node:", $e.target)

    if(!data.title && !data.article){
        data.title = num;
        console.log("data:", data)
        $e.target.classList.add('selected')
    }else if (data.title && !data.article){
        data.article = num;
        console.log("data:", data)
        $e.target.classList.add('selected')
    }else{
        selected = Array.from(document.getElementsByClassName("selected"))
        selected.forEach(function(el){
            el.classList.remove('selected')
        })

        data.title = num;
        data.article = null;
        $e.target.classList.add('selected')

    }

    if(data.title && data.article){
        var obj = {
            url: url,
            text: body_html,
            title: data.title,
            article: data.article,
        }

        var datasetItem = JSON.stringify(obj)
        localStorage.setItem(url, datasetItem)
    }
}
</script> 
      </html>