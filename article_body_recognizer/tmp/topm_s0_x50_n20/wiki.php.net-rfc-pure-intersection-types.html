<!DOCTYPE html>
<html>
<head>

      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

        <script> var url = encodeURIComponent('https://wiki.php.net/rfc/pure-intersection-types');</script>

        <script> var body_html = 'PGJvZHkgPiA8ZGl2ID4gPGhlYWRlciA+ICA8L2hlYWRlcj4gPHNlY3Rpb24gPiA8c2VjdGlvbiA+ICA8L3NlY3Rpb24+IDxzZWN0aW9uID4gPGRpdiA+PGRpdiA+IDxkaXYgPiA8ZGl2ID48ZGl2ID4gPGRpdiA+cmZjOnB1cmUtaW50ZXJzZWN0aW9uLXR5cGVzPC9kaXY+IDxkaXYgPiA8aDEgPlBIUCBSRkM6IFB1cmUgaW50ZXJzZWN0aW9uIHR5cGVzPC9oMT4gPGRpdiA+IDx1bD4gPGxpID48ZGl2ID4gVmVyc2lvbjogMC4xPC9kaXY+IDwvbGk+IDxsaSA+PGRpdiA+IERhdGU6IDIwMjEtMDMtMjM8L2Rpdj4gPC9saT4gPGxpID48ZGl2ID4gQXV0aG9yOiBHZW9yZ2UgUGV0ZXIgQmFueWFyZCwgZ2lyZ2lhc0BwaHAubmV0PC9kaXY+IDwvbGk+IDxsaSA+PGRpdiA+IFN0YXR1czogSW1wbGVtZW50ZWQgOC4xIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9jb21taXQvMDY5YTlmYTVlNDQ3OGM3MDQ0Y2I2NDMyMjU4Y2ZlMjA3ZDEwYTIwMjwvZGl2PiA8L2xpPiA8bGkgPjxkaXYgPiBUYXJnZXQgVmVyc2lvbjogUEhQIDguMTwvZGl2PiA8L2xpPiA8bGkgPjxkaXYgPiBJbXBsZW1lbnRhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL3B1bGwvNjc5OTwvZGl2PiA8L2xpPiA8bGkgPjxkaXYgPiBGaXJzdCBQdWJsaXNoZWQgYXQ6IGh0dHA6Ly93aWtpLnBocC5uZXQvcmZjL3B1cmUtaW50ZXJzZWN0aW9uLXR5cGVzPC9kaXY+IDwvbGk+IDxsaSA+PGRpdiA+IEdpdEh1YiBtaXJyb3I6IGh0dHBzOi8vZ2l0aHViLmNvbS9HaXJnaWFzL2ludGVyc2VjdGlvbi10eXBlczwvZGl2PiA8L2xpPiA8L3VsPiA8L2Rpdj4gPGgyID5JbnRyb2R1Y3Rpb248L2gyPiA8ZGl2ID4gPHA+IEFuIOKAnGludGVyc2VjdGlvbiB0eXBl4oCdIHJlcXVpcmVzIGEgdmFsdWUgdG8gc2F0aXNmeSBtdWx0aXBsZSB0eXBlIGNvbnN0cmFpbnRzIGluc3RlYWQgb2YgYSBzaW5nbGUgb25lLiA8L3A+IDxwPiBJbnRlcnNlY3Rpb24gdHlwZXMgYXJlIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIG5hdGl2ZWx5IGJ5IHRoZSBsYW5ndWFnZS4gSW5zdGVhZCwgb25lIG11c3QgZWl0aGVyIHVzZSBwaHBkb2MgYW5ub3RhdGlvbnMsIGFuZC9vciBhYnVzZSB0eXBlZCBwcm9wZXJ0aWVzIFsxXSBhcyBjYW4gYmUgc2VlbiBpbiB0aGUgZm9sbG93aW5nIGV4YW1wbGU6IDwvcD4gPHByZSA+Y2xhc3MgVGVzdCB7IHByaXZhdGUgP1RyYXZlcnNhYmxlICR0cmF2ZXJzYWJsZSA9IG51bGw7IHByaXZhdGUgP0NvdW50YWJsZSAkY291bnRhYmxlID0gbnVsbDsgLyoqIEB2YXIgVHJhdmVyc2FibGVDb3VudGFibGUgKi8gcHJpdmF0ZSAkYm90aCA9IG51bGw7IHB1YmxpYyBmdW5jdGlvbiBfX2NvbnN0cnVjdCgkY291bnRhYmxlSXRlcmF0b3IpIHsgJHRoaXMtJmd0O3RyYXZlcnNhYmxlID0gJHRoaXMtJmd0O2JvdGg7ICR0aGlzLSZndDtjb3VudGFibGUgPSAkdGhpcy0mZ3Q7Ym90aDsgJHRoaXMtJmd0O2JvdGggPSAkY291bnRhYmxlSXRlcmF0b3I7IH0gfTwvcHJlPiA8cD4gU3VwcG9ydGluZyBpbnRlcnNlY3Rpb24gdHlwZXMgaW4gdGhlIGxhbmd1YWdlIGFsbG93cyB1cyB0byBtb3ZlIG1vcmUgdHlwZSBpbmZvcm1hdGlvbiBmcm9tIHBocGRvYyBpbnRvIGZ1bmN0aW9uIHNpZ25hdHVyZXMsIHdpdGggdGhlIHVzdWFsIGFkdmFudGFnZXMgdGhpcyBicmluZ3M6IDwvcD4gPHVsPiA8bGkgPjxkaXYgPiBUeXBlcyBhcmUgYWN0dWFsbHkgZW5mb3JjZWQsIHNvIG1pc3Rha2VzIGNhbiBiZSBjYXVnaHQgZWFybHkuPC9kaXY+IDwvbGk+IDxsaSA+PGRpdiA+IEJlY2F1c2UgdGhleSBhcmUgZW5mb3JjZWQsIHR5cGUgaW5mb3JtYXRpb24gaXMgbGVzcyBsaWtlbHkgdG8gYmVjb21lIG91dGRhdGVkIG9yIG1pc3MgZWRnZS1jYXNlcy48L2Rpdj4gPC9saT4gPGxpID48ZGl2ID4gVHlwZXMgYXJlIGNoZWNrZWQgZHVyaW5nIGluaGVyaXRhbmNlLCBlbmZvcmNpbmcgdGhlIExpc2tvdiBTdWJzdGl0dXRpb24gUHJpbmNpcGxlLjwvZGl2PiA8L2xpPiA8bGkgPjxkaXYgPiBUeXBlcyBhcmUgYXZhaWxhYmxlIHRocm91Z2ggUmVmbGVjdGlvbi48L2Rpdj4gPC9saT4gPGxpID48ZGl2ID4gVGhlIHN5bnRheCBpcyBhIGxvdCBsZXNzIGJvaWxlcnBsYXRlLXkgdGhhbiBwaHBkb2MuPC9kaXY+IDwvbGk+IDwvdWw+IDwvZGl2PiA8aDIgPk1vdGl2YXRpb248L2gyPiA8ZGl2ID4gPHA+IEl0IGlzIHBvc3NpYmxlIHRvIGVtdWxhdGUgaW50ZXJzZWN0aW9uIHR5cGVzIGJ5IGNyZWF0aW5nIGEgbmV3IGludGVyZmFjZSB3aGljaCBpbmhlcml0cyBmcm9tIG11bHRpcGxlIG9uZXMsIG9uZSBzdWNoIGNhc2UgaXMgdGhlIGJ1aWx0IGluIDxjb2RlPlNlZWthYmxlSXRlcmF0b3I8L2NvZGU+IHdoaWNoIGV4dGVuZHMgdGhlIDxjb2RlPkl0ZXJhdG9yPC9jb2RlPiBpbnRlcmZhY2UgYnkgYWRkaW5nIGEgPGNvZGU+c2VlaygpPC9jb2RlPiBtZXRob2Qgb24gaXQuIEhvd2V2ZXIsIGFuIGl0ZXJhdG9yIGNhbiBhbHNvIGJlIGNvdW50YWJsZSwgYW4gaWYgYSBmdW5jdGlvbiBuZWVkcyB0byB0eXBlIGFnYWluc3Qgc3VjaCBhIHJlcXVpcmVtZW50IHRoZSBvbmx5IHBvc3NpYmxlIHdheSBpcyB0byBjdXJyZW50bHkgY3JlYXRlIGEgbmV3IGludGVyZmFjZTogPC9wPiA8cHJlID5pbnRlcmZhY2UgQ291bnRhYmxlSXRlcmF0b3IgZXh0ZW5kcyBJdGVyYXRvciwgQ291bnRhYmxlIHt9PC9wcmU+IDxwPiBUaGlzIHdvcmtzLCBidXQgd2hhdCBpZiB3ZSB3YW50IGFuIGl0ZXJhdG9yIHRoYXQgaXMgY291bnRhYmxlIGFuZCBzZWVrYWJsZT8gV2UgbmVlZCB0byBjcmVhdGUgYW5vdGhlciBpbnRlcmZhY2U6IDwvcD4gPHByZSA+aW50ZXJmYWNlIFNlZWthYmxlQ291bnRhYmxlSXRlcmF0b3IgZXh0ZW5kcyBDb3VudGFibGVJdGVyYXRvciwgU2Vla2FibGVJdGVyYXRvciB7fTwvcHJlPiA8cD4gQXMgc3VjaCwgZWFjaCBuZXcgcmVxdWlyZW1lbnQgbmVjZXNzaXRhdGVzIHRoZSBjcmVhdGlvbiBvZiB2YXJpb3VzIG5ldyBpbnRlcmZhY2VzIHRha2luZyBpbnRvIGFjY291bnQgYWxsIHBvc3NpYmxlIGNvbWJpbmF0aW9ucy4gPC9wPiA8cD4gTW9yZW92ZXIsIHRoZSBjbGFzcyBuZWVkcyB0byBpbXBsZW1lbnQgdGhlIHNwZWNpZmljIGludGVyZmFjZSBhbmQgY2Fubm90IHJlbHkgb24ganVzdCBpbXBsZW1lbnRpbmcgdGhlIGJhc2UgaW50ZXJmYWNlcywgbWVhbmluZyB0aGUgaW50cm9kdWN0aW9uIG9mIHN1Y2ggaW50ZXJmYWNlcyBuZWVkIHRvIGJlIHByb3BhZ2F0ZWQgdG8gYWxsIHJlbGV2YW50IGNsYXNzZXMsIHNvbWV0aGluZyB3aGljaCBjYW4gYmUgZXJyb3IgcHJvbmUuIFNlZSB0aGlzIG5vbi1leGFtcGxlOiA8L3A+IDxwcmUgPmludGVyZmFjZSBBIHt9IGludGVyZmFjZSBCIHt9IGludGVyZmFjZSBBQiBleHRlbmRzIEEsIEIge30gY2xhc3MgVGVzdCBpbXBsZW1lbnRzIEEsIEIge30gZnVuY3Rpb24gZm9vKEFCICR2KSB7IHZhcl9kdW1wKCR2KTsgfSBmb28obmV3IFRlc3QoKSk7PC9wcmU+IDxwPiBJbnRlcnNlY3Rpb24gdHlwZXMgc29sdmUgdGhlc2UgaXNzdWVzLiA8L3A+IDwvZGl2PiA8aDIgPlByb3Bvc2FsPC9oMj4gPGRpdiA+IDxwPiBBZGQgc3VwcG9ydCBmb3IgcHVyZSBpbnRlcnNlY3Rpb24gdHlwZXMgYXJlIHNwZWNpZmllZCB1c2luZyB0aGUgc3ludGF4IDxjb2RlPlQxVDIuLi48L2NvZGU+IGFuZCBjYW4gYmUgdXNlZCBpbiBhbGwgcG9zaXRpb25zIHdoZXJlIHR5cGVzIGFyZSBjdXJyZW50bHkgYWNjZXB0ZWQ6IDwvcD4gPHByZSA+Y2xhc3MgQSB7IHByaXZhdGUgVHJhdmVyc2FibGVDb3VudGFibGUgJGNvdW50YWJsZUl0ZXJhdG9yOyBwdWJsaWMgZnVuY3Rpb24gc2V0SXRlcmF0b3IoVHJhdmVyc2FibGVDb3VudGFibGUgJGNvdW50YWJsZUl0ZXJhdG9yKTogdm9pZCB7ICR0aGlzLSZndDtjb3VudGFibGVJdGVyYXRvciA9ICRjb3VudGFibGVJdGVyYXRvcjsgfSBwdWJsaWMgZnVuY3Rpb24gZ2V0SXRlcmF0b3IoKTogVHJhdmVyc2FibGVDb3VudGFibGUgeyByZXR1cm4gJHRoaXMtJmd0O2NvdW50YWJsZUl0ZXJhdG9yOyB9IH08L3ByZT4gPHA+IFRoaXMgbWVhbnMgaXQgd291bGQgbm90IGJlIHBvc3NpYmxlIHRvIG1peCBpbnRlcnNlY3Rpb24gYW5kIHVuaW9uIHR5cGVzIHRvZ2V0aGVyIHN1Y2ggYXMgPGNvZGU+QUJ8QzwvY29kZT4sIHRoaXMgaXMgbGVmdCBhcyBhIGZ1dHVyZSBzY29wZS4gPC9wPiA8L2Rpdj4gPGgzID5TdXBwb3J0ZWQgdHlwZXM8L2gzPiA8ZGl2ID4gPHA+IE9ubHkgY2xhc3MgdHlwZXMgKGludGVyZmFjZXMgYW5kIGNsYXNzIG5hbWVzKSBhcmUgc3VwcG9ydGVkIGJ5IGludGVyc2VjdGlvbiB0eXBlcy4gPC9wPiA8cD4gVGhlIHJhdGlvbmFsZSBpcyB0aGF0IGZvciBuZWFybHkgYWxsIHN0YW5kYXJkIHR5cGVzIHVzaW5nIHRoZW0gaW4gYW4gaW50ZXJzZWN0aW9uIHR5cGUgcmVzdWx0IGluIGEgdHlwZSB3aGljaCBjYW4gbmV2ZXIgYmUgc2F0aXNmaWVkIChlLmcuIDxjb2RlPmludHN0cmluZzwvY29kZT4pLiA8L3A+IDxwPiBVc2FnZSBvZiA8Y29kZT5taXhlZDwvY29kZT4gaW4gYW4gaW50ZXJzZWN0aW9uIHR5cGUgaXMgcmVkdW5kYW50IGFzIDxjb2RlPm1peGVkVDwvY29kZT4gY29ycmVzcG9uZHMgdG8gPGNvZGU+VDwvY29kZT4sIGFzIHN1Y2ggdGhpcyBpcyBkaXNhbGxvd2VkLiA8L3A+IDxwPiBTaW1pbGFybHkgdXNpbmcgPGNvZGU+aXRlcmFibGU8L2NvZGU+IGluIGFuIGludGVyc2VjdGlvbiByZXN1bHRzIGluIGEgcmVkdW5kYW50IGludmFsaWQgdHlwZSwgdGhpcyBjYW4gYmUgc2VlbiBieSBleHBhbmRpbmcgdGhlIHR5cGUgZXhwcmVzc2lvbiA8Y29kZT5pdGVyYWJsZVQgPSAoYXJyYXl8VHJhdmVyc2FibGUpVCA9IChhcnJheVQpIHwgKFRyYXZlcnNhYmxlVCkgPSBUcmF2ZXJzYWJsZVQ8L2NvZGU+IDwvcD4gPHA+IEFsdGhvdWdoIGFuIGludGVyc2VjdGlvbiB3aXRoIDxjb2RlPmNhbGxhYmxlPC9jb2RlPiBjYW4gbWFrZSBzZW5zZSAoZS5nLiBzdHJpbmdjYWxsYWJsZSksIHdlIHRoaW5rIGl0IGlzIHVud2lzZSBhbmQgcG9pbnRzIHRvIGEgYnVnLiA8L3A+IDxwPiBTaW1pbGFybHkgPGNvZGU+cGFyZW50PC9jb2RlPiwgPGNvZGU+c2VsZjwvY29kZT4sIGFuZCA8Y29kZT5zdGF0aWM8L2NvZGU+IGFyZSB0ZWNobmljYWxseSBmZWFzaWJsZSBhbmQgY291bGQgYmUgdXNlZCBhcyBwYXJ0IG9mIGFuIGludGVyc2VjdGlvbiwgYnV0IGltcG9zZSBzdHJhbmdlIHJlc3RyaWN0aW9ucyBvbiBhIGNoaWxkIGNsYXNzIHdoaWNoIHRoZSBiYXNlIGNsYXNzIHZpb2xhdGVzIG9yIHRoZSBiYXNlIGNsYXNzIGFscmVhZHkgc2F0aXNmaWVzIHRoZSB0eXBlIHJlcXVpcmVtZW50cyBpbiB3aGljaCBjYXNlIGl0IGlzIHJlZHVuZGFudC4gVGhlcmVmb3JlIHRob3NlIDMgdHlwZXMgYXJlIGFsc28gZm9yYmlkZGVuIGJlY2F1c2UgdGhleSBsaWtlbHkgcG9pbnQgdG8gYSBkZXNpZ24gaXNzdWUuIDwvcD4gPC9kaXY+IDxoNCA+RHVwbGljYXRlIGFuZCByZWR1bmRhbnQgdHlwZXM8L2g0PiA8ZGl2ID4gPHA+IFRvIGNhdGNoIHNvbWUgc2ltcGxlIGJ1Z3MgaW4gaW50ZXJzZWN0aW9uIHR5cGUgZGVjbGFyYXRpb25zLCByZWR1bmRhbnQgdHlwZXMgdGhhdCBjYW4gYmUgZGV0ZWN0ZWQgd2l0aG91dCBwZXJmb3JtaW5nIGNsYXNzIGxvYWRpbmcgd2lsbCByZXN1bHQgaW4gYSBjb21waWxlLXRpbWUgZXJyb3IuIFRoaXMgaW5jbHVkZXM6IDwvcD4gPHVsPiA8bGkgPjxkaXYgPiBFYWNoIG5hbWUtcmVzb2x2ZWQgdHlwZSBtYXkgb25seSBvY2N1ciBvbmNlLiBUeXBlcyBsaWtlIDxjb2RlPkFCQTwvY29kZT4gcmVzdWx0IGluIGFuIGVycm9yLjwvZGl2PiA8L2xpPiA8L3VsPiA8cD4gVGhpcyBkb2VzIG5vdCBndWFyYW50ZWUgdGhhdCB0aGUgdHlwZSBpcyDigJxtaW5pbWFs4oCdLCBiZWNhdXNlIGRvaW5nIHNvIHdvdWxkIHJlcXVpcmUgbG9hZGluZyBhbGwgdXNlZCBjbGFzcyB0eXBlcy4gPC9wPiA8cD4gRm9yIGV4YW1wbGUsIGlmIDxjb2RlPkE8L2NvZGU+IGFuZCA8Y29kZT5CPC9jb2RlPiBhcmUgcnVudGltZSBjbGFzcyBhbGlhc2VzLCB0aGVuIDxjb2RlPkFCPC9jb2RlPiByZW1haW5zIGEgbGVnYWwgaW50ZXJzZWN0aW9uIHR5cGUsIGV2ZW4gdGhvdWdoIGl0IGNvdWxkIGJlIHJlZHVjZWQgdG8gZWl0aGVyIDxjb2RlPkE8L2NvZGU+IG9yIDxjb2RlPkI8L2NvZGU+LiBTaW1pbGFybHksIGlmIDxjb2RlPmNsYXNzIEIgZXh0ZW5kcyBBIHt9PC9jb2RlPiwgdGhlbiA8Y29kZT5BQjwvY29kZT4gaXMgYWxzbyBhIGxlZ2FsIGludGVyc2VjdGlvbiB0eXBlLCBldmVuIHRob3VnaCBpdCBjb3VsZCBiZSByZWR1Y2VkIHRvIGp1c3QgPGNvZGU+QjwvY29kZT4uIDwvcD4gPHByZSA+ZnVuY3Rpb24gZm9vKCk6IEFBIHt9IC8vIERpc2FsbG93ZWQgdXNlIEEgYXMgQjsgZnVuY3Rpb24gZm9vKCk6IEFCIHt9IC8vIERpc2FsbG93ZWQgKCJ1c2UiIGlzIHBhcnQgb2YgbmFtZSByZXNvbHV0aW9uKSBjbGFzc19hbGlhcygnWCcsICdZJyk7IGZ1bmN0aW9uIGZvbygpOiBYWSB7fSAvLyBBbGxvd2VkIChyZWR1bmRhbmN5IGlzIG9ubHkga25vd24gYXQgcnVudGltZSk8L3ByZT4gPC9kaXY+IDxoNCA+VHlwZSBncmFtbWFyPC9oND4gPGRpdiA+IDxwPiBEdWUgdG8gYSBwYXJzZXIgYW1iaWd1aXR5IHdpdGggdGhlIGRlY2xhcmF0aW9uIG9mIGJ5LXJlZiBwYXJhbWV0ZXIgd2hpbGUgdXNpbmcgdGhlIGN1cnJlbnQgTFIoMSkgcGFyc2VyLCB0aGUgZ3JhbW1hciBhbmQgbGV4ZXIgYXJlIG1vZGlmaWVkIHRvIGNyZWF0ZSBkaWZmZXJlbnQgdG9rZW5zIGZvciB0aGUgPGNvZGU+PC9jb2RlPiBjaGFyYWN0ZXIgZGVwZW5kaW5nIGlmIGl0IGlzIGZvbGxvd2VkIGJ5IGEgKHZhcmlhZGljKSB2YXJpYWJsZSBvciBub3QuIDwvcD4gPHA+IFRoZSBncmFtbWFyIHRodXMgbG9va3MgYXMgZm9sbG93aW5nOiA8L3A+IDxwcmUgPnR5cGVfZXhwcjogdHlwZSB8ICc/JyB0eXBlIHwgdW5pb25fdHlwZSB8IGludGVyc2VjdGlvbl90eXBlIDsgaW50ZXJzZWN0aW9uX3R5cGU6IHR5cGUgVF9BTVBFUlNBTkRfTk9UX0ZPTExPV0VEX0JZX1ZBUl9PUl9WQVJBUkcgdHlwZSB8IGludGVyc2VjdGlvbl90eXBlIFRfQU1QRVJTQU5EX05PVF9GT0xMT1dFRF9CWV9WQVJfT1JfVkFSQVJHIHR5cGUgOyA8L3ByZT4gPC9kaXY+IDxoMyA+VmFyaWFuY2U8L2gzPiA8ZGl2ID4gPHA+IEludGVyc2VjdGlvbiB0eXBlcyBmb2xsb3cgc3RhbmRhcmQgUEhQIHZhcmlhbmNlIHJ1bGVzIHRoYXQgYXJlIGFscmVhZHkgdXNlZCBmb3IgaW5oZXJpdGFuY2UgYW5kIHR5cGUgY2hlY2tpbmc6IDwvcD4gPHVsPiA8bGkgPjxkaXYgPiBSZXR1cm4gdHlwZXMgYXJlIGNvdmFyaWFudCAoY2hpbGQgbXVzdCBiZSBzdWJ0eXBlKS48L2Rpdj4gPC9saT4gPGxpID48ZGl2ID4gUGFyYW1ldGVyIHR5cGVzIGFyZSBjb250cmF2YXJpYW50IChjaGlsZCBtdXN0IGJlIHN1cGVydHlwZSkuPC9kaXY+IDwvbGk+IDxsaSA+PGRpdiA+IFByb3BlcnR5IHR5cGVzIGFyZSBpbnZhcmlhbnQgKGNoaWxkIG11c3QgYmUgc3VidHlwZSBhbmQgc3VwZXJ0eXBlKS48L2Rpdj4gPC9saT4gPC91bD4gPHA+IFRoZSBvbmx5IGNoYW5nZSBpcyBpbiBob3cgaW50ZXJzZWN0aW9uIHR5cGVzIGludGVyYWN0IHdpdGggc3VidHlwaW5nLCB3aXRoIHR3byBhZGRpdGlvbmFsIHJ1bGVzOiA8L3A+IDx1bD4gPGxpID48ZGl2ID4gPGNvZGU+QTwvY29kZT4gaXMgYSBzdWJ0eXBlIG9mIDxjb2RlPkJfMS4uLkJfbjwvY29kZT4gaWYgZm9yIGFsbCA8Y29kZT5CX2k8L2NvZGU+LCA8Y29kZT5BPC9jb2RlPiBpcyBhIHN1YnR5cGUgb2YgPGNvZGU+Ql9pPC9jb2RlPjwvZGl2PiA8L2xpPiA8bGkgPjxkaXYgPiA8Y29kZT5BXzEuLi5BX248L2NvZGU+IGlzIGEgc3VidHlwZSBvZiA8Y29kZT5CPC9jb2RlPiBpZiB0aGVyZSBleGlzdHMgYW4gPGNvZGU+QV9pPC9jb2RlPiBzdWNoIHRoYXQgPGNvZGU+QV9pPC9jb2RlPiBpcyBhIHN1YnR5cGUgb2YgPGNvZGU+QjwvY29kZT48L2Rpdj4gPC9saT4gPC91bD4gPHA+IEluIHRoZSBmb2xsb3dpbmcsIHNvbWUgZXhhbXBsZXMgb2Ygd2hhdCBpcyBhbGxvd2VkIGFuZCB3aGF0IGlzbid0IGFyZSBnaXZlbi4gPC9wPiA8L2Rpdj4gPGg0ID5Qcm9wZXJ0eSB0eXBlczwvaDQ+IDxkaXYgPiA8cD4gUHJvcGVydHkgdHlwZXMgYXJlIGludmFyaWFudCwgd2hpY2ggbWVhbnMgdGhhdCB0eXBlcyBtdXN0IHN0YXkgdGhlIHNhbWUgZHVyaW5nIGluaGVyaXRhbmNlLiBIb3dldmVyLCB0aGUg4oCcc2FtZeKAnSB0eXBlIG1heSBiZSBleHByZXNzZWQgaW4gZGlmZmVyZW50IHdheXMuIDwvcD4gPHA+IEludGVyc2VjdGlvbiB0eXBlcyBleHBhbmQgdGhlIHBvc3NpYmlsaXRpZXMgaW4gdGhpcyBhcmVhOiBGb3IgZXhhbXBsZSA8Y29kZT5BQjwvY29kZT4gYW5kIDxjb2RlPkJBPC9jb2RlPiByZXByZXNlbnQgdGhlIHNhbWUgdHlwZS4gVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGEgbW9yZSBjb21wbGV4IGNhc2U6IDwvcD4gPHByZSA+Y2xhc3MgQSB7fSBjbGFzcyBCIGV4dGVuZHMgQSB7fSBjbGFzcyBUZXN0IHsgcHVibGljIEFCICRwcm9wOyB9IGNsYXNzIFRlc3QyIGV4dGVuZHMgVGVzdCB7IHB1YmxpYyBCICRwcm9wOyB9PC9wcmU+IDxwPiBJbiB0aGlzIGV4YW1wbGUsIHRoZSBpbnRlcnNlY3Rpb24gPGNvZGU+QUI8L2NvZGU+IGFjdHVhbGx5IHJlcHJlc2VudHMgdGhlIHNhbWUgdHlwZSBhcyBqdXN0IDxjb2RlPkI8L2NvZGU+LCBhbmQgdGhpcyBpbmhlcml0YW5jZSBpcyBsZWdhbCwgZGVzcGl0ZSB0aGUgdHlwZSBub3QgYmVpbmcgc3ludGFjdGljYWxseSB0aGUgc2FtZS4gPC9wPiA8cD4gRm9ybWFsbHksIHdlIGFycml2ZSBhdCB0aGlzIHJlc3VsdCBhcyBmb2xsb3dzOiBGaXJzdCwgdGhlIHBhcmVudCB0eXBlIDxjb2RlPkFCPC9jb2RlPiBpcyBhIHN1YnR5cGUgb2YgPGNvZGU+QjwvY29kZT4uIFNlY29uZCwgPGNvZGU+QjwvY29kZT4gaXMgYSBzdWJ0eXBlIG9mIDxjb2RlPkFCPC9jb2RlPiwgYmVjYXVzZSA8Y29kZT5CPC9jb2RlPiBpcyBhIHN1YnR5cGUgb2YgPGNvZGU+QTwvY29kZT4gYW5kIDxjb2RlPkI8L2NvZGU+IGlzIGEgc3VidHlwZSBvZiA8Y29kZT5CPC9jb2RlPi4gPC9wPiA8L2Rpdj4gPGg0ID5BZGRpbmcgYW5kIHJlbW92aW5nIGludGVyc2VjdGlvbiB0eXBlczwvaDQ+IDxkaXYgPiA8cD4gSXQgaXMgbGVnYWwgdG8gYWRkIGludGVyc2VjdGlvbiB0eXBlcyBpbiByZXR1cm4gcG9zaXRpb24gYW5kIHJlbW92ZSBpbnRlcnNlY3Rpb24gdHlwZXMgaW4gcGFyYW1ldGVyIHBvc2l0aW9uOiA8L3A+IDxwcmUgPmNsYXNzIEEge30gaW50ZXJmYWNlIFgge30gY2xhc3MgVGVzdCB7IHB1YmxpYyBmdW5jdGlvbiBwYXJhbTEoQSAkcGFyYW0pIHt9IHB1YmxpYyBmdW5jdGlvbiBwYXJhbTIoQVggJHBhcmFtKSB7fSBwdWJsaWMgZnVuY3Rpb24gcmV0dXJuMSgpOiBBWCB7fSBwdWJsaWMgZnVuY3Rpb24gcmV0dXJuMigpOiBBIHt9IH0gY2xhc3MgVGVzdDIgZXh0ZW5kcyBUZXN0IHsgcHVibGljIGZ1bmN0aW9uIHBhcmFtMShBWCAkcGFyYW0pIHt9IC8vIEZPUkJJRERFTjogQWRkaW5nIGV4dHJhIHBhcmFtIHR5cGUgY29uc3RyYWludCBwdWJsaWMgZnVuY3Rpb24gcGFyYW0yKEEgJHBhcmFtKSB7fSAvLyBBbGxvd2VkOiBSZW1vdmluZyBwYXJhbSB0eXBlIGNvbnN0cmFpbnQgcHVibGljIGZ1bmN0aW9uIHJldHVybjEoKTogQSB7fSAvLyBGT1JCSURERU46IFJlbW92aW5nIHJldHVybiB0eXBlIGNvbnN0cmFpbnQgcHVibGljIGZ1bmN0aW9uIHJldHVybjIoKTogQVgge30gLy8gQWxsb3dlZDogQWRkaW5nIGV4dHJhIHJldHVybiB0eXBlIGNvbnN0cmFpbnQgfTwvcHJlPiA8L2Rpdj4gPGg0ID5WYXJpYW5jZSBvZiBpbmRpdmlkdWFsIGludGVyc2VjdGlvbiBtZW1iZXJzPC9oND4gPGRpdiA+IDxwPiBTaW1pbGFybHksIGl0IGlzIHBvc3NpYmxlIHRvIHJlc3RyaWN0IGFuIGludGVyc2VjdGlvbiBtZW1iZXIgaW4gcmV0dXJuIHBvc2l0aW9uLCBvciB3aWRlbiBhbiBpbnRlcnNlY3Rpb24gbWVtYmVyIGluIHBhcmFtZXRlciBwb3NpdGlvbjogPC9wPiA8cHJlID5jbGFzcyBBIHt9IGNsYXNzIEIgZXh0ZW5kcyBBIHt9IGludGVyZmFjZSBYIHt9IGNsYXNzIFRlc3QgeyBwdWJsaWMgZnVuY3Rpb24gcGFyYW0xKEJYICRwYXJhbSkge30gcHVibGljIGZ1bmN0aW9uIHBhcmFtMihBWCAkcGFyYW0pIHt9IHB1YmxpYyBmdW5jdGlvbiByZXR1cm4xKCk6IEFYIHt9IHB1YmxpYyBmdW5jdGlvbiByZXR1cm4yKCk6IEJYIHt9IH0gY2xhc3MgVGVzdDIgZXh0ZW5kcyBUZXN0IHsgcHVibGljIGZ1bmN0aW9uIHBhcmFtMShBWCAkcGFyYW0pIHt9IC8vIEFsbG93ZWQ6IFdpZGVuaW5nIGludGVyc2VjdGlvbiBtZW1iZXIgQiAtJmd0OyBBIHB1YmxpYyBmdW5jdGlvbiBwYXJhbTIoQlggJHBhcmFtKSB7fSAvLyBGT1JCSURERU46IFJlc3RyaWN0aW5nIGludGVyc2VjdGlvbiBtZW1iZXIgQSAtJmd0OyBCIHB1YmxpYyBmdW5jdGlvbiByZXR1cm4xKCk6IEJYIHt9IC8vIEFsbG93ZWQ6IFJlc3RyaWN0aW5nIGludGVyc2VjdGlvbiBtZW1iZXIgQSAtJmd0OyBCIHB1YmxpYyBmdW5jdGlvbiByZXR1cm4yKCk6IEFYIHt9IC8vIEZPUkJJRERFTjogV2lkZW5pbmcgaW50ZXJzZWN0aW9uIG1lbWJlciBCIC0mZ3Q7IEEgfTwvcHJlPiA8cD4gT2YgY291cnNlLCB0aGUgc2FtZSBjYW4gYWxzbyBiZSBkb25lIHdpdGggbXVsdGlwbGUgaW50ZXJzZWN0aW9uIG1lbWJlcnMgYXQgYSB0aW1lLCBhbmQgYmUgY29tYmluZWQgd2l0aCB0aGUgYWRkaXRpb24vcmVtb3ZhbCBvZiB0eXBlcyBtZW50aW9uZWQgcHJldmlvdXNseS4gPC9wPiA8L2Rpdj4gPGg0ID5WYXJpYW5jZSBvZiBpbnRlcnNlY3Rpb24gdHlwZSB0byBjb25jcmV0ZSBjbGFzcyB0eXBlPC9oND4gPGRpdiA+IDxwPiBBcyB0aGUgcHJpbWFyeSB1c2Ugb2YgaW50ZXJzZWN0aW9uIHR5cGVzIGlzIHRvIGVuc3VyZSBtdWx0aXBsZSBpbnRlcmZhY2VzIGFyZSBpbXBsZW1lbnRlZCwgYSBjb25jcmV0ZSBjbGFzcyBvciBpbnRlcmZhY2Ugd2hpY2ggaW1wbGVtZW50cyBhbGwgdGhlIGludGVyZmFjZXMgcHJlc2VudCBpbiB0aGUgaW50ZXJzZWN0aW9uIGlzIGNvbnNpZGVyZWQgYSBzdWJ0eXBlIGFuZCB0aHVzIGNhbiBiZSB1c2VkIHdoZXJlIGNvLXZhcmlhbmNlIGlzIGFsbG93ZWQuIDwvcD4gPHByZSA+aW50ZXJmYWNlIFgge30gaW50ZXJmYWNlIFkge30gY2xhc3MgVGVzdE9uZSBpbXBsZW1lbnRzIFgsIFkge30gaW50ZXJmYWNlIEEgeyBwdWJsaWMgZnVuY3Rpb24gZm9vKCk6IFhZOyB9IGludGVyZmFjZSBCIGV4dGVuZHMgQSB7IHB1YmxpYyBmdW5jdGlvbiBmb28oKTogVGVzdE9uZTsgfTwvcHJlPiA8cD4gTW9yZW92ZXIsIGl0IGlzIHBvc3NpYmxlIHRvIHVzZSBhIHVuaW9uIHR5cGUgb2YgY29uY3JldGUgY2xhc3Nlcy9pbnRlcmZhY2Ugd2hlbiBlYWNoIG9mIHRoZSBtZW1iZXIgb2YgdGhlIHVuaW9uIGltcGxlbWVudCBhbGwgb2YgdGhlIGludGVyZmFjZXMgaW4gdGhlIGludGVyc2VjdGlvbi4gPC9wPiA8cHJlID5jbGFzcyBUZXN0VHdvIGltcGxlbWVudHMgWCwgWSB7fSBpbnRlcmZhY2UgQyBleHRlbmRzIEEgeyBwdWJsaWMgZnVuY3Rpb24gZm9vKFhZICRwYXJhbSk6IFRlc3RPbmV8VGVzdFR3bzsgfTwvcHJlPiA8cD4gVGhlIHJlYXNvbiB3aHkgdGhpcyBpcyBwb3NzaWJsZSBpcyB0aGF0IGEgdW5pb24gb2YgY29uY3JldGUgY2xhc3Nlcy9pbnRlcmZhY2VzIGlzIGxlc3MgZ2VuZXJhbCB0aGVuIHRoZSBzZXQgb2YgcG9zc2libGUgY2xhc3NlcyB3aGljaCBzYXRpc2Z5IHRoZSBpbnRlcnNlY3Rpb24gdHlwZS4gPC9wPiA8L2Rpdj4gPGgzID5Db2VyY2l2ZSB0eXBpbmcgbW9kZTwvaDM+IDxkaXYgPiA8cD4gQXMgc3RhbmRhcmQgdHlwZXMgYXJlIG5vdCBhbGxvd2VkIGluIHB1cmUgaW50ZXJzZWN0aW9uIHR5cGVzLCBubyBjb25zaWRlcmF0aW9uIGZvciB0aGUgY29lcmNpdmUgdHlwaW5nIG1vZGUgbmVlZHMgdG8gZG9uZS4gPC9wPiA8L2Rpdj4gPGgzID5Qcm9wZXJ0eSB0eXBlcyBhbmQgcmVmZXJlbmNlczwvaDM+IDxkaXYgPiA8cD4gUmVmZXJlbmNlcyB0byB0eXBlZCBwcm9wZXJ0aWVzIHdpdGggaW50ZXJzZWN0aW9uIHR5cGVzIGZvbGxvdyB0aGUgc2VtYW50aWNzIG91dGxpbmVkIGluIHRoZSB0eXBlZCBwcm9wZXJ0aWVzIFJGQzogPC9wPiA8YmxvY2txdW90ZT48ZGl2ID4gSWYgdHlwZWQgcHJvcGVydGllcyBhcmUgcGFydCBvZiB0aGUgcmVmZXJlbmNlIHNldCwgdGhlbiB0aGUgdmFsdWUgaXMgY2hlY2tlZCBhZ2FpbnN0IGVhY2ggcHJvcGVydHkgdHlwZS4gSWYgYSB0eXBlIGNoZWNrIGZhaWxzLCBhIFR5cGVFcnJvciBpcyBnZW5lcmF0ZWQgYW5kIHRoZSB2YWx1ZSBvZiB0aGUgcmVmZXJlbmNlIHJlbWFpbnMgdW5jaGFuZ2VkLjwvZGl2PjwvYmxvY2txdW90ZT4gPHByZSA+aW50ZXJmYWNlIFgge30gaW50ZXJmYWNlIFkge30gaW50ZXJmYWNlIFoge30gY2xhc3MgQSBpbXBsZW1lbnRzIFgsIFksIFoge30gY2xhc3MgQiBpbXBsZW1lbnRzIFgsIFkge30gY2xhc3MgVGVzdCB7IHB1YmxpYyBYWSAkeTsgcHVibGljIFhaICR6OyB9ICR0ZXN0ID0gbmV3IFRlc3Q7ICRyID0gbmV3IEE7ICR0ZXN0LSZndDt5ID0gJHI7ICR0ZXN0LSZndDt6ID0gJHI7IC8vIFJlZmVyZW5jZSBzZXQ6IHsgJHIsICR0ZXN0LSZndDt5LCAkdGVzdC0mZ3Q7eiB9IC8vIFR5cGVzOiB7IEEsIFhZLCBYWiB9ICRyID0gbmV3IEI7IC8vIFR5cGVFcnJvcjogQ2Fubm90IGFzc2lnbiBCIHRvIHJlZmVyZW5jZSBoZWxkIGJ5IHByb3BlcnR5IFRlc3Q6OiR6IG9mIHR5cGUgWFo8L3ByZT4gPC9kaXY+IDxoMyA+UmVmbGVjdGlvbjwvaDM+IDxkaXYgPiA8cD4gVG8gc3VwcG9ydCBpbnRlcnNlY3Rpb24gdHlwZXMsIGEgbmV3IGNsYXNzIDxjb2RlPlJlZmxlY3Rpb25JbnRlcnNlY3Rpb25UeXBlPC9jb2RlPiBpcyBhZGRlZDogPC9wPiA8cHJlID5jbGFzcyBSZWZsZWN0aW9uSW50ZXJzZWN0aW9uVHlwZSBleHRlbmRzIFJlZmxlY3Rpb25UeXBlIHsgLyoqIEByZXR1cm4gUmVmbGVjdGlvblR5cGVbXSAqLyBwdWJsaWMgZnVuY3Rpb24gZ2V0VHlwZXMoKTsgLyogSW5oZXJpdGVkIGZyb20gUmVmbGVjdGlvblR5cGUgKi8gLyoqIEByZXR1cm4gYm9vbCAqLyBwdWJsaWMgZnVuY3Rpb24gYWxsb3dzTnVsbCgpOyAvKiBJbmhlcml0ZWQgZnJvbSBSZWZsZWN0aW9uVHlwZSAqLyAvKiogQHJldHVybiBzdHJpbmcgKi8gcHVibGljIGZ1bmN0aW9uIF9fdG9TdHJpbmcoKTsgfTwvcHJlPiA8cD4gVGhlIDxjb2RlPmdldFR5cGVzKCk8L2NvZGU+IG1ldGhvZCByZXR1cm5zIGFuIGFycmF5IG9mIDxjb2RlPlJlZmxlY3Rpb25UeXBlPC9jb2RlPnMgdGhhdCBhcmUgcGFydCBvZiB0aGUgaW50ZXJzZWN0aW9uLiBUaGUgdHlwZXMgbWF5IGJlIHJldHVybmVkIGluIGFuIGFyYml0cmFyeSBvcmRlciB0aGF0IGRvZXMgbm90IG1hdGNoIHRoZSBvcmlnaW5hbCB0eXBlIGRlY2xhcmF0aW9uLiBUaGUgdHlwZXMgbWF5IGFsc28gYmUgc3ViamVjdCB0byBlcXVpdmFsZW5jZSB0cmFuc2Zvcm1hdGlvbnMuIDwvcD4gPHA+IEZvciBleGFtcGxlLCB0aGUgdHlwZSA8Y29kZT5YWTwvY29kZT4gbWF5IHJldHVybiB0eXBlcyBpbiB0aGUgb3JkZXIgPGNvZGU+WyJZIiwgIlgiXTwvY29kZT4gaW5zdGVhZC4gVGhlIG9ubHkgcmVxdWlyZW1lbnQgb24gdGhlIFJlZmxlY3Rpb24gPGFiYnIgPkFQSTwvYWJicj4gaXMgdGhhdCB0aGUgdWx0aW1hdGVseSByZXByZXNlbnRlZCB0eXBlIGlzIGVxdWl2YWxlbnQuIDwvcD4gPHA+IFRoZSA8Y29kZT5fX3RvU3RyaW5nKCk8L2NvZGU+IG1ldGhvZCByZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0eXBlIHRoYXQgY29uc3RpdHV0ZXMgYSB2YWxpZCBjb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0eXBlIGluIGEgbm9uLW5hbWVzcGFjZWQgY29udGV4dC4gSXQgaXMgbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIGFzIHdoYXQgd2FzIHVzZWQgaW4gdGhlIG9yaWdpbmFsIGNvZGUuIDwvcD4gPC9kaXY+IDxoMyA+RXhhbXBsZXM8L2gzPiA8ZGl2ID4gPHByZSA+Ly8gVGhpcyBpcyBvbmUgcG9zc2libGUgb3V0cHV0LCBnZXRUeXBlcygpIGFuZCBfX3RvU3RyaW5nKCkgY291bGQgLy8gYWxzbyBwcm92aWRlIHRoZSB0eXBlcyBpbiB0aGUgcmV2ZXJzZSBvcmRlciBpbnN0ZWFkLiBmdW5jdGlvbiB0ZXN0KCk6IEFCIHt9ICRydCA9IChuZXcgUmVmbGVjdGlvbkZ1bmN0aW9uKCd0ZXN0JykpLSZndDtnZXRSZXR1cm5UeXBlKCk7IHZhcl9kdW1wKGdldF9jbGFzcygkcnQpKTsgLy8gIlJlZmxlY3Rpb25JbnRlcnNlY3Rpb25UeXBlIiB2YXJfZHVtcCgkcnQtJmd0O2FsbG93c051bGwoKSk7IC8vIGZhbHNlIHZhcl9kdW1wKCRydC0mZ3Q7Z2V0VHlwZXMoKSk7IC8vIFtSZWZsZWN0aW9uVHlwZSgiQSIpLCBSZWZsZWN0aW9uVHlwZSgiQiIpXSB2YXJfZHVtcCgoc3RyaW5nKSAkcnQpOyAvLyAiQUIiIGZ1bmN0aW9uIHRlc3QyKCk6IEFCQyB7fSAkcnQgPSAobmV3IFJlZmxlY3Rpb25GdW5jdGlvbigndGVzdDInKSktJmd0O2dldFJldHVyblR5cGUoKTsgdmFyX2R1bXAoZ2V0X2NsYXNzKCRydCkpOyAvLyAiUmVmbGVjdGlvbkludGVyc2VjdGlvblR5cGUiIHZhcl9kdW1wKCRydC0mZ3Q7YWxsb3dzTnVsbCgpKTsgLy8gZmFsc2UgdmFyX2R1bXAoJHJ0LSZndDtnZXRUeXBlcygpKTsgLy8gW1JlZmxlY3Rpb25UeXBlKCJBIiksIFJlZmxlY3Rpb25UeXBlKCJCIiksIC8vIFJlZmxlY3Rpb25UeXBlKCJDIildIHZhcl9kdW1wKChzdHJpbmcpICRydCk7IC8vICJBQkMiPC9wcmU+IDwvZGl2PiA8aDIgPkJhY2t3YXJkIEluY29tcGF0aWJsZSBDaGFuZ2VzPC9oMj4gPGRpdiA+IDxwPiBUaGlzIDxhYmJyID5SRkM8L2FiYnI+IGRvZXMgbm90IGNvbnRhaW4gYW55IGJhY2t3YXJkcyBpbmNvbXBhdGlibGUgY2hhbmdlcy4gPC9wPiA8cD4gSG93ZXZlciwgZXhpc3RpbmcgPGNvZGU+UmVmbGVjdGlvblR5cGU8L2NvZGU+IGJhc2VkIGNvZGUgbWlnaHQgbmVlZCB0byBiZSBhZGp1c3RlZCBpbiBvcmRlciB0byBzdXBwb3J0IHByb2Nlc3Npbmcgb2YgY29kZSB0aGF0IHVzZXMgaW50ZXJzZWN0aW9uIHR5cGVzLiA8L3A+IDwvZGl2PiA8aDIgPlByb3Bvc2VkIFBIUCBWZXJzaW9uPC9oMj4gPGRpdiA+IDxwPiBOZXh0IG1pbm9yIHZlcnNpb24sIGkuZS4gUEhQIDguMS4gPC9wPiA8L2Rpdj4gPGgyID5GdXR1cmUgU2NvcGU8L2gyPiA8ZGl2ID4gPHA+IFRoZSBmZWF0dXJlcyBkaXNjdXNzZWQgaW4gdGhlIGZvbGxvd2luZyBhcmUgbm90IHBhcnQgb2YgdGhpcyBwcm9wb3NhbC4gPC9wPiA8L2Rpdj4gPGgzID5Db21wb3NpdGUgdHlwZXMgKGkuZS4gbWl4aW5nIHVuaW9uIGFuZCBpbnRlcnNlY3Rpb24gdHlwZXMpPC9oMz4gPGRpdiA+IDxwPiBXaGlsZSBlYXJseSBwcm90b3R5cGluZyBbMl0gc2hvd3MgdGhhdCBzdXBwb3J0aW5nIDxjb2RlPkFCfEM8L2NvZGU+IHdpdGhvdXQgYW55IGdyb3VwaW5nIGxvb2tzIGZlYXNpYmxlLCB0aGVyZSBhcmUgc3RpbGwgbWFueSBvdGhlciBjb25zaWRlcmF0aW9ucyAoZS5nLiBSZWZsZWN0aW9uKSwgYnV0IG5hbWVseSB0aGUgdmFyaWFuY2UgcnVsZXMgYW5kIGNoZWNrcywgd2hpY2ggd291bGQgYmUgZHJhbWF0aWNhbGx5IGluY3JlYXNlZCBhbmQgcHJvbmUgdG8gZXJyb3IuIDwvcD4gPHA+IFRoZXJlIGlzIGFsc28gdGhlIG9waW5pb24gdGhhdCBjb21wb3NpdGUgdHlwZXMgc2hvdWxkIG5vdCByZWx5IG9uIHByZWNlZGVuY2Ugb2YgdW5pb25zIGJ1dCBiZSBleHBsaWNpdGx5IGdyb3VwZWQgdG9nZXRoZXIuIDwvcD4gPHA+IEFzIHN1Y2ggd2UgY29uc2lkZXIgYSBzdGVwcGVkIGFwcHJvYWNoIGJ5IG9ubHkgYWxsb3dpbmcgcHVyZSBpbnRlcnNlY3Rpb24gZmlyc3QgdGhlIGJlc3Qgd2F5IGZvcndhcmQuIDwvcD4gPC9kaXY+IDxoMyA+VHlwZSBBbGlhc2VzPC9oMz4gPGRpdiA+IDxwPiBBcyB0eXBlcyBiZWNvbWUgaW5jcmVhc2luZ2x5IGNvbXBsZXgsIGl0IG1heSBiZSB3b3J0aHdoaWxlIHRvIGFsbG93IHJldXNpbmcgdHlwZSBkZWNsYXJhdGlvbnMuIFRoZXJlIGFyZSB0d28gZ2VuZXJhbCB3YXlzIGluIHdoaWNoIHRoaXMgY291bGQgd29yay4gT25lIGlzIGEgbG9jYWwgYWxpYXMsIHN1Y2ggYXM6IDwvcD4gPHByZSA+dXNlIFRyYXZlcnNhYmxlQ291bnRhYmxlIGFzIENvdW50YWJsZUl0ZXJhdG9yOyBmdW5jdGlvbiBmb28oQ291bnRhYmxlSXRlcmF0b3IgJHgpIHt9PC9wcmU+IDxwPiBJbiB0aGlzIGNhc2UgPGNvZGU+Q291bnRhYmxlSXRlcmF0b3I8L2NvZGU+IGlzIGEgc3ltYm9sIHRoYXQgaXMgb25seSB2aXNpYmxlIGxvY2FsbHkgYW5kIHdpbGwgYmUgcmVzb2x2ZWQgdG8gdGhlIG9yaWdpbmFsIDxjb2RlPlRyYXZlcnNhYmxlQ291bnRhYmxlPC9jb2RlPiB0eXBlIGR1cmluZyBjb21waWxhdGlvbi4gPC9wPiA8cD4gVGhlIHNlY29uZCBwb3NzaWJpbGl0eSBpcyBhbiBleHBvcnRlZCB0eXBlZGVmOiA8L3A+IDxwcmUgPm5hbWVzcGFjZSBGb287IHR5cGUgQ291bnRhYmxlSXRlcmF0b3IgPSBUcmF2ZXJzYWJsZUNvdW50YWJsZTsgLy8gVXNhYmxlIGFzIFxGb29cQ291bnRhYmxlSXRlcmF0b3IgZnJvbSBlbHNld2hlcmU8L3ByZT4gPHA+IEl0IHNob3VsZCBiZSBub3RlZCB0aGF0IGluY2x1c2lvbiBvZiB0aGlzIHByb3Bvc2FsIHdpbGwgYWRkIGV4dHJhIGNvbnNpZGVyYXRpb25zIGZvciB0eXBlIGFsaWFzZXMgYXMgaXQgd291bGQgYmUgcG9zc2libGUgdG8gd3JpdGUgY29tcG9zaXRlIHR5cGVzIGFzIGlmIGdyb3VwaW5nIHdhcyBzdXBwb3J0ZWQuIEhvd2V2ZXIsIHRoZSBncm91bmR3b3JrIGZvciBzdXBwb3J0aW5nIHRoaXMgaXMgcHJlc2VudCBpbiB0aGlzIHByb3Bvc2FsLiA8L3A+IDwvZGl2PiA8aDIgPlByb3Bvc2VkIFZvdGluZyBDaG9pY2VzPC9oMj4gPGRpdiA+IDxwPiBBcyBwZXIgdGhlIHZvdGluZyA8YWJiciA+UkZDPC9hYmJyPiBhIHllcy9ubyB2b3RlIHdpdGggYSAyLzMgbWFqb3JpdHkgaXMgbmVlZGVkIGZvciB0aGlzIHByb3Bvc2FsIHRvIGJlIGFjY2VwdGVkLiA8L3A+IDwvZGl2PiA8aDIgPkltcGxlbWVudGF0aW9uPC9oMj4gPGRpdiA+IDxwPiBJbXBsZW1lbnRlZCBpbiBQSFAgOC4xOiA8L3A+IDx1bD4gPGxpID48ZGl2ID4gY29tbWl0OiBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvY29tbWl0LzA2OWE5ZmE1ZTQ0NzhjNzA0NGNiNjQzMjI1OGNmZTIwN2QxMGEyMDI8L2Rpdj4gPC9saT4gPGxpID48ZGl2ID4gZG9jczogVERCPC9kaXY+IDwvbGk+IDwvdWw+IDwvZGl2PiA8aDIgPkFja25vd2xlZGdlbWVudHM8L2gyPiA8ZGl2ID4gPHA+IFRvIElsaWphIFRvdmlsbyBmb3IgcmVzb2x2aW5nIHRoZSBwYXJzZXIgY29uZmxpY3Qgd2l0aCBieS1yZWYgcGFyYW1ldGVycy4gPC9wPiA8cD4gVG8gTmlraXRhIFBvcG92IGZvciByZXZpZXdpbmcgYW5kIHJlZmFjdG9yaW5nIHRoZSB2YXJpYW5jZSBjb2RlLiA8L3A+IDwvZGl2PiA8aDIgPlJlZmVyZW5jZXM8L2gyPiA8ZGl2ID4gPHA+IFsxXTogU2xpZGUgMTQgb2YgTmlraXRhIFBvcG92J3MgdGFsayDigJxUeXBlZCBQcm9wZXJ0aWVzIGFuZCBtb3JlOiBXaGF0J3MgY29taW5nIGluIFBIUCA3LjQ/4oCdIDxhID5odHRwczovL2ltYWdlLnNsaWRlc2hhcmVjZG4uY29tL3ByZXNlbnRhdGlvbm5pa2l0YS0xOTA1MTkxOTAyNTEvOTUvdHlwZWQtcHJvcGVydGllcy1hbmQtbW9yZS13aGF0cy1jb21pbmctaW4tcGhwLTc0LTE0LTYzOC5qcGc/Y2I9MTU1ODI5MjYyMDwvYT4gWzJdOiBHaXQgUFIgd2l0aCBiYXNpYyBwcm90b3R5cGUgZm9yIG1peGluZyBpbnRlcnNlY3Rpb24gYW5kIHVuaW9uIHR5cGVzIDxhID5odHRwczovL2dpdGh1Yi5jb20vR2lyZ2lhcy9waHAtc3JjL3B1bGwvODwvYT4gPC9wPiA8L2Rpdj4gPC9kaXY+IDxkaXYgPjxiZGk+cmZjL3B1cmUtaW50ZXJzZWN0aW9uLXR5cGVzLnR4dDwvYmRpPiDCtyBMYXN0IG1vZGlmaWVkOiAyMDIxLzA3LzA1IDEyOjE3IGJ5IDxiZGk+Z2lyZ2lhczwvYmRpPjwvZGl2PiA8L2Rpdj48L2Rpdj4gPGRpdiA+IDxoMyA+UGFnZSBUb29sczwvaDM+IDxkaXYgPiA8dWw+IDxsaT48YSA+U2hvdyBwYWdlc291cmNlPC9hPjwvbGk+PGxpPjxhID5PbGQgcmV2aXNpb25zPC9hPjwvbGk+PGxpPjxhID5CYWNrbGlua3M8L2E+PC9saT48bGk+PGEgPkJhY2sgdG8gdG9wPC9hPjwvbGk+IDwvdWw+IDwvZGl2PiA8L2Rpdj4gPC9kaXY+IDwvZGl2PjwvZGl2PiA8L3NlY3Rpb24+IO+7vzxzZWN0aW9uID4gPGRpdiA+IDxoMyA+VGFibGUgb2YgQ29udGVudHM8L2gzPiA8ZGl2PiA8dWwgPiA8bGkgPjxkaXYgPjxhID5QSFAgUkZDOiBQdXJlIGludGVyc2VjdGlvbiB0eXBlczwvYT48L2Rpdj4gPHVsID4gPGxpID48ZGl2ID48YSA+SW50cm9kdWN0aW9uPC9hPjwvZGl2PjwvbGk+IDxsaSA+PGRpdiA+PGEgPk1vdGl2YXRpb248L2E+PC9kaXY+PC9saT4gPGxpID48ZGl2ID48YSA+UHJvcG9zYWw8L2E+PC9kaXY+IDx1bCA+IDxsaSA+PGRpdiA+PGEgPlN1cHBvcnRlZCB0eXBlczwvYT48L2Rpdj48L2xpPiA8bGkgPjxkaXYgPjxhID5WYXJpYW5jZTwvYT48L2Rpdj48L2xpPiA8bGkgPjxkaXYgPjxhID5Db2VyY2l2ZSB0eXBpbmcgbW9kZTwvYT48L2Rpdj48L2xpPiA8bGkgPjxkaXYgPjxhID5Qcm9wZXJ0eSB0eXBlcyBhbmQgcmVmZXJlbmNlczwvYT48L2Rpdj48L2xpPiA8bGkgPjxkaXYgPjxhID5SZWZsZWN0aW9uPC9hPjwvZGl2PjwvbGk+IDxsaSA+PGRpdiA+PGEgPkV4YW1wbGVzPC9hPjwvZGl2PjwvbGk+IDwvdWw+IDwvbGk+IDxsaSA+PGRpdiA+PGEgPkJhY2t3YXJkIEluY29tcGF0aWJsZSBDaGFuZ2VzPC9hPjwvZGl2PjwvbGk+IDxsaSA+PGRpdiA+PGEgPlByb3Bvc2VkIFBIUCBWZXJzaW9uPC9hPjwvZGl2PjwvbGk+IDxsaSA+PGRpdiA+PGEgPkZ1dHVyZSBTY29wZTwvYT48L2Rpdj4gPHVsID4gPGxpID48ZGl2ID48YSA+Q29tcG9zaXRlIHR5cGVzIChpLmUuIG1peGluZyB1bmlvbiBhbmQgaW50ZXJzZWN0aW9uIHR5cGVzKTwvYT48L2Rpdj48L2xpPiA8bGkgPjxkaXYgPjxhID5UeXBlIEFsaWFzZXM8L2E+PC9kaXY+PC9saT4gPC91bD4gPC9saT4gPGxpID48ZGl2ID48YSA+UHJvcG9zZWQgVm90aW5nIENob2ljZXM8L2E+PC9kaXY+PC9saT4gPGxpID48ZGl2ID48YSA+SW1wbGVtZW50YXRpb248L2E+PC9kaXY+PC9saT4gPGxpID48ZGl2ID48YSA+QWNrbm93bGVkZ2VtZW50czwvYT48L2Rpdj48L2xpPiA8bGkgPjxkaXYgPjxhID5SZWZlcmVuY2VzPC9hPjwvZGl2PjwvbGk+IDwvdWw+PC9saT4gPC91bD4gPC9kaXY+IDwvZGl2PiA8L3NlY3Rpb24+IDwvc2VjdGlvbj4gPC9kaXY+IDwvYm9keT4='</script>

      </head>
        <body class="valid" valid="valid" title="valid: True, node: 1, level: 1" node_number="1"> <div class="valid" valid="valid" title="valid: True, node: 2, level: 2" node_number="2"> <header class="valid" valid="valid" title="valid: True, node: 3, level: 3" node_number="3">  </header> <section class="valid" valid="valid" title="valid: True, node: 4, level: 3" node_number="4"> <section class="valid" valid="valid" title="valid: True, node: 5, level: 4" node_number="5">  </section> <section class="valid" valid="valid" title="valid: True, node: 6, level: 4" node_number="6"> <div class="valid" valid="valid" title="valid: True, node: 7, level: 5" node_number="7"><div class="valid" valid="valid" title="valid: True, node: 8, level: 6" node_number="8"> <div class="valid" valid="valid" title="valid: True, node: 9, level: 7" node_number="9"> <div class="valid" valid="valid" title="valid: True, node: 10, level: 8" node_number="10"><div class="valid" valid="valid" title="valid: True, node: 11, level: 9" node_number="11"> <div class="valid" valid="valid" title="valid: True, node: 12, level: 10" node_number="12">rfc:pure-intersection-types</div> <div class="valid" valid="valid" title="valid: True, node: 13, level: 10" node_number="13"> <h1 class="valid" valid="valid" title="valid: True, node: 14, level: 11" node_number="14">PHP RFC: Pure intersection types</h1> <div class="valid" valid="valid" title="valid: True, node: 15, level: 11" node_number="15"> <ul class="valid" valid="valid" title="valid: True, node: 16, level: 12" node_number="16"> <li class="valid" valid="valid" title="valid: True, node: 17, level: 13" node_number="17"><div class="valid" valid="valid" title="valid: True, node: 18, level: 14" node_number="18"> Version: 0.1</div> </li> <li class="valid" valid="valid" title="valid: True, node: 19, level: 13" node_number="19"><div class="valid" valid="valid" title="valid: True, node: 20, level: 14" node_number="20"> Date: 2021-03-23</div> </li> <li class="valid" valid="valid" title="valid: True, node: 21, level: 13" node_number="21"><div class="valid" valid="valid" title="valid: True, node: 22, level: 14" node_number="22"> Author: George Peter Banyard, girgias@php.net</div> </li> <li class="valid" valid="valid" title="valid: True, node: 23, level: 13" node_number="23"><div class="valid" valid="valid" title="valid: True, node: 24, level: 14" node_number="24"> Status: Implemented 8.1 https://github.com/php/php-src/commit/069a9fa5e4478c7044cb6432258cfe207d10a202</div> </li> <li class="valid" valid="valid" title="valid: True, node: 25, level: 13" node_number="25"><div class="valid" valid="valid" title="valid: True, node: 26, level: 14" node_number="26"> Target Version: PHP 8.1</div> </li> <li class="valid" valid="valid" title="valid: True, node: 27, level: 13" node_number="27"><div class="valid" valid="valid" title="valid: True, node: 28, level: 14" node_number="28"> Implementation: https://github.com/php/php-src/pull/6799</div> </li> <li class="valid" valid="valid" title="valid: True, node: 29, level: 13" node_number="29"><div class="valid" valid="valid" title="valid: True, node: 30, level: 14" node_number="30"> First Published at: http://wiki.php.net/rfc/pure-intersection-types</div> </li> <li class="valid" valid="valid" title="valid: True, node: 31, level: 13" node_number="31"><div class="valid" valid="valid" title="valid: True, node: 32, level: 14" node_number="32"> GitHub mirror: https://github.com/Girgias/intersection-types</div> </li> </ul> </div> <h2 class="valid" valid="valid" title="valid: True, node: 33, level: 11" node_number="33">Introduction</h2> <div class="valid" valid="valid" title="valid: True, node: 34, level: 11" node_number="34"> <p class="valid" valid="valid" title="valid: True, node: 35, level: 12" node_number="35"> An &#8220;intersection type&#8221; requires a value to satisfy multiple type constraints instead of a single one. </p> <p class="valid" valid="valid" title="valid: True, node: 36, level: 12" node_number="36"> Intersection types are currently not supported natively by the language. Instead, one must either use phpdoc annotations, and/or abuse typed properties [1] as can be seen in the following example: </p> <pre class="valid" valid="valid" title="valid: True, node: 37, level: 12" node_number="37">class Test { private ?Traversable $traversable = null; private ?Countable $countable = null; /** @var TraversableCountable */ private $both = null; public function __construct($countableIterator) { $this-&gt;traversable = $this-&gt;both; $this-&gt;countable = $this-&gt;both; $this-&gt;both = $countableIterator; } }</pre> <p class="valid" valid="valid" title="valid: True, node: 38, level: 12" node_number="38"> Supporting intersection types in the language allows us to move more type information from phpdoc into function signatures, with the usual advantages this brings: </p> <ul class="valid" valid="valid" title="valid: True, node: 39, level: 12" node_number="39"> <li class="valid" valid="valid" title="valid: True, node: 40, level: 13" node_number="40"><div class="valid" valid="valid" title="valid: True, node: 41, level: 14" node_number="41"> Types are actually enforced, so mistakes can be caught early.</div> </li> <li class="valid" valid="valid" title="valid: True, node: 42, level: 13" node_number="42"><div class="valid" valid="valid" title="valid: True, node: 43, level: 14" node_number="43"> Because they are enforced, type information is less likely to become outdated or miss edge-cases.</div> </li> <li class="valid" valid="valid" title="valid: True, node: 44, level: 13" node_number="44"><div class="valid" valid="valid" title="valid: True, node: 45, level: 14" node_number="45"> Types are checked during inheritance, enforcing the Liskov Substitution Principle.</div> </li> <li class="valid" valid="valid" title="valid: True, node: 46, level: 13" node_number="46"><div class="valid" valid="valid" title="valid: True, node: 47, level: 14" node_number="47"> Types are available through Reflection.</div> </li> <li class="valid" valid="valid" title="valid: True, node: 48, level: 13" node_number="48"><div class="valid" valid="valid" title="valid: True, node: 49, level: 14" node_number="49"> The syntax is a lot less boilerplate-y than phpdoc.</div> </li> </ul> </div> <h2 class="valid" valid="valid" title="valid: True, node: 50, level: 11" node_number="50">Motivation</h2> <div class="valid" valid="valid" title="valid: True, node: 51, level: 11" node_number="51"> <p class="valid" valid="valid" title="valid: True, node: 52, level: 12" node_number="52"> It is possible to emulate intersection types by creating a new interface which inherits from multiple ones, one such case is the built in <code class="valid" valid="valid" title="valid: True, node: 53, level: 13" node_number="53">SeekableIterator</code> which extends the <code class="valid" valid="valid" title="valid: True, node: 54, level: 13" node_number="54">Iterator</code> interface by adding a <code class="valid" valid="valid" title="valid: True, node: 55, level: 13" node_number="55">seek()</code> method on it. However, an iterator can also be countable, an if a function needs to type against such a requirement the only possible way is to currently create a new interface: </p> <pre class="valid" valid="valid" title="valid: True, node: 56, level: 12" node_number="56">interface CountableIterator extends Iterator, Countable {}</pre> <p class="valid" valid="valid" title="valid: True, node: 57, level: 12" node_number="57"> This works, but what if we want an iterator that is countable and seekable? We need to create another interface: </p> <pre class="valid" valid="valid" title="valid: True, node: 58, level: 12" node_number="58">interface SeekableCountableIterator extends CountableIterator, SeekableIterator {}</pre> <p class="valid" valid="valid" title="valid: True, node: 59, level: 12" node_number="59"> As such, each new requirement necessitates the creation of various new interfaces taking into account all possible combinations. </p> <p class="valid" valid="valid" title="valid: True, node: 60, level: 12" node_number="60"> Moreover, the class needs to implement the specific interface and cannot rely on just implementing the base interfaces, meaning the introduction of such interfaces need to be propagated to all relevant classes, something which can be error prone. See this non-example: </p> <pre class="valid" valid="valid" title="valid: True, node: 61, level: 12" node_number="61">interface A {} interface B {} interface AB extends A, B {} class Test implements A, B {} function foo(AB $v) { var_dump($v); } foo(new Test());</pre> <p class="valid" valid="valid" title="valid: True, node: 62, level: 12" node_number="62"> Intersection types solve these issues. </p> </div> <h2 class="valid" valid="valid" title="valid: True, node: 63, level: 11" node_number="63">Proposal</h2> <div class="valid" valid="valid" title="valid: True, node: 64, level: 11" node_number="64"> <p class="valid" valid="valid" title="valid: True, node: 65, level: 12" node_number="65"> Add support for pure intersection types are specified using the syntax <code class="valid" valid="valid" title="valid: True, node: 66, level: 13" node_number="66">T1T2...</code> and can be used in all positions where types are currently accepted: </p> <pre class="valid" valid="valid" title="valid: True, node: 67, level: 12" node_number="67">class A { private TraversableCountable $countableIterator; public function setIterator(TraversableCountable $countableIterator): void { $this-&gt;countableIterator = $countableIterator; } public function getIterator(): TraversableCountable { return $this-&gt;countableIterator; } }</pre> <p class="valid" valid="valid" title="valid: True, node: 68, level: 12" node_number="68"> This means it would not be possible to mix intersection and union types together such as <code class="valid" valid="valid" title="valid: True, node: 69, level: 13" node_number="69">AB|C</code>, this is left as a future scope. </p> </div> <h3 class="valid" valid="valid" title="valid: True, node: 70, level: 11" node_number="70">Supported types</h3> <div class="valid" valid="valid" title="valid: True, node: 71, level: 11" node_number="71"> <p class="valid" valid="valid" title="valid: True, node: 72, level: 12" node_number="72"> Only class types (interfaces and class names) are supported by intersection types. </p> <p class="valid" valid="valid" title="valid: True, node: 73, level: 12" node_number="73"> The rationale is that for nearly all standard types using them in an intersection type result in a type which can never be satisfied (e.g. <code class="valid" valid="valid" title="valid: True, node: 74, level: 13" node_number="74">intstring</code>). </p> <p class="valid" valid="valid" title="valid: True, node: 75, level: 12" node_number="75"> Usage of <code class="valid" valid="valid" title="valid: True, node: 76, level: 13" node_number="76">mixed</code> in an intersection type is redundant as <code class="valid" valid="valid" title="valid: True, node: 77, level: 13" node_number="77">mixedT</code> corresponds to <code class="valid" valid="valid" title="valid: True, node: 78, level: 13" node_number="78">T</code>, as such this is disallowed. </p> <p class="valid" valid="valid" title="valid: True, node: 79, level: 12" node_number="79"> Similarly using <code class="valid" valid="valid" title="valid: True, node: 80, level: 13" node_number="80">iterable</code> in an intersection results in a redundant invalid type, this can be seen by expanding the type expression <code class="valid" valid="valid" title="valid: True, node: 81, level: 13" node_number="81">iterableT = (array|Traversable)T = (arrayT) | (TraversableT) = TraversableT</code> </p> <p class="valid" valid="valid" title="valid: True, node: 82, level: 12" node_number="82"> Although an intersection with <code class="valid" valid="valid" title="valid: True, node: 83, level: 13" node_number="83">callable</code> can make sense (e.g. stringcallable), we think it is unwise and points to a bug. </p> <p class="valid" valid="valid" title="valid: True, node: 84, level: 12" node_number="84"> Similarly <code class="valid" valid="valid" title="valid: True, node: 85, level: 13" node_number="85">parent</code>, <code class="valid" valid="valid" title="valid: True, node: 86, level: 13" node_number="86">self</code>, and <code class="valid" valid="valid" title="valid: True, node: 87, level: 13" node_number="87">static</code> are technically feasible and could be used as part of an intersection, but impose strange restrictions on a child class which the base class violates or the base class already satisfies the type requirements in which case it is redundant. Therefore those 3 types are also forbidden because they likely point to a design issue. </p> </div> <h4 class="valid" valid="valid" title="valid: True, node: 88, level: 11" node_number="88">Duplicate and redundant types</h4> <div class="valid" valid="valid" title="valid: True, node: 89, level: 11" node_number="89"> <p class="valid" valid="valid" title="valid: True, node: 90, level: 12" node_number="90"> To catch some simple bugs in intersection type declarations, redundant types that can be detected without performing class loading will result in a compile-time error. This includes: </p> <ul class="valid" valid="valid" title="valid: True, node: 91, level: 12" node_number="91"> <li class="valid" valid="valid" title="valid: True, node: 92, level: 13" node_number="92"><div class="valid" valid="valid" title="valid: True, node: 93, level: 14" node_number="93"> Each name-resolved type may only occur once. Types like <code title="valid: False, node: 94, level: 15" node_number="94">ABA</code> result in an error.</div> </li> </ul> <p class="valid" valid="valid" title="valid: True, node: 95, level: 12" node_number="95"> This does not guarantee that the type is &#8220;minimal&#8221;, because doing so would require loading all used class types. </p> <p class="valid" valid="valid" title="valid: True, node: 96, level: 12" node_number="96"> For example, if <code class="valid" valid="valid" title="valid: True, node: 97, level: 13" node_number="97">A</code> and <code class="valid" valid="valid" title="valid: True, node: 98, level: 13" node_number="98">B</code> are runtime class aliases, then <code class="valid" valid="valid" title="valid: True, node: 99, level: 13" node_number="99">AB</code> remains a legal intersection type, even though it could be reduced to either <code class="valid" valid="valid" title="valid: True, node: 100, level: 13" node_number="100">A</code> or <code class="valid" valid="valid" title="valid: True, node: 101, level: 13" node_number="101">B</code>. Similarly, if <code class="valid" valid="valid" title="valid: True, node: 102, level: 13" node_number="102">class B extends A {}</code>, then <code class="valid" valid="valid" title="valid: True, node: 103, level: 13" node_number="103">AB</code> is also a legal intersection type, even though it could be reduced to just <code class="valid" valid="valid" title="valid: True, node: 104, level: 13" node_number="104">B</code>. </p> <pre class="valid" valid="valid" title="valid: True, node: 105, level: 12" node_number="105">function foo(): AA {} // Disallowed use A as B; function foo(): AB {} // Disallowed ("use" is part of name resolution) class_alias('X', 'Y'); function foo(): XY {} // Allowed (redundancy is only known at runtime)</pre> </div> <h4 class="valid" valid="valid" title="valid: True, node: 106, level: 11" node_number="106">Type grammar</h4> <div class="valid" valid="valid" title="valid: True, node: 107, level: 11" node_number="107"> <p class="valid" valid="valid" title="valid: True, node: 108, level: 12" node_number="108"> Due to a parser ambiguity with the declaration of by-ref parameter while using the current LR(1) parser, the grammar and lexer are modified to create different tokens for the <code class="valid" valid="valid" title="valid: True, node: 109, level: 13" node_number="109"/> character depending if it is followed by a (variadic) variable or not. </p> <p class="valid" valid="valid" title="valid: True, node: 110, level: 12" node_number="110"> The grammar thus looks as following: </p> <pre class="valid" valid="valid" title="valid: True, node: 111, level: 12" node_number="111">type_expr: type | '?' type | union_type | intersection_type ; intersection_type: type T_AMPERSAND_NOT_FOLLOWED_BY_VAR_OR_VARARG type | intersection_type T_AMPERSAND_NOT_FOLLOWED_BY_VAR_OR_VARARG type ; </pre> </div> <h3 class="valid" valid="valid" title="valid: True, node: 112, level: 11" node_number="112">Variance</h3> <div class="valid" valid="valid" title="valid: True, node: 113, level: 11" node_number="113"> <p class="valid" valid="valid" title="valid: True, node: 114, level: 12" node_number="114"> Intersection types follow standard PHP variance rules that are already used for inheritance and type checking: </p> <ul class="valid" valid="valid" title="valid: True, node: 115, level: 12" node_number="115"> <li class="valid" valid="valid" title="valid: True, node: 116, level: 13" node_number="116"><div class="valid" valid="valid" title="valid: True, node: 117, level: 14" node_number="117"> Return types are covariant (child must be subtype).</div> </li> <li class="valid" valid="valid" title="valid: True, node: 118, level: 13" node_number="118"><div class="valid" valid="valid" title="valid: True, node: 119, level: 14" node_number="119"> Parameter types are contravariant (child must be supertype).</div> </li> <li class="valid" valid="valid" title="valid: True, node: 120, level: 13" node_number="120"><div class="valid" valid="valid" title="valid: True, node: 121, level: 14" node_number="121"> Property types are invariant (child must be subtype and supertype).</div> </li> </ul> <p class="valid" valid="valid" title="valid: True, node: 122, level: 12" node_number="122"> The only change is in how intersection types interact with subtyping, with two additional rules: </p> <ul class="valid" valid="valid" title="valid: True, node: 123, level: 12" node_number="123"> <li class="valid" valid="valid" title="valid: True, node: 124, level: 13" node_number="124"><div class="valid" valid="valid" title="valid: True, node: 125, level: 14" node_number="125"> <code title="valid: False, node: 126, level: 15" node_number="126">A</code> is a subtype of <code title="valid: False, node: 127, level: 15" node_number="127">B_1...B_n</code> if for all <code title="valid: False, node: 128, level: 15" node_number="128">B_i</code>, <code title="valid: False, node: 129, level: 15" node_number="129">A</code> is a subtype of <code title="valid: False, node: 130, level: 15" node_number="130">B_i</code></div> </li> <li class="valid" valid="valid" title="valid: True, node: 131, level: 13" node_number="131"><div class="valid" valid="valid" title="valid: True, node: 132, level: 14" node_number="132"> <code title="valid: False, node: 133, level: 15" node_number="133">A_1...A_n</code> is a subtype of <code title="valid: False, node: 134, level: 15" node_number="134">B</code> if there exists an <code title="valid: False, node: 135, level: 15" node_number="135">A_i</code> such that <code title="valid: False, node: 136, level: 15" node_number="136">A_i</code> is a subtype of <code title="valid: False, node: 137, level: 15" node_number="137">B</code></div> </li> </ul> <p class="valid" valid="valid" title="valid: True, node: 138, level: 12" node_number="138"> In the following, some examples of what is allowed and what isn't are given. </p> </div> <h4 class="valid" valid="valid" title="valid: True, node: 139, level: 11" node_number="139">Property types</h4> <div class="valid" valid="valid" title="valid: True, node: 140, level: 11" node_number="140"> <p class="valid" valid="valid" title="valid: True, node: 141, level: 12" node_number="141"> Property types are invariant, which means that types must stay the same during inheritance. However, the &#8220;same&#8221; type may be expressed in different ways. </p> <p class="valid" valid="valid" title="valid: True, node: 142, level: 12" node_number="142"> Intersection types expand the possibilities in this area: For example <code class="valid" valid="valid" title="valid: True, node: 143, level: 13" node_number="143">AB</code> and <code class="valid" valid="valid" title="valid: True, node: 144, level: 13" node_number="144">BA</code> represent the same type. The following example shows a more complex case: </p> <pre class="valid" valid="valid" title="valid: True, node: 145, level: 12" node_number="145">class A {} class B extends A {} class Test { public AB $prop; } class Test2 extends Test { public B $prop; }</pre> <p class="valid" valid="valid" title="valid: True, node: 146, level: 12" node_number="146"> In this example, the intersection <code class="valid" valid="valid" title="valid: True, node: 147, level: 13" node_number="147">AB</code> actually represents the same type as just <code class="valid" valid="valid" title="valid: True, node: 148, level: 13" node_number="148">B</code>, and this inheritance is legal, despite the type not being syntactically the same. </p> <p class="valid" valid="valid" title="valid: True, node: 149, level: 12" node_number="149"> Formally, we arrive at this result as follows: First, the parent type <code class="valid" valid="valid" title="valid: True, node: 150, level: 13" node_number="150">AB</code> is a subtype of <code class="valid" valid="valid" title="valid: True, node: 151, level: 13" node_number="151">B</code>. Second, <code class="valid" valid="valid" title="valid: True, node: 152, level: 13" node_number="152">B</code> is a subtype of <code class="valid" valid="valid" title="valid: True, node: 153, level: 13" node_number="153">AB</code>, because <code class="valid" valid="valid" title="valid: True, node: 154, level: 13" node_number="154">B</code> is a subtype of <code class="valid" valid="valid" title="valid: True, node: 155, level: 13" node_number="155">A</code> and <code class="valid" valid="valid" title="valid: True, node: 156, level: 13" node_number="156">B</code> is a subtype of <code class="valid" valid="valid" title="valid: True, node: 157, level: 13" node_number="157">B</code>. </p> </div> <h4 class="valid" valid="valid" title="valid: True, node: 158, level: 11" node_number="158">Adding and removing intersection types</h4> <div class="valid" valid="valid" title="valid: True, node: 159, level: 11" node_number="159"> <p class="valid" valid="valid" title="valid: True, node: 160, level: 12" node_number="160"> It is legal to add intersection types in return position and remove intersection types in parameter position: </p> <pre class="valid" valid="valid" title="valid: True, node: 161, level: 12" node_number="161">class A {} interface X {} class Test { public function param1(A $param) {} public function param2(AX $param) {} public function return1(): AX {} public function return2(): A {} } class Test2 extends Test { public function param1(AX $param) {} // FORBIDDEN: Adding extra param type constraint public function param2(A $param) {} // Allowed: Removing param type constraint public function return1(): A {} // FORBIDDEN: Removing return type constraint public function return2(): AX {} // Allowed: Adding extra return type constraint }</pre> </div> <h4 class="valid" valid="valid" title="valid: True, node: 162, level: 11" node_number="162">Variance of individual intersection members</h4> <div class="valid" valid="valid" title="valid: True, node: 163, level: 11" node_number="163"> <p class="valid" valid="valid" title="valid: True, node: 164, level: 12" node_number="164"> Similarly, it is possible to restrict an intersection member in return position, or widen an intersection member in parameter position: </p> <pre class="valid" valid="valid" title="valid: True, node: 165, level: 12" node_number="165">class A {} class B extends A {} interface X {} class Test { public function param1(BX $param) {} public function param2(AX $param) {} public function return1(): AX {} public function return2(): BX {} } class Test2 extends Test { public function param1(AX $param) {} // Allowed: Widening intersection member B -&gt; A public function param2(BX $param) {} // FORBIDDEN: Restricting intersection member A -&gt; B public function return1(): BX {} // Allowed: Restricting intersection member A -&gt; B public function return2(): AX {} // FORBIDDEN: Widening intersection member B -&gt; A }</pre> <p class="valid" valid="valid" title="valid: True, node: 166, level: 12" node_number="166"> Of course, the same can also be done with multiple intersection members at a time, and be combined with the addition/removal of types mentioned previously. </p> </div> <h4 class="valid" valid="valid" title="valid: True, node: 167, level: 11" node_number="167">Variance of intersection type to concrete class type</h4> <div class="valid" valid="valid" title="valid: True, node: 168, level: 11" node_number="168"> <p class="valid" valid="valid" title="valid: True, node: 169, level: 12" node_number="169"> As the primary use of intersection types is to ensure multiple interfaces are implemented, a concrete class or interface which implements all the interfaces present in the intersection is considered a subtype and thus can be used where co-variance is allowed. </p> <pre class="valid" valid="valid" title="valid: True, node: 170, level: 12" node_number="170">interface X {} interface Y {} class TestOne implements X, Y {} interface A { public function foo(): XY; } interface B extends A { public function foo(): TestOne; }</pre> <p class="valid" valid="valid" title="valid: True, node: 171, level: 12" node_number="171"> Moreover, it is possible to use a union type of concrete classes/interface when each of the member of the union implement all of the interfaces in the intersection. </p> <pre class="valid" valid="valid" title="valid: True, node: 172, level: 12" node_number="172">class TestTwo implements X, Y {} interface C extends A { public function foo(XY $param): TestOne|TestTwo; }</pre> <p class="valid" valid="valid" title="valid: True, node: 173, level: 12" node_number="173"> The reason why this is possible is that a union of concrete classes/interfaces is less general then the set of possible classes which satisfy the intersection type. </p> </div> <h3 class="valid" valid="valid" title="valid: True, node: 174, level: 11" node_number="174">Coercive typing mode</h3> <div class="valid" valid="valid" title="valid: True, node: 175, level: 11" node_number="175"> <p class="valid" valid="valid" title="valid: True, node: 176, level: 12" node_number="176"> As standard types are not allowed in pure intersection types, no consideration for the coercive typing mode needs to done. </p> </div> <h3 class="valid" valid="valid" title="valid: True, node: 177, level: 11" node_number="177">Property types and references</h3> <div class="valid" valid="valid" title="valid: True, node: 178, level: 11" node_number="178"> <p class="valid" valid="valid" title="valid: True, node: 179, level: 12" node_number="179"> References to typed properties with intersection types follow the semantics outlined in the typed properties RFC: </p> <blockquote class="valid" valid="valid" title="valid: True, node: 180, level: 12" node_number="180"><div class="valid" valid="valid" title="valid: True, node: 181, level: 13" node_number="181"> If typed properties are part of the reference set, then the value is checked against each property type. If a type check fails, a TypeError is generated and the value of the reference remains unchanged.</div></blockquote> <pre class="valid" valid="valid" title="valid: True, node: 182, level: 12" node_number="182">interface X {} interface Y {} interface Z {} class A implements X, Y, Z {} class B implements X, Y {} class Test { public XY $y; public XZ $z; } $test = new Test; $r = new A; $test-&gt;y = $r; $test-&gt;z = $r; // Reference set: { $r, $test-&gt;y, $test-&gt;z } // Types: { A, XY, XZ } $r = new B; // TypeError: Cannot assign B to reference held by property Test::$z of type XZ</pre> </div> <h3 class="valid" valid="valid" title="valid: True, node: 183, level: 11" node_number="183">Reflection</h3> <div class="valid" valid="valid" title="valid: True, node: 184, level: 11" node_number="184"> <p class="valid" valid="valid" title="valid: True, node: 185, level: 12" node_number="185"> To support intersection types, a new class <code class="valid" valid="valid" title="valid: True, node: 186, level: 13" node_number="186">ReflectionIntersectionType</code> is added: </p> <pre class="valid" valid="valid" title="valid: True, node: 187, level: 12" node_number="187">class ReflectionIntersectionType extends ReflectionType { /** @return ReflectionType[] */ public function getTypes(); /* Inherited from ReflectionType */ /** @return bool */ public function allowsNull(); /* Inherited from ReflectionType */ /** @return string */ public function __toString(); }</pre> <p class="valid" valid="valid" title="valid: True, node: 188, level: 12" node_number="188"> The <code class="valid" valid="valid" title="valid: True, node: 189, level: 13" node_number="189">getTypes()</code> method returns an array of <code class="valid" valid="valid" title="valid: True, node: 190, level: 13" node_number="190">ReflectionType</code>s that are part of the intersection. The types may be returned in an arbitrary order that does not match the original type declaration. The types may also be subject to equivalence transformations. </p> <p class="valid" valid="valid" title="valid: True, node: 191, level: 12" node_number="191"> For example, the type <code class="valid" valid="valid" title="valid: True, node: 192, level: 13" node_number="192">XY</code> may return types in the order <code class="valid" valid="valid" title="valid: True, node: 193, level: 13" node_number="193">["Y", "X"]</code> instead. The only requirement on the Reflection <abbr class="valid" valid="valid" title="valid: True, node: 194, level: 13" node_number="194">API</abbr> is that the ultimately represented type is equivalent. </p> <p class="valid" valid="valid" title="valid: True, node: 195, level: 12" node_number="195"> The <code class="valid" valid="valid" title="valid: True, node: 196, level: 13" node_number="196">__toString()</code> method returns a string representation of the type that constitutes a valid code representation of the type in a non-namespaced context. It is not necessarily the same as what was used in the original code. </p> </div> <h3 class="valid" valid="valid" title="valid: True, node: 197, level: 11" node_number="197">Examples</h3> <div class="valid" valid="valid" title="valid: True, node: 198, level: 11" node_number="198"> <pre class="valid" valid="valid" title="valid: True, node: 199, level: 12" node_number="199">// This is one possible output, getTypes() and __toString() could // also provide the types in the reverse order instead. function test(): AB {} $rt = (new ReflectionFunction('test'))-&gt;getReturnType(); var_dump(get_class($rt)); // "ReflectionIntersectionType" var_dump($rt-&gt;allowsNull()); // false var_dump($rt-&gt;getTypes()); // [ReflectionType("A"), ReflectionType("B")] var_dump((string) $rt); // "AB" function test2(): ABC {} $rt = (new ReflectionFunction('test2'))-&gt;getReturnType(); var_dump(get_class($rt)); // "ReflectionIntersectionType" var_dump($rt-&gt;allowsNull()); // false var_dump($rt-&gt;getTypes()); // [ReflectionType("A"), ReflectionType("B"), // ReflectionType("C")] var_dump((string) $rt); // "ABC"</pre> </div> <h2 class="valid" valid="valid" title="valid: True, node: 200, level: 11" node_number="200">Backward Incompatible Changes</h2> <div class="valid" valid="valid" title="valid: True, node: 201, level: 11" node_number="201"> <p class="valid" valid="valid" title="valid: True, node: 202, level: 12" node_number="202"> This <abbr class="valid" valid="valid" title="valid: True, node: 203, level: 13" node_number="203">RFC</abbr> does not contain any backwards incompatible changes. </p> <p class="valid" valid="valid" title="valid: True, node: 204, level: 12" node_number="204"> However, existing <code class="valid" valid="valid" title="valid: True, node: 205, level: 13" node_number="205">ReflectionType</code> based code might need to be adjusted in order to support processing of code that uses intersection types. </p> </div> <h2 class="valid" valid="valid" title="valid: True, node: 206, level: 11" node_number="206">Proposed PHP Version</h2> <div class="valid" valid="valid" title="valid: True, node: 207, level: 11" node_number="207"> <p class="valid" valid="valid" title="valid: True, node: 208, level: 12" node_number="208"> Next minor version, i.e. PHP 8.1. </p> </div> <h2 class="valid" valid="valid" title="valid: True, node: 209, level: 11" node_number="209">Future Scope</h2> <div class="valid" valid="valid" title="valid: True, node: 210, level: 11" node_number="210"> <p class="valid" valid="valid" title="valid: True, node: 211, level: 12" node_number="211"> The features discussed in the following are not part of this proposal. </p> </div> <h3 class="valid" valid="valid" title="valid: True, node: 212, level: 11" node_number="212">Composite types (i.e. mixing union and intersection types)</h3> <div class="valid" valid="valid" title="valid: True, node: 213, level: 11" node_number="213"> <p class="valid" valid="valid" title="valid: True, node: 214, level: 12" node_number="214"> While early prototyping [2] shows that supporting <code class="valid" valid="valid" title="valid: True, node: 215, level: 13" node_number="215">AB|C</code> without any grouping looks feasible, there are still many other considerations (e.g. Reflection), but namely the variance rules and checks, which would be dramatically increased and prone to error. </p> <p class="valid" valid="valid" title="valid: True, node: 216, level: 12" node_number="216"> There is also the opinion that composite types should not rely on precedence of unions but be explicitly grouped together. </p> <p class="valid" valid="valid" title="valid: True, node: 217, level: 12" node_number="217"> As such we consider a stepped approach by only allowing pure intersection first the best way forward. </p> </div> <h3 class="valid" valid="valid" title="valid: True, node: 218, level: 11" node_number="218">Type Aliases</h3> <div class="valid" valid="valid" title="valid: True, node: 219, level: 11" node_number="219"> <p class="valid" valid="valid" title="valid: True, node: 220, level: 12" node_number="220"> As types become increasingly complex, it may be worthwhile to allow reusing type declarations. There are two general ways in which this could work. One is a local alias, such as: </p> <pre class="valid" valid="valid" title="valid: True, node: 221, level: 12" node_number="221">use TraversableCountable as CountableIterator; function foo(CountableIterator $x) {}</pre> <p class="valid" valid="valid" title="valid: True, node: 222, level: 12" node_number="222"> In this case <code class="valid" valid="valid" title="valid: True, node: 223, level: 13" node_number="223">CountableIterator</code> is a symbol that is only visible locally and will be resolved to the original <code class="valid" valid="valid" title="valid: True, node: 224, level: 13" node_number="224">TraversableCountable</code> type during compilation. </p> <p class="valid" valid="valid" title="valid: True, node: 225, level: 12" node_number="225"> The second possibility is an exported typedef: </p> <pre class="valid" valid="valid" title="valid: True, node: 226, level: 12" node_number="226">namespace Foo; type CountableIterator = TraversableCountable; // Usable as \Foo\CountableIterator from elsewhere</pre> <p class="valid" valid="valid" title="valid: True, node: 227, level: 12" node_number="227"> It should be noted that inclusion of this proposal will add extra considerations for type aliases as it would be possible to write composite types as if grouping was supported. However, the groundwork for supporting this is present in this proposal. </p> </div> <h2 class="valid" valid="valid" title="valid: True, node: 228, level: 11" node_number="228">Proposed Voting Choices</h2> <div class="valid" valid="valid" title="valid: True, node: 229, level: 11" node_number="229"> <p class="valid" valid="valid" title="valid: True, node: 230, level: 12" node_number="230"> As per the voting <abbr class="valid" valid="valid" title="valid: True, node: 231, level: 13" node_number="231">RFC</abbr> a yes/no vote with a 2/3 majority is needed for this proposal to be accepted. </p> </div> <h2 class="valid" valid="valid" title="valid: True, node: 232, level: 11" node_number="232">Implementation</h2> <div class="valid" valid="valid" title="valid: True, node: 233, level: 11" node_number="233"> <p class="valid" valid="valid" title="valid: True, node: 234, level: 12" node_number="234"> Implemented in PHP 8.1: </p> <ul class="valid" valid="valid" title="valid: True, node: 235, level: 12" node_number="235"> <li class="valid" valid="valid" title="valid: True, node: 236, level: 13" node_number="236"><div class="valid" valid="valid" title="valid: True, node: 237, level: 14" node_number="237"> commit: https://github.com/php/php-src/commit/069a9fa5e4478c7044cb6432258cfe207d10a202</div> </li> <li class="valid" valid="valid" title="valid: True, node: 238, level: 13" node_number="238"><div class="valid" valid="valid" title="valid: True, node: 239, level: 14" node_number="239"> docs: TDB</div> </li> </ul> </div> <h2 class="valid" valid="valid" title="valid: True, node: 240, level: 11" node_number="240">Acknowledgements</h2> <div class="valid" valid="valid" title="valid: True, node: 241, level: 11" node_number="241"> <p class="valid" valid="valid" title="valid: True, node: 242, level: 12" node_number="242"> To Ilija Tovilo for resolving the parser conflict with by-ref parameters. </p> <p class="valid" valid="valid" title="valid: True, node: 243, level: 12" node_number="243"> To Nikita Popov for reviewing and refactoring the variance code. </p> </div> <h2 class="valid" valid="valid" title="valid: True, node: 244, level: 11" node_number="244">References</h2> <div class="valid" valid="valid" title="valid: True, node: 245, level: 11" node_number="245"> <p class="valid" valid="valid" title="valid: True, node: 246, level: 12" node_number="246"> [1]: Slide 14 of Nikita Popov's talk &#8220;Typed Properties and more: What's coming in PHP 7.4?&#8221; <a class="valid" valid="valid" title="valid: True, node: 247, level: 13" node_number="247">https://image.slidesharecdn.com/presentationnikita-190519190251/95/typed-properties-and-more-whats-coming-in-php-74-14-638.jpg?cb=1558292620</a> [2]: Git PR with basic prototype for mixing intersection and union types <a class="valid" valid="valid" title="valid: True, node: 248, level: 13" node_number="248">https://github.com/Girgias/php-src/pull/8</a> </p> </div> </div> <div class="valid" valid="valid" title="valid: True, node: 249, level: 10" node_number="249"><bdi class="valid" valid="valid" title="valid: True, node: 250, level: 11" node_number="250">rfc/pure-intersection-types.txt</bdi> &#183; Last modified: 2021/07/05 12:17 by <bdi class="valid" valid="valid" title="valid: True, node: 251, level: 11" node_number="251">girgias</bdi></div> </div></div> <div class="valid" valid="valid" title="valid: True, node: 252, level: 8" node_number="252"> <h3 class="valid" valid="valid" title="valid: True, node: 253, level: 9" node_number="253">Page Tools</h3> <div class="valid" valid="valid" title="valid: True, node: 254, level: 9" node_number="254"> <ul class="valid" valid="valid" title="valid: True, node: 255, level: 10" node_number="255"> <li class="valid" valid="valid" title="valid: True, node: 256, level: 11" node_number="256"><a class="valid" valid="valid" title="valid: True, node: 257, level: 12" node_number="257">Show pagesource</a></li><li class="valid" valid="valid" title="valid: True, node: 258, level: 11" node_number="258"><a class="valid" valid="valid" title="valid: True, node: 259, level: 12" node_number="259">Old revisions</a></li><li class="valid" valid="valid" title="valid: True, node: 260, level: 11" node_number="260"><a class="valid" valid="valid" title="valid: True, node: 261, level: 12" node_number="261">Backlinks</a></li><li class="valid" valid="valid" title="valid: True, node: 262, level: 11" node_number="262"><a class="valid" valid="valid" title="valid: True, node: 263, level: 12" node_number="263">Back to top</a></li> </ul> </div> </div> </div> </div></div> </section> &#65279;<section class="valid" valid="valid" title="valid: True, node: 264, level: 4" node_number="264"> <div class="valid" valid="valid" title="valid: True, node: 265, level: 5" node_number="265"> <h3 class="valid" valid="valid" title="valid: True, node: 266, level: 6" node_number="266">Table of Contents</h3> <div class="valid" valid="valid" title="valid: True, node: 267, level: 6" node_number="267"> <ul class="valid" valid="valid" title="valid: True, node: 268, level: 7" node_number="268"> <li class="valid" valid="valid" title="valid: True, node: 269, level: 8" node_number="269"><div class="valid" valid="valid" title="valid: True, node: 270, level: 9" node_number="270"><a class="valid" valid="valid" title="valid: True, node: 271, level: 10" node_number="271">PHP RFC: Pure intersection types</a></div> <ul class="valid" valid="valid" title="valid: True, node: 272, level: 9" node_number="272"> <li class="valid" valid="valid" title="valid: True, node: 273, level: 10" node_number="273"><div class="valid" valid="valid" title="valid: True, node: 274, level: 11" node_number="274"><a class="valid" valid="valid" title="valid: True, node: 275, level: 12" node_number="275">Introduction</a></div></li> <li class="valid" valid="valid" title="valid: True, node: 276, level: 10" node_number="276"><div class="valid" valid="valid" title="valid: True, node: 277, level: 11" node_number="277"><a class="valid" valid="valid" title="valid: True, node: 278, level: 12" node_number="278">Motivation</a></div></li> <li class="valid" valid="valid" title="valid: True, node: 279, level: 10" node_number="279"><div class="valid" valid="valid" title="valid: True, node: 280, level: 11" node_number="280"><a class="valid" valid="valid" title="valid: True, node: 281, level: 12" node_number="281">Proposal</a></div> <ul class="valid" valid="valid" title="valid: True, node: 282, level: 11" node_number="282"> <li class="valid" valid="valid" title="valid: True, node: 283, level: 12" node_number="283"><div class="valid" valid="valid" title="valid: True, node: 284, level: 13" node_number="284"><a class="valid" valid="valid" title="valid: True, node: 285, level: 14" node_number="285">Supported types</a></div></li> <li class="valid" valid="valid" title="valid: True, node: 286, level: 12" node_number="286"><div class="valid" valid="valid" title="valid: True, node: 287, level: 13" node_number="287"><a class="valid" valid="valid" title="valid: True, node: 288, level: 14" node_number="288">Variance</a></div></li> <li class="valid" valid="valid" title="valid: True, node: 289, level: 12" node_number="289"><div class="valid" valid="valid" title="valid: True, node: 290, level: 13" node_number="290"><a class="valid" valid="valid" title="valid: True, node: 291, level: 14" node_number="291">Coercive typing mode</a></div></li> <li class="valid" valid="valid" title="valid: True, node: 292, level: 12" node_number="292"><div class="valid" valid="valid" title="valid: True, node: 293, level: 13" node_number="293"><a class="valid" valid="valid" title="valid: True, node: 294, level: 14" node_number="294">Property types and references</a></div></li> <li class="valid" valid="valid" title="valid: True, node: 295, level: 12" node_number="295"><div class="valid" valid="valid" title="valid: True, node: 296, level: 13" node_number="296"><a class="valid" valid="valid" title="valid: True, node: 297, level: 14" node_number="297">Reflection</a></div></li> <li class="valid" valid="valid" title="valid: True, node: 298, level: 12" node_number="298"><div class="valid" valid="valid" title="valid: True, node: 299, level: 13" node_number="299"><a class="valid" valid="valid" title="valid: True, node: 300, level: 14" node_number="300">Examples</a></div></li> </ul> </li> <li class="valid" valid="valid" title="valid: True, node: 301, level: 10" node_number="301"><div class="valid" valid="valid" title="valid: True, node: 302, level: 11" node_number="302"><a class="valid" valid="valid" title="valid: True, node: 303, level: 12" node_number="303">Backward Incompatible Changes</a></div></li> <li class="valid" valid="valid" title="valid: True, node: 304, level: 10" node_number="304"><div class="valid" valid="valid" title="valid: True, node: 305, level: 11" node_number="305"><a class="valid" valid="valid" title="valid: True, node: 306, level: 12" node_number="306">Proposed PHP Version</a></div></li> <li class="valid" valid="valid" title="valid: True, node: 307, level: 10" node_number="307"><div class="valid" valid="valid" title="valid: True, node: 308, level: 11" node_number="308"><a class="valid" valid="valid" title="valid: True, node: 309, level: 12" node_number="309">Future Scope</a></div> <ul class="valid" valid="valid" title="valid: True, node: 310, level: 11" node_number="310"> <li class="valid" valid="valid" title="valid: True, node: 311, level: 12" node_number="311"><div class="valid" valid="valid" title="valid: True, node: 312, level: 13" node_number="312"><a class="valid" valid="valid" title="valid: True, node: 313, level: 14" node_number="313">Composite types (i.e. mixing union and intersection types)</a></div></li> <li class="valid" valid="valid" title="valid: True, node: 314, level: 12" node_number="314"><div class="valid" valid="valid" title="valid: True, node: 315, level: 13" node_number="315"><a class="valid" valid="valid" title="valid: True, node: 316, level: 14" node_number="316">Type Aliases</a></div></li> </ul> </li> <li class="valid" valid="valid" title="valid: True, node: 317, level: 10" node_number="317"><div class="valid" valid="valid" title="valid: True, node: 318, level: 11" node_number="318"><a class="valid" valid="valid" title="valid: True, node: 319, level: 12" node_number="319">Proposed Voting Choices</a></div></li> <li class="valid" valid="valid" title="valid: True, node: 320, level: 10" node_number="320"><div class="valid" valid="valid" title="valid: True, node: 321, level: 11" node_number="321"><a class="valid" valid="valid" title="valid: True, node: 322, level: 12" node_number="322">Implementation</a></div></li> <li class="valid" valid="valid" title="valid: True, node: 323, level: 10" node_number="323"><div class="valid" valid="valid" title="valid: True, node: 324, level: 11" node_number="324"><a class="valid" valid="valid" title="valid: True, node: 325, level: 12" node_number="325">Acknowledgements</a></div></li> <li class="valid" valid="valid" title="valid: True, node: 326, level: 10" node_number="326"><div class="valid" valid="valid" title="valid: True, node: 327, level: 11" node_number="327"><a class="valid" valid="valid" title="valid: True, node: 328, level: 12" node_number="328">References</a></div></li> </ul></li> </ul> </div> </div> </section> </section> </div> </body>
        <style tyle='text/css'>
body{
    position: relative;
    padding-left: 30px;
    top: 60px;
}
* {
    border: 1px solid #eee;
    padding: 5px 12px;
    margin: 3px 0;
    box-sizing: content-box;
    background-color: #fff;
    cursor: no-drop;
}
main:hover > *, section:hover > *, header:hover > *, nav:hover > *, a:hover > *, div:hover > *, p:hover > *, ul:hover > *, h1:hover > *, h2:hover > *, h3:hover > *, li:hover > *, span:hover > *{
    border: 2px solid green;
    background-color: #fffeee;
    padding: 5px 23px !important;
    margin: 1px 0;
    color: green;
}
main:hover, section:hover, header:hover, nav:hover, a:hover, div:hover, p:hover, ul:hover, h1:hover, h2:hover, h3:hover, li:hover, span:hover{
    border: 1px solid #fff;
    background-color: #eee;
}
a, span {
    display: block;
}
.selected {
    border: 2px solid orchid !important;
    opacity: 0.8;
    color: orchid !important;
}
.selected * {
    padding: 2px !important;
    color: orchid !important;
}
.valid {
  cursor: pointer;
}
.btn{
  cursor: pointer;
  font-weight: bolder;
  padding: 8px;
}
</style> 
        <script>function OpenOriginalLink($event){
    $event.stopPropagation();
    console.log(url);
}

function removeItem($event){
    $event.stopPropagation();
    console.log('Remove item: ', url)
    localStorage.removeItem(url)
}

function exportData($event){
    $event.stopPropagation();

    result = []
    for(let i=0; i<localStorage.length; i++) {
        let key = localStorage.key(i);
        result.push(localStorage.getItem(key))
    }
    const _url = URL.createObjectURL(new Blob([result.join("\n")], {type: 'text/plain'}))
    $event.target.href = _url;
    localStorage.clear()
}

var removeItemBtn = document.createElement("BUTTON");   // Create a <button> element
removeItemBtn.innerHTML = "Remove Item";
removeItemBtn.classList.add('btn');
removeItemBtn.style.position = "fixed";
removeItemBtn.style.left = '5px';
removeItemBtn.style.top = 0;
removeItemBtn.style.border = "1px solid";
removeItemBtn.style.boxShadow = "3px 3px #888";
removeItemBtn.onclick = removeItem;
document.body.appendChild(removeItemBtn);

var goToOriginLink = document.createElement("A");   // Create a <button> element
goToOriginLink.innerHTML = "GoToOrigin";
goToOriginLink.classList.add('btn');
goToOriginLink.style.position = "fixed"
goToOriginLink.style.left = '115px'
goToOriginLink.style.top = 0;
goToOriginLink.onclick = OpenOriginalLink;
goToOriginLink.setAttribute('href', decodeURIComponent(url));
goToOriginLink.target = '_blank';
document.body.appendChild(goToOriginLink);

var current = new Date
var exportDataLink = document.createElement("A");   // Create a <button> element
exportDataLink.innerHTML = "Export data";
exportDataLink.classList.add('btn');
exportDataLink.download = current.toISOString() + '.exported.txt';
exportDataLink.style.position = "fixed";
exportDataLink.style.right = '5px';
exportDataLink.style.top = 0;
exportDataLink.style.border = "1px solid #888";
exportDataLink.style.boxShadow = "3px 3px #888";
exportDataLink.onclick = exportData;
document.body.appendChild(exportDataLink);

data = {
    'title': null ,
    'article': null
}

var body = document.getElementsByTagName("body")[0];

body.onclick = function($e){
    var num = $e.target.getAttribute('node_number')
    var valid = $e.target.getAttribute('valid')

    if(!valid){
        console.log("Element is invalid")
        return
    }

    if(data.length > 2){
        data = data.splice(0, 2)
    }

    console.log("node:", $e.target)

    if(!data.title && !data.article){
        data.title = num;
        console.log("data:", data)
        $e.target.classList.add('selected')
    }else if (data.title && !data.article){
        data.article = num;
        console.log("data:", data)
        $e.target.classList.add('selected')
    }else{
        selected = Array.from(document.getElementsByClassName("selected"))
        selected.forEach(function(el){
            el.classList.remove('selected')
        })

        data.title = num;
        data.article = null;
        $e.target.classList.add('selected')

    }

    if(data.title && data.article){
        var obj = {
            url: url,
            text: body_html,
            title: data.title,
            article: data.article,
        }

        var datasetItem = JSON.stringify(obj)
        localStorage.setItem(url, datasetItem)
    }
}
</script> 
      </html>