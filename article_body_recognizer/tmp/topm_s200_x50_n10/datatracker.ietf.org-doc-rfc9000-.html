<!DOCTYPE html>
<html>
<head>

      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

        <script> var url = encodeURIComponent('https://datatracker.ietf.org/doc/rfc9000/');</script>

        <script> var body_html = 'PGJvZHkgPiAgPGRpdiA+IDxkaXYgPiA8aDI+UVVJQzogQSBVRFAtQmFzZWQgTXVsdGlwbGV4ZWQgYW5kIFNlY3VyZSBUcmFuc3BvcnQ8c21hbGw+UkZDIDkwMDA8L3NtYWxsPjwvaDI+IDx1bCA+IDxsaSA+IDxhID5TdGF0dXM8L2E+IDwvbGk+IDxsaSA+IDxhID5JRVNHIGV2YWx1YXRpb24gcmVjb3JkPC9hPiA8L2xpPiA8bGkgPiA8YSA+SUVTRyB3cml0ZXVwczwvYT4gPC9saT4gPGxpID4gPGEgPkVtYWlsIGV4cGFuc2lvbnM8L2E+IDwvbGk+IDxsaSA+IDxhID5IaXN0b3J5PC9hPiA8L2xpPiA8L3VsPiA8dWwgPiA8bGkgPjxhPjxiPlZlcnNpb25zPC9iPjwvYT48L2xpPiA8bGk+IDxhID4wMDwvYT4gPC9saT4gPGxpPiA8YSA+MDE8L2E+IDwvbGk+IDxsaT4gPGEgPjAyPC9hPiA8L2xpPiA8bGk+IDxhID4wMzwvYT4gPC9saT4gPGxpPiA8YSA+MDQ8L2E+IDwvbGk+IDxsaT4gPGEgPjA1PC9hPiA8L2xpPiA8bGk+IDxhID4wNjwvYT4gPC9saT4gPGxpPiA8YSA+MDc8L2E+IDwvbGk+IDxsaT4gPGEgPjA4PC9hPiA8L2xpPiA8bGk+IDxhID4wOTwvYT4gPC9saT4gPGxpPiA8YSA+MTA8L2E+IDwvbGk+IDxsaT4gPGEgPjExPC9hPiA8L2xpPiA8bGk+IDxhID4xMjwvYT4gPC9saT4gPGxpPiA8YSA+MTM8L2E+IDwvbGk+IDxsaT4gPGEgPjE0PC9hPiA8L2xpPiA8bGk+IDxhID4xNTwvYT4gPC9saT4gPGxpPiA8YSA+MTY8L2E+IDwvbGk+IDxsaT4gPGEgPjE3PC9hPiA8L2xpPiA8bGk+IDxhID4xODwvYT4gPC9saT4gPGxpPiA8YSA+MTk8L2E+IDwvbGk+IDxsaT4gPGEgPjIwPC9hPiA8L2xpPiA8bGk+IDxhID4yMTwvYT4gPC9saT4gPGxpPiA8YSA+MjI8L2E+IDwvbGk+IDxsaT4gPGEgPjIzPC9hPiA8L2xpPiA8bGk+IDxhID4yNDwvYT4gPC9saT4gPGxpPiA8YSA+MjU8L2E+IDwvbGk+IDxsaT4gPGEgPjI2PC9hPiA8L2xpPiA8bGk+IDxhID4yNzwvYT4gPC9saT4gPGxpPiA8YSA+Mjg8L2E+IDwvbGk+IDxsaT4gPGEgPjI5PC9hPiA8L2xpPiA8bGk+IDxhID4zMDwvYT4gPC9saT4gPGxpPiA8YSA+MzE8L2E+IDwvbGk+IDxsaT4gPGEgPjMyPC9hPiA8L2xpPiA8bGk+IDxhID4zMzwvYT4gPC9saT4gPGxpPiA8YSA+MzQ8L2E+IDwvbGk+IDwvdWw+IDxkaXYgPiA8YSA+IEVtYWlsIGF1dGhvcnM8L2E+IDxhID4gRW1haWwgV0c8L2E+IDxhID4gSVBSIDwvYT4gPGEgPiBSZWZlcmVuY2VzPC9hPiA8YSA+IFJlZmVyZW5jZWQgYnk8L2E+IDxhID4gTml0czwvYT4gPGRpdiA+IDx1bCA+IDxsaSA+SUVURiBNYWlsIEFyY2hpdmU8L2xpPiA8bGkgPjxhID5Hb29nbGU8L2E+PC9saT4gPC91bD4gPC9kaXY+IDwvZGl2PiA8cHJlPu+7vyBJbnRlcm5ldCBFbmdpbmVlcmluZyBUYXNrIEZvcmNlIChJRVRGKSBKLiBJeWVuZ2FyLCBFZC4gUmVxdWVzdCBmb3IgQ29tbWVudHM6IDkwMDAgRmFzdGx5IENhdGVnb3J5OiBTdGFuZGFyZHMgVHJhY2sgTS4gVGhvbXNvbiwgRWQuIElTU046IDIwNzAtMTcyMSBNb3ppbGxhIE1heSAyMDIxIFFVSUM6IEEgVURQLUJhc2VkIE11bHRpcGxleGVkIGFuZCBTZWN1cmUgVHJhbnNwb3J0IEFic3RyYWN0IFRoaXMgZG9jdW1lbnQgZGVmaW5lcyB0aGUgY29yZSBvZiB0aGUgUVVJQyB0cmFuc3BvcnQgcHJvdG9jb2wuIFFVSUMgcHJvdmlkZXMgYXBwbGljYXRpb25zIHdpdGggZmxvdy1jb250cm9sbGVkIHN0cmVhbXMgZm9yIHN0cnVjdHVyZWQgY29tbXVuaWNhdGlvbiwgbG93LWxhdGVuY3kgY29ubmVjdGlvbiBlc3RhYmxpc2htZW50LCBhbmQgbmV0d29yayBwYXRoIG1pZ3JhdGlvbi4gUVVJQyBpbmNsdWRlcyBzZWN1cml0eSBtZWFzdXJlcyB0aGF0IGVuc3VyZSBjb25maWRlbnRpYWxpdHksIGludGVncml0eSwgYW5kIGF2YWlsYWJpbGl0eSBpbiBhIHJhbmdlIG9mIGRlcGxveW1lbnQgY2lyY3Vtc3RhbmNlcy4gQWNjb21wYW55aW5nIGRvY3VtZW50cyBkZXNjcmliZSB0aGUgaW50ZWdyYXRpb24gb2YgVExTIGZvciBrZXkgbmVnb3RpYXRpb24sIGxvc3MgZGV0ZWN0aW9uLCBhbmQgYW4gZXhlbXBsYXJ5IGNvbmdlc3Rpb24gY29udHJvbCBhbGdvcml0aG0uIFN0YXR1cyBvZiBUaGlzIE1lbW8gVGhpcyBpcyBhbiBJbnRlcm5ldCBTdGFuZGFyZHMgVHJhY2sgZG9jdW1lbnQuIFRoaXMgZG9jdW1lbnQgaXMgYSBwcm9kdWN0IG9mIHRoZSBJbnRlcm5ldCBFbmdpbmVlcmluZyBUYXNrIEZvcmNlIChJRVRGKS4gSXQgcmVwcmVzZW50cyB0aGUgY29uc2Vuc3VzIG9mIHRoZSBJRVRGIGNvbW11bml0eS4gSXQgaGFzIHJlY2VpdmVkIHB1YmxpYyByZXZpZXcgYW5kIGhhcyBiZWVuIGFwcHJvdmVkIGZvciBwdWJsaWNhdGlvbiBieSB0aGUgSW50ZXJuZXQgRW5naW5lZXJpbmcgU3RlZXJpbmcgR3JvdXAgKElFU0cpLiBGdXJ0aGVyIGluZm9ybWF0aW9uIG9uIEludGVybmV0IFN0YW5kYXJkcyBpcyBhdmFpbGFibGUgaW4gU2VjdGlvbiAyIG9mIFJGQyA3ODQxLiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBzdGF0dXMgb2YgdGhpcyBkb2N1bWVudCwgYW55IGVycmF0YSwgYW5kIGhvdyB0byBwcm92aWRlIGZlZWRiYWNrIG9uIGl0IG1heSBiZSBvYnRhaW5lZCBhdCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9pbmZvL3JmYzkwMDAuIENvcHlyaWdodCBOb3RpY2UgQ29weXJpZ2h0IChjKSAyMDIxIElFVEYgVHJ1c3QgYW5kIHRoZSBwZXJzb25zIGlkZW50aWZpZWQgYXMgdGhlIGRvY3VtZW50IGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFRoaXMgZG9jdW1lbnQgaXMgc3ViamVjdCB0byBCQ1AgNzggYW5kIHRoZSBJRVRGIFRydXN0J3MgTGVnYWwgUHJvdmlzaW9ucyBSZWxhdGluZyB0byBJRVRGIERvY3VtZW50cyAoaHR0cHM6Ly90cnVzdGVlLmlldGYub3JnL2xpY2Vuc2UtaW5mbykgaW4gZWZmZWN0IG9uIHRoZSBkYXRlIG9mIHB1YmxpY2F0aW9uIG9mIHRoaXMgZG9jdW1lbnQuIFBsZWFzZSByZXZpZXcgdGhlc2UgZG9jdW1lbnRzIGNhcmVmdWxseSwgYXMgdGhleSBkZXNjcmliZSB5b3VyIHJpZ2h0cyBhbmQgcmVzdHJpY3Rpb25zIHdpdGggcmVzcGVjdCB0byB0aGlzIGRvY3VtZW50LiBDb2RlIENvbXBvbmVudHMgZXh0cmFjdGVkIGZyb20gdGhpcyBkb2N1bWVudCBtdXN0IGluY2x1ZGUgU2ltcGxpZmllZCBCU0QgTGljZW5zZSB0ZXh0IGFzIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDQuZSBvZiB0aGUgVHJ1c3QgTGVnYWwgUHJvdmlzaW9ucyBhbmQgYXJlIHByb3ZpZGVkIHdpdGhvdXQgd2FycmFudHkgYXMgZGVzY3JpYmVkIGluIHRoZSBTaW1wbGlmaWVkIEJTRCBMaWNlbnNlLiBUYWJsZSBvZiBDb250ZW50cyAxLiBPdmVydmlldyAxLjEuIERvY3VtZW50IFN0cnVjdHVyZSAxLjIuIFRlcm1zIGFuZCBEZWZpbml0aW9ucyAxLjMuIE5vdGF0aW9uYWwgQ29udmVudGlvbnMgMi4gU3RyZWFtcyAyLjEuIFN0cmVhbSBUeXBlcyBhbmQgSWRlbnRpZmllcnMgMi4yLiBTZW5kaW5nIGFuZCBSZWNlaXZpbmcgRGF0YSAyLjMuIFN0cmVhbSBQcmlvcml0aXphdGlvbiAyLjQuIE9wZXJhdGlvbnMgb24gU3RyZWFtcyAzLiBTdHJlYW0gU3RhdGVzIDMuMS4gU2VuZGluZyBTdHJlYW0gU3RhdGVzIDMuMi4gUmVjZWl2aW5nIFN0cmVhbSBTdGF0ZXMgMy4zLiBQZXJtaXR0ZWQgRnJhbWUgVHlwZXMgMy40LiBCaWRpcmVjdGlvbmFsIFN0cmVhbSBTdGF0ZXMgMy41LiBTb2xpY2l0ZWQgU3RhdGUgVHJhbnNpdGlvbnMgNC4gRmxvdyBDb250cm9sIDQuMS4gRGF0YSBGbG93IENvbnRyb2wgNC4yLiBJbmNyZWFzaW5nIEZsb3cgQ29udHJvbCBMaW1pdHMgNC4zLiBGbG93IENvbnRyb2wgUGVyZm9ybWFuY2UgNC40LiBIYW5kbGluZyBTdHJlYW0gQ2FuY2VsbGF0aW9uIDQuNS4gU3RyZWFtIEZpbmFsIFNpemUgNC42LiBDb250cm9sbGluZyBDb25jdXJyZW5jeSA1LiBDb25uZWN0aW9ucyA1LjEuIENvbm5lY3Rpb24gSUQgNS4xLjEuIElzc3VpbmcgQ29ubmVjdGlvbiBJRHMgNS4xLjIuIENvbnN1bWluZyBhbmQgUmV0aXJpbmcgQ29ubmVjdGlvbiBJRHMgNS4yLiBNYXRjaGluZyBQYWNrZXRzIHRvIENvbm5lY3Rpb25zIDUuMi4xLiBDbGllbnQgUGFja2V0IEhhbmRsaW5nIDUuMi4yLiBTZXJ2ZXIgUGFja2V0IEhhbmRsaW5nIDUuMi4zLiBDb25zaWRlcmF0aW9ucyBmb3IgU2ltcGxlIExvYWQgQmFsYW5jZXJzIDUuMy4gT3BlcmF0aW9ucyBvbiBDb25uZWN0aW9ucyA2LiBWZXJzaW9uIE5lZ290aWF0aW9uIDYuMS4gU2VuZGluZyBWZXJzaW9uIE5lZ290aWF0aW9uIFBhY2tldHMgNi4yLiBIYW5kbGluZyBWZXJzaW9uIE5lZ290aWF0aW9uIFBhY2tldHMgNi4zLiBVc2luZyBSZXNlcnZlZCBWZXJzaW9ucyA3LiBDcnlwdG9ncmFwaGljIGFuZCBUcmFuc3BvcnQgSGFuZHNoYWtlIDcuMS4gRXhhbXBsZSBIYW5kc2hha2UgRmxvd3MgNy4yLiBOZWdvdGlhdGluZyBDb25uZWN0aW9uIElEcyA3LjMuIEF1dGhlbnRpY2F0aW5nIENvbm5lY3Rpb24gSURzIDcuNC4gVHJhbnNwb3J0IFBhcmFtZXRlcnMgNy40LjEuIFZhbHVlcyBvZiBUcmFuc3BvcnQgUGFyYW1ldGVycyBmb3IgMC1SVFQgNy40LjIuIE5ldyBUcmFuc3BvcnQgUGFyYW1ldGVycyA3LjUuIENyeXB0b2dyYXBoaWMgTWVzc2FnZSBCdWZmZXJpbmcgOC4gQWRkcmVzcyBWYWxpZGF0aW9uIDguMS4gQWRkcmVzcyBWYWxpZGF0aW9uIGR1cmluZyBDb25uZWN0aW9uIEVzdGFibGlzaG1lbnQgOC4xLjEuIFRva2VuIENvbnN0cnVjdGlvbiA4LjEuMi4gQWRkcmVzcyBWYWxpZGF0aW9uIFVzaW5nIFJldHJ5IFBhY2tldHMgOC4xLjMuIEFkZHJlc3MgVmFsaWRhdGlvbiBmb3IgRnV0dXJlIENvbm5lY3Rpb25zIDguMS40LiBBZGRyZXNzIFZhbGlkYXRpb24gVG9rZW4gSW50ZWdyaXR5IDguMi4gUGF0aCBWYWxpZGF0aW9uIDguMi4xLiBJbml0aWF0aW5nIFBhdGggVmFsaWRhdGlvbiA4LjIuMi4gUGF0aCBWYWxpZGF0aW9uIFJlc3BvbnNlcyA4LjIuMy4gU3VjY2Vzc2Z1bCBQYXRoIFZhbGlkYXRpb24gOC4yLjQuIEZhaWxlZCBQYXRoIFZhbGlkYXRpb24gOS4gQ29ubmVjdGlvbiBNaWdyYXRpb24gOS4xLiBQcm9iaW5nIGEgTmV3IFBhdGggOS4yLiBJbml0aWF0aW5nIENvbm5lY3Rpb24gTWlncmF0aW9uIDkuMy4gUmVzcG9uZGluZyB0byBDb25uZWN0aW9uIE1pZ3JhdGlvbiA5LjMuMS4gUGVlciBBZGRyZXNzIFNwb29maW5nIDkuMy4yLiBPbi1QYXRoIEFkZHJlc3MgU3Bvb2ZpbmcgOS4zLjMuIE9mZi1QYXRoIFBhY2tldCBGb3J3YXJkaW5nIDkuNC4gTG9zcyBEZXRlY3Rpb24gYW5kIENvbmdlc3Rpb24gQ29udHJvbCA5LjUuIFByaXZhY3kgSW1wbGljYXRpb25zIG9mIENvbm5lY3Rpb24gTWlncmF0aW9uIDkuNi4gU2VydmVyJ3MgUHJlZmVycmVkIEFkZHJlc3MgOS42LjEuIENvbW11bmljYXRpbmcgYSBQcmVmZXJyZWQgQWRkcmVzcyA5LjYuMi4gTWlncmF0aW9uIHRvIGEgUHJlZmVycmVkIEFkZHJlc3MgOS42LjMuIEludGVyYWN0aW9uIG9mIENsaWVudCBNaWdyYXRpb24gYW5kIFByZWZlcnJlZCBBZGRyZXNzIDkuNy4gVXNlIG9mIElQdjYgRmxvdyBMYWJlbCBhbmQgTWlncmF0aW9uIDEwLiBDb25uZWN0aW9uIFRlcm1pbmF0aW9uIDEwLjEuIElkbGUgVGltZW91dCAxMC4xLjEuIExpdmVuZXNzIFRlc3RpbmcgMTAuMS4yLiBEZWZlcnJpbmcgSWRsZSBUaW1lb3V0IDEwLjIuIEltbWVkaWF0ZSBDbG9zZSAxMC4yLjEuIENsb3NpbmcgQ29ubmVjdGlvbiBTdGF0ZSAxMC4yLjIuIERyYWluaW5nIENvbm5lY3Rpb24gU3RhdGUgMTAuMi4zLiBJbW1lZGlhdGUgQ2xvc2UgZHVyaW5nIHRoZSBIYW5kc2hha2UgMTAuMy4gU3RhdGVsZXNzIFJlc2V0IDEwLjMuMS4gRGV0ZWN0aW5nIGEgU3RhdGVsZXNzIFJlc2V0IDEwLjMuMi4gQ2FsY3VsYXRpbmcgYSBTdGF0ZWxlc3MgUmVzZXQgVG9rZW4gMTAuMy4zLiBMb29waW5nIDExLiBFcnJvciBIYW5kbGluZyAxMS4xLiBDb25uZWN0aW9uIEVycm9ycyAxMS4yLiBTdHJlYW0gRXJyb3JzIDEyLiBQYWNrZXRzIGFuZCBGcmFtZXMgMTIuMS4gUHJvdGVjdGVkIFBhY2tldHMgMTIuMi4gQ29hbGVzY2luZyBQYWNrZXRzIDEyLjMuIFBhY2tldCBOdW1iZXJzIDEyLjQuIEZyYW1lcyBhbmQgRnJhbWUgVHlwZXMgMTIuNS4gRnJhbWVzIGFuZCBOdW1iZXIgU3BhY2VzIDEzLiBQYWNrZXRpemF0aW9uIGFuZCBSZWxpYWJpbGl0eSAxMy4xLiBQYWNrZXQgUHJvY2Vzc2luZyAxMy4yLiBHZW5lcmF0aW5nIEFja25vd2xlZGdtZW50cyAxMy4yLjEuIFNlbmRpbmcgQUNLIEZyYW1lcyAxMy4yLjIuIEFja25vd2xlZGdtZW50IEZyZXF1ZW5jeSAxMy4yLjMuIE1hbmFnaW5nIEFDSyBSYW5nZXMgMTMuMi40LiBMaW1pdGluZyBSYW5nZXMgYnkgVHJhY2tpbmcgQUNLIEZyYW1lcyAxMy4yLjUuIE1lYXN1cmluZyBhbmQgUmVwb3J0aW5nIEhvc3QgRGVsYXkgMTMuMi42LiBBQ0sgRnJhbWVzIGFuZCBQYWNrZXQgUHJvdGVjdGlvbiAxMy4yLjcuIFBBRERJTkcgRnJhbWVzIENvbnN1bWUgQ29uZ2VzdGlvbiBXaW5kb3cgMTMuMy4gUmV0cmFuc21pc3Npb24gb2YgSW5mb3JtYXRpb24gMTMuNC4gRXhwbGljaXQgQ29uZ2VzdGlvbiBOb3RpZmljYXRpb24gMTMuNC4xLiBSZXBvcnRpbmcgRUNOIENvdW50cyAxMy40LjIuIEVDTiBWYWxpZGF0aW9uIDE0LiBEYXRhZ3JhbSBTaXplIDE0LjEuIEluaXRpYWwgRGF0YWdyYW0gU2l6ZSAxNC4yLiBQYXRoIE1heGltdW0gVHJhbnNtaXNzaW9uIFVuaXQgMTQuMi4xLiBIYW5kbGluZyBvZiBJQ01QIE1lc3NhZ2VzIGJ5IFBNVFVEIDE0LjMuIERhdGFncmFtIFBhY2tldGl6YXRpb24gTGF5ZXIgUE1UVSBEaXNjb3ZlcnkgMTQuMy4xLiBEUExQTVRVRCBhbmQgSW5pdGlhbCBDb25uZWN0aXZpdHkgMTQuMy4yLiBWYWxpZGF0aW5nIHRoZSBOZXR3b3JrIFBhdGggd2l0aCBEUExQTVRVRCAxNC4zLjMuIEhhbmRsaW5nIG9mIElDTVAgTWVzc2FnZXMgYnkgRFBMUE1UVUQgMTQuNC4gU2VuZGluZyBRVUlDIFBNVFUgUHJvYmVzIDE0LjQuMS4gUE1UVSBQcm9iZXMgQ29udGFpbmluZyBTb3VyY2UgQ29ubmVjdGlvbiBJRCAxNS4gVmVyc2lvbnMgMTYuIFZhcmlhYmxlLUxlbmd0aCBJbnRlZ2VyIEVuY29kaW5nIDE3LiBQYWNrZXQgRm9ybWF0cyAxNy4xLiBQYWNrZXQgTnVtYmVyIEVuY29kaW5nIGFuZCBEZWNvZGluZyAxNy4yLiBMb25nIEhlYWRlciBQYWNrZXRzIDE3LjIuMS4gVmVyc2lvbiBOZWdvdGlhdGlvbiBQYWNrZXQgMTcuMi4yLiBJbml0aWFsIFBhY2tldCAxNy4yLjMuIDAtUlRUIDE3LjIuNC4gSGFuZHNoYWtlIFBhY2tldCAxNy4yLjUuIFJldHJ5IFBhY2tldCAxNy4zLiBTaG9ydCBIZWFkZXIgUGFja2V0cyAxNy4zLjEuIDEtUlRUIFBhY2tldCAxNy40LiBMYXRlbmN5IFNwaW4gQml0IDE4LiBUcmFuc3BvcnQgUGFyYW1ldGVyIEVuY29kaW5nIDE4LjEuIFJlc2VydmVkIFRyYW5zcG9ydCBQYXJhbWV0ZXJzIDE4LjIuIFRyYW5zcG9ydCBQYXJhbWV0ZXIgRGVmaW5pdGlvbnMgMTkuIEZyYW1lIFR5cGVzIGFuZCBGb3JtYXRzIDE5LjEuIFBBRERJTkcgRnJhbWVzIDE5LjIuIFBJTkcgRnJhbWVzIDE5LjMuIEFDSyBGcmFtZXMgMTkuMy4xLiBBQ0sgUmFuZ2VzIDE5LjMuMi4gRUNOIENvdW50cyAxOS40LiBSRVNFVF9TVFJFQU0gRnJhbWVzIDE5LjUuIFNUT1BfU0VORElORyBGcmFtZXMgMTkuNi4gQ1JZUFRPIEZyYW1lcyAxOS43LiBORVdfVE9LRU4gRnJhbWVzIDE5LjguIFNUUkVBTSBGcmFtZXMgMTkuOS4gTUFYX0RBVEEgRnJhbWVzIDE5LjEwLiBNQVhfU1RSRUFNX0RBVEEgRnJhbWVzIDE5LjExLiBNQVhfU1RSRUFNUyBGcmFtZXMgMTkuMTIuIERBVEFfQkxPQ0tFRCBGcmFtZXMgMTkuMTMuIFNUUkVBTV9EQVRBX0JMT0NLRUQgRnJhbWVzIDE5LjE0LiBTVFJFQU1TX0JMT0NLRUQgRnJhbWVzIDE5LjE1LiBORVdfQ09OTkVDVElPTl9JRCBGcmFtZXMgMTkuMTYuIFJFVElSRV9DT05ORUNUSU9OX0lEIEZyYW1lcyAxOS4xNy4gUEFUSF9DSEFMTEVOR0UgRnJhbWVzIDE5LjE4LiBQQVRIX1JFU1BPTlNFIEZyYW1lcyAxOS4xOS4gQ09OTkVDVElPTl9DTE9TRSBGcmFtZXMgMTkuMjAuIEhBTkRTSEFLRV9ET05FIEZyYW1lcyAxOS4yMS4gRXh0ZW5zaW9uIEZyYW1lcyAyMC4gRXJyb3IgQ29kZXMgMjAuMS4gVHJhbnNwb3J0IEVycm9yIENvZGVzIDIwLjIuIEFwcGxpY2F0aW9uIFByb3RvY29sIEVycm9yIENvZGVzIDIxLiBTZWN1cml0eSBDb25zaWRlcmF0aW9ucyAyMS4xLiBPdmVydmlldyBvZiBTZWN1cml0eSBQcm9wZXJ0aWVzIDIxLjEuMS4gSGFuZHNoYWtlIDIxLjEuMi4gUHJvdGVjdGVkIFBhY2tldHMgMjEuMS4zLiBDb25uZWN0aW9uIE1pZ3JhdGlvbiAyMS4yLiBIYW5kc2hha2UgRGVuaWFsIG9mIFNlcnZpY2UgMjEuMy4gQW1wbGlmaWNhdGlvbiBBdHRhY2sgMjEuNC4gT3B0aW1pc3RpYyBBQ0sgQXR0YWNrIDIxLjUuIFJlcXVlc3QgRm9yZ2VyeSBBdHRhY2tzIDIxLjUuMS4gQ29udHJvbCBPcHRpb25zIGZvciBFbmRwb2ludHMgMjEuNS4yLiBSZXF1ZXN0IEZvcmdlcnkgd2l0aCBDbGllbnQgSW5pdGlhbCBQYWNrZXRzIDIxLjUuMy4gUmVxdWVzdCBGb3JnZXJ5IHdpdGggUHJlZmVycmVkIEFkZHJlc3NlcyAyMS41LjQuIFJlcXVlc3QgRm9yZ2VyeSB3aXRoIFNwb29mZWQgTWlncmF0aW9uIDIxLjUuNS4gUmVxdWVzdCBGb3JnZXJ5IHdpdGggVmVyc2lvbiBOZWdvdGlhdGlvbiAyMS41LjYuIEdlbmVyaWMgUmVxdWVzdCBGb3JnZXJ5IENvdW50ZXJtZWFzdXJlcyAyMS42LiBTbG93bG9yaXMgQXR0YWNrcyAyMS43LiBTdHJlYW0gRnJhZ21lbnRhdGlvbiBhbmQgUmVhc3NlbWJseSBBdHRhY2tzIDIxLjguIFN0cmVhbSBDb21taXRtZW50IEF0dGFjayAyMS45LiBQZWVyIERlbmlhbCBvZiBTZXJ2aWNlIDIxLjEwLiBFeHBsaWNpdCBDb25nZXN0aW9uIE5vdGlmaWNhdGlvbiBBdHRhY2tzIDIxLjExLiBTdGF0ZWxlc3MgUmVzZXQgT3JhY2xlIDIxLjEyLiBWZXJzaW9uIERvd25ncmFkZSAyMS4xMy4gVGFyZ2V0ZWQgQXR0YWNrcyBieSBSb3V0aW5nIDIxLjE0LiBUcmFmZmljIEFuYWx5c2lzIDIyLiBJQU5BIENvbnNpZGVyYXRpb25zIDIyLjEuIFJlZ2lzdHJhdGlvbiBQb2xpY2llcyBmb3IgUVVJQyBSZWdpc3RyaWVzIDIyLjEuMS4gUHJvdmlzaW9uYWwgUmVnaXN0cmF0aW9ucyAyMi4xLjIuIFNlbGVjdGluZyBDb2RlcG9pbnRzIDIyLjEuMy4gUmVjbGFpbWluZyBQcm92aXNpb25hbCBDb2RlcG9pbnRzIDIyLjEuNC4gUGVybWFuZW50IFJlZ2lzdHJhdGlvbnMgMjIuMi4gUVVJQyBWZXJzaW9ucyBSZWdpc3RyeSAyMi4zLiBRVUlDIFRyYW5zcG9ydCBQYXJhbWV0ZXJzIFJlZ2lzdHJ5IDIyLjQuIFFVSUMgRnJhbWUgVHlwZXMgUmVnaXN0cnkgMjIuNS4gUVVJQyBUcmFuc3BvcnQgRXJyb3IgQ29kZXMgUmVnaXN0cnkgMjMuIFJlZmVyZW5jZXMgMjMuMS4gTm9ybWF0aXZlIFJlZmVyZW5jZXMgMjMuMi4gSW5mb3JtYXRpdmUgUmVmZXJlbmNlcyBBcHBlbmRpeCBBLiBQc2V1ZG9jb2RlIEEuMS4gU2FtcGxlIFZhcmlhYmxlLUxlbmd0aCBJbnRlZ2VyIERlY29kaW5nIEEuMi4gU2FtcGxlIFBhY2tldCBOdW1iZXIgRW5jb2RpbmcgQWxnb3JpdGhtIEEuMy4gU2FtcGxlIFBhY2tldCBOdW1iZXIgRGVjb2RpbmcgQWxnb3JpdGhtIEEuNC4gU2FtcGxlIEVDTiBWYWxpZGF0aW9uIEFsZ29yaXRobSBDb250cmlidXRvcnMgQXV0aG9ycycgQWRkcmVzc2VzIDEuIE92ZXJ2aWV3IFFVSUMgaXMgYSBzZWN1cmUgZ2VuZXJhbC1wdXJwb3NlIHRyYW5zcG9ydCBwcm90b2NvbC4gVGhpcyBkb2N1bWVudCBkZWZpbmVzIHZlcnNpb24gMSBvZiBRVUlDLCB3aGljaCBjb25mb3JtcyB0byB0aGUgdmVyc2lvbi1pbmRlcGVuZGVudCBwcm9wZXJ0aWVzIG9mIFFVSUMgZGVmaW5lZCBpbiBbUVVJQy1JTlZBUklBTlRTXS4gUVVJQyBpcyBhIGNvbm5lY3Rpb24tb3JpZW50ZWQgcHJvdG9jb2wgdGhhdCBjcmVhdGVzIGEgc3RhdGVmdWwgaW50ZXJhY3Rpb24gYmV0d2VlbiBhIGNsaWVudCBhbmQgc2VydmVyLiBUaGUgUVVJQyBoYW5kc2hha2UgY29tYmluZXMgbmVnb3RpYXRpb24gb2YgY3J5cHRvZ3JhcGhpYyBhbmQgdHJhbnNwb3J0IHBhcmFtZXRlcnMuIFFVSUMgaW50ZWdyYXRlcyB0aGUgVExTIGhhbmRzaGFrZSBbVExTMTNdLCBhbHRob3VnaCB1c2luZyBhIGN1c3RvbWl6ZWQgZnJhbWluZyBmb3IgcHJvdGVjdGluZyBwYWNrZXRzLiBUaGUgaW50ZWdyYXRpb24gb2YgVExTIGFuZCBRVUlDIGlzIGRlc2NyaWJlZCBpbiBtb3JlIGRldGFpbCBpbiBbUVVJQy1UTFNdLiBUaGUgaGFuZHNoYWtlIGlzIHN0cnVjdHVyZWQgdG8gcGVybWl0IHRoZSBleGNoYW5nZSBvZiBhcHBsaWNhdGlvbiBkYXRhIGFzIHNvb24gYXMgcG9zc2libGUuIFRoaXMgaW5jbHVkZXMgYW4gb3B0aW9uIGZvciBjbGllbnRzIHRvIHNlbmQgZGF0YSBpbW1lZGlhdGVseSAoMC1SVFQpLCB3aGljaCByZXF1aXJlcyBzb21lIGZvcm0gb2YgcHJpb3IgY29tbXVuaWNhdGlvbiBvciBjb25maWd1cmF0aW9uIHRvIGVuYWJsZS4gRW5kcG9pbnRzIGNvbW11bmljYXRlIGluIFFVSUMgYnkgZXhjaGFuZ2luZyBRVUlDIHBhY2tldHMuIE1vc3QgcGFja2V0cyBjb250YWluIGZyYW1lcywgd2hpY2ggY2FycnkgY29udHJvbCBpbmZvcm1hdGlvbiBhbmQgYXBwbGljYXRpb24gZGF0YSBiZXR3ZWVuIGVuZHBvaW50cy4gUVVJQyBhdXRoZW50aWNhdGVzIHRoZSBlbnRpcmV0eSBvZiBlYWNoIHBhY2tldCBhbmQgZW5jcnlwdHMgYXMgbXVjaCBvZiBlYWNoIHBhY2tldCBhcyBpcyBwcmFjdGljYWwuIFFVSUMgcGFja2V0cyBhcmUgY2FycmllZCBpbiBVRFAgZGF0YWdyYW1zIFtVRFBdIHRvIGJldHRlciBmYWNpbGl0YXRlIGRlcGxveW1lbnQgaW4gZXhpc3Rpbmcgc3lzdGVtcyBhbmQgbmV0d29ya3MuIEFwcGxpY2F0aW9uIHByb3RvY29scyBleGNoYW5nZSBpbmZvcm1hdGlvbiBvdmVyIGEgUVVJQyBjb25uZWN0aW9uIHZpYSBzdHJlYW1zLCB3aGljaCBhcmUgb3JkZXJlZCBzZXF1ZW5jZXMgb2YgYnl0ZXMuIFR3byB0eXBlcyBvZiBzdHJlYW1zIGNhbiBiZSBjcmVhdGVkOiBiaWRpcmVjdGlvbmFsIHN0cmVhbXMsIHdoaWNoIGFsbG93IGJvdGggZW5kcG9pbnRzIHRvIHNlbmQgZGF0YTsgYW5kIHVuaWRpcmVjdGlvbmFsIHN0cmVhbXMsIHdoaWNoIGFsbG93IGEgc2luZ2xlIGVuZHBvaW50IHRvIHNlbmQgZGF0YS4gQSBjcmVkaXQtYmFzZWQgc2NoZW1lIGlzIHVzZWQgdG8gbGltaXQgc3RyZWFtIGNyZWF0aW9uIGFuZCB0byBib3VuZCB0aGUgYW1vdW50IG9mIGRhdGEgdGhhdCBjYW4gYmUgc2VudC4gUVVJQyBwcm92aWRlcyB0aGUgbmVjZXNzYXJ5IGZlZWRiYWNrIHRvIGltcGxlbWVudCByZWxpYWJsZSBkZWxpdmVyeSBhbmQgY29uZ2VzdGlvbiBjb250cm9sLiBBbiBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBhbmQgcmVjb3ZlcmluZyBmcm9tIGxvc3Mgb2YgZGF0YSBpcyBkZXNjcmliZWQgaW4gU2VjdGlvbiA2IG9mIFtRVUlDLVJFQ09WRVJZXS4gUVVJQyBkZXBlbmRzIG9uIGNvbmdlc3Rpb24gY29udHJvbCB0byBhdm9pZCBuZXR3b3JrIGNvbmdlc3Rpb24uIEFuIGV4ZW1wbGFyeSBjb25nZXN0aW9uIGNvbnRyb2wgYWxnb3JpdGhtIGlzIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDcgb2YgW1FVSUMtUkVDT1ZFUlldLiBRVUlDIGNvbm5lY3Rpb25zIGFyZSBub3Qgc3RyaWN0bHkgYm91bmQgdG8gYSBzaW5nbGUgbmV0d29yayBwYXRoLiBDb25uZWN0aW9uIG1pZ3JhdGlvbiB1c2VzIGNvbm5lY3Rpb24gaWRlbnRpZmllcnMgdG8gYWxsb3cgY29ubmVjdGlvbnMgdG8gdHJhbnNmZXIgdG8gYSBuZXcgbmV0d29yayBwYXRoLiBPbmx5IGNsaWVudHMgYXJlIGFibGUgdG8gbWlncmF0ZSBpbiB0aGlzIHZlcnNpb24gb2YgUVVJQy4gVGhpcyBkZXNpZ24gYWxzbyBhbGxvd3MgY29ubmVjdGlvbnMgdG8gY29udGludWUgYWZ0ZXIgY2hhbmdlcyBpbiBuZXR3b3JrIHRvcG9sb2d5IG9yIGFkZHJlc3MgbWFwcGluZ3MsIHN1Y2ggYXMgbWlnaHQgYmUgY2F1c2VkIGJ5IE5BVCByZWJpbmRpbmcuIE9uY2UgZXN0YWJsaXNoZWQsIG11bHRpcGxlIG9wdGlvbnMgYXJlIHByb3ZpZGVkIGZvciBjb25uZWN0aW9uIHRlcm1pbmF0aW9uLiBBcHBsaWNhdGlvbnMgY2FuIG1hbmFnZSBhIGdyYWNlZnVsIHNodXRkb3duLCBlbmRwb2ludHMgY2FuIG5lZ290aWF0ZSBhIHRpbWVvdXQgcGVyaW9kLCBlcnJvcnMgY2FuIGNhdXNlIGltbWVkaWF0ZSBjb25uZWN0aW9uIHRlYXJkb3duLCBhbmQgYSBzdGF0ZWxlc3MgbWVjaGFuaXNtIHByb3ZpZGVzIGZvciB0ZXJtaW5hdGlvbiBvZiBjb25uZWN0aW9ucyBhZnRlciBvbmUgZW5kcG9pbnQgaGFzIGxvc3Qgc3RhdGUuIDEuMS4gRG9jdW1lbnQgU3RydWN0dXJlIFRoaXMgZG9jdW1lbnQgZGVzY3JpYmVzIHRoZSBjb3JlIFFVSUMgcHJvdG9jb2wgYW5kIGlzIHN0cnVjdHVyZWQgYXMgZm9sbG93czogKiBTdHJlYW1zIGFyZSB0aGUgYmFzaWMgc2VydmljZSBhYnN0cmFjdGlvbiB0aGF0IFFVSUMgcHJvdmlkZXMuIC0gU2VjdGlvbiAyIGRlc2NyaWJlcyBjb3JlIGNvbmNlcHRzIHJlbGF0ZWQgdG8gc3RyZWFtcywgLSBTZWN0aW9uIDMgcHJvdmlkZXMgYSByZWZlcmVuY2UgbW9kZWwgZm9yIHN0cmVhbSBzdGF0ZXMsIGFuZCAtIFNlY3Rpb24gNCBvdXRsaW5lcyB0aGUgb3BlcmF0aW9uIG9mIGZsb3cgY29udHJvbC4gKiBDb25uZWN0aW9ucyBhcmUgdGhlIGNvbnRleHQgaW4gd2hpY2ggUVVJQyBlbmRwb2ludHMgY29tbXVuaWNhdGUuIC0gU2VjdGlvbiA1IGRlc2NyaWJlcyBjb3JlIGNvbmNlcHRzIHJlbGF0ZWQgdG8gY29ubmVjdGlvbnMsIC0gU2VjdGlvbiA2IGRlc2NyaWJlcyB2ZXJzaW9uIG5lZ290aWF0aW9uLCAtIFNlY3Rpb24gNyBkZXRhaWxzIHRoZSBwcm9jZXNzIGZvciBlc3RhYmxpc2hpbmcgY29ubmVjdGlvbnMsIC0gU2VjdGlvbiA4IGRlc2NyaWJlcyBhZGRyZXNzIHZhbGlkYXRpb24gYW5kIGNyaXRpY2FsIGRlbmlhbC1vZi0gc2VydmljZSBtaXRpZ2F0aW9ucywgLSBTZWN0aW9uIDkgZGVzY3JpYmVzIGhvdyBlbmRwb2ludHMgbWlncmF0ZSBhIGNvbm5lY3Rpb24gdG8gYSBuZXcgbmV0d29yayBwYXRoLCAtIFNlY3Rpb24gMTAgbGlzdHMgdGhlIG9wdGlvbnMgZm9yIHRlcm1pbmF0aW5nIGFuIG9wZW4gY29ubmVjdGlvbiwgYW5kIC0gU2VjdGlvbiAxMSBwcm92aWRlcyBndWlkYW5jZSBmb3Igc3RyZWFtIGFuZCBjb25uZWN0aW9uIGVycm9yIGhhbmRsaW5nLiAqIFBhY2tldHMgYW5kIGZyYW1lcyBhcmUgdGhlIGJhc2ljIHVuaXQgdXNlZCBieSBRVUlDIHRvIGNvbW11bmljYXRlLiAtIFNlY3Rpb24gMTIgZGVzY3JpYmVzIGNvbmNlcHRzIHJlbGF0ZWQgdG8gcGFja2V0cyBhbmQgZnJhbWVzLCAtIFNlY3Rpb24gMTMgZGVmaW5lcyBtb2RlbHMgZm9yIHRoZSB0cmFuc21pc3Npb24sIHJldHJhbnNtaXNzaW9uLCBhbmQgYWNrbm93bGVkZ21lbnQgb2YgZGF0YSwgYW5kIC0gU2VjdGlvbiAxNCBzcGVjaWZpZXMgcnVsZXMgZm9yIG1hbmFnaW5nIHRoZSBzaXplIG9mIGRhdGFncmFtcyBjYXJyeWluZyBRVUlDIHBhY2tldHMuICogRmluYWxseSwgZW5jb2RpbmcgZGV0YWlscyBvZiBRVUlDIHByb3RvY29sIGVsZW1lbnRzIGFyZSBkZXNjcmliZWQgaW46IC0gU2VjdGlvbiAxNSAodmVyc2lvbnMpLCAtIFNlY3Rpb24gMTYgKGludGVnZXIgZW5jb2RpbmcpLCAtIFNlY3Rpb24gMTcgKHBhY2tldCBoZWFkZXJzKSwgLSBTZWN0aW9uIDE4ICh0cmFuc3BvcnQgcGFyYW1ldGVycyksIC0gU2VjdGlvbiAxOSAoZnJhbWVzKSwgYW5kIC0gU2VjdGlvbiAyMCAoZXJyb3JzKS4gQWNjb21wYW55aW5nIGRvY3VtZW50cyBkZXNjcmliZSBRVUlDJ3MgbG9zcyBkZXRlY3Rpb24gYW5kIGNvbmdlc3Rpb24gY29udHJvbCBbUVVJQy1SRUNPVkVSWV0sIGFuZCB0aGUgdXNlIG9mIFRMUyBhbmQgb3RoZXIgY3J5cHRvZ3JhcGhpYyBtZWNoYW5pc21zIFtRVUlDLVRMU10uIFRoaXMgZG9jdW1lbnQgZGVmaW5lcyBRVUlDIHZlcnNpb24gMSwgd2hpY2ggY29uZm9ybXMgdG8gdGhlIHByb3RvY29sIGludmFyaWFudHMgaW4gW1FVSUMtSU5WQVJJQU5UU10uIFRvIHJlZmVyIHRvIFFVSUMgdmVyc2lvbiAxLCBjaXRlIHRoaXMgZG9jdW1lbnQuIFJlZmVyZW5jZXMgdG8gdGhlIGxpbWl0ZWQgc2V0IG9mIHZlcnNpb24taW5kZXBlbmRlbnQgcHJvcGVydGllcyBvZiBRVUlDIGNhbiBjaXRlIFtRVUlDLUlOVkFSSUFOVFNdLiAxLjIuIFRlcm1zIGFuZCBEZWZpbml0aW9ucyBUaGUga2V5IHdvcmRzICJNVVNUIiwgIk1VU1QgTk9UIiwgIlJFUVVJUkVEIiwgIlNIQUxMIiwgIlNIQUxMIE5PVCIsICJTSE9VTEQiLCAiU0hPVUxEIE5PVCIsICJSRUNPTU1FTkRFRCIsICJOT1QgUkVDT01NRU5ERUQiLCAiTUFZIiwgYW5kICJPUFRJT05BTCIgaW4gdGhpcyBkb2N1bWVudCBhcmUgdG8gYmUgaW50ZXJwcmV0ZWQgYXMgZGVzY3JpYmVkIGluIEJDUCAxNCBbUkZDMjExOV0gW1JGQzgxNzRdIHdoZW4sIGFuZCBvbmx5IHdoZW4sIHRoZXkgYXBwZWFyIGluIGFsbCBjYXBpdGFscywgYXMgc2hvd24gaGVyZS4gQ29tbW9ubHkgdXNlZCB0ZXJtcyBpbiB0aGlzIGRvY3VtZW50IGFyZSBkZXNjcmliZWQgYmVsb3cuIFFVSUM6IFRoZSB0cmFuc3BvcnQgcHJvdG9jb2wgZGVzY3JpYmVkIGJ5IHRoaXMgZG9jdW1lbnQuIFFVSUMgaXMgYSBuYW1lLCBub3QgYW4gYWNyb255bS4gRW5kcG9pbnQ6IEFuIGVudGl0eSB0aGF0IGNhbiBwYXJ0aWNpcGF0ZSBpbiBhIFFVSUMgY29ubmVjdGlvbiBieSBnZW5lcmF0aW5nLCByZWNlaXZpbmcsIGFuZCBwcm9jZXNzaW5nIFFVSUMgcGFja2V0cy4gVGhlcmUgYXJlIG9ubHkgdHdvIHR5cGVzIG9mIGVuZHBvaW50cyBpbiBRVUlDOiBjbGllbnQgYW5kIHNlcnZlci4gQ2xpZW50OiBUaGUgZW5kcG9pbnQgdGhhdCBpbml0aWF0ZXMgYSBRVUlDIGNvbm5lY3Rpb24uIFNlcnZlcjogVGhlIGVuZHBvaW50IHRoYXQgYWNjZXB0cyBhIFFVSUMgY29ubmVjdGlvbi4gUVVJQyBwYWNrZXQ6IEEgY29tcGxldGUgcHJvY2Vzc2FibGUgdW5pdCBvZiBRVUlDIHRoYXQgY2FuIGJlIGVuY2Fwc3VsYXRlZCBpbiBhIFVEUCBkYXRhZ3JhbS4gT25lIG9yIG1vcmUgUVVJQyBwYWNrZXRzIGNhbiBiZSBlbmNhcHN1bGF0ZWQgaW4gYSBzaW5nbGUgVURQIGRhdGFncmFtLiBBY2stZWxpY2l0aW5nIHBhY2tldDogQSBRVUlDIHBhY2tldCB0aGF0IGNvbnRhaW5zIGZyYW1lcyBvdGhlciB0aGFuIEFDSywgUEFERElORywgYW5kIENPTk5FQ1RJT05fQ0xPU0UuIFRoZXNlIGNhdXNlIGEgcmVjaXBpZW50IHRvIHNlbmQgYW4gYWNrbm93bGVkZ21lbnQ7IHNlZSBTZWN0aW9uIDEzLjIuMS4gRnJhbWU6IEEgdW5pdCBvZiBzdHJ1Y3R1cmVkIHByb3RvY29sIGluZm9ybWF0aW9uLiBUaGVyZSBhcmUgbXVsdGlwbGUgZnJhbWUgdHlwZXMsIGVhY2ggb2Ygd2hpY2ggY2FycmllcyBkaWZmZXJlbnQgaW5mb3JtYXRpb24uIEZyYW1lcyBhcmUgY29udGFpbmVkIGluIFFVSUMgcGFja2V0cy4gQWRkcmVzczogV2hlbiB1c2VkIHdpdGhvdXQgcXVhbGlmaWNhdGlvbiwgdGhlIHR1cGxlIG9mIElQIHZlcnNpb24sIElQIGFkZHJlc3MsIGFuZCBVRFAgcG9ydCBudW1iZXIgdGhhdCByZXByZXNlbnRzIG9uZSBlbmQgb2YgYSBuZXR3b3JrIHBhdGguIENvbm5lY3Rpb24gSUQ6IEFuIGlkZW50aWZpZXIgdGhhdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGEgUVVJQyBjb25uZWN0aW9uIGF0IGFuIGVuZHBvaW50LiBFYWNoIGVuZHBvaW50IHNlbGVjdHMgb25lIG9yIG1vcmUgY29ubmVjdGlvbiBJRHMgZm9yIGl0cyBwZWVyIHRvIGluY2x1ZGUgaW4gcGFja2V0cyBzZW50IHRvd2FyZHMgdGhlIGVuZHBvaW50LiBUaGlzIHZhbHVlIGlzIG9wYXF1ZSB0byB0aGUgcGVlci4gU3RyZWFtOiBBIHVuaWRpcmVjdGlvbmFsIG9yIGJpZGlyZWN0aW9uYWwgY2hhbm5lbCBvZiBvcmRlcmVkIGJ5dGVzIHdpdGhpbiBhIFFVSUMgY29ubmVjdGlvbi4gQSBRVUlDIGNvbm5lY3Rpb24gY2FuIGNhcnJ5IG11bHRpcGxlIHNpbXVsdGFuZW91cyBzdHJlYW1zLiBBcHBsaWNhdGlvbjogQW4gZW50aXR5IHRoYXQgdXNlcyBRVUlDIHRvIHNlbmQgYW5kIHJlY2VpdmUgZGF0YS4gVGhpcyBkb2N1bWVudCB1c2VzIHRoZSB0ZXJtcyAiUVVJQyBwYWNrZXRzIiwgIlVEUCBkYXRhZ3JhbXMiLCBhbmQgIklQIHBhY2tldHMiIHRvIHJlZmVyIHRvIHRoZSB1bml0cyBvZiB0aGUgcmVzcGVjdGl2ZSBwcm90b2NvbHMuIFRoYXQgaXMsIG9uZSBvciBtb3JlIFFVSUMgcGFja2V0cyBjYW4gYmUgZW5jYXBzdWxhdGVkIGluIGEgVURQIGRhdGFncmFtLCB3aGljaCBpcyBpbiB0dXJuIGVuY2Fwc3VsYXRlZCBpbiBhbiBJUCBwYWNrZXQuIDEuMy4gTm90YXRpb25hbCBDb252ZW50aW9ucyBQYWNrZXQgYW5kIGZyYW1lIGRpYWdyYW1zIGluIHRoaXMgZG9jdW1lbnQgdXNlIGEgY3VzdG9tIGZvcm1hdC4gVGhlIHB1cnBvc2Ugb2YgdGhpcyBmb3JtYXQgaXMgdG8gc3VtbWFyaXplLCBub3QgZGVmaW5lLCBwcm90b2NvbCBlbGVtZW50cy4gUHJvc2UgZGVmaW5lcyB0aGUgY29tcGxldGUgc2VtYW50aWNzIGFuZCBkZXRhaWxzIG9mIHN0cnVjdHVyZXMuIENvbXBsZXggZmllbGRzIGFyZSBuYW1lZCBhbmQgdGhlbiBmb2xsb3dlZCBieSBhIGxpc3Qgb2YgZmllbGRzIHN1cnJvdW5kZWQgYnkgYSBwYWlyIG9mIG1hdGNoaW5nIGJyYWNlcy4gRWFjaCBmaWVsZCBpbiB0aGlzIGxpc3QgaXMgc2VwYXJhdGVkIGJ5IGNvbW1hcy4gSW5kaXZpZHVhbCBmaWVsZHMgaW5jbHVkZSBsZW5ndGggaW5mb3JtYXRpb24sIHBsdXMgaW5kaWNhdGlvbnMgYWJvdXQgZml4ZWQgdmFsdWUsIG9wdGlvbmFsaXR5LCBvciByZXBldGl0aW9ucy4gSW5kaXZpZHVhbCBmaWVsZHMgdXNlIHRoZSBmb2xsb3dpbmcgbm90YXRpb25hbCBjb252ZW50aW9ucywgd2l0aCBhbGwgbGVuZ3RocyBpbiBiaXRzOiB4IChBKTogSW5kaWNhdGVzIHRoYXQgeCBpcyBBIGJpdHMgbG9uZyB4IChpKTogSW5kaWNhdGVzIHRoYXQgeCBob2xkcyBhbiBpbnRlZ2VyIHZhbHVlIHVzaW5nIHRoZSB2YXJpYWJsZS0gbGVuZ3RoIGVuY29kaW5nIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDE2IHggKEEuLkIpOiBJbmRpY2F0ZXMgdGhhdCB4IGNhbiBiZSBhbnkgbGVuZ3RoIGZyb20gQSB0byBCOyBBIGNhbiBiZSBvbWl0dGVkIHRvIGluZGljYXRlIGEgbWluaW11bSBvZiB6ZXJvIGJpdHMsIGFuZCBCIGNhbiBiZSBvbWl0dGVkIHRvIGluZGljYXRlIG5vIHNldCB1cHBlciBsaW1pdDsgdmFsdWVzIGluIHRoaXMgZm9ybWF0IGFsd2F5cyBlbmQgb24gYSBieXRlIGJvdW5kYXJ5IHggKEwpID0gQzogSW5kaWNhdGVzIHRoYXQgeCBoYXMgYSBmaXhlZCB2YWx1ZSBvZiBDOyB0aGUgbGVuZ3RoIG9mIHggaXMgZGVzY3JpYmVkIGJ5IEwsIHdoaWNoIGNhbiB1c2UgYW55IG9mIHRoZSBsZW5ndGggZm9ybXMgYWJvdmUgeCAoTCkgPSBDLi5EOiBJbmRpY2F0ZXMgdGhhdCB4IGhhcyBhIHZhbHVlIGluIHRoZSByYW5nZSBmcm9tIEMgdG8gRCwgaW5jbHVzaXZlLCB3aXRoIHRoZSBsZW5ndGggZGVzY3JpYmVkIGJ5IEwsIGFzIGFib3ZlIFt4IChMKV06IEluZGljYXRlcyB0aGF0IHggaXMgb3B0aW9uYWwgYW5kIGhhcyBhIGxlbmd0aCBvZiBMIHggKEwpIC4uLjogSW5kaWNhdGVzIHRoYXQgeCBpcyByZXBlYXRlZCB6ZXJvIG9yIG1vcmUgdGltZXMgYW5kIHRoYXQgZWFjaCBpbnN0YW5jZSBoYXMgYSBsZW5ndGggb2YgTCBUaGlzIGRvY3VtZW50IHVzZXMgbmV0d29yayBieXRlIG9yZGVyICh0aGF0IGlzLCBiaWcgZW5kaWFuKSB2YWx1ZXMuIEZpZWxkcyBhcmUgcGxhY2VkIHN0YXJ0aW5nIGZyb20gdGhlIGhpZ2gtb3JkZXIgYml0cyBvZiBlYWNoIGJ5dGUuIEJ5IGNvbnZlbnRpb24sIGluZGl2aWR1YWwgZmllbGRzIHJlZmVyZW5jZSBhIGNvbXBsZXggZmllbGQgYnkgdXNpbmcgdGhlIG5hbWUgb2YgdGhlIGNvbXBsZXggZmllbGQuIEZpZ3VyZSAxIHByb3ZpZGVzIGFuIGV4YW1wbGU6IEV4YW1wbGUgU3RydWN0dXJlIHsgT25lLWJpdCBGaWVsZCAoMSksIDctYml0IEZpZWxkIHdpdGggRml4ZWQgVmFsdWUgKDcpID0gNjEsIEZpZWxkIHdpdGggVmFyaWFibGUtTGVuZ3RoIEludGVnZXIgKGkpLCBBcmJpdHJhcnktTGVuZ3RoIEZpZWxkICguLiksIFZhcmlhYmxlLUxlbmd0aCBGaWVsZCAoOC4uMjQpLCBGaWVsZCBXaXRoIE1pbmltdW0gTGVuZ3RoICgxNi4uKSwgRmllbGQgV2l0aCBNYXhpbXVtIExlbmd0aCAoLi4xMjgpLCBbT3B0aW9uYWwgRmllbGQgKDY0KV0sIFJlcGVhdGVkIEZpZWxkICg4KSAuLi4sIH0gRmlndXJlIDE6IEV4YW1wbGUgRm9ybWF0IFdoZW4gYSBzaW5nbGUtYml0IGZpZWxkIGlzIHJlZmVyZW5jZWQgaW4gcHJvc2UsIHRoZSBwb3NpdGlvbiBvZiB0aGF0IGZpZWxkIGNhbiBiZSBjbGFyaWZpZWQgYnkgdXNpbmcgdGhlIHZhbHVlIG9mIHRoZSBieXRlIHRoYXQgY2FycmllcyB0aGUgZmllbGQgd2l0aCB0aGUgZmllbGQncyB2YWx1ZSBzZXQuIEZvciBleGFtcGxlLCB0aGUgdmFsdWUgMHg4MCBjb3VsZCBiZSB1c2VkIHRvIHJlZmVyIHRvIHRoZSBzaW5nbGUtYml0IGZpZWxkIGluIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgYnl0ZSwgc3VjaCBhcyBPbmUtYml0IEZpZWxkIGluIEZpZ3VyZSAxLiAyLiBTdHJlYW1zIFN0cmVhbXMgaW4gUVVJQyBwcm92aWRlIGEgbGlnaHR3ZWlnaHQsIG9yZGVyZWQgYnl0ZS1zdHJlYW0gYWJzdHJhY3Rpb24gdG8gYW4gYXBwbGljYXRpb24uIFN0cmVhbXMgY2FuIGJlIHVuaWRpcmVjdGlvbmFsIG9yIGJpZGlyZWN0aW9uYWwuIFN0cmVhbXMgY2FuIGJlIGNyZWF0ZWQgYnkgc2VuZGluZyBkYXRhLiBPdGhlciBwcm9jZXNzZXMgYXNzb2NpYXRlZCB3aXRoIHN0cmVhbSBtYW5hZ2VtZW50IC0tIGVuZGluZywgY2FuY2VsaW5nLCBhbmQgbWFuYWdpbmcgZmxvdyBjb250cm9sIC0tIGFyZSBhbGwgZGVzaWduZWQgdG8gaW1wb3NlIG1pbmltYWwgb3ZlcmhlYWRzLiBGb3IgaW5zdGFuY2UsIGEgc2luZ2xlIFNUUkVBTSBmcmFtZSAoU2VjdGlvbiAxOS44KSBjYW4gb3BlbiwgY2FycnkgZGF0YSBmb3IsIGFuZCBjbG9zZSBhIHN0cmVhbS4gU3RyZWFtcyBjYW4gYWxzbyBiZSBsb25nLWxpdmVkIGFuZCBjYW4gbGFzdCB0aGUgZW50aXJlIGR1cmF0aW9uIG9mIGEgY29ubmVjdGlvbi4gU3RyZWFtcyBjYW4gYmUgY3JlYXRlZCBieSBlaXRoZXIgZW5kcG9pbnQsIGNhbiBjb25jdXJyZW50bHkgc2VuZCBkYXRhIGludGVybGVhdmVkIHdpdGggb3RoZXIgc3RyZWFtcywgYW5kIGNhbiBiZSBjYW5jZWxlZC4gUVVJQyBkb2VzIG5vdCBwcm92aWRlIGFueSBtZWFucyBvZiBlbnN1cmluZyBvcmRlcmluZyBiZXR3ZWVuIGJ5dGVzIG9uIGRpZmZlcmVudCBzdHJlYW1zLiBRVUlDIGFsbG93cyBmb3IgYW4gYXJiaXRyYXJ5IG51bWJlciBvZiBzdHJlYW1zIHRvIG9wZXJhdGUgY29uY3VycmVudGx5IGFuZCBmb3IgYW4gYXJiaXRyYXJ5IGFtb3VudCBvZiBkYXRhIHRvIGJlIHNlbnQgb24gYW55IHN0cmVhbSwgc3ViamVjdCB0byBmbG93IGNvbnRyb2wgY29uc3RyYWludHMgYW5kIHN0cmVhbSBsaW1pdHM7IHNlZSBTZWN0aW9uIDQuIDIuMS4gU3RyZWFtIFR5cGVzIGFuZCBJZGVudGlmaWVycyBTdHJlYW1zIGNhbiBiZSB1bmlkaXJlY3Rpb25hbCBvciBiaWRpcmVjdGlvbmFsLiBVbmlkaXJlY3Rpb25hbCBzdHJlYW1zIGNhcnJ5IGRhdGEgaW4gb25lIGRpcmVjdGlvbjogZnJvbSB0aGUgaW5pdGlhdG9yIG9mIHRoZSBzdHJlYW0gdG8gaXRzIHBlZXIuIEJpZGlyZWN0aW9uYWwgc3RyZWFtcyBhbGxvdyBmb3IgZGF0YSB0byBiZSBzZW50IGluIGJvdGggZGlyZWN0aW9ucy4gU3RyZWFtcyBhcmUgaWRlbnRpZmllZCB3aXRoaW4gYSBjb25uZWN0aW9uIGJ5IGEgbnVtZXJpYyB2YWx1ZSwgcmVmZXJyZWQgdG8gYXMgdGhlIHN0cmVhbSBJRC4gQSBzdHJlYW0gSUQgaXMgYSA2Mi1iaXQgaW50ZWdlciAoMCB0byAyXjYyLTEpIHRoYXQgaXMgdW5pcXVlIGZvciBhbGwgc3RyZWFtcyBvbiBhIGNvbm5lY3Rpb24uIFN0cmVhbSBJRHMgYXJlIGVuY29kZWQgYXMgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJzOyBzZWUgU2VjdGlvbiAxNi4gQSBRVUlDIGVuZHBvaW50IE1VU1QgTk9UIHJldXNlIGEgc3RyZWFtIElEIHdpdGhpbiBhIGNvbm5lY3Rpb24uIFRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgKDB4MDEpIG9mIHRoZSBzdHJlYW0gSUQgaWRlbnRpZmllcyB0aGUgaW5pdGlhdG9yIG9mIHRoZSBzdHJlYW0uIENsaWVudC1pbml0aWF0ZWQgc3RyZWFtcyBoYXZlIGV2ZW4tbnVtYmVyZWQgc3RyZWFtIElEcyAod2l0aCB0aGUgYml0IHNldCB0byAwKSwgYW5kIHNlcnZlci1pbml0aWF0ZWQgc3RyZWFtcyBoYXZlIG9kZC1udW1iZXJlZCBzdHJlYW0gSURzICh3aXRoIHRoZSBiaXQgc2V0IHRvIDEpLiBUaGUgc2Vjb25kIGxlYXN0IHNpZ25pZmljYW50IGJpdCAoMHgwMikgb2YgdGhlIHN0cmVhbSBJRCBkaXN0aW5ndWlzaGVzIGJldHdlZW4gYmlkaXJlY3Rpb25hbCBzdHJlYW1zICh3aXRoIHRoZSBiaXQgc2V0IHRvIDApIGFuZCB1bmlkaXJlY3Rpb25hbCBzdHJlYW1zICh3aXRoIHRoZSBiaXQgc2V0IHRvIDEpLiBUaGUgdHdvIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgZnJvbSBhIHN0cmVhbSBJRCB0aGVyZWZvcmUgaWRlbnRpZnkgYSBzdHJlYW0gYXMgb25lIG9mIGZvdXIgdHlwZXMsIGFzIHN1bW1hcml6ZWQgaW4gVGFibGUgMS4gKz09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09KyB8IEJpdHMgfCBTdHJlYW0gVHlwZSB8ICs9PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSsgfCAweDAwIHwgQ2xpZW50LUluaXRpYXRlZCwgQmlkaXJlY3Rpb25hbCB8ICstLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgfCAweDAxIHwgU2VydmVyLUluaXRpYXRlZCwgQmlkaXJlY3Rpb25hbCB8ICstLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgfCAweDAyIHwgQ2xpZW50LUluaXRpYXRlZCwgVW5pZGlyZWN0aW9uYWwgfCArLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHwgMHgwMyB8IFNlcnZlci1Jbml0aWF0ZWQsIFVuaWRpcmVjdGlvbmFsIHwgKy0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyBUYWJsZSAxOiBTdHJlYW0gSUQgVHlwZXMgVGhlIHN0cmVhbSBzcGFjZSBmb3IgZWFjaCB0eXBlIGJlZ2lucyBhdCB0aGUgbWluaW11bSB2YWx1ZSAoMHgwMCB0aHJvdWdoIDB4MDMsIHJlc3BlY3RpdmVseSk7IHN1Y2Nlc3NpdmUgc3RyZWFtcyBvZiBlYWNoIHR5cGUgYXJlIGNyZWF0ZWQgd2l0aCBudW1lcmljYWxseSBpbmNyZWFzaW5nIHN0cmVhbSBJRHMuIEEgc3RyZWFtIElEIHRoYXQgaXMgdXNlZCBvdXQgb2Ygb3JkZXIgcmVzdWx0cyBpbiBhbGwgc3RyZWFtcyBvZiB0aGF0IHR5cGUgd2l0aCBsb3dlci0gbnVtYmVyZWQgc3RyZWFtIElEcyBhbHNvIGJlaW5nIG9wZW5lZC4gMi4yLiBTZW5kaW5nIGFuZCBSZWNlaXZpbmcgRGF0YSBTVFJFQU0gZnJhbWVzIChTZWN0aW9uIDE5LjgpIGVuY2Fwc3VsYXRlIGRhdGEgc2VudCBieSBhbiBhcHBsaWNhdGlvbi4gQW4gZW5kcG9pbnQgdXNlcyB0aGUgU3RyZWFtIElEIGFuZCBPZmZzZXQgZmllbGRzIGluIFNUUkVBTSBmcmFtZXMgdG8gcGxhY2UgZGF0YSBpbiBvcmRlci4gRW5kcG9pbnRzIE1VU1QgYmUgYWJsZSB0byBkZWxpdmVyIHN0cmVhbSBkYXRhIHRvIGFuIGFwcGxpY2F0aW9uIGFzIGFuIG9yZGVyZWQgYnl0ZSBzdHJlYW0uIERlbGl2ZXJpbmcgYW4gb3JkZXJlZCBieXRlIHN0cmVhbSByZXF1aXJlcyB0aGF0IGFuIGVuZHBvaW50IGJ1ZmZlciBhbnkgZGF0YSB0aGF0IGlzIHJlY2VpdmVkIG91dCBvZiBvcmRlciwgdXAgdG8gdGhlIGFkdmVydGlzZWQgZmxvdyBjb250cm9sIGxpbWl0LiBRVUlDIG1ha2VzIG5vIHNwZWNpZmljIGFsbG93YW5jZXMgZm9yIGRlbGl2ZXJ5IG9mIHN0cmVhbSBkYXRhIG91dCBvZiBvcmRlci4gSG93ZXZlciwgaW1wbGVtZW50YXRpb25zIE1BWSBjaG9vc2UgdG8gb2ZmZXIgdGhlIGFiaWxpdHkgdG8gZGVsaXZlciBkYXRhIG91dCBvZiBvcmRlciB0byBhIHJlY2VpdmluZyBhcHBsaWNhdGlvbi4gQW4gZW5kcG9pbnQgY291bGQgcmVjZWl2ZSBkYXRhIGZvciBhIHN0cmVhbSBhdCB0aGUgc2FtZSBzdHJlYW0gb2Zmc2V0IG11bHRpcGxlIHRpbWVzLiBEYXRhIHRoYXQgaGFzIGFscmVhZHkgYmVlbiByZWNlaXZlZCBjYW4gYmUgZGlzY2FyZGVkLiBUaGUgZGF0YSBhdCBhIGdpdmVuIG9mZnNldCBNVVNUIE5PVCBjaGFuZ2UgaWYgaXQgaXMgc2VudCBtdWx0aXBsZSB0aW1lczsgYW4gZW5kcG9pbnQgTUFZIHRyZWF0IHJlY2VpcHQgb2YgZGlmZmVyZW50IGRhdGEgYXQgdGhlIHNhbWUgb2Zmc2V0IHdpdGhpbiBhIHN0cmVhbSBhcyBhIGNvbm5lY3Rpb24gZXJyb3Igb2YgdHlwZSBQUk9UT0NPTF9WSU9MQVRJT04uIFN0cmVhbXMgYXJlIGFuIG9yZGVyZWQgYnl0ZS1zdHJlYW0gYWJzdHJhY3Rpb24gd2l0aCBubyBvdGhlciBzdHJ1Y3R1cmUgdmlzaWJsZSB0byBRVUlDLiBTVFJFQU0gZnJhbWUgYm91bmRhcmllcyBhcmUgbm90IGV4cGVjdGVkIHRvIGJlIHByZXNlcnZlZCB3aGVuIGRhdGEgaXMgdHJhbnNtaXR0ZWQsIHJldHJhbnNtaXR0ZWQgYWZ0ZXIgcGFja2V0IGxvc3MsIG9yIGRlbGl2ZXJlZCB0byB0aGUgYXBwbGljYXRpb24gYXQgYSByZWNlaXZlci4gQW4gZW5kcG9pbnQgTVVTVCBOT1Qgc2VuZCBkYXRhIG9uIGFueSBzdHJlYW0gd2l0aG91dCBlbnN1cmluZyB0aGF0IGl0IGlzIHdpdGhpbiB0aGUgZmxvdyBjb250cm9sIGxpbWl0cyBzZXQgYnkgaXRzIHBlZXIuIEZsb3cgY29udHJvbCBpcyBkZXNjcmliZWQgaW4gZGV0YWlsIGluIFNlY3Rpb24gNC4gMi4zLiBTdHJlYW0gUHJpb3JpdGl6YXRpb24gU3RyZWFtIG11bHRpcGxleGluZyBjYW4gaGF2ZSBhIHNpZ25pZmljYW50IGVmZmVjdCBvbiBhcHBsaWNhdGlvbiBwZXJmb3JtYW5jZSBpZiByZXNvdXJjZXMgYWxsb2NhdGVkIHRvIHN0cmVhbXMgYXJlIGNvcnJlY3RseSBwcmlvcml0aXplZC4gUVVJQyBkb2VzIG5vdCBwcm92aWRlIGEgbWVjaGFuaXNtIGZvciBleGNoYW5naW5nIHByaW9yaXRpemF0aW9uIGluZm9ybWF0aW9uLiBJbnN0ZWFkLCBpdCByZWxpZXMgb24gcmVjZWl2aW5nIHByaW9yaXR5IGluZm9ybWF0aW9uIGZyb20gdGhlIGFwcGxpY2F0aW9uLiBBIFFVSUMgaW1wbGVtZW50YXRpb24gU0hPVUxEIHByb3ZpZGUgd2F5cyBpbiB3aGljaCBhbiBhcHBsaWNhdGlvbiBjYW4gaW5kaWNhdGUgdGhlIHJlbGF0aXZlIHByaW9yaXR5IG9mIHN0cmVhbXMuIEFuIGltcGxlbWVudGF0aW9uIHVzZXMgaW5mb3JtYXRpb24gcHJvdmlkZWQgYnkgdGhlIGFwcGxpY2F0aW9uIHRvIGRldGVybWluZSBob3cgdG8gYWxsb2NhdGUgcmVzb3VyY2VzIHRvIGFjdGl2ZSBzdHJlYW1zLiAyLjQuIE9wZXJhdGlvbnMgb24gU3RyZWFtcyBUaGlzIGRvY3VtZW50IGRvZXMgbm90IGRlZmluZSBhbiBBUEkgZm9yIFFVSUM7IGl0IGluc3RlYWQgZGVmaW5lcyBhIHNldCBvZiBmdW5jdGlvbnMgb24gc3RyZWFtcyB0aGF0IGFwcGxpY2F0aW9uIHByb3RvY29scyBjYW4gcmVseSB1cG9uLiBBbiBhcHBsaWNhdGlvbiBwcm90b2NvbCBjYW4gYXNzdW1lIHRoYXQgYSBRVUlDIGltcGxlbWVudGF0aW9uIHByb3ZpZGVzIGFuIGludGVyZmFjZSB0aGF0IGluY2x1ZGVzIHRoZSBvcGVyYXRpb25zIGRlc2NyaWJlZCBpbiB0aGlzIHNlY3Rpb24uIEFuIGltcGxlbWVudGF0aW9uIGRlc2lnbmVkIGZvciB1c2Ugd2l0aCBhIHNwZWNpZmljIGFwcGxpY2F0aW9uIHByb3RvY29sIG1pZ2h0IHByb3ZpZGUgb25seSB0aG9zZSBvcGVyYXRpb25zIHRoYXQgYXJlIHVzZWQgYnkgdGhhdCBwcm90b2NvbC4gT24gdGhlIHNlbmRpbmcgcGFydCBvZiBhIHN0cmVhbSwgYW4gYXBwbGljYXRpb24gcHJvdG9jb2wgY2FuOiAqIHdyaXRlIGRhdGEsIHVuZGVyc3RhbmRpbmcgd2hlbiBzdHJlYW0gZmxvdyBjb250cm9sIGNyZWRpdCAoU2VjdGlvbiA0LjEpIGhhcyBzdWNjZXNzZnVsbHkgYmVlbiByZXNlcnZlZCB0byBzZW5kIHRoZSB3cml0dGVuIGRhdGE7ICogZW5kIHRoZSBzdHJlYW0gKGNsZWFuIHRlcm1pbmF0aW9uKSwgcmVzdWx0aW5nIGluIGEgU1RSRUFNIGZyYW1lIChTZWN0aW9uIDE5LjgpIHdpdGggdGhlIEZJTiBiaXQgc2V0OyBhbmQgKiByZXNldCB0aGUgc3RyZWFtIChhYnJ1cHQgdGVybWluYXRpb24pLCByZXN1bHRpbmcgaW4gYSBSRVNFVF9TVFJFQU0gZnJhbWUgKFNlY3Rpb24gMTkuNCkgaWYgdGhlIHN0cmVhbSB3YXMgbm90IGFscmVhZHkgaW4gYSB0ZXJtaW5hbCBzdGF0ZS4gT24gdGhlIHJlY2VpdmluZyBwYXJ0IG9mIGEgc3RyZWFtLCBhbiBhcHBsaWNhdGlvbiBwcm90b2NvbCBjYW46ICogcmVhZCBkYXRhOyBhbmQgKiBhYm9ydCByZWFkaW5nIG9mIHRoZSBzdHJlYW0gYW5kIHJlcXVlc3QgY2xvc3VyZSwgcG9zc2libHkgcmVzdWx0aW5nIGluIGEgU1RPUF9TRU5ESU5HIGZyYW1lIChTZWN0aW9uIDE5LjUpLiBBbiBhcHBsaWNhdGlvbiBwcm90b2NvbCBjYW4gYWxzbyByZXF1ZXN0IHRvIGJlIGluZm9ybWVkIG9mIHN0YXRlIGNoYW5nZXMgb24gc3RyZWFtcywgaW5jbHVkaW5nIHdoZW4gdGhlIHBlZXIgaGFzIG9wZW5lZCBvciByZXNldCBhIHN0cmVhbSwgd2hlbiBhIHBlZXIgYWJvcnRzIHJlYWRpbmcgb24gYSBzdHJlYW0sIHdoZW4gbmV3IGRhdGEgaXMgYXZhaWxhYmxlLCBhbmQgd2hlbiBkYXRhIGNhbiBvciBjYW5ub3QgYmUgd3JpdHRlbiB0byB0aGUgc3RyZWFtIGR1ZSB0byBmbG93IGNvbnRyb2wuIDMuIFN0cmVhbSBTdGF0ZXMgVGhpcyBzZWN0aW9uIGRlc2NyaWJlcyBzdHJlYW1zIGluIHRlcm1zIG9mIHRoZWlyIHNlbmQgb3IgcmVjZWl2ZSBjb21wb25lbnRzLiBUd28gc3RhdGUgbWFjaGluZXMgYXJlIGRlc2NyaWJlZDogb25lIGZvciB0aGUgc3RyZWFtcyBvbiB3aGljaCBhbiBlbmRwb2ludCB0cmFuc21pdHMgZGF0YSAoU2VjdGlvbiAzLjEpIGFuZCBhbm90aGVyIGZvciBzdHJlYW1zIG9uIHdoaWNoIGFuIGVuZHBvaW50IHJlY2VpdmVzIGRhdGEgKFNlY3Rpb24gMy4yKS4gVW5pZGlyZWN0aW9uYWwgc3RyZWFtcyB1c2UgZWl0aGVyIHRoZSBzZW5kaW5nIG9yIHJlY2VpdmluZyBzdGF0ZSBtYWNoaW5lLCBkZXBlbmRpbmcgb24gdGhlIHN0cmVhbSB0eXBlIGFuZCBlbmRwb2ludCByb2xlLiBCaWRpcmVjdGlvbmFsIHN0cmVhbXMgdXNlIGJvdGggc3RhdGUgbWFjaGluZXMgYXQgYm90aCBlbmRwb2ludHMuIEZvciB0aGUgbW9zdCBwYXJ0LCB0aGUgdXNlIG9mIHRoZXNlIHN0YXRlIG1hY2hpbmVzIGlzIHRoZSBzYW1lIHdoZXRoZXIgdGhlIHN0cmVhbSBpcyB1bmlkaXJlY3Rpb25hbCBvciBiaWRpcmVjdGlvbmFsLiBUaGUgY29uZGl0aW9ucyBmb3Igb3BlbmluZyBhIHN0cmVhbSBhcmUgc2xpZ2h0bHkgbW9yZSBjb21wbGV4IGZvciBhIGJpZGlyZWN0aW9uYWwgc3RyZWFtIGJlY2F1c2UgdGhlIG9wZW5pbmcgb2YgZWl0aGVyIHRoZSBzZW5kIG9yIHJlY2VpdmUgc2lkZSBjYXVzZXMgdGhlIHN0cmVhbSB0byBvcGVuIGluIGJvdGggZGlyZWN0aW9ucy4gVGhlIHN0YXRlIG1hY2hpbmVzIHNob3duIGluIHRoaXMgc2VjdGlvbiBhcmUgbGFyZ2VseSBpbmZvcm1hdGl2ZS4gVGhpcyBkb2N1bWVudCB1c2VzIHN0cmVhbSBzdGF0ZXMgdG8gZGVzY3JpYmUgcnVsZXMgZm9yIHdoZW4gYW5kIGhvdyBkaWZmZXJlbnQgdHlwZXMgb2YgZnJhbWVzIGNhbiBiZSBzZW50IGFuZCB0aGUgcmVhY3Rpb25zIHRoYXQgYXJlIGV4cGVjdGVkIHdoZW4gZGlmZmVyZW50IHR5cGVzIG9mIGZyYW1lcyBhcmUgcmVjZWl2ZWQuIFRob3VnaCB0aGVzZSBzdGF0ZSBtYWNoaW5lcyBhcmUgaW50ZW5kZWQgdG8gYmUgdXNlZnVsIGluIGltcGxlbWVudGluZyBRVUlDLCB0aGVzZSBzdGF0ZXMgYXJlIG5vdCBpbnRlbmRlZCB0byBjb25zdHJhaW4gaW1wbGVtZW50YXRpb25zLiBBbiBpbXBsZW1lbnRhdGlvbiBjYW4gZGVmaW5lIGEgZGlmZmVyZW50IHN0YXRlIG1hY2hpbmUgYXMgbG9uZyBhcyBpdHMgYmVoYXZpb3IgaXMgY29uc2lzdGVudCB3aXRoIGFuIGltcGxlbWVudGF0aW9uIHRoYXQgaW1wbGVtZW50cyB0aGVzZSBzdGF0ZXMuIHwgTm90ZTogSW4gc29tZSBjYXNlcywgYSBzaW5nbGUgZXZlbnQgb3IgYWN0aW9uIGNhbiBjYXVzZSBhIHwgdHJhbnNpdGlvbiB0aHJvdWdoIG11bHRpcGxlIHN0YXRlcy4gRm9yIGluc3RhbmNlLCBzZW5kaW5nIHwgU1RSRUFNIHdpdGggYSBGSU4gYml0IHNldCBjYW4gY2F1c2UgdHdvIHN0YXRlIHRyYW5zaXRpb25zIGZvciBhIHwgc2VuZGluZyBzdHJlYW06IGZyb20gdGhlICJSZWFkeSIgc3RhdGUgdG8gdGhlICJTZW5kIiBzdGF0ZSwgYW5kIHwgZnJvbSB0aGUgIlNlbmQiIHN0YXRlIHRvIHRoZSAiRGF0YSBTZW50IiBzdGF0ZS4gMy4xLiBTZW5kaW5nIFN0cmVhbSBTdGF0ZXMgRmlndXJlIDIgc2hvd3MgdGhlIHN0YXRlcyBmb3IgdGhlIHBhcnQgb2YgYSBzdHJlYW0gdGhhdCBzZW5kcyBkYXRhIHRvIGEgcGVlci4gbyB8IENyZWF0ZSBTdHJlYW0gKFNlbmRpbmcpIHwgUGVlciBDcmVhdGVzIEJpZGlyZWN0aW9uYWwgU3RyZWFtIHYgKy0tLS0tLS0rIHwgUmVhZHkgfCBTZW5kIFJFU0VUX1NUUkVBTSB8IHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS4gKy0tLS0tLS0rIHwgfCB8IHwgU2VuZCBTVFJFQU0gLyB8IHwgU1RSRUFNX0RBVEFfQkxPQ0tFRCB8IHYgfCArLS0tLS0tLSsgfCB8IFNlbmQgfCBTZW5kIFJFU0VUX1NUUkVBTSB8IHwgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0mZ3Q7fCArLS0tLS0tLSsgfCB8IHwgfCBTZW5kIFNUUkVBTSArIEZJTiB8IHYgdiArLS0tLS0tLSsgKy0tLS0tLS0rIHwgRGF0YSB8IFNlbmQgUkVTRVRfU1RSRUFNIHwgUmVzZXQgfCB8IFNlbnQgfC0tLS0tLS0tLS0tLS0tLS0tLSZndDt8IFNlbnQgfCArLS0tLS0tLSsgKy0tLS0tLS0rIHwgfCB8IFJlY3YgQWxsIEFDS3MgfCBSZWN2IEFDSyB2IHYgKy0tLS0tLS0rICstLS0tLS0tKyB8IERhdGEgfCB8IFJlc2V0IHwgfCBSZWN2ZCB8IHwgUmVjdmQgfCArLS0tLS0tLSsgKy0tLS0tLS0rIEZpZ3VyZSAyOiBTdGF0ZXMgZm9yIFNlbmRpbmcgUGFydHMgb2YgU3RyZWFtcyBUaGUgc2VuZGluZyBwYXJ0IG9mIGEgc3RyZWFtIHRoYXQgdGhlIGVuZHBvaW50IGluaXRpYXRlcyAodHlwZXMgMCBhbmQgMiBmb3IgY2xpZW50cywgMSBhbmQgMyBmb3Igc2VydmVycykgaXMgb3BlbmVkIGJ5IHRoZSBhcHBsaWNhdGlvbi4gVGhlICJSZWFkeSIgc3RhdGUgcmVwcmVzZW50cyBhIG5ld2x5IGNyZWF0ZWQgc3RyZWFtIHRoYXQgaXMgYWJsZSB0byBhY2NlcHQgZGF0YSBmcm9tIHRoZSBhcHBsaWNhdGlvbi4gU3RyZWFtIGRhdGEgbWlnaHQgYmUgYnVmZmVyZWQgaW4gdGhpcyBzdGF0ZSBpbiBwcmVwYXJhdGlvbiBmb3Igc2VuZGluZy4gU2VuZGluZyB0aGUgZmlyc3QgU1RSRUFNIG9yIFNUUkVBTV9EQVRBX0JMT0NLRUQgZnJhbWUgY2F1c2VzIGEgc2VuZGluZyBwYXJ0IG9mIGEgc3RyZWFtIHRvIGVudGVyIHRoZSAiU2VuZCIgc3RhdGUuIEFuIGltcGxlbWVudGF0aW9uIG1pZ2h0IGNob29zZSB0byBkZWZlciBhbGxvY2F0aW5nIGEgc3RyZWFtIElEIHRvIGEgc3RyZWFtIHVudGlsIGl0IHNlbmRzIHRoZSBmaXJzdCBTVFJFQU0gZnJhbWUgYW5kIGVudGVycyB0aGlzIHN0YXRlLCB3aGljaCBjYW4gYWxsb3cgZm9yIGJldHRlciBzdHJlYW0gcHJpb3JpdGl6YXRpb24uIFRoZSBzZW5kaW5nIHBhcnQgb2YgYSBiaWRpcmVjdGlvbmFsIHN0cmVhbSBpbml0aWF0ZWQgYnkgYSBwZWVyICh0eXBlIDAgZm9yIGEgc2VydmVyLCB0eXBlIDEgZm9yIGEgY2xpZW50KSBzdGFydHMgaW4gdGhlICJSZWFkeSIgc3RhdGUgd2hlbiB0aGUgcmVjZWl2aW5nIHBhcnQgaXMgY3JlYXRlZC4gSW4gdGhlICJTZW5kIiBzdGF0ZSwgYW4gZW5kcG9pbnQgdHJhbnNtaXRzIC0tIGFuZCByZXRyYW5zbWl0cyBhcyBuZWNlc3NhcnkgLS0gc3RyZWFtIGRhdGEgaW4gU1RSRUFNIGZyYW1lcy4gVGhlIGVuZHBvaW50IHJlc3BlY3RzIHRoZSBmbG93IGNvbnRyb2wgbGltaXRzIHNldCBieSBpdHMgcGVlciBhbmQgY29udGludWVzIHRvIGFjY2VwdCBhbmQgcHJvY2VzcyBNQVhfU1RSRUFNX0RBVEEgZnJhbWVzLiBBbiBlbmRwb2ludCBpbiB0aGUgIlNlbmQiIHN0YXRlIGdlbmVyYXRlcyBTVFJFQU1fREFUQV9CTE9DS0VEIGZyYW1lcyBpZiBpdCBpcyBibG9ja2VkIGZyb20gc2VuZGluZyBieSBzdHJlYW0gZmxvdyBjb250cm9sIGxpbWl0cyAoU2VjdGlvbiA0LjEpLiBBZnRlciB0aGUgYXBwbGljYXRpb24gaW5kaWNhdGVzIHRoYXQgYWxsIHN0cmVhbSBkYXRhIGhhcyBiZWVuIHNlbnQgYW5kIGEgU1RSRUFNIGZyYW1lIGNvbnRhaW5pbmcgdGhlIEZJTiBiaXQgaXMgc2VudCwgdGhlIHNlbmRpbmcgcGFydCBvZiB0aGUgc3RyZWFtIGVudGVycyB0aGUgIkRhdGEgU2VudCIgc3RhdGUuIEZyb20gdGhpcyBzdGF0ZSwgdGhlIGVuZHBvaW50IG9ubHkgcmV0cmFuc21pdHMgc3RyZWFtIGRhdGEgYXMgbmVjZXNzYXJ5LiBUaGUgZW5kcG9pbnQgZG9lcyBub3QgbmVlZCB0byBjaGVjayBmbG93IGNvbnRyb2wgbGltaXRzIG9yIHNlbmQgU1RSRUFNX0RBVEFfQkxPQ0tFRCBmcmFtZXMgZm9yIGEgc3RyZWFtIGluIHRoaXMgc3RhdGUuIE1BWF9TVFJFQU1fREFUQSBmcmFtZXMgbWlnaHQgYmUgcmVjZWl2ZWQgdW50aWwgdGhlIHBlZXIgcmVjZWl2ZXMgdGhlIGZpbmFsIHN0cmVhbSBvZmZzZXQuIFRoZSBlbmRwb2ludCBjYW4gc2FmZWx5IGlnbm9yZSBhbnkgTUFYX1NUUkVBTV9EQVRBIGZyYW1lcyBpdCByZWNlaXZlcyBmcm9tIGl0cyBwZWVyIGZvciBhIHN0cmVhbSBpbiB0aGlzIHN0YXRlLiBPbmNlIGFsbCBzdHJlYW0gZGF0YSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgYWNrbm93bGVkZ2VkLCB0aGUgc2VuZGluZyBwYXJ0IG9mIHRoZSBzdHJlYW0gZW50ZXJzIHRoZSAiRGF0YSBSZWN2ZCIgc3RhdGUsIHdoaWNoIGlzIGEgdGVybWluYWwgc3RhdGUuIEZyb20gYW55IHN0YXRlIHRoYXQgaXMgb25lIG9mICJSZWFkeSIsICJTZW5kIiwgb3IgIkRhdGEgU2VudCIsIGFuIGFwcGxpY2F0aW9uIGNhbiBzaWduYWwgdGhhdCBpdCB3aXNoZXMgdG8gYWJhbmRvbiB0cmFuc21pc3Npb24gb2Ygc3RyZWFtIGRhdGEuIEFsdGVybmF0aXZlbHksIGFuIGVuZHBvaW50IG1pZ2h0IHJlY2VpdmUgYSBTVE9QX1NFTkRJTkcgZnJhbWUgZnJvbSBpdHMgcGVlci4gSW4gZWl0aGVyIGNhc2UsIHRoZSBlbmRwb2ludCBzZW5kcyBhIFJFU0VUX1NUUkVBTSBmcmFtZSwgd2hpY2ggY2F1c2VzIHRoZSBzdHJlYW0gdG8gZW50ZXIgdGhlICJSZXNldCBTZW50IiBzdGF0ZS4gQW4gZW5kcG9pbnQgTUFZIHNlbmQgYSBSRVNFVF9TVFJFQU0gYXMgdGhlIGZpcnN0IGZyYW1lIHRoYXQgbWVudGlvbnMgYSBzdHJlYW07IHRoaXMgY2F1c2VzIHRoZSBzZW5kaW5nIHBhcnQgb2YgdGhhdCBzdHJlYW0gdG8gb3BlbiBhbmQgdGhlbiBpbW1lZGlhdGVseSB0cmFuc2l0aW9uIHRvIHRoZSAiUmVzZXQgU2VudCIgc3RhdGUuIE9uY2UgYSBwYWNrZXQgY29udGFpbmluZyBhIFJFU0VUX1NUUkVBTSBoYXMgYmVlbiBhY2tub3dsZWRnZWQsIHRoZSBzZW5kaW5nIHBhcnQgb2YgdGhlIHN0cmVhbSBlbnRlcnMgdGhlICJSZXNldCBSZWN2ZCIgc3RhdGUsIHdoaWNoIGlzIGEgdGVybWluYWwgc3RhdGUuIDMuMi4gUmVjZWl2aW5nIFN0cmVhbSBTdGF0ZXMgRmlndXJlIDMgc2hvd3MgdGhlIHN0YXRlcyBmb3IgdGhlIHBhcnQgb2YgYSBzdHJlYW0gdGhhdCByZWNlaXZlcyBkYXRhIGZyb20gYSBwZWVyLiBUaGUgc3RhdGVzIGZvciBhIHJlY2VpdmluZyBwYXJ0IG9mIGEgc3RyZWFtIG1pcnJvciBvbmx5IHNvbWUgb2YgdGhlIHN0YXRlcyBvZiB0aGUgc2VuZGluZyBwYXJ0IG9mIHRoZSBzdHJlYW0gYXQgdGhlIHBlZXIuIFRoZSByZWNlaXZpbmcgcGFydCBvZiBhIHN0cmVhbSBkb2VzIG5vdCB0cmFjayBzdGF0ZXMgb24gdGhlIHNlbmRpbmcgcGFydCB0aGF0IGNhbm5vdCBiZSBvYnNlcnZlZCwgc3VjaCBhcyB0aGUgIlJlYWR5IiBzdGF0ZS4gSW5zdGVhZCwgdGhlIHJlY2VpdmluZyBwYXJ0IG9mIGEgc3RyZWFtIHRyYWNrcyB0aGUgZGVsaXZlcnkgb2YgZGF0YSB0byB0aGUgYXBwbGljYXRpb24sIHNvbWUgb2Ygd2hpY2ggY2Fubm90IGJlIG9ic2VydmVkIGJ5IHRoZSBzZW5kZXIuIG8gfCBSZWN2IFNUUkVBTSAvIFNUUkVBTV9EQVRBX0JMT0NLRUQgLyBSRVNFVF9TVFJFQU0gfCBDcmVhdGUgQmlkaXJlY3Rpb25hbCBTdHJlYW0gKFNlbmRpbmcpIHwgUmVjdiBNQVhfU1RSRUFNX0RBVEEgLyBTVE9QX1NFTkRJTkcgKEJpZGlyZWN0aW9uYWwpIHwgQ3JlYXRlIEhpZ2hlci1OdW1iZXJlZCBTdHJlYW0gdiArLS0tLS0tLSsgfCBSZWN2IHwgUmVjdiBSRVNFVF9TVFJFQU0gfCB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0uICstLS0tLS0tKyB8IHwgfCB8IFJlY3YgU1RSRUFNICsgRklOIHwgdiB8ICstLS0tLS0tKyB8IHwgU2l6ZSB8IFJlY3YgUkVTRVRfU1RSRUFNIHwgfCBLbm93biB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLSZndDt8ICstLS0tLS0tKyB8IHwgfCB8IFJlY3YgQWxsIERhdGEgfCB2IHYgKy0tLS0tLS0rIFJlY3YgUkVTRVRfU1RSRUFNICstLS0tLS0tKyB8IERhdGEgfC0tLSAob3B0aW9uYWwpIC0tLSZndDt8IFJlc2V0IHwgfCBSZWN2ZCB8IFJlY3YgQWxsIERhdGEgfCBSZWN2ZCB8ICstLS0tLS0tKyZsdDstLSAob3B0aW9uYWwpIC0tLS0rLS0tLS0tLSsgfCB8IHwgQXBwIFJlYWQgQWxsIERhdGEgfCBBcHAgUmVhZCBSZXNldCB2IHYgKy0tLS0tLS0rICstLS0tLS0tKyB8IERhdGEgfCB8IFJlc2V0IHwgfCBSZWFkIHwgfCBSZWFkIHwgKy0tLS0tLS0rICstLS0tLS0tKyBGaWd1cmUgMzogU3RhdGVzIGZvciBSZWNlaXZpbmcgUGFydHMgb2YgU3RyZWFtcyBUaGUgcmVjZWl2aW5nIHBhcnQgb2YgYSBzdHJlYW0gaW5pdGlhdGVkIGJ5IGEgcGVlciAodHlwZXMgMSBhbmQgMyBmb3IgYSBjbGllbnQsIG9yIDAgYW5kIDIgZm9yIGEgc2VydmVyKSBpcyBjcmVhdGVkIHdoZW4gdGhlIGZpcnN0IFNUUkVBTSwgU1RSRUFNX0RBVEFfQkxPQ0tFRCwgb3IgUkVTRVRfU1RSRUFNIGZyYW1lIGlzIHJlY2VpdmVkIGZvciB0aGF0IHN0cmVhbS4gRm9yIGJpZGlyZWN0aW9uYWwgc3RyZWFtcyBpbml0aWF0ZWQgYnkgYSBwZWVyLCByZWNlaXB0IG9mIGEgTUFYX1NUUkVBTV9EQVRBIG9yIFNUT1BfU0VORElORyBmcmFtZSBmb3IgdGhlIHNlbmRpbmcgcGFydCBvZiB0aGUgc3RyZWFtIGFsc28gY3JlYXRlcyB0aGUgcmVjZWl2aW5nIHBhcnQuIFRoZSBpbml0aWFsIHN0YXRlIGZvciB0aGUgcmVjZWl2aW5nIHBhcnQgb2YgYSBzdHJlYW0gaXMgIlJlY3YiLiBGb3IgYSBiaWRpcmVjdGlvbmFsIHN0cmVhbSwgdGhlIHJlY2VpdmluZyBwYXJ0IGVudGVycyB0aGUgIlJlY3YiIHN0YXRlIHdoZW4gdGhlIHNlbmRpbmcgcGFydCBpbml0aWF0ZWQgYnkgdGhlIGVuZHBvaW50ICh0eXBlIDAgZm9yIGEgY2xpZW50LCB0eXBlIDEgZm9yIGEgc2VydmVyKSBlbnRlcnMgdGhlICJSZWFkeSIgc3RhdGUuIEFuIGVuZHBvaW50IG9wZW5zIGEgYmlkaXJlY3Rpb25hbCBzdHJlYW0gd2hlbiBhIE1BWF9TVFJFQU1fREFUQSBvciBTVE9QX1NFTkRJTkcgZnJhbWUgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgcGVlciBmb3IgdGhhdCBzdHJlYW0uIFJlY2VpdmluZyBhIE1BWF9TVFJFQU1fREFUQSBmcmFtZSBmb3IgYW4gdW5vcGVuZWQgc3RyZWFtIGluZGljYXRlcyB0aGF0IHRoZSByZW1vdGUgcGVlciBoYXMgb3BlbmVkIHRoZSBzdHJlYW0gYW5kIGlzIHByb3ZpZGluZyBmbG93IGNvbnRyb2wgY3JlZGl0LiBSZWNlaXZpbmcgYSBTVE9QX1NFTkRJTkcgZnJhbWUgZm9yIGFuIHVub3BlbmVkIHN0cmVhbSBpbmRpY2F0ZXMgdGhhdCB0aGUgcmVtb3RlIHBlZXIgbm8gbG9uZ2VyIHdpc2hlcyB0byByZWNlaXZlIGRhdGEgb24gdGhpcyBzdHJlYW0uIEVpdGhlciBmcmFtZSBtaWdodCBhcnJpdmUgYmVmb3JlIGEgU1RSRUFNIG9yIFNUUkVBTV9EQVRBX0JMT0NLRUQgZnJhbWUgaWYgcGFja2V0cyBhcmUgbG9zdCBvciByZW9yZGVyZWQuIEJlZm9yZSBhIHN0cmVhbSBpcyBjcmVhdGVkLCBhbGwgc3RyZWFtcyBvZiB0aGUgc2FtZSB0eXBlIHdpdGggbG93ZXItIG51bWJlcmVkIHN0cmVhbSBJRHMgTVVTVCBiZSBjcmVhdGVkLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgY3JlYXRpb24gb3JkZXIgZm9yIHN0cmVhbXMgaXMgY29uc2lzdGVudCBvbiBib3RoIGVuZHBvaW50cy4gSW4gdGhlICJSZWN2IiBzdGF0ZSwgdGhlIGVuZHBvaW50IHJlY2VpdmVzIFNUUkVBTSBhbmQgU1RSRUFNX0RBVEFfQkxPQ0tFRCBmcmFtZXMuIEluY29taW5nIGRhdGEgaXMgYnVmZmVyZWQgYW5kIGNhbiBiZSByZWFzc2VtYmxlZCBpbnRvIHRoZSBjb3JyZWN0IG9yZGVyIGZvciBkZWxpdmVyeSB0byB0aGUgYXBwbGljYXRpb24uIEFzIGRhdGEgaXMgY29uc3VtZWQgYnkgdGhlIGFwcGxpY2F0aW9uIGFuZCBidWZmZXIgc3BhY2UgYmVjb21lcyBhdmFpbGFibGUsIHRoZSBlbmRwb2ludCBzZW5kcyBNQVhfU1RSRUFNX0RBVEEgZnJhbWVzIHRvIGFsbG93IHRoZSBwZWVyIHRvIHNlbmQgbW9yZSBkYXRhLiBXaGVuIGEgU1RSRUFNIGZyYW1lIHdpdGggYSBGSU4gYml0IGlzIHJlY2VpdmVkLCB0aGUgZmluYWwgc2l6ZSBvZiB0aGUgc3RyZWFtIGlzIGtub3duOyBzZWUgU2VjdGlvbiA0LjUuIFRoZSByZWNlaXZpbmcgcGFydCBvZiB0aGUgc3RyZWFtIHRoZW4gZW50ZXJzIHRoZSAiU2l6ZSBLbm93biIgc3RhdGUuIEluIHRoaXMgc3RhdGUsIHRoZSBlbmRwb2ludCBubyBsb25nZXIgbmVlZHMgdG8gc2VuZCBNQVhfU1RSRUFNX0RBVEEgZnJhbWVzOyBpdCBvbmx5IHJlY2VpdmVzIGFueSByZXRyYW5zbWlzc2lvbnMgb2Ygc3RyZWFtIGRhdGEuIE9uY2UgYWxsIGRhdGEgZm9yIHRoZSBzdHJlYW0gaGFzIGJlZW4gcmVjZWl2ZWQsIHRoZSByZWNlaXZpbmcgcGFydCBlbnRlcnMgdGhlICJEYXRhIFJlY3ZkIiBzdGF0ZS4gVGhpcyBtaWdodCBoYXBwZW4gYXMgYSByZXN1bHQgb2YgcmVjZWl2aW5nIHRoZSBzYW1lIFNUUkVBTSBmcmFtZSB0aGF0IGNhdXNlcyB0aGUgdHJhbnNpdGlvbiB0byAiU2l6ZSBLbm93biIuIEFmdGVyIGFsbCBkYXRhIGhhcyBiZWVuIHJlY2VpdmVkLCBhbnkgU1RSRUFNIG9yIFNUUkVBTV9EQVRBX0JMT0NLRUQgZnJhbWVzIGZvciB0aGUgc3RyZWFtIGNhbiBiZSBkaXNjYXJkZWQuIFRoZSAiRGF0YSBSZWN2ZCIgc3RhdGUgcGVyc2lzdHMgdW50aWwgc3RyZWFtIGRhdGEgaGFzIGJlZW4gZGVsaXZlcmVkIHRvIHRoZSBhcHBsaWNhdGlvbi4gT25jZSBzdHJlYW0gZGF0YSBoYXMgYmVlbiBkZWxpdmVyZWQsIHRoZSBzdHJlYW0gZW50ZXJzIHRoZSAiRGF0YSBSZWFkIiBzdGF0ZSwgd2hpY2ggaXMgYSB0ZXJtaW5hbCBzdGF0ZS4gUmVjZWl2aW5nIGEgUkVTRVRfU1RSRUFNIGZyYW1lIGluIHRoZSAiUmVjdiIgb3IgIlNpemUgS25vd24iIHN0YXRlIGNhdXNlcyB0aGUgc3RyZWFtIHRvIGVudGVyIHRoZSAiUmVzZXQgUmVjdmQiIHN0YXRlLiBUaGlzIG1pZ2h0IGNhdXNlIHRoZSBkZWxpdmVyeSBvZiBzdHJlYW0gZGF0YSB0byB0aGUgYXBwbGljYXRpb24gdG8gYmUgaW50ZXJydXB0ZWQuIEl0IGlzIHBvc3NpYmxlIHRoYXQgYWxsIHN0cmVhbSBkYXRhIGhhcyBhbHJlYWR5IGJlZW4gcmVjZWl2ZWQgd2hlbiBhIFJFU0VUX1NUUkVBTSBpcyByZWNlaXZlZCAodGhhdCBpcywgaW4gdGhlICJEYXRhIFJlY3ZkIiBzdGF0ZSkuIFNpbWlsYXJseSwgaXQgaXMgcG9zc2libGUgZm9yIHJlbWFpbmluZyBzdHJlYW0gZGF0YSB0byBhcnJpdmUgYWZ0ZXIgcmVjZWl2aW5nIGEgUkVTRVRfU1RSRUFNIGZyYW1lICh0aGUgIlJlc2V0IFJlY3ZkIiBzdGF0ZSkuIEFuIGltcGxlbWVudGF0aW9uIGlzIGZyZWUgdG8gbWFuYWdlIHRoaXMgc2l0dWF0aW9uIGFzIGl0IGNob29zZXMuIFNlbmRpbmcgYSBSRVNFVF9TVFJFQU0gbWVhbnMgdGhhdCBhbiBlbmRwb2ludCBjYW5ub3QgZ3VhcmFudGVlIGRlbGl2ZXJ5IG9mIHN0cmVhbSBkYXRhOyBob3dldmVyLCB0aGVyZSBpcyBubyByZXF1aXJlbWVudCB0aGF0IHN0cmVhbSBkYXRhIG5vdCBiZSBkZWxpdmVyZWQgaWYgYSBSRVNFVF9TVFJFQU0gaXMgcmVjZWl2ZWQuIEFuIGltcGxlbWVudGF0aW9uIE1BWSBpbnRlcnJ1cHQgZGVsaXZlcnkgb2Ygc3RyZWFtIGRhdGEsIGRpc2NhcmQgYW55IGRhdGEgdGhhdCB3YXMgbm90IGNvbnN1bWVkLCBhbmQgc2lnbmFsIHRoZSByZWNlaXB0IG9mIHRoZSBSRVNFVF9TVFJFQU0uIEEgUkVTRVRfU1RSRUFNIHNpZ25hbCBtaWdodCBiZSBzdXBwcmVzc2VkIG9yIHdpdGhoZWxkIGlmIHN0cmVhbSBkYXRhIGlzIGNvbXBsZXRlbHkgcmVjZWl2ZWQgYW5kIGlzIGJ1ZmZlcmVkIHRvIGJlIHJlYWQgYnkgdGhlIGFwcGxpY2F0aW9uLiBJZiB0aGUgUkVTRVRfU1RSRUFNIGlzIHN1cHByZXNzZWQsIHRoZSByZWNlaXZpbmcgcGFydCBvZiB0aGUgc3RyZWFtIHJlbWFpbnMgaW4gIkRhdGEgUmVjdmQiLiBPbmNlIHRoZSBhcHBsaWNhdGlvbiByZWNlaXZlcyB0aGUgc2lnbmFsIGluZGljYXRpbmcgdGhhdCB0aGUgc3RyZWFtIHdhcyByZXNldCwgdGhlIHJlY2VpdmluZyBwYXJ0IG9mIHRoZSBzdHJlYW0gdHJhbnNpdGlvbnMgdG8gdGhlICJSZXNldCBSZWFkIiBzdGF0ZSwgd2hpY2ggaXMgYSB0ZXJtaW5hbCBzdGF0ZS4gMy4zLiBQZXJtaXR0ZWQgRnJhbWUgVHlwZXMgVGhlIHNlbmRlciBvZiBhIHN0cmVhbSBzZW5kcyBqdXN0IHRocmVlIGZyYW1lIHR5cGVzIHRoYXQgYWZmZWN0IHRoZSBzdGF0ZSBvZiBhIHN0cmVhbSBhdCBlaXRoZXIgdGhlIHNlbmRlciBvciB0aGUgcmVjZWl2ZXI6IFNUUkVBTSAoU2VjdGlvbiAxOS44KSwgU1RSRUFNX0RBVEFfQkxPQ0tFRCAoU2VjdGlvbiAxOS4xMyksIGFuZCBSRVNFVF9TVFJFQU0gKFNlY3Rpb24gMTkuNCkuIEEgc2VuZGVyIE1VU1QgTk9UIHNlbmQgYW55IG9mIHRoZXNlIGZyYW1lcyBmcm9tIGEgdGVybWluYWwgc3RhdGUgKCJEYXRhIFJlY3ZkIiBvciAiUmVzZXQgUmVjdmQiKS4gQSBzZW5kZXIgTVVTVCBOT1Qgc2VuZCBhIFNUUkVBTSBvciBTVFJFQU1fREFUQV9CTE9DS0VEIGZyYW1lIGZvciBhIHN0cmVhbSBpbiB0aGUgIlJlc2V0IFNlbnQiIHN0YXRlIG9yIGFueSB0ZXJtaW5hbCBzdGF0ZSAtLSB0aGF0IGlzLCBhZnRlciBzZW5kaW5nIGEgUkVTRVRfU1RSRUFNIGZyYW1lLiBBIHJlY2VpdmVyIGNvdWxkIHJlY2VpdmUgYW55IG9mIHRoZXNlIHRocmVlIGZyYW1lcyBpbiBhbnkgc3RhdGUsIGR1ZSB0byB0aGUgcG9zc2liaWxpdHkgb2YgZGVsYXllZCBkZWxpdmVyeSBvZiBwYWNrZXRzIGNhcnJ5aW5nIHRoZW0uIFRoZSByZWNlaXZlciBvZiBhIHN0cmVhbSBzZW5kcyBNQVhfU1RSRUFNX0RBVEEgZnJhbWVzIChTZWN0aW9uIDE5LjEwKSBhbmQgU1RPUF9TRU5ESU5HIGZyYW1lcyAoU2VjdGlvbiAxOS41KS4gVGhlIHJlY2VpdmVyIG9ubHkgc2VuZHMgTUFYX1NUUkVBTV9EQVRBIGZyYW1lcyBpbiB0aGUgIlJlY3YiIHN0YXRlLiBBIHJlY2VpdmVyIE1BWSBzZW5kIGEgU1RPUF9TRU5ESU5HIGZyYW1lIGluIGFueSBzdGF0ZSB3aGVyZSBpdCBoYXMgbm90IHJlY2VpdmVkIGEgUkVTRVRfU1RSRUFNIGZyYW1lIC0tIHRoYXQgaXMsIHN0YXRlcyBvdGhlciB0aGFuICJSZXNldCBSZWN2ZCIgb3IgIlJlc2V0IFJlYWQiLiBIb3dldmVyLCB0aGVyZSBpcyBsaXR0bGUgdmFsdWUgaW4gc2VuZGluZyBhIFNUT1BfU0VORElORyBmcmFtZSBpbiB0aGUgIkRhdGEgUmVjdmQiIHN0YXRlLCBhcyBhbGwgc3RyZWFtIGRhdGEgaGFzIGJlZW4gcmVjZWl2ZWQuIEEgc2VuZGVyIGNvdWxkIHJlY2VpdmUgZWl0aGVyIG9mIHRoZXNlIHR3byB0eXBlcyBvZiBmcmFtZXMgaW4gYW55IHN0YXRlIGFzIGEgcmVzdWx0IG9mIGRlbGF5ZWQgZGVsaXZlcnkgb2YgcGFja2V0cy4gMy40LiBCaWRpcmVjdGlvbmFsIFN0cmVhbSBTdGF0ZXMgQSBiaWRpcmVjdGlvbmFsIHN0cmVhbSBpcyBjb21wb3NlZCBvZiBzZW5kaW5nIGFuZCByZWNlaXZpbmcgcGFydHMuIEltcGxlbWVudGF0aW9ucyBjYW4gcmVwcmVzZW50IHN0YXRlcyBvZiB0aGUgYmlkaXJlY3Rpb25hbCBzdHJlYW0gYXMgY29tcG9zaXRlcyBvZiBzZW5kaW5nIGFuZCByZWNlaXZpbmcgc3RyZWFtIHN0YXRlcy4gVGhlIHNpbXBsZXN0IG1vZGVsIHByZXNlbnRzIHRoZSBzdHJlYW0gYXMgIm9wZW4iIHdoZW4gZWl0aGVyIHNlbmRpbmcgb3IgcmVjZWl2aW5nIHBhcnRzIGFyZSBpbiBhIG5vbi10ZXJtaW5hbCBzdGF0ZSBhbmQgImNsb3NlZCIgd2hlbiBib3RoIHNlbmRpbmcgYW5kIHJlY2VpdmluZyBzdHJlYW1zIGFyZSBpbiB0ZXJtaW5hbCBzdGF0ZXMuIFRhYmxlIDIgc2hvd3MgYSBtb3JlIGNvbXBsZXggbWFwcGluZyBvZiBiaWRpcmVjdGlvbmFsIHN0cmVhbSBzdGF0ZXMgdGhhdCBsb29zZWx5IGNvcnJlc3BvbmQgdG8gdGhlIHN0cmVhbSBzdGF0ZXMgZGVmaW5lZCBpbiBIVFRQLzIgW0hUVFAyXS4gVGhpcyBzaG93cyB0aGF0IG11bHRpcGxlIHN0YXRlcyBvbiBzZW5kaW5nIG9yIHJlY2VpdmluZyBwYXJ0cyBvZiBzdHJlYW1zIGFyZSBtYXBwZWQgdG8gdGhlIHNhbWUgY29tcG9zaXRlIHN0YXRlLiBOb3RlIHRoYXQgdGhpcyBpcyBqdXN0IG9uZSBwb3NzaWJpbGl0eSBmb3Igc3VjaCBhIG1hcHBpbmc7IHRoaXMgbWFwcGluZyByZXF1aXJlcyB0aGF0IGRhdGEgYmUgYWNrbm93bGVkZ2VkIGJlZm9yZSB0aGUgdHJhbnNpdGlvbiB0byBhICJjbG9zZWQiIG9yICJoYWxmLWNsb3NlZCIgc3RhdGUuICs9PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09KyB8IFNlbmRpbmcgUGFydCB8IFJlY2VpdmluZyBQYXJ0IHwgQ29tcG9zaXRlIFN0YXRlIHwgKz09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rIHwgTm8gU3RyZWFtIC8gUmVhZHkgfCBObyBTdHJlYW0gLyBSZWN2ICgqMSkgfCBpZGxlIHwgKy0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rIHwgUmVhZHkgLyBTZW5kIC8gfCBSZWN2IC8gU2l6ZSBLbm93biB8IG9wZW4gfCB8IERhdGEgU2VudCB8IHwgfCArLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSsgfCBSZWFkeSAvIFNlbmQgLyB8IERhdGEgUmVjdmQgLyBEYXRhIHwgaGFsZi1jbG9zZWQgfCB8IERhdGEgU2VudCB8IFJlYWQgfCAocmVtb3RlKSB8ICstLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKyB8IFJlYWR5IC8gU2VuZCAvIHwgUmVzZXQgUmVjdmQgLyBSZXNldCB8IGhhbGYtY2xvc2VkIHwgfCBEYXRhIFNlbnQgfCBSZWFkIHwgKHJlbW90ZSkgfCArLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSsgfCBEYXRhIFJlY3ZkIHwgUmVjdiAvIFNpemUgS25vd24gfCBoYWxmLWNsb3NlZCB8IHwgfCB8IChsb2NhbCkgfCArLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSsgfCBSZXNldCBTZW50IC8gfCBSZWN2IC8gU2l6ZSBLbm93biB8IGhhbGYtY2xvc2VkIHwgfCBSZXNldCBSZWN2ZCB8IHwgKGxvY2FsKSB8ICstLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKyB8IFJlc2V0IFNlbnQgLyB8IERhdGEgUmVjdmQgLyBEYXRhIHwgY2xvc2VkIHwgfCBSZXNldCBSZWN2ZCB8IFJlYWQgfCB8ICstLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKyB8IFJlc2V0IFNlbnQgLyB8IFJlc2V0IFJlY3ZkIC8gUmVzZXQgfCBjbG9zZWQgfCB8IFJlc2V0IFJlY3ZkIHwgUmVhZCB8IHwgKy0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rIHwgRGF0YSBSZWN2ZCB8IERhdGEgUmVjdmQgLyBEYXRhIHwgY2xvc2VkIHwgfCB8IFJlYWQgfCB8ICstLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKyB8IERhdGEgUmVjdmQgfCBSZXNldCBSZWN2ZCAvIFJlc2V0IHwgY2xvc2VkIHwgfCB8IFJlYWQgfCB8ICstLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKyBUYWJsZSAyOiBQb3NzaWJsZSBNYXBwaW5nIG9mIFN0cmVhbSBTdGF0ZXMgdG8gSFRUUC8yIHwgTm90ZSAoKjEpOiBBIHN0cmVhbSBpcyBjb25zaWRlcmVkICJpZGxlIiBpZiBpdCBoYXMgbm90IHlldCBiZWVuIHwgY3JlYXRlZCBvciBpZiB0aGUgcmVjZWl2aW5nIHBhcnQgb2YgdGhlIHN0cmVhbSBpcyBpbiB0aGUgIlJlY3YiIHwgc3RhdGUgd2l0aG91dCB5ZXQgaGF2aW5nIHJlY2VpdmVkIGFueSBmcmFtZXMuIDMuNS4gU29saWNpdGVkIFN0YXRlIFRyYW5zaXRpb25zIElmIGFuIGFwcGxpY2F0aW9uIGlzIG5vIGxvbmdlciBpbnRlcmVzdGVkIGluIHRoZSBkYXRhIGl0IGlzIHJlY2VpdmluZyBvbiBhIHN0cmVhbSwgaXQgY2FuIGFib3J0IHJlYWRpbmcgdGhlIHN0cmVhbSBhbmQgc3BlY2lmeSBhbiBhcHBsaWNhdGlvbiBlcnJvciBjb2RlLiBJZiB0aGUgc3RyZWFtIGlzIGluIHRoZSAiUmVjdiIgb3IgIlNpemUgS25vd24iIHN0YXRlLCB0aGUgdHJhbnNwb3J0IFNIT1VMRCBzaWduYWwgdGhpcyBieSBzZW5kaW5nIGEgU1RPUF9TRU5ESU5HIGZyYW1lIHRvIHByb21wdCBjbG9zdXJlIG9mIHRoZSBzdHJlYW0gaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbi4gVGhpcyB0eXBpY2FsbHkgaW5kaWNhdGVzIHRoYXQgdGhlIHJlY2VpdmluZyBhcHBsaWNhdGlvbiBpcyBubyBsb25nZXIgcmVhZGluZyBkYXRhIGl0IHJlY2VpdmVzIGZyb20gdGhlIHN0cmVhbSwgYnV0IGl0IGlzIG5vdCBhIGd1YXJhbnRlZSB0aGF0IGluY29taW5nIGRhdGEgd2lsbCBiZSBpZ25vcmVkLiBTVFJFQU0gZnJhbWVzIHJlY2VpdmVkIGFmdGVyIHNlbmRpbmcgYSBTVE9QX1NFTkRJTkcgZnJhbWUgYXJlIHN0aWxsIGNvdW50ZWQgdG93YXJkIGNvbm5lY3Rpb24gYW5kIHN0cmVhbSBmbG93IGNvbnRyb2wsIGV2ZW4gdGhvdWdoIHRoZXNlIGZyYW1lcyBjYW4gYmUgZGlzY2FyZGVkIHVwb24gcmVjZWlwdC4gQSBTVE9QX1NFTkRJTkcgZnJhbWUgcmVxdWVzdHMgdGhhdCB0aGUgcmVjZWl2aW5nIGVuZHBvaW50IHNlbmQgYSBSRVNFVF9TVFJFQU0gZnJhbWUuIEFuIGVuZHBvaW50IHRoYXQgcmVjZWl2ZXMgYSBTVE9QX1NFTkRJTkcgZnJhbWUgTVVTVCBzZW5kIGEgUkVTRVRfU1RSRUFNIGZyYW1lIGlmIHRoZSBzdHJlYW0gaXMgaW4gdGhlICJSZWFkeSIgb3IgIlNlbmQiIHN0YXRlLiBJZiB0aGUgc3RyZWFtIGlzIGluIHRoZSAiRGF0YSBTZW50IiBzdGF0ZSwgdGhlIGVuZHBvaW50IE1BWSBkZWZlciBzZW5kaW5nIHRoZSBSRVNFVF9TVFJFQU0gZnJhbWUgdW50aWwgdGhlIHBhY2tldHMgY29udGFpbmluZyBvdXRzdGFuZGluZyBkYXRhIGFyZSBhY2tub3dsZWRnZWQgb3IgZGVjbGFyZWQgbG9zdC4gSWYgYW55IG91dHN0YW5kaW5nIGRhdGEgaXMgZGVjbGFyZWQgbG9zdCwgdGhlIGVuZHBvaW50IFNIT1VMRCBzZW5kIGEgUkVTRVRfU1RSRUFNIGZyYW1lIGluc3RlYWQgb2YgcmV0cmFuc21pdHRpbmcgdGhlIGRhdGEuIEFuIGVuZHBvaW50IFNIT1VMRCBjb3B5IHRoZSBlcnJvciBjb2RlIGZyb20gdGhlIFNUT1BfU0VORElORyBmcmFtZSB0byB0aGUgUkVTRVRfU1RSRUFNIGZyYW1lIGl0IHNlbmRzLCBidXQgaXQgY2FuIHVzZSBhbnkgYXBwbGljYXRpb24gZXJyb3IgY29kZS4gQW4gZW5kcG9pbnQgdGhhdCBzZW5kcyBhIFNUT1BfU0VORElORyBmcmFtZSBNQVkgaWdub3JlIHRoZSBlcnJvciBjb2RlIGluIGFueSBSRVNFVF9TVFJFQU0gZnJhbWVzIHN1YnNlcXVlbnRseSByZWNlaXZlZCBmb3IgdGhhdCBzdHJlYW0uIFNUT1BfU0VORElORyBTSE9VTEQgb25seSBiZSBzZW50IGZvciBhIHN0cmVhbSB0aGF0IGhhcyBub3QgYmVlbiByZXNldCBieSB0aGUgcGVlci4gU1RPUF9TRU5ESU5HIGlzIG1vc3QgdXNlZnVsIGZvciBzdHJlYW1zIGluIHRoZSAiUmVjdiIgb3IgIlNpemUgS25vd24iIHN0YXRlLiBBbiBlbmRwb2ludCBpcyBleHBlY3RlZCB0byBzZW5kIGFub3RoZXIgU1RPUF9TRU5ESU5HIGZyYW1lIGlmIGEgcGFja2V0IGNvbnRhaW5pbmcgYSBwcmV2aW91cyBTVE9QX1NFTkRJTkcgaXMgbG9zdC4gSG93ZXZlciwgb25jZSBlaXRoZXIgYWxsIHN0cmVhbSBkYXRhIG9yIGEgUkVTRVRfU1RSRUFNIGZyYW1lIGhhcyBiZWVuIHJlY2VpdmVkIGZvciB0aGUgc3RyZWFtIC0tIHRoYXQgaXMsIHRoZSBzdHJlYW0gaXMgaW4gYW55IHN0YXRlIG90aGVyIHRoYW4gIlJlY3YiIG9yICJTaXplIEtub3duIiAtLSBzZW5kaW5nIGEgU1RPUF9TRU5ESU5HIGZyYW1lIGlzIHVubmVjZXNzYXJ5LiBBbiBlbmRwb2ludCB0aGF0IHdpc2hlcyB0byB0ZXJtaW5hdGUgYm90aCBkaXJlY3Rpb25zIG9mIGEgYmlkaXJlY3Rpb25hbCBzdHJlYW0gY2FuIHRlcm1pbmF0ZSBvbmUgZGlyZWN0aW9uIGJ5IHNlbmRpbmcgYSBSRVNFVF9TVFJFQU0gZnJhbWUsIGFuZCBpdCBjYW4gZW5jb3VyYWdlIHByb21wdCB0ZXJtaW5hdGlvbiBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIGJ5IHNlbmRpbmcgYSBTVE9QX1NFTkRJTkcgZnJhbWUuIDQuIEZsb3cgQ29udHJvbCBSZWNlaXZlcnMgbmVlZCB0byBsaW1pdCB0aGUgYW1vdW50IG9mIGRhdGEgdGhhdCB0aGV5IGFyZSByZXF1aXJlZCB0byBidWZmZXIsIGluIG9yZGVyIHRvIHByZXZlbnQgYSBmYXN0IHNlbmRlciBmcm9tIG92ZXJ3aGVsbWluZyB0aGVtIG9yIGEgbWFsaWNpb3VzIHNlbmRlciBmcm9tIGNvbnN1bWluZyBhIGxhcmdlIGFtb3VudCBvZiBtZW1vcnkuIFRvIGVuYWJsZSBhIHJlY2VpdmVyIHRvIGxpbWl0IG1lbW9yeSBjb21taXRtZW50cyBmb3IgYSBjb25uZWN0aW9uLCBzdHJlYW1zIGFyZSBmbG93IGNvbnRyb2xsZWQgYm90aCBpbmRpdmlkdWFsbHkgYW5kIGFjcm9zcyBhIGNvbm5lY3Rpb24gYXMgYSB3aG9sZS4gQSBRVUlDIHJlY2VpdmVyIGNvbnRyb2xzIHRoZSBtYXhpbXVtIGFtb3VudCBvZiBkYXRhIHRoZSBzZW5kZXIgY2FuIHNlbmQgb24gYSBzdHJlYW0gYXMgd2VsbCBhcyBhY3Jvc3MgYWxsIHN0cmVhbXMgYXQgYW55IHRpbWUsIGFzIGRlc2NyaWJlZCBpbiBTZWN0aW9ucyA0LjEgYW5kIDQuMi4gU2ltaWxhcmx5LCB0byBsaW1pdCBjb25jdXJyZW5jeSB3aXRoaW4gYSBjb25uZWN0aW9uLCBhIFFVSUMgZW5kcG9pbnQgY29udHJvbHMgdGhlIG1heGltdW0gY3VtdWxhdGl2ZSBudW1iZXIgb2Ygc3RyZWFtcyB0aGF0IGl0cyBwZWVyIGNhbiBpbml0aWF0ZSwgYXMgZGVzY3JpYmVkIGluIFNlY3Rpb24gNC42LiBEYXRhIHNlbnQgaW4gQ1JZUFRPIGZyYW1lcyBpcyBub3QgZmxvdyBjb250cm9sbGVkIGluIHRoZSBzYW1lIHdheSBhcyBzdHJlYW0gZGF0YS4gUVVJQyByZWxpZXMgb24gdGhlIGNyeXB0b2dyYXBoaWMgcHJvdG9jb2wgaW1wbGVtZW50YXRpb24gdG8gYXZvaWQgZXhjZXNzaXZlIGJ1ZmZlcmluZyBvZiBkYXRhOyBzZWUgW1FVSUMtVExTXS4gVG8gYXZvaWQgZXhjZXNzaXZlIGJ1ZmZlcmluZyBhdCBtdWx0aXBsZSBsYXllcnMsIFFVSUMgaW1wbGVtZW50YXRpb25zIFNIT1VMRCBwcm92aWRlIGFuIGludGVyZmFjZSBmb3IgdGhlIGNyeXB0b2dyYXBoaWMgcHJvdG9jb2wgaW1wbGVtZW50YXRpb24gdG8gY29tbXVuaWNhdGUgaXRzIGJ1ZmZlcmluZyBsaW1pdHMuIDQuMS4gRGF0YSBGbG93IENvbnRyb2wgUVVJQyBlbXBsb3lzIGEgbGltaXQtYmFzZWQgZmxvdyBjb250cm9sIHNjaGVtZSB3aGVyZSBhIHJlY2VpdmVyIGFkdmVydGlzZXMgdGhlIGxpbWl0IG9mIHRvdGFsIGJ5dGVzIGl0IGlzIHByZXBhcmVkIHRvIHJlY2VpdmUgb24gYSBnaXZlbiBzdHJlYW0gb3IgZm9yIHRoZSBlbnRpcmUgY29ubmVjdGlvbi4gVGhpcyBsZWFkcyB0byB0d28gbGV2ZWxzIG9mIGRhdGEgZmxvdyBjb250cm9sIGluIFFVSUM6ICogU3RyZWFtIGZsb3cgY29udHJvbCwgd2hpY2ggcHJldmVudHMgYSBzaW5nbGUgc3RyZWFtIGZyb20gY29uc3VtaW5nIHRoZSBlbnRpcmUgcmVjZWl2ZSBidWZmZXIgZm9yIGEgY29ubmVjdGlvbiBieSBsaW1pdGluZyB0aGUgYW1vdW50IG9mIGRhdGEgdGhhdCBjYW4gYmUgc2VudCBvbiBlYWNoIHN0cmVhbS4gKiBDb25uZWN0aW9uIGZsb3cgY29udHJvbCwgd2hpY2ggcHJldmVudHMgc2VuZGVycyBmcm9tIGV4Y2VlZGluZyBhIHJlY2VpdmVyJ3MgYnVmZmVyIGNhcGFjaXR5IGZvciB0aGUgY29ubmVjdGlvbiBieSBsaW1pdGluZyB0aGUgdG90YWwgYnl0ZXMgb2Ygc3RyZWFtIGRhdGEgc2VudCBpbiBTVFJFQU0gZnJhbWVzIG9uIGFsbCBzdHJlYW1zLiBTZW5kZXJzIE1VU1QgTk9UIHNlbmQgZGF0YSBpbiBleGNlc3Mgb2YgZWl0aGVyIGxpbWl0LiBBIHJlY2VpdmVyIHNldHMgaW5pdGlhbCBsaW1pdHMgZm9yIGFsbCBzdHJlYW1zIHRocm91Z2ggdHJhbnNwb3J0IHBhcmFtZXRlcnMgZHVyaW5nIHRoZSBoYW5kc2hha2UgKFNlY3Rpb24gNy40KS4gU3Vic2VxdWVudGx5LCBhIHJlY2VpdmVyIHNlbmRzIE1BWF9TVFJFQU1fREFUQSBmcmFtZXMgKFNlY3Rpb24gMTkuMTApIG9yIE1BWF9EQVRBIGZyYW1lcyAoU2VjdGlvbiAxOS45KSB0byB0aGUgc2VuZGVyIHRvIGFkdmVydGlzZSBsYXJnZXIgbGltaXRzLiBBIHJlY2VpdmVyIGNhbiBhZHZlcnRpc2UgYSBsYXJnZXIgbGltaXQgZm9yIGEgc3RyZWFtIGJ5IHNlbmRpbmcgYSBNQVhfU1RSRUFNX0RBVEEgZnJhbWUgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBzdHJlYW0gSUQuIEEgTUFYX1NUUkVBTV9EQVRBIGZyYW1lIGluZGljYXRlcyB0aGUgbWF4aW11bSBhYnNvbHV0ZSBieXRlIG9mZnNldCBvZiBhIHN0cmVhbS4gQSByZWNlaXZlciBjb3VsZCBkZXRlcm1pbmUgdGhlIGZsb3cgY29udHJvbCBvZmZzZXQgdG8gYmUgYWR2ZXJ0aXNlZCBiYXNlZCBvbiB0aGUgY3VycmVudCBvZmZzZXQgb2YgZGF0YSBjb25zdW1lZCBvbiB0aGF0IHN0cmVhbS4gQSByZWNlaXZlciBjYW4gYWR2ZXJ0aXNlIGEgbGFyZ2VyIGxpbWl0IGZvciBhIGNvbm5lY3Rpb24gYnkgc2VuZGluZyBhIE1BWF9EQVRBIGZyYW1lLCB3aGljaCBpbmRpY2F0ZXMgdGhlIG1heGltdW0gb2YgdGhlIHN1bSBvZiB0aGUgYWJzb2x1dGUgYnl0ZSBvZmZzZXRzIG9mIGFsbCBzdHJlYW1zLiBBIHJlY2VpdmVyIG1haW50YWlucyBhIGN1bXVsYXRpdmUgc3VtIG9mIGJ5dGVzIHJlY2VpdmVkIG9uIGFsbCBzdHJlYW1zLCB3aGljaCBpcyB1c2VkIHRvIGNoZWNrIGZvciB2aW9sYXRpb25zIG9mIHRoZSBhZHZlcnRpc2VkIGNvbm5lY3Rpb24gb3Igc3RyZWFtIGRhdGEgbGltaXRzLiBBIHJlY2VpdmVyIGNvdWxkIGRldGVybWluZSB0aGUgbWF4aW11bSBkYXRhIGxpbWl0IHRvIGJlIGFkdmVydGlzZWQgYmFzZWQgb24gdGhlIHN1bSBvZiBieXRlcyBjb25zdW1lZCBvbiBhbGwgc3RyZWFtcy4gT25jZSBhIHJlY2VpdmVyIGFkdmVydGlzZXMgYSBsaW1pdCBmb3IgdGhlIGNvbm5lY3Rpb24gb3IgYSBzdHJlYW0sIGl0IGlzIG5vdCBhbiBlcnJvciB0byBhZHZlcnRpc2UgYSBzbWFsbGVyIGxpbWl0LCBidXQgdGhlIHNtYWxsZXIgbGltaXQgaGFzIG5vIGVmZmVjdC4gQSByZWNlaXZlciBNVVNUIGNsb3NlIHRoZSBjb25uZWN0aW9uIHdpdGggYW4gZXJyb3Igb2YgdHlwZSBGTE9XX0NPTlRST0xfRVJST1IgaWYgdGhlIHNlbmRlciB2aW9sYXRlcyB0aGUgYWR2ZXJ0aXNlZCBjb25uZWN0aW9uIG9yIHN0cmVhbSBkYXRhIGxpbWl0czsgc2VlIFNlY3Rpb24gMTEgZm9yIGRldGFpbHMgb24gZXJyb3IgaGFuZGxpbmcuIEEgc2VuZGVyIE1VU1QgaWdub3JlIGFueSBNQVhfU1RSRUFNX0RBVEEgb3IgTUFYX0RBVEEgZnJhbWVzIHRoYXQgZG8gbm90IGluY3JlYXNlIGZsb3cgY29udHJvbCBsaW1pdHMuIElmIGEgc2VuZGVyIGhhcyBzZW50IGRhdGEgdXAgdG8gdGhlIGxpbWl0LCBpdCB3aWxsIGJlIHVuYWJsZSB0byBzZW5kIG5ldyBkYXRhIGFuZCBpcyBjb25zaWRlcmVkIGJsb2NrZWQuIEEgc2VuZGVyIFNIT1VMRCBzZW5kIGEgU1RSRUFNX0RBVEFfQkxPQ0tFRCBvciBEQVRBX0JMT0NLRUQgZnJhbWUgdG8gaW5kaWNhdGUgdG8gdGhlIHJlY2VpdmVyIHRoYXQgaXQgaGFzIGRhdGEgdG8gd3JpdGUgYnV0IGlzIGJsb2NrZWQgYnkgZmxvdyBjb250cm9sIGxpbWl0cy4gSWYgYSBzZW5kZXIgaXMgYmxvY2tlZCBmb3IgYSBwZXJpb2QgbG9uZ2VyIHRoYW4gdGhlIGlkbGUgdGltZW91dCAoU2VjdGlvbiAxMC4xKSwgdGhlIHJlY2VpdmVyIG1pZ2h0IGNsb3NlIHRoZSBjb25uZWN0aW9uIGV2ZW4gd2hlbiB0aGUgc2VuZGVyIGhhcyBkYXRhIHRoYXQgaXMgYXZhaWxhYmxlIGZvciB0cmFuc21pc3Npb24uIFRvIGtlZXAgdGhlIGNvbm5lY3Rpb24gZnJvbSBjbG9zaW5nLCBhIHNlbmRlciB0aGF0IGlzIGZsb3cgY29udHJvbCBsaW1pdGVkIFNIT1VMRCBwZXJpb2RpY2FsbHkgc2VuZCBhIFNUUkVBTV9EQVRBX0JMT0NLRUQgb3IgREFUQV9CTE9DS0VEIGZyYW1lIHdoZW4gaXQgaGFzIG5vIGFjay1lbGljaXRpbmcgcGFja2V0cyBpbiBmbGlnaHQuIDQuMi4gSW5jcmVhc2luZyBGbG93IENvbnRyb2wgTGltaXRzIEltcGxlbWVudGF0aW9ucyBkZWNpZGUgd2hlbiBhbmQgaG93IG11Y2ggY3JlZGl0IHRvIGFkdmVydGlzZSBpbiBNQVhfU1RSRUFNX0RBVEEgYW5kIE1BWF9EQVRBIGZyYW1lcywgYnV0IHRoaXMgc2VjdGlvbiBvZmZlcnMgYSBmZXcgY29uc2lkZXJhdGlvbnMuIFRvIGF2b2lkIGJsb2NraW5nIGEgc2VuZGVyLCBhIHJlY2VpdmVyIE1BWSBzZW5kIGEgTUFYX1NUUkVBTV9EQVRBIG9yIE1BWF9EQVRBIGZyYW1lIG11bHRpcGxlIHRpbWVzIHdpdGhpbiBhIHJvdW5kIHRyaXAgb3Igc2VuZCBpdCBlYXJseSBlbm91Z2ggdG8gYWxsb3cgdGltZSBmb3IgbG9zcyBvZiB0aGUgZnJhbWUgYW5kIHN1YnNlcXVlbnQgcmVjb3ZlcnkuIENvbnRyb2wgZnJhbWVzIGNvbnRyaWJ1dGUgdG8gY29ubmVjdGlvbiBvdmVyaGVhZC4gVGhlcmVmb3JlLCBmcmVxdWVudGx5IHNlbmRpbmcgTUFYX1NUUkVBTV9EQVRBIGFuZCBNQVhfREFUQSBmcmFtZXMgd2l0aCBzbWFsbCBjaGFuZ2VzIGlzIHVuZGVzaXJhYmxlLiBPbiB0aGUgb3RoZXIgaGFuZCwgaWYgdXBkYXRlcyBhcmUgbGVzcyBmcmVxdWVudCwgbGFyZ2VyIGluY3JlbWVudHMgdG8gbGltaXRzIGFyZSBuZWNlc3NhcnkgdG8gYXZvaWQgYmxvY2tpbmcgYSBzZW5kZXIsIHJlcXVpcmluZyBsYXJnZXIgcmVzb3VyY2UgY29tbWl0bWVudHMgYXQgdGhlIHJlY2VpdmVyLiBUaGVyZSBpcyBhIHRyYWRlLW9mZiBiZXR3ZWVuIHJlc291cmNlIGNvbW1pdG1lbnQgYW5kIG92ZXJoZWFkIHdoZW4gZGV0ZXJtaW5pbmcgaG93IGxhcmdlIGEgbGltaXQgaXMgYWR2ZXJ0aXNlZC4gQSByZWNlaXZlciBjYW4gdXNlIGFuIGF1dG90dW5pbmcgbWVjaGFuaXNtIHRvIHR1bmUgdGhlIGZyZXF1ZW5jeSBhbmQgYW1vdW50IG9mIGFkdmVydGlzZWQgYWRkaXRpb25hbCBjcmVkaXQgYmFzZWQgb24gYSByb3VuZC10cmlwIHRpbWUgZXN0aW1hdGUgYW5kIHRoZSByYXRlIGF0IHdoaWNoIHRoZSByZWNlaXZpbmcgYXBwbGljYXRpb24gY29uc3VtZXMgZGF0YSwgc2ltaWxhciB0byBjb21tb24gVENQIGltcGxlbWVudGF0aW9ucy4gQXMgYW4gb3B0aW1pemF0aW9uLCBhbiBlbmRwb2ludCBjb3VsZCBzZW5kIGZyYW1lcyByZWxhdGVkIHRvIGZsb3cgY29udHJvbCBvbmx5IHdoZW4gdGhlcmUgYXJlIG90aGVyIGZyYW1lcyB0byBzZW5kLCBlbnN1cmluZyB0aGF0IGZsb3cgY29udHJvbCBkb2VzIG5vdCBjYXVzZSBleHRyYSBwYWNrZXRzIHRvIGJlIHNlbnQuIEEgYmxvY2tlZCBzZW5kZXIgaXMgbm90IHJlcXVpcmVkIHRvIHNlbmQgU1RSRUFNX0RBVEFfQkxPQ0tFRCBvciBEQVRBX0JMT0NLRUQgZnJhbWVzLiBUaGVyZWZvcmUsIGEgcmVjZWl2ZXIgTVVTVCBOT1Qgd2FpdCBmb3IgYSBTVFJFQU1fREFUQV9CTE9DS0VEIG9yIERBVEFfQkxPQ0tFRCBmcmFtZSBiZWZvcmUgc2VuZGluZyBhIE1BWF9TVFJFQU1fREFUQSBvciBNQVhfREFUQSBmcmFtZTsgZG9pbmcgc28gY291bGQgcmVzdWx0IGluIHRoZSBzZW5kZXIgYmVpbmcgYmxvY2tlZCBmb3IgdGhlIHJlc3Qgb2YgdGhlIGNvbm5lY3Rpb24uIEV2ZW4gaWYgdGhlIHNlbmRlciBzZW5kcyB0aGVzZSBmcmFtZXMsIHdhaXRpbmcgZm9yIHRoZW0gd2lsbCByZXN1bHQgaW4gdGhlIHNlbmRlciBiZWluZyBibG9ja2VkIGZvciBhdCBsZWFzdCBhbiBlbnRpcmUgcm91bmQgdHJpcC4gV2hlbiBhIHNlbmRlciByZWNlaXZlcyBjcmVkaXQgYWZ0ZXIgYmVpbmcgYmxvY2tlZCwgaXQgbWlnaHQgYmUgYWJsZSB0byBzZW5kIGEgbGFyZ2UgYW1vdW50IG9mIGRhdGEgaW4gcmVzcG9uc2UsIHJlc3VsdGluZyBpbiBzaG9ydC10ZXJtIGNvbmdlc3Rpb247IHNlZSBTZWN0aW9uIDcuNyBvZiBbUVVJQy1SRUNPVkVSWV0gZm9yIGEgZGlzY3Vzc2lvbiBvZiBob3cgYSBzZW5kZXIgY2FuIGF2b2lkIHRoaXMgY29uZ2VzdGlvbi4gNC4zLiBGbG93IENvbnRyb2wgUGVyZm9ybWFuY2UgSWYgYW4gZW5kcG9pbnQgY2Fubm90IGVuc3VyZSB0aGF0IGl0cyBwZWVyIGFsd2F5cyBoYXMgYXZhaWxhYmxlIGZsb3cgY29udHJvbCBjcmVkaXQgdGhhdCBpcyBncmVhdGVyIHRoYW4gdGhlIHBlZXIncyBiYW5kd2lkdGgtZGVsYXkgcHJvZHVjdCBvbiB0aGlzIGNvbm5lY3Rpb24sIGl0cyByZWNlaXZlIHRocm91Z2hwdXQgd2lsbCBiZSBsaW1pdGVkIGJ5IGZsb3cgY29udHJvbC4gUGFja2V0IGxvc3MgY2FuIGNhdXNlIGdhcHMgaW4gdGhlIHJlY2VpdmUgYnVmZmVyLCBwcmV2ZW50aW5nIHRoZSBhcHBsaWNhdGlvbiBmcm9tIGNvbnN1bWluZyBkYXRhIGFuZCBmcmVlaW5nIHVwIHJlY2VpdmUgYnVmZmVyIHNwYWNlLiBTZW5kaW5nIHRpbWVseSB1cGRhdGVzIG9mIGZsb3cgY29udHJvbCBsaW1pdHMgY2FuIGltcHJvdmUgcGVyZm9ybWFuY2UuIFNlbmRpbmcgcGFja2V0cyBvbmx5IHRvIHByb3ZpZGUgZmxvdyBjb250cm9sIHVwZGF0ZXMgY2FuIGluY3JlYXNlIG5ldHdvcmsgbG9hZCBhbmQgYWR2ZXJzZWx5IGFmZmVjdCBwZXJmb3JtYW5jZS4gU2VuZGluZyBmbG93IGNvbnRyb2wgdXBkYXRlcyBhbG9uZyB3aXRoIG90aGVyIGZyYW1lcywgc3VjaCBhcyBBQ0sgZnJhbWVzLCByZWR1Y2VzIHRoZSBjb3N0IG9mIHRob3NlIHVwZGF0ZXMuIDQuNC4gSGFuZGxpbmcgU3RyZWFtIENhbmNlbGxhdGlvbiBFbmRwb2ludHMgbmVlZCB0byBldmVudHVhbGx5IGFncmVlIG9uIHRoZSBhbW91bnQgb2YgZmxvdyBjb250cm9sIGNyZWRpdCB0aGF0IGhhcyBiZWVuIGNvbnN1bWVkIG9uIGV2ZXJ5IHN0cmVhbSwgdG8gYmUgYWJsZSB0byBhY2NvdW50IGZvciBhbGwgYnl0ZXMgZm9yIGNvbm5lY3Rpb24tbGV2ZWwgZmxvdyBjb250cm9sLiBPbiByZWNlaXB0IG9mIGEgUkVTRVRfU1RSRUFNIGZyYW1lLCBhbiBlbmRwb2ludCB3aWxsIHRlYXIgZG93biBzdGF0ZSBmb3IgdGhlIG1hdGNoaW5nIHN0cmVhbSBhbmQgaWdub3JlIGZ1cnRoZXIgZGF0YSBhcnJpdmluZyBvbiB0aGF0IHN0cmVhbS4gUkVTRVRfU1RSRUFNIHRlcm1pbmF0ZXMgb25lIGRpcmVjdGlvbiBvZiBhIHN0cmVhbSBhYnJ1cHRseS4gRm9yIGEgYmlkaXJlY3Rpb25hbCBzdHJlYW0sIFJFU0VUX1NUUkVBTSBoYXMgbm8gZWZmZWN0IG9uIGRhdGEgZmxvdyBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLiBCb3RoIGVuZHBvaW50cyBNVVNUIG1haW50YWluIGZsb3cgY29udHJvbCBzdGF0ZSBmb3IgdGhlIHN0cmVhbSBpbiB0aGUgdW50ZXJtaW5hdGVkIGRpcmVjdGlvbiB1bnRpbCB0aGF0IGRpcmVjdGlvbiBlbnRlcnMgYSB0ZXJtaW5hbCBzdGF0ZS4gNC41LiBTdHJlYW0gRmluYWwgU2l6ZSBUaGUgZmluYWwgc2l6ZSBpcyB0aGUgYW1vdW50IG9mIGZsb3cgY29udHJvbCBjcmVkaXQgdGhhdCBpcyBjb25zdW1lZCBieSBhIHN0cmVhbS4gQXNzdW1pbmcgdGhhdCBldmVyeSBjb250aWd1b3VzIGJ5dGUgb24gdGhlIHN0cmVhbSB3YXMgc2VudCBvbmNlLCB0aGUgZmluYWwgc2l6ZSBpcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHNlbnQuIE1vcmUgZ2VuZXJhbGx5LCB0aGlzIGlzIG9uZSBoaWdoZXIgdGhhbiB0aGUgb2Zmc2V0IG9mIHRoZSBieXRlIHdpdGggdGhlIGxhcmdlc3Qgb2Zmc2V0IHNlbnQgb24gdGhlIHN0cmVhbSwgb3IgemVybyBpZiBubyBieXRlcyB3ZXJlIHNlbnQuIEEgc2VuZGVyIGFsd2F5cyBjb21tdW5pY2F0ZXMgdGhlIGZpbmFsIHNpemUgb2YgYSBzdHJlYW0gdG8gdGhlIHJlY2VpdmVyIHJlbGlhYmx5LCBubyBtYXR0ZXIgaG93IHRoZSBzdHJlYW0gaXMgdGVybWluYXRlZC4gVGhlIGZpbmFsIHNpemUgaXMgdGhlIHN1bSBvZiB0aGUgT2Zmc2V0IGFuZCBMZW5ndGggZmllbGRzIG9mIGEgU1RSRUFNIGZyYW1lIHdpdGggYSBGSU4gZmxhZywgbm90aW5nIHRoYXQgdGhlc2UgZmllbGRzIG1pZ2h0IGJlIGltcGxpY2l0LiBBbHRlcm5hdGl2ZWx5LCB0aGUgRmluYWwgU2l6ZSBmaWVsZCBvZiBhIFJFU0VUX1NUUkVBTSBmcmFtZSBjYXJyaWVzIHRoaXMgdmFsdWUuIFRoaXMgZ3VhcmFudGVlcyB0aGF0IGJvdGggZW5kcG9pbnRzIGFncmVlIG9uIGhvdyBtdWNoIGZsb3cgY29udHJvbCBjcmVkaXQgd2FzIGNvbnN1bWVkIGJ5IHRoZSBzZW5kZXIgb24gdGhhdCBzdHJlYW0uIEFuIGVuZHBvaW50IHdpbGwga25vdyB0aGUgZmluYWwgc2l6ZSBmb3IgYSBzdHJlYW0gd2hlbiB0aGUgcmVjZWl2aW5nIHBhcnQgb2YgdGhlIHN0cmVhbSBlbnRlcnMgdGhlICJTaXplIEtub3duIiBvciAiUmVzZXQgUmVjdmQiIHN0YXRlIChTZWN0aW9uIDMpLiBUaGUgcmVjZWl2ZXIgTVVTVCB1c2UgdGhlIGZpbmFsIHNpemUgb2YgdGhlIHN0cmVhbSB0byBhY2NvdW50IGZvciBhbGwgYnl0ZXMgc2VudCBvbiB0aGUgc3RyZWFtIGluIGl0cyBjb25uZWN0aW9uLWxldmVsIGZsb3cgY29udHJvbGxlci4gQW4gZW5kcG9pbnQgTVVTVCBOT1Qgc2VuZCBkYXRhIG9uIGEgc3RyZWFtIGF0IG9yIGJleW9uZCB0aGUgZmluYWwgc2l6ZS4gT25jZSBhIGZpbmFsIHNpemUgZm9yIGEgc3RyZWFtIGlzIGtub3duLCBpdCBjYW5ub3QgY2hhbmdlLiBJZiBhIFJFU0VUX1NUUkVBTSBvciBTVFJFQU0gZnJhbWUgaXMgcmVjZWl2ZWQgaW5kaWNhdGluZyBhIGNoYW5nZSBpbiB0aGUgZmluYWwgc2l6ZSBmb3IgdGhlIHN0cmVhbSwgYW4gZW5kcG9pbnQgU0hPVUxEIHJlc3BvbmQgd2l0aCBhbiBlcnJvciBvZiB0eXBlIEZJTkFMX1NJWkVfRVJST1I7IHNlZSBTZWN0aW9uIDExIGZvciBkZXRhaWxzIG9uIGVycm9yIGhhbmRsaW5nLiBBIHJlY2VpdmVyIFNIT1VMRCB0cmVhdCByZWNlaXB0IG9mIGRhdGEgYXQgb3IgYmV5b25kIHRoZSBmaW5hbCBzaXplIGFzIGFuIGVycm9yIG9mIHR5cGUgRklOQUxfU0laRV9FUlJPUiwgZXZlbiBhZnRlciBhIHN0cmVhbSBpcyBjbG9zZWQuIEdlbmVyYXRpbmcgdGhlc2UgZXJyb3JzIGlzIG5vdCBtYW5kYXRvcnksIGJlY2F1c2UgcmVxdWlyaW5nIHRoYXQgYW4gZW5kcG9pbnQgZ2VuZXJhdGUgdGhlc2UgZXJyb3JzIGFsc28gbWVhbnMgdGhhdCB0aGUgZW5kcG9pbnQgbmVlZHMgdG8gbWFpbnRhaW4gdGhlIGZpbmFsIHNpemUgc3RhdGUgZm9yIGNsb3NlZCBzdHJlYW1zLCB3aGljaCBjb3VsZCBtZWFuIGEgc2lnbmlmaWNhbnQgc3RhdGUgY29tbWl0bWVudC4gNC42LiBDb250cm9sbGluZyBDb25jdXJyZW5jeSBBbiBlbmRwb2ludCBsaW1pdHMgdGhlIGN1bXVsYXRpdmUgbnVtYmVyIG9mIGluY29taW5nIHN0cmVhbXMgYSBwZWVyIGNhbiBvcGVuLiBPbmx5IHN0cmVhbXMgd2l0aCBhIHN0cmVhbSBJRCBsZXNzIHRoYW4gIihtYXhfc3RyZWFtcyAqIDQgKyBmaXJzdF9zdHJlYW1faWRfb2ZfdHlwZSkiIGNhbiBiZSBvcGVuZWQ7IHNlZSBUYWJsZSAxLiBJbml0aWFsIGxpbWl0cyBhcmUgc2V0IGluIHRoZSB0cmFuc3BvcnQgcGFyYW1ldGVyczsgc2VlIFNlY3Rpb24gMTguMi4gU3Vic2VxdWVudCBsaW1pdHMgYXJlIGFkdmVydGlzZWQgdXNpbmcgTUFYX1NUUkVBTVMgZnJhbWVzOyBzZWUgU2VjdGlvbiAxOS4xMS4gU2VwYXJhdGUgbGltaXRzIGFwcGx5IHRvIHVuaWRpcmVjdGlvbmFsIGFuZCBiaWRpcmVjdGlvbmFsIHN0cmVhbXMuIElmIGEgbWF4X3N0cmVhbXMgdHJhbnNwb3J0IHBhcmFtZXRlciBvciBhIE1BWF9TVFJFQU1TIGZyYW1lIGlzIHJlY2VpdmVkIHdpdGggYSB2YWx1ZSBncmVhdGVyIHRoYW4gMl42MCwgdGhpcyB3b3VsZCBhbGxvdyBhIG1heGltdW0gc3RyZWFtIElEIHRoYXQgY2Fubm90IGJlIGV4cHJlc3NlZCBhcyBhIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyOyBzZWUgU2VjdGlvbiAxNi4gSWYgZWl0aGVyIGlzIHJlY2VpdmVkLCB0aGUgY29ubmVjdGlvbiBNVVNUIGJlIGNsb3NlZCBpbW1lZGlhdGVseSB3aXRoIGEgY29ubmVjdGlvbiBlcnJvciBvZiB0eXBlIFRSQU5TUE9SVF9QQVJBTUVURVJfRVJST1IgaWYgdGhlIG9mZmVuZGluZyB2YWx1ZSB3YXMgcmVjZWl2ZWQgaW4gYSB0cmFuc3BvcnQgcGFyYW1ldGVyIG9yIG9mIHR5cGUgRlJBTUVfRU5DT0RJTkdfRVJST1IgaWYgaXQgd2FzIHJlY2VpdmVkIGluIGEgZnJhbWU7IHNlZSBTZWN0aW9uIDEwLjIuIEVuZHBvaW50cyBNVVNUIE5PVCBleGNlZWQgdGhlIGxpbWl0IHNldCBieSB0aGVpciBwZWVyLiBBbiBlbmRwb2ludCB0aGF0IHJlY2VpdmVzIGEgZnJhbWUgd2l0aCBhIHN0cmVhbSBJRCBleGNlZWRpbmcgdGhlIGxpbWl0IGl0IGhhcyBzZW50IE1VU1QgdHJlYXQgdGhpcyBhcyBhIGNvbm5lY3Rpb24gZXJyb3Igb2YgdHlwZSBTVFJFQU1fTElNSVRfRVJST1I7IHNlZSBTZWN0aW9uIDExIGZvciBkZXRhaWxzIG9uIGVycm9yIGhhbmRsaW5nLiBPbmNlIGEgcmVjZWl2ZXIgYWR2ZXJ0aXNlcyBhIHN0cmVhbSBsaW1pdCB1c2luZyB0aGUgTUFYX1NUUkVBTVMgZnJhbWUsIGFkdmVydGlzaW5nIGEgc21hbGxlciBsaW1pdCBoYXMgbm8gZWZmZWN0LiBNQVhfU1RSRUFNUyBmcmFtZXMgdGhhdCBkbyBub3QgaW5jcmVhc2UgdGhlIHN0cmVhbSBsaW1pdCBNVVNUIGJlIGlnbm9yZWQuIEFzIHdpdGggc3RyZWFtIGFuZCBjb25uZWN0aW9uIGZsb3cgY29udHJvbCwgdGhpcyBkb2N1bWVudCBsZWF2ZXMgaW1wbGVtZW50YXRpb25zIHRvIGRlY2lkZSB3aGVuIGFuZCBob3cgbWFueSBzdHJlYW1zIHNob3VsZCBiZSBhZHZlcnRpc2VkIHRvIGEgcGVlciB2aWEgTUFYX1NUUkVBTVMuIEltcGxlbWVudGF0aW9ucyBtaWdodCBjaG9vc2UgdG8gaW5jcmVhc2UgbGltaXRzIGFzIHN0cmVhbXMgYXJlIGNsb3NlZCwgdG8ga2VlcCB0aGUgbnVtYmVyIG9mIHN0cmVhbXMgYXZhaWxhYmxlIHRvIHBlZXJzIHJvdWdobHkgY29uc2lzdGVudC4gQW4gZW5kcG9pbnQgdGhhdCBpcyB1bmFibGUgdG8gb3BlbiBhIG5ldyBzdHJlYW0gZHVlIHRvIHRoZSBwZWVyJ3MgbGltaXRzIFNIT1VMRCBzZW5kIGEgU1RSRUFNU19CTE9DS0VEIGZyYW1lIChTZWN0aW9uIDE5LjE0KS4gVGhpcyBzaWduYWwgaXMgY29uc2lkZXJlZCB1c2VmdWwgZm9yIGRlYnVnZ2luZy4gQW4gZW5kcG9pbnQgTVVTVCBOT1Qgd2FpdCB0byByZWNlaXZlIHRoaXMgc2lnbmFsIGJlZm9yZSBhZHZlcnRpc2luZyBhZGRpdGlvbmFsIGNyZWRpdCwgc2luY2UgZG9pbmcgc28gd2lsbCBtZWFuIHRoYXQgdGhlIHBlZXIgd2lsbCBiZSBibG9ja2VkIGZvciBhdCBsZWFzdCBhbiBlbnRpcmUgcm91bmQgdHJpcCwgYW5kIHBvdGVudGlhbGx5IGluZGVmaW5pdGVseSBpZiB0aGUgcGVlciBjaG9vc2VzIG5vdCB0byBzZW5kIFNUUkVBTVNfQkxPQ0tFRCBmcmFtZXMuIDUuIENvbm5lY3Rpb25zIEEgUVVJQyBjb25uZWN0aW9uIGlzIHNoYXJlZCBzdGF0ZSBiZXR3ZWVuIGEgY2xpZW50IGFuZCBhIHNlcnZlci4gRWFjaCBjb25uZWN0aW9uIHN0YXJ0cyB3aXRoIGEgaGFuZHNoYWtlIHBoYXNlLCBkdXJpbmcgd2hpY2ggdGhlIHR3byBlbmRwb2ludHMgZXN0YWJsaXNoIGEgc2hhcmVkIHNlY3JldCB1c2luZyB0aGUgY3J5cHRvZ3JhcGhpYyBoYW5kc2hha2UgcHJvdG9jb2wgW1FVSUMtVExTXSBhbmQgbmVnb3RpYXRlIHRoZSBhcHBsaWNhdGlvbiBwcm90b2NvbC4gVGhlIGhhbmRzaGFrZSAoU2VjdGlvbiA3KSBjb25maXJtcyB0aGF0IGJvdGggZW5kcG9pbnRzIGFyZSB3aWxsaW5nIHRvIGNvbW11bmljYXRlIChTZWN0aW9uIDguMSkgYW5kIGVzdGFibGlzaGVzIHBhcmFtZXRlcnMgZm9yIHRoZSBjb25uZWN0aW9uIChTZWN0aW9uIDcuNCkuIEFuIGFwcGxpY2F0aW9uIHByb3RvY29sIGNhbiB1c2UgdGhlIGNvbm5lY3Rpb24gZHVyaW5nIHRoZSBoYW5kc2hha2UgcGhhc2Ugd2l0aCBzb21lIGxpbWl0YXRpb25zLiAwLVJUVCBhbGxvd3MgYXBwbGljYXRpb24gZGF0YSB0byBiZSBzZW50IGJ5IGEgY2xpZW50IGJlZm9yZSByZWNlaXZpbmcgYSByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIuIEhvd2V2ZXIsIDAtUlRUIHByb3ZpZGVzIG5vIHByb3RlY3Rpb24gYWdhaW5zdCByZXBsYXkgYXR0YWNrczsgc2VlIFNlY3Rpb24gOS4yIG9mIFtRVUlDLVRMU10uIEEgc2VydmVyIGNhbiBhbHNvIHNlbmQgYXBwbGljYXRpb24gZGF0YSB0byBhIGNsaWVudCBiZWZvcmUgaXQgcmVjZWl2ZXMgdGhlIGZpbmFsIGNyeXB0b2dyYXBoaWMgaGFuZHNoYWtlIG1lc3NhZ2VzIHRoYXQgYWxsb3cgaXQgdG8gY29uZmlybSB0aGUgaWRlbnRpdHkgYW5kIGxpdmVuZXNzIG9mIHRoZSBjbGllbnQuIFRoZXNlIGNhcGFiaWxpdGllcyBhbGxvdyBhbiBhcHBsaWNhdGlvbiBwcm90b2NvbCB0byBvZmZlciB0aGUgb3B0aW9uIG9mIHRyYWRpbmcgc29tZSBzZWN1cml0eSBndWFyYW50ZWVzIGZvciByZWR1Y2VkIGxhdGVuY3kuIFRoZSB1c2Ugb2YgY29ubmVjdGlvbiBJRHMgKFNlY3Rpb24gNS4xKSBhbGxvd3MgY29ubmVjdGlvbnMgdG8gbWlncmF0ZSB0byBhIG5ldyBuZXR3b3JrIHBhdGgsIGJvdGggYXMgYSBkaXJlY3QgY2hvaWNlIG9mIGFuIGVuZHBvaW50IGFuZCB3aGVuIGZvcmNlZCBieSBhIGNoYW5nZSBpbiBhIG1pZGRsZWJveC4gU2VjdGlvbiA5IGRlc2NyaWJlcyBtaXRpZ2F0aW9ucyBmb3IgdGhlIHNlY3VyaXR5IGFuZCBwcml2YWN5IGlzc3VlcyBhc3NvY2lhdGVkIHdpdGggbWlncmF0aW9uLiBGb3IgY29ubmVjdGlvbnMgdGhhdCBhcmUgbm8gbG9uZ2VyIG5lZWRlZCBvciBkZXNpcmVkLCB0aGVyZSBhcmUgc2V2ZXJhbCB3YXlzIGZvciBhIGNsaWVudCBhbmQgc2VydmVyIHRvIHRlcm1pbmF0ZSBhIGNvbm5lY3Rpb24sIGFzIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDEwLiA1LjEuIENvbm5lY3Rpb24gSUQgRWFjaCBjb25uZWN0aW9uIHBvc3Nlc3NlcyBhIHNldCBvZiBjb25uZWN0aW9uIGlkZW50aWZpZXJzLCBvciBjb25uZWN0aW9uIElEcywgZWFjaCBvZiB3aGljaCBjYW4gaWRlbnRpZnkgdGhlIGNvbm5lY3Rpb24uIENvbm5lY3Rpb24gSURzIGFyZSBpbmRlcGVuZGVudGx5IHNlbGVjdGVkIGJ5IGVuZHBvaW50czsgZWFjaCBlbmRwb2ludCBzZWxlY3RzIHRoZSBjb25uZWN0aW9uIElEcyB0aGF0IGl0cyBwZWVyIHVzZXMuIFRoZSBwcmltYXJ5IGZ1bmN0aW9uIG9mIGEgY29ubmVjdGlvbiBJRCBpcyB0byBlbnN1cmUgdGhhdCBjaGFuZ2VzIGluIGFkZHJlc3NpbmcgYXQgbG93ZXIgcHJvdG9jb2wgbGF5ZXJzIChVRFAsIElQKSBkbyBub3QgY2F1c2UgcGFja2V0cyBmb3IgYSBRVUlDIGNvbm5lY3Rpb24gdG8gYmUgZGVsaXZlcmVkIHRvIHRoZSB3cm9uZyBlbmRwb2ludC4gRWFjaCBlbmRwb2ludCBzZWxlY3RzIGNvbm5lY3Rpb24gSURzIHVzaW5nIGFuIGltcGxlbWVudGF0aW9uLXNwZWNpZmljIChhbmQgcGVyaGFwcyBkZXBsb3ltZW50LXNwZWNpZmljKSBtZXRob2QgdGhhdCB3aWxsIGFsbG93IHBhY2tldHMgd2l0aCB0aGF0IGNvbm5lY3Rpb24gSUQgdG8gYmUgcm91dGVkIGJhY2sgdG8gdGhlIGVuZHBvaW50IGFuZCB0byBiZSBpZGVudGlmaWVkIGJ5IHRoZSBlbmRwb2ludCB1cG9uIHJlY2VpcHQuIE11bHRpcGxlIGNvbm5lY3Rpb24gSURzIGFyZSB1c2VkIHNvIHRoYXQgZW5kcG9pbnRzIGNhbiBzZW5kIHBhY2tldHMgdGhhdCBjYW5ub3QgYmUgaWRlbnRpZmllZCBieSBhbiBvYnNlcnZlciBhcyBiZWluZyBmb3IgdGhlIHNhbWUgY29ubmVjdGlvbiB3aXRob3V0IGNvb3BlcmF0aW9uIGZyb20gYW4gZW5kcG9pbnQ7IHNlZSBTZWN0aW9uIDkuNS4gQ29ubmVjdGlvbiBJRHMgTVVTVCBOT1QgY29udGFpbiBhbnkgaW5mb3JtYXRpb24gdGhhdCBjYW4gYmUgdXNlZCBieSBhbiBleHRlcm5hbCBvYnNlcnZlciAodGhhdCBpcywgb25lIHRoYXQgZG9lcyBub3QgY29vcGVyYXRlIHdpdGggdGhlIGlzc3VlcikgdG8gY29ycmVsYXRlIHRoZW0gd2l0aCBvdGhlciBjb25uZWN0aW9uIElEcyBmb3IgdGhlIHNhbWUgY29ubmVjdGlvbi4gQXMgYSB0cml2aWFsIGV4YW1wbGUsIHRoaXMgbWVhbnMgdGhlIHNhbWUgY29ubmVjdGlvbiBJRCBNVVNUIE5PVCBiZSBpc3N1ZWQgbW9yZSB0aGFuIG9uY2Ugb24gdGhlIHNhbWUgY29ubmVjdGlvbi4gUGFja2V0cyB3aXRoIGxvbmcgaGVhZGVycyBpbmNsdWRlIFNvdXJjZSBDb25uZWN0aW9uIElEIGFuZCBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEIGZpZWxkcy4gVGhlc2UgZmllbGRzIGFyZSB1c2VkIHRvIHNldCB0aGUgY29ubmVjdGlvbiBJRHMgZm9yIG5ldyBjb25uZWN0aW9uczsgc2VlIFNlY3Rpb24gNy4yIGZvciBkZXRhaWxzLiBQYWNrZXRzIHdpdGggc2hvcnQgaGVhZGVycyAoU2VjdGlvbiAxNy4zKSBvbmx5IGluY2x1ZGUgdGhlIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgYW5kIG9taXQgdGhlIGV4cGxpY2l0IGxlbmd0aC4gVGhlIGxlbmd0aCBvZiB0aGUgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBmaWVsZCBpcyBleHBlY3RlZCB0byBiZSBrbm93biB0byBlbmRwb2ludHMuIEVuZHBvaW50cyB1c2luZyBhIGxvYWQgYmFsYW5jZXIgdGhhdCByb3V0ZXMgYmFzZWQgb24gY29ubmVjdGlvbiBJRCBjb3VsZCBhZ3JlZSB3aXRoIHRoZSBsb2FkIGJhbGFuY2VyIG9uIGEgZml4ZWQgbGVuZ3RoIGZvciBjb25uZWN0aW9uIElEcyBvciBhZ3JlZSBvbiBhbiBlbmNvZGluZyBzY2hlbWUuIEEgZml4ZWQgcG9ydGlvbiBjb3VsZCBlbmNvZGUgYW4gZXhwbGljaXQgbGVuZ3RoLCB3aGljaCBhbGxvd3MgdGhlIGVudGlyZSBjb25uZWN0aW9uIElEIHRvIHZhcnkgaW4gbGVuZ3RoIGFuZCBzdGlsbCBiZSB1c2VkIGJ5IHRoZSBsb2FkIGJhbGFuY2VyLiBBIFZlcnNpb24gTmVnb3RpYXRpb24gKFNlY3Rpb24gMTcuMi4xKSBwYWNrZXQgZWNob2VzIHRoZSBjb25uZWN0aW9uIElEcyBzZWxlY3RlZCBieSB0aGUgY2xpZW50LCBib3RoIHRvIGVuc3VyZSBjb3JyZWN0IHJvdXRpbmcgdG93YXJkIHRoZSBjbGllbnQgYW5kIHRvIGRlbW9uc3RyYXRlIHRoYXQgdGhlIHBhY2tldCBpcyBpbiByZXNwb25zZSB0byBhIHBhY2tldCBzZW50IGJ5IHRoZSBjbGllbnQuIEEgemVyby1sZW5ndGggY29ubmVjdGlvbiBJRCBjYW4gYmUgdXNlZCB3aGVuIGEgY29ubmVjdGlvbiBJRCBpcyBub3QgbmVlZGVkIHRvIHJvdXRlIHRvIHRoZSBjb3JyZWN0IGVuZHBvaW50LiBIb3dldmVyLCBtdWx0aXBsZXhpbmcgY29ubmVjdGlvbnMgb24gdGhlIHNhbWUgbG9jYWwgSVAgYWRkcmVzcyBhbmQgcG9ydCB3aGlsZSB1c2luZyB6ZXJvLSBsZW5ndGggY29ubmVjdGlvbiBJRHMgd2lsbCBjYXVzZSBmYWlsdXJlcyBpbiB0aGUgcHJlc2VuY2Ugb2YgcGVlciBjb25uZWN0aW9uIG1pZ3JhdGlvbiwgTkFUIHJlYmluZGluZywgYW5kIGNsaWVudCBwb3J0IHJldXNlLiBBbiBlbmRwb2ludCBNVVNUIE5PVCB1c2UgdGhlIHNhbWUgSVAgYWRkcmVzcyBhbmQgcG9ydCBmb3IgbXVsdGlwbGUgY29uY3VycmVudCBjb25uZWN0aW9ucyB3aXRoIHplcm8tbGVuZ3RoIGNvbm5lY3Rpb24gSURzLCB1bmxlc3MgaXQgaXMgY2VydGFpbiB0aGF0IHRob3NlIHByb3RvY29sIGZlYXR1cmVzIGFyZSBub3QgaW4gdXNlLiBXaGVuIGFuIGVuZHBvaW50IHVzZXMgYSBub24temVyby1sZW5ndGggY29ubmVjdGlvbiBJRCwgaXQgbmVlZHMgdG8gZW5zdXJlIHRoYXQgdGhlIHBlZXIgaGFzIGEgc3VwcGx5IG9mIGNvbm5lY3Rpb24gSURzIGZyb20gd2hpY2ggdG8gY2hvb3NlIGZvciBwYWNrZXRzIHNlbnQgdG8gdGhlIGVuZHBvaW50LiBUaGVzZSBjb25uZWN0aW9uIElEcyBhcmUgc3VwcGxpZWQgYnkgdGhlIGVuZHBvaW50IHVzaW5nIHRoZSBORVdfQ09OTkVDVElPTl9JRCBmcmFtZSAoU2VjdGlvbiAxOS4xNSkuIDUuMS4xLiBJc3N1aW5nIENvbm5lY3Rpb24gSURzIEVhY2ggY29ubmVjdGlvbiBJRCBoYXMgYW4gYXNzb2NpYXRlZCBzZXF1ZW5jZSBudW1iZXIgdG8gYXNzaXN0IGluIGRldGVjdGluZyB3aGVuIE5FV19DT05ORUNUSU9OX0lEIG9yIFJFVElSRV9DT05ORUNUSU9OX0lEIGZyYW1lcyByZWZlciB0byB0aGUgc2FtZSB2YWx1ZS4gVGhlIGluaXRpYWwgY29ubmVjdGlvbiBJRCBpc3N1ZWQgYnkgYW4gZW5kcG9pbnQgaXMgc2VudCBpbiB0aGUgU291cmNlIENvbm5lY3Rpb24gSUQgZmllbGQgb2YgdGhlIGxvbmcgcGFja2V0IGhlYWRlciAoU2VjdGlvbiAxNy4yKSBkdXJpbmcgdGhlIGhhbmRzaGFrZS4gVGhlIHNlcXVlbmNlIG51bWJlciBvZiB0aGUgaW5pdGlhbCBjb25uZWN0aW9uIElEIGlzIDAuIElmIHRoZSBwcmVmZXJyZWRfYWRkcmVzcyB0cmFuc3BvcnQgcGFyYW1ldGVyIGlzIHNlbnQsIHRoZSBzZXF1ZW5jZSBudW1iZXIgb2YgdGhlIHN1cHBsaWVkIGNvbm5lY3Rpb24gSUQgaXMgMS4gQWRkaXRpb25hbCBjb25uZWN0aW9uIElEcyBhcmUgY29tbXVuaWNhdGVkIHRvIHRoZSBwZWVyIHVzaW5nIE5FV19DT05ORUNUSU9OX0lEIGZyYW1lcyAoU2VjdGlvbiAxOS4xNSkuIFRoZSBzZXF1ZW5jZSBudW1iZXIgb24gZWFjaCBuZXdseSBpc3N1ZWQgY29ubmVjdGlvbiBJRCBNVVNUIGluY3JlYXNlIGJ5IDEuIFRoZSBjb25uZWN0aW9uIElEIHRoYXQgYSBjbGllbnQgc2VsZWN0cyBmb3IgdGhlIGZpcnN0IERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgZmllbGQgaXQgc2VuZHMgYW5kIGFueSBjb25uZWN0aW9uIElEIHByb3ZpZGVkIGJ5IGEgUmV0cnkgcGFja2V0IGFyZSBub3QgYXNzaWduZWQgc2VxdWVuY2UgbnVtYmVycy4gV2hlbiBhbiBlbmRwb2ludCBpc3N1ZXMgYSBjb25uZWN0aW9uIElELCBpdCBNVVNUIGFjY2VwdCBwYWNrZXRzIHRoYXQgY2FycnkgdGhpcyBjb25uZWN0aW9uIElEIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGNvbm5lY3Rpb24gb3IgdW50aWwgaXRzIHBlZXIgaW52YWxpZGF0ZXMgdGhlIGNvbm5lY3Rpb24gSUQgdmlhIGEgUkVUSVJFX0NPTk5FQ1RJT05fSUQgZnJhbWUgKFNlY3Rpb24gMTkuMTYpLiBDb25uZWN0aW9uIElEcyB0aGF0IGFyZSBpc3N1ZWQgYW5kIG5vdCByZXRpcmVkIGFyZSBjb25zaWRlcmVkIGFjdGl2ZTsgYW55IGFjdGl2ZSBjb25uZWN0aW9uIElEIGlzIHZhbGlkIGZvciB1c2Ugd2l0aCB0aGUgY3VycmVudCBjb25uZWN0aW9uIGF0IGFueSB0aW1lLCBpbiBhbnkgcGFja2V0IHR5cGUuIFRoaXMgaW5jbHVkZXMgdGhlIGNvbm5lY3Rpb24gSUQgaXNzdWVkIGJ5IHRoZSBzZXJ2ZXIgdmlhIHRoZSBwcmVmZXJyZWRfYWRkcmVzcyB0cmFuc3BvcnQgcGFyYW1ldGVyLiBBbiBlbmRwb2ludCBTSE9VTEQgZW5zdXJlIHRoYXQgaXRzIHBlZXIgaGFzIGEgc3VmZmljaWVudCBudW1iZXIgb2YgYXZhaWxhYmxlIGFuZCB1bnVzZWQgY29ubmVjdGlvbiBJRHMuIEVuZHBvaW50cyBhZHZlcnRpc2UgdGhlIG51bWJlciBvZiBhY3RpdmUgY29ubmVjdGlvbiBJRHMgdGhleSBhcmUgd2lsbGluZyB0byBtYWludGFpbiB1c2luZyB0aGUgYWN0aXZlX2Nvbm5lY3Rpb25faWRfbGltaXQgdHJhbnNwb3J0IHBhcmFtZXRlci4gQW4gZW5kcG9pbnQgTVVTVCBOT1QgcHJvdmlkZSBtb3JlIGNvbm5lY3Rpb24gSURzIHRoYW4gdGhlIHBlZXIncyBsaW1pdC4gQW4gZW5kcG9pbnQgTUFZIHNlbmQgY29ubmVjdGlvbiBJRHMgdGhhdCB0ZW1wb3JhcmlseSBleGNlZWQgYSBwZWVyJ3MgbGltaXQgaWYgdGhlIE5FV19DT05ORUNUSU9OX0lEIGZyYW1lIGFsc28gcmVxdWlyZXMgdGhlIHJldGlyZW1lbnQgb2YgYW55IGV4Y2VzcywgYnkgaW5jbHVkaW5nIGEgc3VmZmljaWVudGx5IGxhcmdlIHZhbHVlIGluIHRoZSBSZXRpcmUgUHJpb3IgVG8gZmllbGQuIEEgTkVXX0NPTk5FQ1RJT05fSUQgZnJhbWUgbWlnaHQgY2F1c2UgYW4gZW5kcG9pbnQgdG8gYWRkIHNvbWUgYWN0aXZlIGNvbm5lY3Rpb24gSURzIGFuZCByZXRpcmUgb3RoZXJzIGJhc2VkIG9uIHRoZSB2YWx1ZSBvZiB0aGUgUmV0aXJlIFByaW9yIFRvIGZpZWxkLiBBZnRlciBwcm9jZXNzaW5nIGEgTkVXX0NPTk5FQ1RJT05fSUQgZnJhbWUgYW5kIGFkZGluZyBhbmQgcmV0aXJpbmcgYWN0aXZlIGNvbm5lY3Rpb24gSURzLCBpZiB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBjb25uZWN0aW9uIElEcyBleGNlZWRzIHRoZSB2YWx1ZSBhZHZlcnRpc2VkIGluIGl0cyBhY3RpdmVfY29ubmVjdGlvbl9pZF9saW1pdCB0cmFuc3BvcnQgcGFyYW1ldGVyLCBhbiBlbmRwb2ludCBNVVNUIGNsb3NlIHRoZSBjb25uZWN0aW9uIHdpdGggYW4gZXJyb3Igb2YgdHlwZSBDT05ORUNUSU9OX0lEX0xJTUlUX0VSUk9SLiBBbiBlbmRwb2ludCBTSE9VTEQgc3VwcGx5IGEgbmV3IGNvbm5lY3Rpb24gSUQgd2hlbiB0aGUgcGVlciByZXRpcmVzIGEgY29ubmVjdGlvbiBJRC4gSWYgYW4gZW5kcG9pbnQgcHJvdmlkZWQgZmV3ZXIgY29ubmVjdGlvbiBJRHMgdGhhbiB0aGUgcGVlcidzIGFjdGl2ZV9jb25uZWN0aW9uX2lkX2xpbWl0LCBpdCBNQVkgc3VwcGx5IGEgbmV3IGNvbm5lY3Rpb24gSUQgd2hlbiBpdCByZWNlaXZlcyBhIHBhY2tldCB3aXRoIGEgcHJldmlvdXNseSB1bnVzZWQgY29ubmVjdGlvbiBJRC4gQW4gZW5kcG9pbnQgTUFZIGxpbWl0IHRoZSB0b3RhbCBudW1iZXIgb2YgY29ubmVjdGlvbiBJRHMgaXNzdWVkIGZvciBlYWNoIGNvbm5lY3Rpb24gdG8gYXZvaWQgdGhlIHJpc2sgb2YgcnVubmluZyBvdXQgb2YgY29ubmVjdGlvbiBJRHM7IHNlZSBTZWN0aW9uIDEwLjMuMi4gQW4gZW5kcG9pbnQgTUFZIGFsc28gbGltaXQgdGhlIGlzc3VhbmNlIG9mIGNvbm5lY3Rpb24gSURzIHRvIHJlZHVjZSB0aGUgYW1vdW50IG9mIHBlci1wYXRoIHN0YXRlIGl0IG1haW50YWlucywgc3VjaCBhcyBwYXRoIHZhbGlkYXRpb24gc3RhdHVzLCBhcyBpdHMgcGVlciBtaWdodCBpbnRlcmFjdCB3aXRoIGl0IG92ZXIgYXMgbWFueSBwYXRocyBhcyB0aGVyZSBhcmUgaXNzdWVkIGNvbm5lY3Rpb24gSURzLiBBbiBlbmRwb2ludCB0aGF0IGluaXRpYXRlcyBtaWdyYXRpb24gYW5kIHJlcXVpcmVzIG5vbi16ZXJvLWxlbmd0aCBjb25uZWN0aW9uIElEcyBTSE9VTEQgZW5zdXJlIHRoYXQgdGhlIHBvb2wgb2YgY29ubmVjdGlvbiBJRHMgYXZhaWxhYmxlIHRvIGl0cyBwZWVyIGFsbG93cyB0aGUgcGVlciB0byB1c2UgYSBuZXcgY29ubmVjdGlvbiBJRCBvbiBtaWdyYXRpb24sIGFzIHRoZSBwZWVyIHdpbGwgYmUgdW5hYmxlIHRvIHJlc3BvbmQgaWYgdGhlIHBvb2wgaXMgZXhoYXVzdGVkLiBBbiBlbmRwb2ludCB0aGF0IHNlbGVjdHMgYSB6ZXJvLWxlbmd0aCBjb25uZWN0aW9uIElEIGR1cmluZyB0aGUgaGFuZHNoYWtlIGNhbm5vdCBpc3N1ZSBhIG5ldyBjb25uZWN0aW9uIElELiBBIHplcm8tbGVuZ3RoIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgZmllbGQgaXMgdXNlZCBpbiBhbGwgcGFja2V0cyBzZW50IHRvd2FyZCBzdWNoIGFuIGVuZHBvaW50IG92ZXIgYW55IG5ldHdvcmsgcGF0aC4gNS4xLjIuIENvbnN1bWluZyBhbmQgUmV0aXJpbmcgQ29ubmVjdGlvbiBJRHMgQW4gZW5kcG9pbnQgY2FuIGNoYW5nZSB0aGUgY29ubmVjdGlvbiBJRCBpdCB1c2VzIGZvciBhIHBlZXIgdG8gYW5vdGhlciBhdmFpbGFibGUgb25lIGF0IGFueSB0aW1lIGR1cmluZyB0aGUgY29ubmVjdGlvbi4gQW4gZW5kcG9pbnQgY29uc3VtZXMgY29ubmVjdGlvbiBJRHMgaW4gcmVzcG9uc2UgdG8gYSBtaWdyYXRpbmcgcGVlcjsgc2VlIFNlY3Rpb24gOS41IGZvciBtb3JlIGRldGFpbHMuIEFuIGVuZHBvaW50IG1haW50YWlucyBhIHNldCBvZiBjb25uZWN0aW9uIElEcyByZWNlaXZlZCBmcm9tIGl0cyBwZWVyLCBhbnkgb2Ygd2hpY2ggaXQgY2FuIHVzZSB3aGVuIHNlbmRpbmcgcGFja2V0cy4gV2hlbiB0aGUgZW5kcG9pbnQgd2lzaGVzIHRvIHJlbW92ZSBhIGNvbm5lY3Rpb24gSUQgZnJvbSB1c2UsIGl0IHNlbmRzIGEgUkVUSVJFX0NPTk5FQ1RJT05fSUQgZnJhbWUgdG8gaXRzIHBlZXIuIFNlbmRpbmcgYSBSRVRJUkVfQ09OTkVDVElPTl9JRCBmcmFtZSBpbmRpY2F0ZXMgdGhhdCB0aGUgY29ubmVjdGlvbiBJRCB3aWxsIG5vdCBiZSB1c2VkIGFnYWluIGFuZCByZXF1ZXN0cyB0aGF0IHRoZSBwZWVyIHJlcGxhY2UgaXQgd2l0aCBhIG5ldyBjb25uZWN0aW9uIElEIHVzaW5nIGEgTkVXX0NPTk5FQ1RJT05fSUQgZnJhbWUuIEFzIGRpc2N1c3NlZCBpbiBTZWN0aW9uIDkuNSwgZW5kcG9pbnRzIGxpbWl0IHRoZSB1c2Ugb2YgYSBjb25uZWN0aW9uIElEIHRvIHBhY2tldHMgc2VudCBmcm9tIGEgc2luZ2xlIGxvY2FsIGFkZHJlc3MgdG8gYSBzaW5nbGUgZGVzdGluYXRpb24gYWRkcmVzcy4gRW5kcG9pbnRzIFNIT1VMRCByZXRpcmUgY29ubmVjdGlvbiBJRHMgd2hlbiB0aGV5IGFyZSBubyBsb25nZXIgYWN0aXZlbHkgdXNpbmcgZWl0aGVyIHRoZSBsb2NhbCBvciBkZXN0aW5hdGlvbiBhZGRyZXNzIGZvciB3aGljaCB0aGUgY29ubmVjdGlvbiBJRCB3YXMgdXNlZC4gQW4gZW5kcG9pbnQgbWlnaHQgbmVlZCB0byBzdG9wIGFjY2VwdGluZyBwcmV2aW91c2x5IGlzc3VlZCBjb25uZWN0aW9uIElEcyBpbiBjZXJ0YWluIGNpcmN1bXN0YW5jZXMuIFN1Y2ggYW4gZW5kcG9pbnQgY2FuIGNhdXNlIGl0cyBwZWVyIHRvIHJldGlyZSBjb25uZWN0aW9uIElEcyBieSBzZW5kaW5nIGEgTkVXX0NPTk5FQ1RJT05fSUQgZnJhbWUgd2l0aCBhbiBpbmNyZWFzZWQgUmV0aXJlIFByaW9yIFRvIGZpZWxkLiBUaGUgZW5kcG9pbnQgU0hPVUxEIGNvbnRpbnVlIHRvIGFjY2VwdCB0aGUgcHJldmlvdXNseSBpc3N1ZWQgY29ubmVjdGlvbiBJRHMgdW50aWwgdGhleSBhcmUgcmV0aXJlZCBieSB0aGUgcGVlci4gSWYgdGhlIGVuZHBvaW50IGNhbiBubyBsb25nZXIgcHJvY2VzcyB0aGUgaW5kaWNhdGVkIGNvbm5lY3Rpb24gSURzLCBpdCBNQVkgY2xvc2UgdGhlIGNvbm5lY3Rpb24uIFVwb24gcmVjZWlwdCBvZiBhbiBpbmNyZWFzZWQgUmV0aXJlIFByaW9yIFRvIGZpZWxkLCB0aGUgcGVlciBNVVNUIHN0b3AgdXNpbmcgdGhlIGNvcnJlc3BvbmRpbmcgY29ubmVjdGlvbiBJRHMgYW5kIHJldGlyZSB0aGVtIHdpdGggUkVUSVJFX0NPTk5FQ1RJT05fSUQgZnJhbWVzIGJlZm9yZSBhZGRpbmcgdGhlIG5ld2x5IHByb3ZpZGVkIGNvbm5lY3Rpb24gSUQgdG8gdGhlIHNldCBvZiBhY3RpdmUgY29ubmVjdGlvbiBJRHMuIFRoaXMgb3JkZXJpbmcgYWxsb3dzIGFuIGVuZHBvaW50IHRvIHJlcGxhY2UgYWxsIGFjdGl2ZSBjb25uZWN0aW9uIElEcyB3aXRob3V0IHRoZSBwb3NzaWJpbGl0eSBvZiBhIHBlZXIgaGF2aW5nIG5vIGF2YWlsYWJsZSBjb25uZWN0aW9uIElEcyBhbmQgd2l0aG91dCBleGNlZWRpbmcgdGhlIGxpbWl0IHRoZSBwZWVyIHNldHMgaW4gdGhlIGFjdGl2ZV9jb25uZWN0aW9uX2lkX2xpbWl0IHRyYW5zcG9ydCBwYXJhbWV0ZXI7IHNlZSBTZWN0aW9uIDE4LjIuIEZhaWx1cmUgdG8gY2Vhc2UgdXNpbmcgdGhlIGNvbm5lY3Rpb24gSURzIHdoZW4gcmVxdWVzdGVkIGNhbiByZXN1bHQgaW4gY29ubmVjdGlvbiBmYWlsdXJlcywgYXMgdGhlIGlzc3VpbmcgZW5kcG9pbnQgbWlnaHQgYmUgdW5hYmxlIHRvIGNvbnRpbnVlIHVzaW5nIHRoZSBjb25uZWN0aW9uIElEcyB3aXRoIHRoZSBhY3RpdmUgY29ubmVjdGlvbi4gQW4gZW5kcG9pbnQgU0hPVUxEIGxpbWl0IHRoZSBudW1iZXIgb2YgY29ubmVjdGlvbiBJRHMgaXQgaGFzIHJldGlyZWQgbG9jYWxseSBmb3Igd2hpY2ggUkVUSVJFX0NPTk5FQ1RJT05fSUQgZnJhbWVzIGhhdmUgbm90IHlldCBiZWVuIGFja25vd2xlZGdlZC4gQW4gZW5kcG9pbnQgU0hPVUxEIGFsbG93IGZvciBzZW5kaW5nIGFuZCB0cmFja2luZyBhIG51bWJlciBvZiBSRVRJUkVfQ09OTkVDVElPTl9JRCBmcmFtZXMgb2YgYXQgbGVhc3QgdHdpY2UgdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmVfY29ubmVjdGlvbl9pZF9saW1pdCB0cmFuc3BvcnQgcGFyYW1ldGVyLiBBbiBlbmRwb2ludCBNVVNUIE5PVCBmb3JnZXQgYSBjb25uZWN0aW9uIElEIHdpdGhvdXQgcmV0aXJpbmcgaXQsIHRob3VnaCBpdCBNQVkgY2hvb3NlIHRvIHRyZWF0IGhhdmluZyBjb25uZWN0aW9uIElEcyBpbiBuZWVkIG9mIHJldGlyZW1lbnQgdGhhdCBleGNlZWQgdGhpcyBsaW1pdCBhcyBhIGNvbm5lY3Rpb24gZXJyb3Igb2YgdHlwZSBDT05ORUNUSU9OX0lEX0xJTUlUX0VSUk9SLiBFbmRwb2ludHMgU0hPVUxEIE5PVCBpc3N1ZSB1cGRhdGVzIG9mIHRoZSBSZXRpcmUgUHJpb3IgVG8gZmllbGQgYmVmb3JlIHJlY2VpdmluZyBSRVRJUkVfQ09OTkVDVElPTl9JRCBmcmFtZXMgdGhhdCByZXRpcmUgYWxsIGNvbm5lY3Rpb24gSURzIGluZGljYXRlZCBieSB0aGUgcHJldmlvdXMgUmV0aXJlIFByaW9yIFRvIHZhbHVlLiA1LjIuIE1hdGNoaW5nIFBhY2tldHMgdG8gQ29ubmVjdGlvbnMgSW5jb21pbmcgcGFja2V0cyBhcmUgY2xhc3NpZmllZCBvbiByZWNlaXB0LiBQYWNrZXRzIGNhbiBlaXRoZXIgYmUgYXNzb2NpYXRlZCB3aXRoIGFuIGV4aXN0aW5nIGNvbm5lY3Rpb24gb3IgLS0gZm9yIHNlcnZlcnMgLS0gcG90ZW50aWFsbHkgY3JlYXRlIGEgbmV3IGNvbm5lY3Rpb24uIEVuZHBvaW50cyB0cnkgdG8gYXNzb2NpYXRlIGEgcGFja2V0IHdpdGggYW4gZXhpc3RpbmcgY29ubmVjdGlvbi4gSWYgdGhlIHBhY2tldCBoYXMgYSBub24temVyby1sZW5ndGggRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBjb3JyZXNwb25kaW5nIHRvIGFuIGV4aXN0aW5nIGNvbm5lY3Rpb24sIFFVSUMgcHJvY2Vzc2VzIHRoYXQgcGFja2V0IGFjY29yZGluZ2x5LiBOb3RlIHRoYXQgbW9yZSB0aGFuIG9uZSBjb25uZWN0aW9uIElEIGNhbiBiZSBhc3NvY2lhdGVkIHdpdGggYSBjb25uZWN0aW9uOyBzZWUgU2VjdGlvbiA1LjEuIElmIHRoZSBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEIGlzIHplcm8gbGVuZ3RoIGFuZCB0aGUgYWRkcmVzc2luZyBpbmZvcm1hdGlvbiBpbiB0aGUgcGFja2V0IG1hdGNoZXMgdGhlIGFkZHJlc3NpbmcgaW5mb3JtYXRpb24gdGhlIGVuZHBvaW50IHVzZXMgdG8gaWRlbnRpZnkgYSBjb25uZWN0aW9uIHdpdGggYSB6ZXJvLWxlbmd0aCBjb25uZWN0aW9uIElELCBRVUlDIHByb2Nlc3NlcyB0aGUgcGFja2V0IGFzIHBhcnQgb2YgdGhhdCBjb25uZWN0aW9uLiBBbiBlbmRwb2ludCBjYW4gdXNlIGp1c3QgZGVzdGluYXRpb24gSVAgYW5kIHBvcnQgb3IgYm90aCBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGFkZHJlc3NlcyBmb3IgaWRlbnRpZmljYXRpb24sIHRob3VnaCB0aGlzIG1ha2VzIGNvbm5lY3Rpb25zIGZyYWdpbGUgYXMgZGVzY3JpYmVkIGluIFNlY3Rpb24gNS4xLiBFbmRwb2ludHMgY2FuIHNlbmQgYSBTdGF0ZWxlc3MgUmVzZXQgKFNlY3Rpb24gMTAuMykgZm9yIGFueSBwYWNrZXRzIHRoYXQgY2Fubm90IGJlIGF0dHJpYnV0ZWQgdG8gYW4gZXhpc3RpbmcgY29ubmVjdGlvbi4gQSBTdGF0ZWxlc3MgUmVzZXQgYWxsb3dzIGEgcGVlciB0byBtb3JlIHF1aWNrbHkgaWRlbnRpZnkgd2hlbiBhIGNvbm5lY3Rpb24gYmVjb21lcyB1bnVzYWJsZS4gUGFja2V0cyB0aGF0IGFyZSBtYXRjaGVkIHRvIGFuIGV4aXN0aW5nIGNvbm5lY3Rpb24gYXJlIGRpc2NhcmRlZCBpZiB0aGUgcGFja2V0cyBhcmUgaW5jb25zaXN0ZW50IHdpdGggdGhlIHN0YXRlIG9mIHRoYXQgY29ubmVjdGlvbi4gRm9yIGV4YW1wbGUsIHBhY2tldHMgYXJlIGRpc2NhcmRlZCBpZiB0aGV5IGluZGljYXRlIGEgZGlmZmVyZW50IHByb3RvY29sIHZlcnNpb24gdGhhbiB0aGF0IG9mIHRoZSBjb25uZWN0aW9uIG9yIGlmIHRoZSByZW1vdmFsIG9mIHBhY2tldCBwcm90ZWN0aW9uIGlzIHVuc3VjY2Vzc2Z1bCBvbmNlIHRoZSBleHBlY3RlZCBrZXlzIGFyZSBhdmFpbGFibGUuIEludmFsaWQgcGFja2V0cyB0aGF0IGxhY2sgc3Ryb25nIGludGVncml0eSBwcm90ZWN0aW9uLCBzdWNoIGFzIEluaXRpYWwsIFJldHJ5LCBvciBWZXJzaW9uIE5lZ290aWF0aW9uLCBNQVkgYmUgZGlzY2FyZGVkLiBBbiBlbmRwb2ludCBNVVNUIGdlbmVyYXRlIGEgY29ubmVjdGlvbiBlcnJvciBpZiBwcm9jZXNzaW5nIHRoZSBjb250ZW50cyBvZiB0aGVzZSBwYWNrZXRzIHByaW9yIHRvIGRpc2NvdmVyaW5nIGFuIGVycm9yLCBvciBmdWxseSByZXZlcnQgYW55IGNoYW5nZXMgbWFkZSBkdXJpbmcgdGhhdCBwcm9jZXNzaW5nLiA1LjIuMS4gQ2xpZW50IFBhY2tldCBIYW5kbGluZyBWYWxpZCBwYWNrZXRzIHNlbnQgdG8gY2xpZW50cyBhbHdheXMgaW5jbHVkZSBhIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgdGhhdCBtYXRjaGVzIGEgdmFsdWUgdGhlIGNsaWVudCBzZWxlY3RzLiBDbGllbnRzIHRoYXQgY2hvb3NlIHRvIHJlY2VpdmUgemVyby1sZW5ndGggY29ubmVjdGlvbiBJRHMgY2FuIHVzZSB0aGUgbG9jYWwgYWRkcmVzcyBhbmQgcG9ydCB0byBpZGVudGlmeSBhIGNvbm5lY3Rpb24uIFBhY2tldHMgdGhhdCBkbyBub3QgbWF0Y2ggYW4gZXhpc3RpbmcgY29ubmVjdGlvbiAtLSBiYXNlZCBvbiBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEIG9yLCBpZiB0aGlzIHZhbHVlIGlzIHplcm8gbGVuZ3RoLCBsb2NhbCBJUCBhZGRyZXNzIGFuZCBwb3J0IC0tIGFyZSBkaXNjYXJkZWQuIER1ZSB0byBwYWNrZXQgcmVvcmRlcmluZyBvciBsb3NzLCBhIGNsaWVudCBtaWdodCByZWNlaXZlIHBhY2tldHMgZm9yIGEgY29ubmVjdGlvbiB0aGF0IGFyZSBlbmNyeXB0ZWQgd2l0aCBhIGtleSBpdCBoYXMgbm90IHlldCBjb21wdXRlZC4gVGhlIGNsaWVudCBNQVkgZHJvcCB0aGVzZSBwYWNrZXRzLCBvciBpdCBNQVkgYnVmZmVyIHRoZW0gaW4gYW50aWNpcGF0aW9uIG9mIGxhdGVyIHBhY2tldHMgdGhhdCBhbGxvdyBpdCB0byBjb21wdXRlIHRoZSBrZXkuIElmIGEgY2xpZW50IHJlY2VpdmVzIGEgcGFja2V0IHRoYXQgdXNlcyBhIGRpZmZlcmVudCB2ZXJzaW9uIHRoYW4gaXQgaW5pdGlhbGx5IHNlbGVjdGVkLCBpdCBNVVNUIGRpc2NhcmQgdGhhdCBwYWNrZXQuIDUuMi4yLiBTZXJ2ZXIgUGFja2V0IEhhbmRsaW5nIElmIGEgc2VydmVyIHJlY2VpdmVzIGEgcGFja2V0IHRoYXQgaW5kaWNhdGVzIGFuIHVuc3VwcG9ydGVkIHZlcnNpb24gYW5kIGlmIHRoZSBwYWNrZXQgaXMgbGFyZ2UgZW5vdWdoIHRvIGluaXRpYXRlIGEgbmV3IGNvbm5lY3Rpb24gZm9yIGFueSBzdXBwb3J0ZWQgdmVyc2lvbiwgdGhlIHNlcnZlciBTSE9VTEQgc2VuZCBhIFZlcnNpb24gTmVnb3RpYXRpb24gcGFja2V0IGFzIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDYuMS4gQSBzZXJ2ZXIgTUFZIGxpbWl0IHRoZSBudW1iZXIgb2YgcGFja2V0cyB0byB3aGljaCBpdCByZXNwb25kcyB3aXRoIGEgVmVyc2lvbiBOZWdvdGlhdGlvbiBwYWNrZXQuIFNlcnZlcnMgTVVTVCBkcm9wIHNtYWxsZXIgcGFja2V0cyB0aGF0IHNwZWNpZnkgdW5zdXBwb3J0ZWQgdmVyc2lvbnMuIFRoZSBmaXJzdCBwYWNrZXQgZm9yIGFuIHVuc3VwcG9ydGVkIHZlcnNpb24gY2FuIHVzZSBkaWZmZXJlbnQgc2VtYW50aWNzIGFuZCBlbmNvZGluZ3MgZm9yIGFueSB2ZXJzaW9uLXNwZWNpZmljIGZpZWxkLiBJbiBwYXJ0aWN1bGFyLCBkaWZmZXJlbnQgcGFja2V0IHByb3RlY3Rpb24ga2V5cyBtaWdodCBiZSB1c2VkIGZvciBkaWZmZXJlbnQgdmVyc2lvbnMuIFNlcnZlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBhIHBhcnRpY3VsYXIgdmVyc2lvbiBhcmUgdW5saWtlbHkgdG8gYmUgYWJsZSB0byBkZWNyeXB0IHRoZSBwYXlsb2FkIG9mIHRoZSBwYWNrZXQgb3IgcHJvcGVybHkgaW50ZXJwcmV0IHRoZSByZXN1bHQuIFNlcnZlcnMgU0hPVUxEIHJlc3BvbmQgd2l0aCBhIFZlcnNpb24gTmVnb3RpYXRpb24gcGFja2V0LCBwcm92aWRlZCB0aGF0IHRoZSBkYXRhZ3JhbSBpcyBzdWZmaWNpZW50bHkgbG9uZy4gUGFja2V0cyB3aXRoIGEgc3VwcG9ydGVkIHZlcnNpb24sIG9yIG5vIFZlcnNpb24gZmllbGQsIGFyZSBtYXRjaGVkIHRvIGEgY29ubmVjdGlvbiB1c2luZyB0aGUgY29ubmVjdGlvbiBJRCBvciAtLSBmb3IgcGFja2V0cyB3aXRoIHplcm8tIGxlbmd0aCBjb25uZWN0aW9uIElEcyAtLSB0aGUgbG9jYWwgYWRkcmVzcyBhbmQgcG9ydC4gVGhlc2UgcGFja2V0cyBhcmUgcHJvY2Vzc2VkIHVzaW5nIHRoZSBzZWxlY3RlZCBjb25uZWN0aW9uOyBvdGhlcndpc2UsIHRoZSBzZXJ2ZXIgY29udGludWVzIGFzIGRlc2NyaWJlZCBiZWxvdy4gSWYgdGhlIHBhY2tldCBpcyBhbiBJbml0aWFsIHBhY2tldCBmdWxseSBjb25mb3JtaW5nIHdpdGggdGhlIHNwZWNpZmljYXRpb24sIHRoZSBzZXJ2ZXIgcHJvY2VlZHMgd2l0aCB0aGUgaGFuZHNoYWtlIChTZWN0aW9uIDcpLiBUaGlzIGNvbW1pdHMgdGhlIHNlcnZlciB0byB0aGUgdmVyc2lvbiB0aGF0IHRoZSBjbGllbnQgc2VsZWN0ZWQuIElmIGEgc2VydmVyIHJlZnVzZXMgdG8gYWNjZXB0IGEgbmV3IGNvbm5lY3Rpb24sIGl0IFNIT1VMRCBzZW5kIGFuIEluaXRpYWwgcGFja2V0IGNvbnRhaW5pbmcgYSBDT05ORUNUSU9OX0NMT1NFIGZyYW1lIHdpdGggZXJyb3IgY29kZSBDT05ORUNUSU9OX1JFRlVTRUQuIElmIHRoZSBwYWNrZXQgaXMgYSAwLVJUVCBwYWNrZXQsIHRoZSBzZXJ2ZXIgTUFZIGJ1ZmZlciBhIGxpbWl0ZWQgbnVtYmVyIG9mIHRoZXNlIHBhY2tldHMgaW4gYW50aWNpcGF0aW9uIG9mIGEgbGF0ZS1hcnJpdmluZyBJbml0aWFsIHBhY2tldC4gQ2xpZW50cyBhcmUgbm90IGFibGUgdG8gc2VuZCBIYW5kc2hha2UgcGFja2V0cyBwcmlvciB0byByZWNlaXZpbmcgYSBzZXJ2ZXIgcmVzcG9uc2UsIHNvIHNlcnZlcnMgU0hPVUxEIGlnbm9yZSBhbnkgc3VjaCBwYWNrZXRzLiBTZXJ2ZXJzIE1VU1QgZHJvcCBpbmNvbWluZyBwYWNrZXRzIHVuZGVyIGFsbCBvdGhlciBjaXJjdW1zdGFuY2VzLiA1LjIuMy4gQ29uc2lkZXJhdGlvbnMgZm9yIFNpbXBsZSBMb2FkIEJhbGFuY2VycyBBIHNlcnZlciBkZXBsb3ltZW50IGNvdWxkIGxvYWQtYmFsYW5jZSBhbW9uZyBzZXJ2ZXJzIHVzaW5nIG9ubHkgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBJUCBhZGRyZXNzZXMgYW5kIHBvcnRzLiBDaGFuZ2VzIHRvIHRoZSBjbGllbnQncyBJUCBhZGRyZXNzIG9yIHBvcnQgY291bGQgcmVzdWx0IGluIHBhY2tldHMgYmVpbmcgZm9yd2FyZGVkIHRvIHRoZSB3cm9uZyBzZXJ2ZXIuIFN1Y2ggYSBzZXJ2ZXIgZGVwbG95bWVudCBjb3VsZCB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmcgbWV0aG9kcyBmb3IgY29ubmVjdGlvbiBjb250aW51aXR5IHdoZW4gYSBjbGllbnQncyBhZGRyZXNzIGNoYW5nZXMuICogU2VydmVycyBjb3VsZCB1c2UgYW4gb3V0LW9mLWJhbmQgbWVjaGFuaXNtIHRvIGZvcndhcmQgcGFja2V0cyB0byB0aGUgY29ycmVjdCBzZXJ2ZXIgYmFzZWQgb24gY29ubmVjdGlvbiBJRC4gKiBJZiBzZXJ2ZXJzIGNhbiB1c2UgYSBkZWRpY2F0ZWQgc2VydmVyIElQIGFkZHJlc3Mgb3IgcG9ydCwgb3RoZXIgdGhhbiB0aGUgb25lIHRoYXQgdGhlIGNsaWVudCBpbml0aWFsbHkgY29ubmVjdHMgdG8sIHRoZXkgY291bGQgdXNlIHRoZSBwcmVmZXJyZWRfYWRkcmVzcyB0cmFuc3BvcnQgcGFyYW1ldGVyIHRvIHJlcXVlc3QgdGhhdCBjbGllbnRzIG1vdmUgY29ubmVjdGlvbnMgdG8gdGhhdCBkZWRpY2F0ZWQgYWRkcmVzcy4gTm90ZSB0aGF0IGNsaWVudHMgY291bGQgY2hvb3NlIG5vdCB0byB1c2UgdGhlIHByZWZlcnJlZCBhZGRyZXNzLiBBIHNlcnZlciBpbiBhIGRlcGxveW1lbnQgdGhhdCBkb2VzIG5vdCBpbXBsZW1lbnQgYSBzb2x1dGlvbiB0byBtYWludGFpbiBjb25uZWN0aW9uIGNvbnRpbnVpdHkgd2hlbiB0aGUgY2xpZW50IGFkZHJlc3MgY2hhbmdlcyBTSE9VTEQgaW5kaWNhdGUgdGhhdCBtaWdyYXRpb24gaXMgbm90IHN1cHBvcnRlZCBieSB1c2luZyB0aGUgZGlzYWJsZV9hY3RpdmVfbWlncmF0aW9uIHRyYW5zcG9ydCBwYXJhbWV0ZXIuIFRoZSBkaXNhYmxlX2FjdGl2ZV9taWdyYXRpb24gdHJhbnNwb3J0IHBhcmFtZXRlciBkb2VzIG5vdCBwcm9oaWJpdCBjb25uZWN0aW9uIG1pZ3JhdGlvbiBhZnRlciBhIGNsaWVudCBoYXMgYWN0ZWQgb24gYSBwcmVmZXJyZWRfYWRkcmVzcyB0cmFuc3BvcnQgcGFyYW1ldGVyLiBTZXJ2ZXIgZGVwbG95bWVudHMgdGhhdCB1c2UgdGhpcyBzaW1wbGUgZm9ybSBvZiBsb2FkIGJhbGFuY2luZyBNVVNUIGF2b2lkIHRoZSBjcmVhdGlvbiBvZiBhIHN0YXRlbGVzcyByZXNldCBvcmFjbGU7IHNlZSBTZWN0aW9uIDIxLjExLiA1LjMuIE9wZXJhdGlvbnMgb24gQ29ubmVjdGlvbnMgVGhpcyBkb2N1bWVudCBkb2VzIG5vdCBkZWZpbmUgYW4gQVBJIGZvciBRVUlDOyBpdCBpbnN0ZWFkIGRlZmluZXMgYSBzZXQgb2YgZnVuY3Rpb25zIGZvciBRVUlDIGNvbm5lY3Rpb25zIHRoYXQgYXBwbGljYXRpb24gcHJvdG9jb2xzIGNhbiByZWx5IHVwb24uIEFuIGFwcGxpY2F0aW9uIHByb3RvY29sIGNhbiBhc3N1bWUgdGhhdCBhbiBpbXBsZW1lbnRhdGlvbiBvZiBRVUlDIHByb3ZpZGVzIGFuIGludGVyZmFjZSB0aGF0IGluY2x1ZGVzIHRoZSBvcGVyYXRpb25zIGRlc2NyaWJlZCBpbiB0aGlzIHNlY3Rpb24uIEFuIGltcGxlbWVudGF0aW9uIGRlc2lnbmVkIGZvciB1c2Ugd2l0aCBhIHNwZWNpZmljIGFwcGxpY2F0aW9uIHByb3RvY29sIG1pZ2h0IHByb3ZpZGUgb25seSB0aG9zZSBvcGVyYXRpb25zIHRoYXQgYXJlIHVzZWQgYnkgdGhhdCBwcm90b2NvbC4gV2hlbiBpbXBsZW1lbnRpbmcgdGhlIGNsaWVudCByb2xlLCBhbiBhcHBsaWNhdGlvbiBwcm90b2NvbCBjYW46ICogb3BlbiBhIGNvbm5lY3Rpb24sIHdoaWNoIGJlZ2lucyB0aGUgZXhjaGFuZ2UgZGVzY3JpYmVkIGluIFNlY3Rpb24gNzsgKiBlbmFibGUgRWFybHkgRGF0YSB3aGVuIGF2YWlsYWJsZTsgYW5kICogYmUgaW5mb3JtZWQgd2hlbiBFYXJseSBEYXRhIGhhcyBiZWVuIGFjY2VwdGVkIG9yIHJlamVjdGVkIGJ5IGEgc2VydmVyLiBXaGVuIGltcGxlbWVudGluZyB0aGUgc2VydmVyIHJvbGUsIGFuIGFwcGxpY2F0aW9uIHByb3RvY29sIGNhbjogKiBsaXN0ZW4gZm9yIGluY29taW5nIGNvbm5lY3Rpb25zLCB3aGljaCBwcmVwYXJlcyBmb3IgdGhlIGV4Y2hhbmdlIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDc7ICogaWYgRWFybHkgRGF0YSBpcyBzdXBwb3J0ZWQsIGVtYmVkIGFwcGxpY2F0aW9uLWNvbnRyb2xsZWQgZGF0YSBpbiB0aGUgVExTIHJlc3VtcHRpb24gdGlja2V0IHNlbnQgdG8gdGhlIGNsaWVudDsgYW5kICogaWYgRWFybHkgRGF0YSBpcyBzdXBwb3J0ZWQsIHJldHJpZXZlIGFwcGxpY2F0aW9uLWNvbnRyb2xsZWQgZGF0YSBmcm9tIHRoZSBjbGllbnQncyByZXN1bXB0aW9uIHRpY2tldCBhbmQgYWNjZXB0IG9yIHJlamVjdCBFYXJseSBEYXRhIGJhc2VkIG9uIHRoYXQgaW5mb3JtYXRpb24uIEluIGVpdGhlciByb2xlLCBhbiBhcHBsaWNhdGlvbiBwcm90b2NvbCBjYW46ICogY29uZmlndXJlIG1pbmltdW0gdmFsdWVzIGZvciB0aGUgaW5pdGlhbCBudW1iZXIgb2YgcGVybWl0dGVkIHN0cmVhbXMgb2YgZWFjaCB0eXBlLCBhcyBjb21tdW5pY2F0ZWQgaW4gdGhlIHRyYW5zcG9ydCBwYXJhbWV0ZXJzIChTZWN0aW9uIDcuNCk7ICogY29udHJvbCByZXNvdXJjZSBhbGxvY2F0aW9uIGZvciByZWNlaXZlIGJ1ZmZlcnMgYnkgc2V0dGluZyBmbG93IGNvbnRyb2wgbGltaXRzIGJvdGggZm9yIHN0cmVhbXMgYW5kIGZvciB0aGUgY29ubmVjdGlvbjsgKiBpZGVudGlmeSB3aGV0aGVyIHRoZSBoYW5kc2hha2UgaGFzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkgb3IgaXMgc3RpbGwgb25nb2luZzsgKiBrZWVwIGEgY29ubmVjdGlvbiBmcm9tIHNpbGVudGx5IGNsb3NpbmcsIGJ5IGVpdGhlciBnZW5lcmF0aW5nIFBJTkcgZnJhbWVzIChTZWN0aW9uIDE5LjIpIG9yIHJlcXVlc3RpbmcgdGhhdCB0aGUgdHJhbnNwb3J0IHNlbmQgYWRkaXRpb25hbCBmcmFtZXMgYmVmb3JlIHRoZSBpZGxlIHRpbWVvdXQgZXhwaXJlcyAoU2VjdGlvbiAxMC4xKTsgYW5kICogaW1tZWRpYXRlbHkgY2xvc2UgKFNlY3Rpb24gMTAuMikgdGhlIGNvbm5lY3Rpb24uIDYuIFZlcnNpb24gTmVnb3RpYXRpb24gVmVyc2lvbiBuZWdvdGlhdGlvbiBhbGxvd3MgYSBzZXJ2ZXIgdG8gaW5kaWNhdGUgdGhhdCBpdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSB2ZXJzaW9uIHRoZSBjbGllbnQgdXNlZC4gQSBzZXJ2ZXIgc2VuZHMgYSBWZXJzaW9uIE5lZ290aWF0aW9uIHBhY2tldCBpbiByZXNwb25zZSB0byBlYWNoIHBhY2tldCB0aGF0IG1pZ2h0IGluaXRpYXRlIGEgbmV3IGNvbm5lY3Rpb247IHNlZSBTZWN0aW9uIDUuMiBmb3IgZGV0YWlscy4gVGhlIHNpemUgb2YgdGhlIGZpcnN0IHBhY2tldCBzZW50IGJ5IGEgY2xpZW50IHdpbGwgZGV0ZXJtaW5lIHdoZXRoZXIgYSBzZXJ2ZXIgc2VuZHMgYSBWZXJzaW9uIE5lZ290aWF0aW9uIHBhY2tldC4gQ2xpZW50cyB0aGF0IHN1cHBvcnQgbXVsdGlwbGUgUVVJQyB2ZXJzaW9ucyBTSE9VTEQgZW5zdXJlIHRoYXQgdGhlIGZpcnN0IFVEUCBkYXRhZ3JhbSB0aGV5IHNlbmQgaXMgc2l6ZWQgdG8gdGhlIGxhcmdlc3Qgb2YgdGhlIG1pbmltdW0gZGF0YWdyYW0gc2l6ZXMgZnJvbSBhbGwgdmVyc2lvbnMgdGhleSBzdXBwb3J0LCB1c2luZyBQQURESU5HIGZyYW1lcyAoU2VjdGlvbiAxOS4xKSBhcyBuZWNlc3NhcnkuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBzZXJ2ZXIgcmVzcG9uZHMgaWYgdGhlcmUgaXMgYSBtdXR1YWxseSBzdXBwb3J0ZWQgdmVyc2lvbi4gQSBzZXJ2ZXIgbWlnaHQgbm90IHNlbmQgYSBWZXJzaW9uIE5lZ290aWF0aW9uIHBhY2tldCBpZiB0aGUgZGF0YWdyYW0gaXQgcmVjZWl2ZXMgaXMgc21hbGxlciB0aGFuIHRoZSBtaW5pbXVtIHNpemUgc3BlY2lmaWVkIGluIGEgZGlmZmVyZW50IHZlcnNpb247IHNlZSBTZWN0aW9uIDE0LjEuIDYuMS4gU2VuZGluZyBWZXJzaW9uIE5lZ290aWF0aW9uIFBhY2tldHMgSWYgdGhlIHZlcnNpb24gc2VsZWN0ZWQgYnkgdGhlIGNsaWVudCBpcyBub3QgYWNjZXB0YWJsZSB0byB0aGUgc2VydmVyLCB0aGUgc2VydmVyIHJlc3BvbmRzIHdpdGggYSBWZXJzaW9uIE5lZ290aWF0aW9uIHBhY2tldDsgc2VlIFNlY3Rpb24gMTcuMi4xLiBUaGlzIGluY2x1ZGVzIGEgbGlzdCBvZiB2ZXJzaW9ucyB0aGF0IHRoZSBzZXJ2ZXIgd2lsbCBhY2NlcHQuIEFuIGVuZHBvaW50IE1VU1QgTk9UIHNlbmQgYSBWZXJzaW9uIE5lZ290aWF0aW9uIHBhY2tldCBpbiByZXNwb25zZSB0byByZWNlaXZpbmcgYSBWZXJzaW9uIE5lZ290aWF0aW9uIHBhY2tldC4gVGhpcyBzeXN0ZW0gYWxsb3dzIGEgc2VydmVyIHRvIHByb2Nlc3MgcGFja2V0cyB3aXRoIHVuc3VwcG9ydGVkIHZlcnNpb25zIHdpdGhvdXQgcmV0YWluaW5nIHN0YXRlLiBUaG91Z2ggZWl0aGVyIHRoZSBJbml0aWFsIHBhY2tldCBvciB0aGUgVmVyc2lvbiBOZWdvdGlhdGlvbiBwYWNrZXQgdGhhdCBpcyBzZW50IGluIHJlc3BvbnNlIGNvdWxkIGJlIGxvc3QsIHRoZSBjbGllbnQgd2lsbCBzZW5kIG5ldyBwYWNrZXRzIHVudGlsIGl0IHN1Y2Nlc3NmdWxseSByZWNlaXZlcyBhIHJlc3BvbnNlIG9yIGl0IGFiYW5kb25zIHRoZSBjb25uZWN0aW9uIGF0dGVtcHQuIEEgc2VydmVyIE1BWSBsaW1pdCB0aGUgbnVtYmVyIG9mIFZlcnNpb24gTmVnb3RpYXRpb24gcGFja2V0cyBpdCBzZW5kcy4gRm9yIGluc3RhbmNlLCBhIHNlcnZlciB0aGF0IGlzIGFibGUgdG8gcmVjb2duaXplIHBhY2tldHMgYXMgMC1SVFQgbWlnaHQgY2hvb3NlIG5vdCB0byBzZW5kIFZlcnNpb24gTmVnb3RpYXRpb24gcGFja2V0cyBpbiByZXNwb25zZSB0byAwLVJUVCBwYWNrZXRzIHdpdGggdGhlIGV4cGVjdGF0aW9uIHRoYXQgaXQgd2lsbCBldmVudHVhbGx5IHJlY2VpdmUgYW4gSW5pdGlhbCBwYWNrZXQuIDYuMi4gSGFuZGxpbmcgVmVyc2lvbiBOZWdvdGlhdGlvbiBQYWNrZXRzIFZlcnNpb24gTmVnb3RpYXRpb24gcGFja2V0cyBhcmUgZGVzaWduZWQgdG8gYWxsb3cgZm9yIGZ1bmN0aW9uYWxpdHkgdG8gYmUgZGVmaW5lZCBpbiB0aGUgZnV0dXJlIHRoYXQgYWxsb3dzIFFVSUMgdG8gbmVnb3RpYXRlIHRoZSB2ZXJzaW9uIG9mIFFVSUMgdG8gdXNlIGZvciBhIGNvbm5lY3Rpb24uIEZ1dHVyZSBTdGFuZGFyZHMgVHJhY2sgc3BlY2lmaWNhdGlvbnMgbWlnaHQgY2hhbmdlIGhvdyBpbXBsZW1lbnRhdGlvbnMgdGhhdCBzdXBwb3J0IG11bHRpcGxlIHZlcnNpb25zIG9mIFFVSUMgcmVhY3QgdG8gVmVyc2lvbiBOZWdvdGlhdGlvbiBwYWNrZXRzIHJlY2VpdmVkIGluIHJlc3BvbnNlIHRvIGFuIGF0dGVtcHQgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB1c2luZyB0aGlzIHZlcnNpb24uIEEgY2xpZW50IHRoYXQgc3VwcG9ydHMgb25seSB0aGlzIHZlcnNpb24gb2YgUVVJQyBNVVNUIGFiYW5kb24gdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBhdHRlbXB0IGlmIGl0IHJlY2VpdmVzIGEgVmVyc2lvbiBOZWdvdGlhdGlvbiBwYWNrZXQsIHdpdGggdGhlIGZvbGxvd2luZyB0d28gZXhjZXB0aW9ucy4gQSBjbGllbnQgTVVTVCBkaXNjYXJkIGFueSBWZXJzaW9uIE5lZ290aWF0aW9uIHBhY2tldCBpZiBpdCBoYXMgcmVjZWl2ZWQgYW5kIHN1Y2Nlc3NmdWxseSBwcm9jZXNzZWQgYW55IG90aGVyIHBhY2tldCwgaW5jbHVkaW5nIGFuIGVhcmxpZXIgVmVyc2lvbiBOZWdvdGlhdGlvbiBwYWNrZXQuIEEgY2xpZW50IE1VU1QgZGlzY2FyZCBhIFZlcnNpb24gTmVnb3RpYXRpb24gcGFja2V0IHRoYXQgbGlzdHMgdGhlIFFVSUMgdmVyc2lvbiBzZWxlY3RlZCBieSB0aGUgY2xpZW50LiBIb3cgdG8gcGVyZm9ybSB2ZXJzaW9uIG5lZ290aWF0aW9uIGlzIGxlZnQgYXMgZnV0dXJlIHdvcmsgZGVmaW5lZCBieSBmdXR1cmUgU3RhbmRhcmRzIFRyYWNrIHNwZWNpZmljYXRpb25zLiBJbiBwYXJ0aWN1bGFyLCB0aGF0IGZ1dHVyZSB3b3JrIHdpbGwgZW5zdXJlIHJvYnVzdG5lc3MgYWdhaW5zdCB2ZXJzaW9uIGRvd25ncmFkZSBhdHRhY2tzOyBzZWUgU2VjdGlvbiAyMS4xMi4gNi4zLiBVc2luZyBSZXNlcnZlZCBWZXJzaW9ucyBGb3IgYSBzZXJ2ZXIgdG8gdXNlIGEgbmV3IHZlcnNpb24gaW4gdGhlIGZ1dHVyZSwgY2xpZW50cyBuZWVkIHRvIGNvcnJlY3RseSBoYW5kbGUgdW5zdXBwb3J0ZWQgdmVyc2lvbnMuIFNvbWUgdmVyc2lvbiBudW1iZXJzICgweD9hP2E/YT9hLCBhcyBkZWZpbmVkIGluIFNlY3Rpb24gMTUpIGFyZSByZXNlcnZlZCBmb3IgaW5jbHVzaW9uIGluIGZpZWxkcyB0aGF0IGNvbnRhaW4gdmVyc2lvbiBudW1iZXJzLiBFbmRwb2ludHMgTUFZIGFkZCByZXNlcnZlZCB2ZXJzaW9ucyB0byBhbnkgZmllbGQgd2hlcmUgdW5rbm93biBvciB1bnN1cHBvcnRlZCB2ZXJzaW9ucyBhcmUgaWdub3JlZCB0byB0ZXN0IHRoYXQgYSBwZWVyIGNvcnJlY3RseSBpZ25vcmVzIHRoZSB2YWx1ZS4gRm9yIGluc3RhbmNlLCBhbiBlbmRwb2ludCBjb3VsZCBpbmNsdWRlIGEgcmVzZXJ2ZWQgdmVyc2lvbiBpbiBhIFZlcnNpb24gTmVnb3RpYXRpb24gcGFja2V0OyBzZWUgU2VjdGlvbiAxNy4yLjEuIEVuZHBvaW50cyBNQVkgc2VuZCBwYWNrZXRzIHdpdGggYSByZXNlcnZlZCB2ZXJzaW9uIHRvIHRlc3QgdGhhdCBhIHBlZXIgY29ycmVjdGx5IGRpc2NhcmRzIHRoZSBwYWNrZXQuIDcuIENyeXB0b2dyYXBoaWMgYW5kIFRyYW5zcG9ydCBIYW5kc2hha2UgUVVJQyByZWxpZXMgb24gYSBjb21iaW5lZCBjcnlwdG9ncmFwaGljIGFuZCB0cmFuc3BvcnQgaGFuZHNoYWtlIHRvIG1pbmltaXplIGNvbm5lY3Rpb24gZXN0YWJsaXNobWVudCBsYXRlbmN5LiBRVUlDIHVzZXMgdGhlIENSWVBUTyBmcmFtZSAoU2VjdGlvbiAxOS42KSB0byB0cmFuc21pdCB0aGUgY3J5cHRvZ3JhcGhpYyBoYW5kc2hha2UuIFRoZSB2ZXJzaW9uIG9mIFFVSUMgZGVmaW5lZCBpbiB0aGlzIGRvY3VtZW50IGlzIGlkZW50aWZpZWQgYXMgMHgwMDAwMDAwMSBhbmQgdXNlcyBUTFMgYXMgZGVzY3JpYmVkIGluIFtRVUlDLVRMU107IGEgZGlmZmVyZW50IFFVSUMgdmVyc2lvbiBjb3VsZCBpbmRpY2F0ZSB0aGF0IGEgZGlmZmVyZW50IGNyeXB0b2dyYXBoaWMgaGFuZHNoYWtlIHByb3RvY29sIGlzIGluIHVzZS4gUVVJQyBwcm92aWRlcyByZWxpYWJsZSwgb3JkZXJlZCBkZWxpdmVyeSBvZiB0aGUgY3J5cHRvZ3JhcGhpYyBoYW5kc2hha2UgZGF0YS4gUVVJQyBwYWNrZXQgcHJvdGVjdGlvbiBpcyB1c2VkIHRvIGVuY3J5cHQgYXMgbXVjaCBvZiB0aGUgaGFuZHNoYWtlIHByb3RvY29sIGFzIHBvc3NpYmxlLiBUaGUgY3J5cHRvZ3JhcGhpYyBoYW5kc2hha2UgTVVTVCBwcm92aWRlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczogKiBhdXRoZW50aWNhdGVkIGtleSBleGNoYW5nZSwgd2hlcmUgLSBhIHNlcnZlciBpcyBhbHdheXMgYXV0aGVudGljYXRlZCwgLSBhIGNsaWVudCBpcyBvcHRpb25hbGx5IGF1dGhlbnRpY2F0ZWQsIC0gZXZlcnkgY29ubmVjdGlvbiBwcm9kdWNlcyBkaXN0aW5jdCBhbmQgdW5yZWxhdGVkIGtleXMsIGFuZCAtIGtleWluZyBtYXRlcmlhbCBpcyB1c2FibGUgZm9yIHBhY2tldCBwcm90ZWN0aW9uIGZvciBib3RoIDAtUlRUIGFuZCAxLVJUVCBwYWNrZXRzLiAqIGF1dGhlbnRpY2F0ZWQgZXhjaGFuZ2Ugb2YgdmFsdWVzIGZvciB0cmFuc3BvcnQgcGFyYW1ldGVycyBvZiBib3RoIGVuZHBvaW50cywgYW5kIGNvbmZpZGVudGlhbGl0eSBwcm90ZWN0aW9uIGZvciBzZXJ2ZXIgdHJhbnNwb3J0IHBhcmFtZXRlcnMgKHNlZSBTZWN0aW9uIDcuNCkuICogYXV0aGVudGljYXRlZCBuZWdvdGlhdGlvbiBvZiBhbiBhcHBsaWNhdGlvbiBwcm90b2NvbCAoVExTIHVzZXMgQXBwbGljYXRpb24tTGF5ZXIgUHJvdG9jb2wgTmVnb3RpYXRpb24gKEFMUE4pIFtBTFBOXSBmb3IgdGhpcyBwdXJwb3NlKS4gVGhlIENSWVBUTyBmcmFtZSBjYW4gYmUgc2VudCBpbiBkaWZmZXJlbnQgcGFja2V0IG51bWJlciBzcGFjZXMgKFNlY3Rpb24gMTIuMykuIFRoZSBvZmZzZXRzIHVzZWQgYnkgQ1JZUFRPIGZyYW1lcyB0byBlbnN1cmUgb3JkZXJlZCBkZWxpdmVyeSBvZiBjcnlwdG9ncmFwaGljIGhhbmRzaGFrZSBkYXRhIHN0YXJ0IGZyb20gemVybyBpbiBlYWNoIHBhY2tldCBudW1iZXIgc3BhY2UuIEZpZ3VyZSA0IHNob3dzIGEgc2ltcGxpZmllZCBoYW5kc2hha2UgYW5kIHRoZSBleGNoYW5nZSBvZiBwYWNrZXRzIGFuZCBmcmFtZXMgdGhhdCBhcmUgdXNlZCB0byBhZHZhbmNlIHRoZSBoYW5kc2hha2UuIEV4Y2hhbmdlIG9mIGFwcGxpY2F0aW9uIGRhdGEgZHVyaW5nIHRoZSBoYW5kc2hha2UgaXMgZW5hYmxlZCB3aGVyZSBwb3NzaWJsZSwgc2hvd24gd2l0aCBhbiBhc3RlcmlzayAoIioiKS4gT25jZSB0aGUgaGFuZHNoYWtlIGlzIGNvbXBsZXRlLCBlbmRwb2ludHMgYXJlIGFibGUgdG8gZXhjaGFuZ2UgYXBwbGljYXRpb24gZGF0YSBmcmVlbHkuIENsaWVudCBTZXJ2ZXIgSW5pdGlhbCAoQ1JZUFRPKSAwLVJUVCAoKikgLS0tLS0tLS0tLSZndDsgSW5pdGlhbCAoQ1JZUFRPKSBIYW5kc2hha2UgKENSWVBUTykgJmx0Oy0tLS0tLS0tLS0gMS1SVFQgKCopIEhhbmRzaGFrZSAoQ1JZUFRPKSAxLVJUVCAoKikgLS0tLS0tLS0tLSZndDsgJmx0Oy0tLS0tLS0tLS0gMS1SVFQgKEhBTkRTSEFLRV9ET05FKSAxLVJUVCAmbHQ7PT09PT09PT09Jmd0OyAxLVJUVCBGaWd1cmUgNDogU2ltcGxpZmllZCBRVUlDIEhhbmRzaGFrZSBFbmRwb2ludHMgY2FuIHVzZSBwYWNrZXRzIHNlbnQgZHVyaW5nIHRoZSBoYW5kc2hha2UgdG8gdGVzdCBmb3IgRXhwbGljaXQgQ29uZ2VzdGlvbiBOb3RpZmljYXRpb24gKEVDTikgc3VwcG9ydDsgc2VlIFNlY3Rpb24gMTMuNC4gQW4gZW5kcG9pbnQgdmFsaWRhdGVzIHN1cHBvcnQgZm9yIEVDTiBieSBvYnNlcnZpbmcgd2hldGhlciB0aGUgQUNLIGZyYW1lcyBhY2tub3dsZWRnaW5nIHRoZSBmaXJzdCBwYWNrZXRzIGl0IHNlbmRzIGNhcnJ5IEVDTiBjb3VudHMsIGFzIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDEzLjQuMi4gRW5kcG9pbnRzIE1VU1QgZXhwbGljaXRseSBuZWdvdGlhdGUgYW4gYXBwbGljYXRpb24gcHJvdG9jb2wuIFRoaXMgYXZvaWRzIHNpdHVhdGlvbnMgd2hlcmUgdGhlcmUgaXMgYSBkaXNhZ3JlZW1lbnQgYWJvdXQgdGhlIHByb3RvY29sIHRoYXQgaXMgaW4gdXNlLiA3LjEuIEV4YW1wbGUgSGFuZHNoYWtlIEZsb3dzIERldGFpbHMgb2YgaG93IFRMUyBpcyBpbnRlZ3JhdGVkIHdpdGggUVVJQyBhcmUgcHJvdmlkZWQgaW4gW1FVSUMtVExTXSwgYnV0IHNvbWUgZXhhbXBsZXMgYXJlIHByb3ZpZGVkIGhlcmUuIEFuIGV4dGVuc2lvbiBvZiB0aGlzIGV4Y2hhbmdlIHRvIHN1cHBvcnQgY2xpZW50IGFkZHJlc3MgdmFsaWRhdGlvbiBpcyBzaG93biBpbiBTZWN0aW9uIDguMS4yLiBPbmNlIGFueSBhZGRyZXNzIHZhbGlkYXRpb24gZXhjaGFuZ2VzIGFyZSBjb21wbGV0ZSwgdGhlIGNyeXB0b2dyYXBoaWMgaGFuZHNoYWtlIGlzIHVzZWQgdG8gYWdyZWUgb24gY3J5cHRvZ3JhcGhpYyBrZXlzLiBUaGUgY3J5cHRvZ3JhcGhpYyBoYW5kc2hha2UgaXMgY2FycmllZCBpbiBJbml0aWFsIChTZWN0aW9uIDE3LjIuMikgYW5kIEhhbmRzaGFrZSAoU2VjdGlvbiAxNy4yLjQpIHBhY2tldHMuIEZpZ3VyZSA1IHByb3ZpZGVzIGFuIG92ZXJ2aWV3IG9mIHRoZSAxLVJUVCBoYW5kc2hha2UuIEVhY2ggbGluZSBzaG93cyBhIFFVSUMgcGFja2V0IHdpdGggdGhlIHBhY2tldCB0eXBlIGFuZCBwYWNrZXQgbnVtYmVyIHNob3duIGZpcnN0LCBmb2xsb3dlZCBieSB0aGUgZnJhbWVzIHRoYXQgYXJlIHR5cGljYWxseSBjb250YWluZWQgaW4gdGhvc2UgcGFja2V0cy4gRm9yIGluc3RhbmNlLCB0aGUgZmlyc3QgcGFja2V0IGlzIG9mIHR5cGUgSW5pdGlhbCwgd2l0aCBwYWNrZXQgbnVtYmVyIDAsIGFuZCBjb250YWlucyBhIENSWVBUTyBmcmFtZSBjYXJyeWluZyB0aGUgQ2xpZW50SGVsbG8uIE11bHRpcGxlIFFVSUMgcGFja2V0cyAtLSBldmVuIG9mIGRpZmZlcmVudCBwYWNrZXQgdHlwZXMgLS0gY2FuIGJlIGNvYWxlc2NlZCBpbnRvIGEgc2luZ2xlIFVEUCBkYXRhZ3JhbTsgc2VlIFNlY3Rpb24gMTIuMi4gQXMgYSByZXN1bHQsIHRoaXMgaGFuZHNoYWtlIGNvdWxkIGNvbnNpc3Qgb2YgYXMgZmV3IGFzIGZvdXIgVURQIGRhdGFncmFtcywgb3IgYW55IG51bWJlciBtb3JlIChzdWJqZWN0IHRvIGxpbWl0cyBpbmhlcmVudCB0byB0aGUgcHJvdG9jb2wsIHN1Y2ggYXMgY29uZ2VzdGlvbiBjb250cm9sIGFuZCBhbnRpLWFtcGxpZmljYXRpb24pLiBGb3IgaW5zdGFuY2UsIHRoZSBzZXJ2ZXIncyBmaXJzdCBmbGlnaHQgY29udGFpbnMgSW5pdGlhbCBwYWNrZXRzLCBIYW5kc2hha2UgcGFja2V0cywgYW5kICIwLjUtUlRUIGRhdGEiIGluIDEtUlRUIHBhY2tldHMuIENsaWVudCBTZXJ2ZXIgSW5pdGlhbFswXTogQ1JZUFRPW0NIXSAtJmd0OyBJbml0aWFsWzBdOiBDUllQVE9bU0hdIEFDS1swXSBIYW5kc2hha2VbMF06IENSWVBUT1tFRSwgQ0VSVCwgQ1YsIEZJTl0gJmx0Oy0gMS1SVFRbMF06IFNUUkVBTVsxLCAiLi4uIl0gSW5pdGlhbFsxXTogQUNLWzBdIEhhbmRzaGFrZVswXTogQ1JZUFRPW0ZJTl0sIEFDS1swXSAxLVJUVFswXTogU1RSRUFNWzAsICIuLi4iXSwgQUNLWzBdIC0mZ3Q7IEhhbmRzaGFrZVsxXTogQUNLWzBdICZsdDstIDEtUlRUWzFdOiBIQU5EU0hBS0VfRE9ORSwgU1RSRUFNWzMsICIuLi4iXSwgQUNLWzBdIEZpZ3VyZSA1OiBFeGFtcGxlIDEtUlRUIEhhbmRzaGFrZSBGaWd1cmUgNiBzaG93cyBhbiBleGFtcGxlIG9mIGEgY29ubmVjdGlvbiB3aXRoIGEgMC1SVFQgaGFuZHNoYWtlIGFuZCBhIHNpbmdsZSBwYWNrZXQgb2YgMC1SVFQgZGF0YS4gTm90ZSB0aGF0IGFzIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDEyLjMsIHRoZSBzZXJ2ZXIgYWNrbm93bGVkZ2VzIDAtUlRUIGRhdGEgaW4gMS1SVFQgcGFja2V0cywgYW5kIHRoZSBjbGllbnQgc2VuZHMgMS1SVFQgcGFja2V0cyBpbiB0aGUgc2FtZSBwYWNrZXQgbnVtYmVyIHNwYWNlLiBDbGllbnQgU2VydmVyIEluaXRpYWxbMF06IENSWVBUT1tDSF0gMC1SVFRbMF06IFNUUkVBTVswLCAiLi4uIl0gLSZndDsgSW5pdGlhbFswXTogQ1JZUFRPW1NIXSBBQ0tbMF0gSGFuZHNoYWtlWzBdIENSWVBUT1tFRSwgRklOXSAmbHQ7LSAxLVJUVFswXTogU1RSRUFNWzEsICIuLi4iXSBBQ0tbMF0gSW5pdGlhbFsxXTogQUNLWzBdIEhhbmRzaGFrZVswXTogQ1JZUFRPW0ZJTl0sIEFDS1swXSAxLVJUVFsxXTogU1RSRUFNWzAsICIuLi4iXSBBQ0tbMF0gLSZndDsgSGFuZHNoYWtlWzFdOiBBQ0tbMF0gJmx0Oy0gMS1SVFRbMV06IEhBTkRTSEFLRV9ET05FLCBTVFJFQU1bMywgIi4uLiJdLCBBQ0tbMV0gRmlndXJlIDY6IEV4YW1wbGUgMC1SVFQgSGFuZHNoYWtlIDcuMi4gTmVnb3RpYXRpbmcgQ29ubmVjdGlvbiBJRHMgQSBjb25uZWN0aW9uIElEIGlzIHVzZWQgdG8gZW5zdXJlIGNvbnNpc3RlbnQgcm91dGluZyBvZiBwYWNrZXRzLCBhcyBkZXNjcmliZWQgaW4gU2VjdGlvbiA1LjEuIFRoZSBsb25nIGhlYWRlciBjb250YWlucyB0d28gY29ubmVjdGlvbiBJRHM6IHRoZSBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEIGlzIGNob3NlbiBieSB0aGUgcmVjaXBpZW50IG9mIHRoZSBwYWNrZXQgYW5kIGlzIHVzZWQgdG8gcHJvdmlkZSBjb25zaXN0ZW50IHJvdXRpbmc7IHRoZSBTb3VyY2UgQ29ubmVjdGlvbiBJRCBpcyB1c2VkIHRvIHNldCB0aGUgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCB1c2VkIGJ5IHRoZSBwZWVyLiBEdXJpbmcgdGhlIGhhbmRzaGFrZSwgcGFja2V0cyB3aXRoIHRoZSBsb25nIGhlYWRlciAoU2VjdGlvbiAxNy4yKSBhcmUgdXNlZCB0byBlc3RhYmxpc2ggdGhlIGNvbm5lY3Rpb24gSURzIHVzZWQgYnkgYm90aCBlbmRwb2ludHMuIEVhY2ggZW5kcG9pbnQgdXNlcyB0aGUgU291cmNlIENvbm5lY3Rpb24gSUQgZmllbGQgdG8gc3BlY2lmeSB0aGUgY29ubmVjdGlvbiBJRCB0aGF0IGlzIHVzZWQgaW4gdGhlIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgZmllbGQgb2YgcGFja2V0cyBiZWluZyBzZW50IHRvIHRoZW0uIEFmdGVyIHByb2Nlc3NpbmcgdGhlIGZpcnN0IEluaXRpYWwgcGFja2V0LCBlYWNoIGVuZHBvaW50IHNldHMgdGhlIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgZmllbGQgaW4gc3Vic2VxdWVudCBwYWNrZXRzIGl0IHNlbmRzIHRvIHRoZSB2YWx1ZSBvZiB0aGUgU291cmNlIENvbm5lY3Rpb24gSUQgZmllbGQgdGhhdCBpdCByZWNlaXZlZC4gV2hlbiBhbiBJbml0aWFsIHBhY2tldCBpcyBzZW50IGJ5IGEgY2xpZW50IHRoYXQgaGFzIG5vdCBwcmV2aW91c2x5IHJlY2VpdmVkIGFuIEluaXRpYWwgb3IgUmV0cnkgcGFja2V0IGZyb20gdGhlIHNlcnZlciwgdGhlIGNsaWVudCBwb3B1bGF0ZXMgdGhlIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgZmllbGQgd2l0aCBhbiB1bnByZWRpY3RhYmxlIHZhbHVlLiBUaGlzIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgTVVTVCBiZSBhdCBsZWFzdCA4IGJ5dGVzIGluIGxlbmd0aC4gVW50aWwgYSBwYWNrZXQgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLCB0aGUgY2xpZW50IE1VU1QgdXNlIHRoZSBzYW1lIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgdmFsdWUgb24gYWxsIHBhY2tldHMgaW4gdGhpcyBjb25uZWN0aW9uLiBUaGUgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBmaWVsZCBmcm9tIHRoZSBmaXJzdCBJbml0aWFsIHBhY2tldCBzZW50IGJ5IGEgY2xpZW50IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHBhY2tldCBwcm90ZWN0aW9uIGtleXMgZm9yIEluaXRpYWwgcGFja2V0cy4gVGhlc2Uga2V5cyBjaGFuZ2UgYWZ0ZXIgcmVjZWl2aW5nIGEgUmV0cnkgcGFja2V0OyBzZWUgU2VjdGlvbiA1LjIgb2YgW1FVSUMtVExTXS4gVGhlIGNsaWVudCBwb3B1bGF0ZXMgdGhlIFNvdXJjZSBDb25uZWN0aW9uIElEIGZpZWxkIHdpdGggYSB2YWx1ZSBvZiBpdHMgY2hvb3NpbmcgYW5kIHNldHMgdGhlIFNvdXJjZSBDb25uZWN0aW9uIElEIExlbmd0aCBmaWVsZCB0byBpbmRpY2F0ZSB0aGUgbGVuZ3RoLiAwLVJUVCBwYWNrZXRzIGluIHRoZSBmaXJzdCBmbGlnaHQgdXNlIHRoZSBzYW1lIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgYW5kIFNvdXJjZSBDb25uZWN0aW9uIElEIHZhbHVlcyBhcyB0aGUgY2xpZW50J3MgZmlyc3QgSW5pdGlhbCBwYWNrZXQuIFVwb24gZmlyc3QgcmVjZWl2aW5nIGFuIEluaXRpYWwgb3IgUmV0cnkgcGFja2V0IGZyb20gdGhlIHNlcnZlciwgdGhlIGNsaWVudCB1c2VzIHRoZSBTb3VyY2UgQ29ubmVjdGlvbiBJRCBzdXBwbGllZCBieSB0aGUgc2VydmVyIGFzIHRoZSBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEIGZvciBzdWJzZXF1ZW50IHBhY2tldHMsIGluY2x1ZGluZyBhbnkgMC1SVFQgcGFja2V0cy4gVGhpcyBtZWFucyB0aGF0IGEgY2xpZW50IG1pZ2h0IGhhdmUgdG8gY2hhbmdlIHRoZSBjb25uZWN0aW9uIElEIGl0IHNldHMgaW4gdGhlIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgZmllbGQgdHdpY2UgZHVyaW5nIGNvbm5lY3Rpb24gZXN0YWJsaXNobWVudDogb25jZSBpbiByZXNwb25zZSB0byBhIFJldHJ5IHBhY2tldCBhbmQgb25jZSBpbiByZXNwb25zZSB0byBhbiBJbml0aWFsIHBhY2tldCBmcm9tIHRoZSBzZXJ2ZXIuIE9uY2UgYSBjbGllbnQgaGFzIHJlY2VpdmVkIGEgdmFsaWQgSW5pdGlhbCBwYWNrZXQgZnJvbSB0aGUgc2VydmVyLCBpdCBNVVNUIGRpc2NhcmQgYW55IHN1YnNlcXVlbnQgcGFja2V0IGl0IHJlY2VpdmVzIG9uIHRoYXQgY29ubmVjdGlvbiB3aXRoIGEgZGlmZmVyZW50IFNvdXJjZSBDb25uZWN0aW9uIElELiBBIGNsaWVudCBNVVNUIGNoYW5nZSB0aGUgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBpdCB1c2VzIGZvciBzZW5kaW5nIHBhY2tldHMgaW4gcmVzcG9uc2UgdG8gb25seSB0aGUgZmlyc3QgcmVjZWl2ZWQgSW5pdGlhbCBvciBSZXRyeSBwYWNrZXQuIEEgc2VydmVyIE1VU1Qgc2V0IHRoZSBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEIGl0IHVzZXMgZm9yIHNlbmRpbmcgcGFja2V0cyBiYXNlZCBvbiB0aGUgZmlyc3QgcmVjZWl2ZWQgSW5pdGlhbCBwYWNrZXQuIEFueSBmdXJ0aGVyIGNoYW5nZXMgdG8gdGhlIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgYXJlIG9ubHkgcGVybWl0dGVkIGlmIHRoZSB2YWx1ZXMgYXJlIHRha2VuIGZyb20gTkVXX0NPTk5FQ1RJT05fSUQgZnJhbWVzOyBpZiBzdWJzZXF1ZW50IEluaXRpYWwgcGFja2V0cyBpbmNsdWRlIGEgZGlmZmVyZW50IFNvdXJjZSBDb25uZWN0aW9uIElELCB0aGV5IE1VU1QgYmUgZGlzY2FyZGVkLiBUaGlzIGF2b2lkcyB1bnByZWRpY3RhYmxlIG91dGNvbWVzIHRoYXQgbWlnaHQgb3RoZXJ3aXNlIHJlc3VsdCBmcm9tIHN0YXRlbGVzcyBwcm9jZXNzaW5nIG9mIG11bHRpcGxlIEluaXRpYWwgcGFja2V0cyB3aXRoIGRpZmZlcmVudCBTb3VyY2UgQ29ubmVjdGlvbiBJRHMuIFRoZSBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEIHRoYXQgYW4gZW5kcG9pbnQgc2VuZHMgY2FuIGNoYW5nZSBvdmVyIHRoZSBsaWZldGltZSBvZiBhIGNvbm5lY3Rpb24sIGVzcGVjaWFsbHkgaW4gcmVzcG9uc2UgdG8gY29ubmVjdGlvbiBtaWdyYXRpb24gKFNlY3Rpb24gOSk7IHNlZSBTZWN0aW9uIDUuMS4xIGZvciBkZXRhaWxzLiA3LjMuIEF1dGhlbnRpY2F0aW5nIENvbm5lY3Rpb24gSURzIFRoZSBjaG9pY2UgZWFjaCBlbmRwb2ludCBtYWtlcyBhYm91dCBjb25uZWN0aW9uIElEcyBkdXJpbmcgdGhlIGhhbmRzaGFrZSBpcyBhdXRoZW50aWNhdGVkIGJ5IGluY2x1ZGluZyBhbGwgdmFsdWVzIGluIHRyYW5zcG9ydCBwYXJhbWV0ZXJzOyBzZWUgU2VjdGlvbiA3LjQuIFRoaXMgZW5zdXJlcyB0aGF0IGFsbCBjb25uZWN0aW9uIElEcyB1c2VkIGZvciB0aGUgaGFuZHNoYWtlIGFyZSBhbHNvIGF1dGhlbnRpY2F0ZWQgYnkgdGhlIGNyeXB0b2dyYXBoaWMgaGFuZHNoYWtlLiBFYWNoIGVuZHBvaW50IGluY2x1ZGVzIHRoZSB2YWx1ZSBvZiB0aGUgU291cmNlIENvbm5lY3Rpb24gSUQgZmllbGQgZnJvbSB0aGUgZmlyc3QgSW5pdGlhbCBwYWNrZXQgaXQgc2VudCBpbiB0aGUgaW5pdGlhbF9zb3VyY2VfY29ubmVjdGlvbl9pZCB0cmFuc3BvcnQgcGFyYW1ldGVyOyBzZWUgU2VjdGlvbiAxOC4yLiBBIHNlcnZlciBpbmNsdWRlcyB0aGUgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBmaWVsZCBmcm9tIHRoZSBmaXJzdCBJbml0aWFsIHBhY2tldCBpdCByZWNlaXZlZCBmcm9tIHRoZSBjbGllbnQgaW4gdGhlIG9yaWdpbmFsX2Rlc3RpbmF0aW9uX2Nvbm5lY3Rpb25faWQgdHJhbnNwb3J0IHBhcmFtZXRlcjsgaWYgdGhlIHNlcnZlciBzZW50IGEgUmV0cnkgcGFja2V0LCB0aGlzIHJlZmVycyB0byB0aGUgZmlyc3QgSW5pdGlhbCBwYWNrZXQgcmVjZWl2ZWQgYmVmb3JlIHNlbmRpbmcgdGhlIFJldHJ5IHBhY2tldC4gSWYgaXQgc2VuZHMgYSBSZXRyeSBwYWNrZXQsIGEgc2VydmVyIGFsc28gaW5jbHVkZXMgdGhlIFNvdXJjZSBDb25uZWN0aW9uIElEIGZpZWxkIGZyb20gdGhlIFJldHJ5IHBhY2tldCBpbiB0aGUgcmV0cnlfc291cmNlX2Nvbm5lY3Rpb25faWQgdHJhbnNwb3J0IHBhcmFtZXRlci4gVGhlIHZhbHVlcyBwcm92aWRlZCBieSBhIHBlZXIgZm9yIHRoZXNlIHRyYW5zcG9ydCBwYXJhbWV0ZXJzIE1VU1QgbWF0Y2ggdGhlIHZhbHVlcyB0aGF0IGFuIGVuZHBvaW50IHVzZWQgaW4gdGhlIERlc3RpbmF0aW9uIGFuZCBTb3VyY2UgQ29ubmVjdGlvbiBJRCBmaWVsZHMgb2YgSW5pdGlhbCBwYWNrZXRzIHRoYXQgaXQgc2VudCAoYW5kIHJlY2VpdmVkLCBmb3Igc2VydmVycykuIEVuZHBvaW50cyBNVVNUIHZhbGlkYXRlIHRoYXQgcmVjZWl2ZWQgdHJhbnNwb3J0IHBhcmFtZXRlcnMgbWF0Y2ggcmVjZWl2ZWQgY29ubmVjdGlvbiBJRCB2YWx1ZXMuIEluY2x1ZGluZyBjb25uZWN0aW9uIElEIHZhbHVlcyBpbiB0cmFuc3BvcnQgcGFyYW1ldGVycyBhbmQgdmVyaWZ5aW5nIHRoZW0gZW5zdXJlcyB0aGF0IGFuIGF0dGFja2VyIGNhbm5vdCBpbmZsdWVuY2UgdGhlIGNob2ljZSBvZiBjb25uZWN0aW9uIElEIGZvciBhIHN1Y2Nlc3NmdWwgY29ubmVjdGlvbiBieSBpbmplY3RpbmcgcGFja2V0cyBjYXJyeWluZyBhdHRhY2tlci1jaG9zZW4gY29ubmVjdGlvbiBJRHMgZHVyaW5nIHRoZSBoYW5kc2hha2UuIEFuIGVuZHBvaW50IE1VU1QgdHJlYXQgdGhlIGFic2VuY2Ugb2YgdGhlIGluaXRpYWxfc291cmNlX2Nvbm5lY3Rpb25faWQgdHJhbnNwb3J0IHBhcmFtZXRlciBmcm9tIGVpdGhlciBlbmRwb2ludCBvciB0aGUgYWJzZW5jZSBvZiB0aGUgb3JpZ2luYWxfZGVzdGluYXRpb25fY29ubmVjdGlvbl9pZCB0cmFuc3BvcnQgcGFyYW1ldGVyIGZyb20gdGhlIHNlcnZlciBhcyBhIGNvbm5lY3Rpb24gZXJyb3Igb2YgdHlwZSBUUkFOU1BPUlRfUEFSQU1FVEVSX0VSUk9SLiBBbiBlbmRwb2ludCBNVVNUIHRyZWF0IHRoZSBmb2xsb3dpbmcgYXMgYSBjb25uZWN0aW9uIGVycm9yIG9mIHR5cGUgVFJBTlNQT1JUX1BBUkFNRVRFUl9FUlJPUiBvciBQUk9UT0NPTF9WSU9MQVRJT046ICogYWJzZW5jZSBvZiB0aGUgcmV0cnlfc291cmNlX2Nvbm5lY3Rpb25faWQgdHJhbnNwb3J0IHBhcmFtZXRlciBmcm9tIHRoZSBzZXJ2ZXIgYWZ0ZXIgcmVjZWl2aW5nIGEgUmV0cnkgcGFja2V0LCAqIHByZXNlbmNlIG9mIHRoZSByZXRyeV9zb3VyY2VfY29ubmVjdGlvbl9pZCB0cmFuc3BvcnQgcGFyYW1ldGVyIHdoZW4gbm8gUmV0cnkgcGFja2V0IHdhcyByZWNlaXZlZCwgb3IgKiBhIG1pc21hdGNoIGJldHdlZW4gdmFsdWVzIHJlY2VpdmVkIGZyb20gYSBwZWVyIGluIHRoZXNlIHRyYW5zcG9ydCBwYXJhbWV0ZXJzIGFuZCB0aGUgdmFsdWUgc2VudCBpbiB0aGUgY29ycmVzcG9uZGluZyBEZXN0aW5hdGlvbiBvciBTb3VyY2UgQ29ubmVjdGlvbiBJRCBmaWVsZHMgb2YgSW5pdGlhbCBwYWNrZXRzLiBJZiBhIHplcm8tbGVuZ3RoIGNvbm5lY3Rpb24gSUQgaXMgc2VsZWN0ZWQsIHRoZSBjb3JyZXNwb25kaW5nIHRyYW5zcG9ydCBwYXJhbWV0ZXIgaXMgaW5jbHVkZWQgd2l0aCBhIHplcm8tbGVuZ3RoIHZhbHVlLiBGaWd1cmUgNyBzaG93cyB0aGUgY29ubmVjdGlvbiBJRHMgKHdpdGggRENJRD1EZXN0aW5hdGlvbiBDb25uZWN0aW9uIElELCBTQ0lEPVNvdXJjZSBDb25uZWN0aW9uIElEKSB0aGF0IGFyZSB1c2VkIGluIGEgY29tcGxldGUgaGFuZHNoYWtlLiBUaGUgZXhjaGFuZ2Ugb2YgSW5pdGlhbCBwYWNrZXRzIGlzIHNob3duLCBwbHVzIHRoZSBsYXRlciBleGNoYW5nZSBvZiAxLVJUVCBwYWNrZXRzIHRoYXQgaW5jbHVkZXMgdGhlIGNvbm5lY3Rpb24gSUQgZXN0YWJsaXNoZWQgZHVyaW5nIHRoZSBoYW5kc2hha2UuIENsaWVudCBTZXJ2ZXIgSW5pdGlhbDogRENJRD1TMSwgU0NJRD1DMSAtJmd0OyAmbHQ7LSBJbml0aWFsOiBEQ0lEPUMxLCBTQ0lEPVMzIC4uLiAxLVJUVDogRENJRD1TMyAtJmd0OyAmbHQ7LSAxLVJUVDogRENJRD1DMSBGaWd1cmUgNzogVXNlIG9mIENvbm5lY3Rpb24gSURzIGluIGEgSGFuZHNoYWtlIEZpZ3VyZSA4IHNob3dzIGEgc2ltaWxhciBoYW5kc2hha2UgdGhhdCBpbmNsdWRlcyBhIFJldHJ5IHBhY2tldC4gQ2xpZW50IFNlcnZlciBJbml0aWFsOiBEQ0lEPVMxLCBTQ0lEPUMxIC0mZ3Q7ICZsdDstIFJldHJ5OiBEQ0lEPUMxLCBTQ0lEPVMyIEluaXRpYWw6IERDSUQ9UzIsIFNDSUQ9QzEgLSZndDsgJmx0Oy0gSW5pdGlhbDogRENJRD1DMSwgU0NJRD1TMyAuLi4gMS1SVFQ6IERDSUQ9UzMgLSZndDsgJmx0Oy0gMS1SVFQ6IERDSUQ9QzEgRmlndXJlIDg6IFVzZSBvZiBDb25uZWN0aW9uIElEcyBpbiBhIEhhbmRzaGFrZSB3aXRoIFJldHJ5IEluIGJvdGggY2FzZXMgKEZpZ3VyZXMgNyBhbmQgOCksIHRoZSBjbGllbnQgc2V0cyB0aGUgdmFsdWUgb2YgdGhlIGluaXRpYWxfc291cmNlX2Nvbm5lY3Rpb25faWQgdHJhbnNwb3J0IHBhcmFtZXRlciB0byAiQzEiLiBXaGVuIHRoZSBoYW5kc2hha2UgZG9lcyBub3QgaW5jbHVkZSBhIFJldHJ5IChGaWd1cmUgNyksIHRoZSBzZXJ2ZXIgc2V0cyBvcmlnaW5hbF9kZXN0aW5hdGlvbl9jb25uZWN0aW9uX2lkIHRvICJTMSIgKG5vdGUgdGhhdCB0aGlzIHZhbHVlIGlzIGNob3NlbiBieSB0aGUgY2xpZW50KSBhbmQgaW5pdGlhbF9zb3VyY2VfY29ubmVjdGlvbl9pZCB0byAiUzMiLiBJbiB0aGlzIGNhc2UsIHRoZSBzZXJ2ZXIgZG9lcyBub3QgaW5jbHVkZSBhIHJldHJ5X3NvdXJjZV9jb25uZWN0aW9uX2lkIHRyYW5zcG9ydCBwYXJhbWV0ZXIuIFdoZW4gdGhlIGhhbmRzaGFrZSBpbmNsdWRlcyBhIFJldHJ5IChGaWd1cmUgOCksIHRoZSBzZXJ2ZXIgc2V0cyBvcmlnaW5hbF9kZXN0aW5hdGlvbl9jb25uZWN0aW9uX2lkIHRvICJTMSIsIHJldHJ5X3NvdXJjZV9jb25uZWN0aW9uX2lkIHRvICJTMiIsIGFuZCBpbml0aWFsX3NvdXJjZV9jb25uZWN0aW9uX2lkIHRvICJTMyIuIDcuNC4gVHJhbnNwb3J0IFBhcmFtZXRlcnMgRHVyaW5nIGNvbm5lY3Rpb24gZXN0YWJsaXNobWVudCwgYm90aCBlbmRwb2ludHMgbWFrZSBhdXRoZW50aWNhdGVkIGRlY2xhcmF0aW9ucyBvZiB0aGVpciB0cmFuc3BvcnQgcGFyYW1ldGVycy4gRW5kcG9pbnRzIGFyZSByZXF1aXJlZCB0byBjb21wbHkgd2l0aCB0aGUgcmVzdHJpY3Rpb25zIHRoYXQgZWFjaCBwYXJhbWV0ZXIgZGVmaW5lczsgdGhlIGRlc2NyaXB0aW9uIG9mIGVhY2ggcGFyYW1ldGVyIGluY2x1ZGVzIHJ1bGVzIGZvciBpdHMgaGFuZGxpbmcuIFRyYW5zcG9ydCBwYXJhbWV0ZXJzIGFyZSBkZWNsYXJhdGlvbnMgdGhhdCBhcmUgbWFkZSB1bmlsYXRlcmFsbHkgYnkgZWFjaCBlbmRwb2ludC4gRWFjaCBlbmRwb2ludCBjYW4gY2hvb3NlIHZhbHVlcyBmb3IgdHJhbnNwb3J0IHBhcmFtZXRlcnMgaW5kZXBlbmRlbnQgb2YgdGhlIHZhbHVlcyBjaG9zZW4gYnkgaXRzIHBlZXIuIFRoZSBlbmNvZGluZyBvZiB0aGUgdHJhbnNwb3J0IHBhcmFtZXRlcnMgaXMgZGV0YWlsZWQgaW4gU2VjdGlvbiAxOC4gUVVJQyBpbmNsdWRlcyB0aGUgZW5jb2RlZCB0cmFuc3BvcnQgcGFyYW1ldGVycyBpbiB0aGUgY3J5cHRvZ3JhcGhpYyBoYW5kc2hha2UuIE9uY2UgdGhlIGhhbmRzaGFrZSBjb21wbGV0ZXMsIHRoZSB0cmFuc3BvcnQgcGFyYW1ldGVycyBkZWNsYXJlZCBieSB0aGUgcGVlciBhcmUgYXZhaWxhYmxlLiBFYWNoIGVuZHBvaW50IHZhbGlkYXRlcyB0aGUgdmFsdWVzIHByb3ZpZGVkIGJ5IGl0cyBwZWVyLiBEZWZpbml0aW9ucyBmb3IgZWFjaCBvZiB0aGUgZGVmaW5lZCB0cmFuc3BvcnQgcGFyYW1ldGVycyBhcmUgaW5jbHVkZWQgaW4gU2VjdGlvbiAxOC4yLiBBbiBlbmRwb2ludCBNVVNUIHRyZWF0IHJlY2VpcHQgb2YgYSB0cmFuc3BvcnQgcGFyYW1ldGVyIHdpdGggYW4gaW52YWxpZCB2YWx1ZSBhcyBhIGNvbm5lY3Rpb24gZXJyb3Igb2YgdHlwZSBUUkFOU1BPUlRfUEFSQU1FVEVSX0VSUk9SLiBBbiBlbmRwb2ludCBNVVNUIE5PVCBzZW5kIGEgcGFyYW1ldGVyIG1vcmUgdGhhbiBvbmNlIGluIGEgZ2l2ZW4gdHJhbnNwb3J0IHBhcmFtZXRlcnMgZXh0ZW5zaW9uLiBBbiBlbmRwb2ludCBTSE9VTEQgdHJlYXQgcmVjZWlwdCBvZiBkdXBsaWNhdGUgdHJhbnNwb3J0IHBhcmFtZXRlcnMgYXMgYSBjb25uZWN0aW9uIGVycm9yIG9mIHR5cGUgVFJBTlNQT1JUX1BBUkFNRVRFUl9FUlJPUi4gRW5kcG9pbnRzIHVzZSB0cmFuc3BvcnQgcGFyYW1ldGVycyB0byBhdXRoZW50aWNhdGUgdGhlIG5lZ290aWF0aW9uIG9mIGNvbm5lY3Rpb24gSURzIGR1cmluZyB0aGUgaGFuZHNoYWtlOyBzZWUgU2VjdGlvbiA3LjMuIEFMUE4gKHNlZSBbQUxQTl0pIGFsbG93cyBjbGllbnRzIHRvIG9mZmVyIG11bHRpcGxlIGFwcGxpY2F0aW9uIHByb3RvY29scyBkdXJpbmcgY29ubmVjdGlvbiBlc3RhYmxpc2htZW50LiBUaGUgdHJhbnNwb3J0IHBhcmFtZXRlcnMgdGhhdCBhIGNsaWVudCBpbmNsdWRlcyBkdXJpbmcgdGhlIGhhbmRzaGFrZSBhcHBseSB0byBhbGwgYXBwbGljYXRpb24gcHJvdG9jb2xzIHRoYXQgdGhlIGNsaWVudCBvZmZlcnMuIEFwcGxpY2F0aW9uIHByb3RvY29scyBjYW4gcmVjb21tZW5kIHZhbHVlcyBmb3IgdHJhbnNwb3J0IHBhcmFtZXRlcnMsIHN1Y2ggYXMgdGhlIGluaXRpYWwgZmxvdyBjb250cm9sIGxpbWl0cy4gSG93ZXZlciwgYXBwbGljYXRpb24gcHJvdG9jb2xzIHRoYXQgc2V0IGNvbnN0cmFpbnRzIG9uIHZhbHVlcyBmb3IgdHJhbnNwb3J0IHBhcmFtZXRlcnMgY291bGQgbWFrZSBpdCBpbXBvc3NpYmxlIGZvciBhIGNsaWVudCB0byBvZmZlciBtdWx0aXBsZSBhcHBsaWNhdGlvbiBwcm90b2NvbHMgaWYgdGhlc2UgY29uc3RyYWludHMgY29uZmxpY3QuIDcuNC4xLiBWYWx1ZXMgb2YgVHJhbnNwb3J0IFBhcmFtZXRlcnMgZm9yIDAtUlRUIFVzaW5nIDAtUlRUIGRlcGVuZHMgb24gYm90aCBjbGllbnQgYW5kIHNlcnZlciB1c2luZyBwcm90b2NvbCBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBuZWdvdGlhdGVkIGZyb20gYSBwcmV2aW91cyBjb25uZWN0aW9uLiBUbyBlbmFibGUgMC1SVFQsIGVuZHBvaW50cyBzdG9yZSB0aGUgdmFsdWVzIG9mIHRoZSBzZXJ2ZXIgdHJhbnNwb3J0IHBhcmFtZXRlcnMgd2l0aCBhbnkgc2Vzc2lvbiB0aWNrZXRzIGl0IHJlY2VpdmVzIG9uIHRoZSBjb25uZWN0aW9uLiBFbmRwb2ludHMgYWxzbyBzdG9yZSBhbnkgaW5mb3JtYXRpb24gcmVxdWlyZWQgYnkgdGhlIGFwcGxpY2F0aW9uIHByb3RvY29sIG9yIGNyeXB0b2dyYXBoaWMgaGFuZHNoYWtlOyBzZWUgU2VjdGlvbiA0LjYgb2YgW1FVSUMtVExTXS4gVGhlIHZhbHVlcyBvZiBzdG9yZWQgdHJhbnNwb3J0IHBhcmFtZXRlcnMgYXJlIHVzZWQgd2hlbiBhdHRlbXB0aW5nIDAtUlRUIHVzaW5nIHRoZSBzZXNzaW9uIHRpY2tldHMuIFJlbWVtYmVyZWQgdHJhbnNwb3J0IHBhcmFtZXRlcnMgYXBwbHkgdG8gdGhlIG5ldyBjb25uZWN0aW9uIHVudGlsIHRoZSBoYW5kc2hha2UgY29tcGxldGVzIGFuZCB0aGUgY2xpZW50IHN0YXJ0cyBzZW5kaW5nIDEtUlRUIHBhY2tldHMuIE9uY2UgdGhlIGhhbmRzaGFrZSBjb21wbGV0ZXMsIHRoZSBjbGllbnQgdXNlcyB0aGUgdHJhbnNwb3J0IHBhcmFtZXRlcnMgZXN0YWJsaXNoZWQgaW4gdGhlIGhhbmRzaGFrZS4gTm90IGFsbCB0cmFuc3BvcnQgcGFyYW1ldGVycyBhcmUgcmVtZW1iZXJlZCwgYXMgc29tZSBkbyBub3QgYXBwbHkgdG8gZnV0dXJlIGNvbm5lY3Rpb25zIG9yIHRoZXkgaGF2ZSBubyBlZmZlY3Qgb24gdGhlIHVzZSBvZiAwLVJUVC4gVGhlIGRlZmluaXRpb24gb2YgYSBuZXcgdHJhbnNwb3J0IHBhcmFtZXRlciAoU2VjdGlvbiA3LjQuMikgTVVTVCBzcGVjaWZ5IHdoZXRoZXIgc3RvcmluZyB0aGUgdHJhbnNwb3J0IHBhcmFtZXRlciBmb3IgMC1SVFQgaXMgbWFuZGF0b3J5LCBvcHRpb25hbCwgb3IgcHJvaGliaXRlZC4gQSBjbGllbnQgbmVlZCBub3Qgc3RvcmUgYSB0cmFuc3BvcnQgcGFyYW1ldGVyIGl0IGNhbm5vdCBwcm9jZXNzLiBBIGNsaWVudCBNVVNUIE5PVCB1c2UgcmVtZW1iZXJlZCB2YWx1ZXMgZm9yIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczogYWNrX2RlbGF5X2V4cG9uZW50LCBtYXhfYWNrX2RlbGF5LCBpbml0aWFsX3NvdXJjZV9jb25uZWN0aW9uX2lkLCBvcmlnaW5hbF9kZXN0aW5hdGlvbl9jb25uZWN0aW9uX2lkLCBwcmVmZXJyZWRfYWRkcmVzcywgcmV0cnlfc291cmNlX2Nvbm5lY3Rpb25faWQsIGFuZCBzdGF0ZWxlc3NfcmVzZXRfdG9rZW4uIFRoZSBjbGllbnQgTVVTVCB1c2UgdGhlIHNlcnZlcidzIG5ldyB2YWx1ZXMgaW4gdGhlIGhhbmRzaGFrZSBpbnN0ZWFkOyBpZiB0aGUgc2VydmVyIGRvZXMgbm90IHByb3ZpZGUgbmV3IHZhbHVlcywgdGhlIGRlZmF1bHQgdmFsdWVzIGFyZSB1c2VkLiBBIGNsaWVudCB0aGF0IGF0dGVtcHRzIHRvIHNlbmQgMC1SVFQgZGF0YSBNVVNUIHJlbWVtYmVyIGFsbCBvdGhlciB0cmFuc3BvcnQgcGFyYW1ldGVycyB1c2VkIGJ5IHRoZSBzZXJ2ZXIgdGhhdCBpdCBpcyBhYmxlIHRvIHByb2Nlc3MuIFRoZSBzZXJ2ZXIgY2FuIHJlbWVtYmVyIHRoZXNlIHRyYW5zcG9ydCBwYXJhbWV0ZXJzIG9yIGNhbiBzdG9yZSBhbiBpbnRlZ3JpdHktcHJvdGVjdGVkIGNvcHkgb2YgdGhlIHZhbHVlcyBpbiB0aGUgdGlja2V0IGFuZCByZWNvdmVyIHRoZSBpbmZvcm1hdGlvbiB3aGVuIGFjY2VwdGluZyAwLVJUVCBkYXRhLiBBIHNlcnZlciB1c2VzIHRoZSB0cmFuc3BvcnQgcGFyYW1ldGVycyBpbiBkZXRlcm1pbmluZyB3aGV0aGVyIHRvIGFjY2VwdCAwLVJUVCBkYXRhLiBJZiAwLVJUVCBkYXRhIGlzIGFjY2VwdGVkIGJ5IHRoZSBzZXJ2ZXIsIHRoZSBzZXJ2ZXIgTVVTVCBOT1QgcmVkdWNlIGFueSBsaW1pdHMgb3IgYWx0ZXIgYW55IHZhbHVlcyB0aGF0IG1pZ2h0IGJlIHZpb2xhdGVkIGJ5IHRoZSBjbGllbnQgd2l0aCBpdHMgMC1SVFQgZGF0YS4gSW4gcGFydGljdWxhciwgYSBzZXJ2ZXIgdGhhdCBhY2NlcHRzIDAtUlRUIGRhdGEgTVVTVCBOT1Qgc2V0IHZhbHVlcyBmb3IgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzIChTZWN0aW9uIDE4LjIpIHRoYXQgYXJlIHNtYWxsZXIgdGhhbiB0aGUgcmVtZW1iZXJlZCB2YWx1ZXMgb2YgdGhlIHBhcmFtZXRlcnMuICogYWN0aXZlX2Nvbm5lY3Rpb25faWRfbGltaXQgKiBpbml0aWFsX21heF9kYXRhICogaW5pdGlhbF9tYXhfc3RyZWFtX2RhdGFfYmlkaV9sb2NhbCAqIGluaXRpYWxfbWF4X3N0cmVhbV9kYXRhX2JpZGlfcmVtb3RlICogaW5pdGlhbF9tYXhfc3RyZWFtX2RhdGFfdW5pICogaW5pdGlhbF9tYXhfc3RyZWFtc19iaWRpICogaW5pdGlhbF9tYXhfc3RyZWFtc191bmkgT21pdHRpbmcgb3Igc2V0dGluZyBhIHplcm8gdmFsdWUgZm9yIGNlcnRhaW4gdHJhbnNwb3J0IHBhcmFtZXRlcnMgY2FuIHJlc3VsdCBpbiAwLVJUVCBkYXRhIGJlaW5nIGVuYWJsZWQgYnV0IG5vdCB1c2FibGUuIFRoZSBhcHBsaWNhYmxlIHN1YnNldCBvZiB0cmFuc3BvcnQgcGFyYW1ldGVycyB0aGF0IHBlcm1pdCB0aGUgc2VuZGluZyBvZiBhcHBsaWNhdGlvbiBkYXRhIFNIT1VMRCBiZSBzZXQgdG8gbm9uLXplcm8gdmFsdWVzIGZvciAwLVJUVC4gVGhpcyBpbmNsdWRlcyBpbml0aWFsX21heF9kYXRhIGFuZCBlaXRoZXIgKDEpIGluaXRpYWxfbWF4X3N0cmVhbXNfYmlkaSBhbmQgaW5pdGlhbF9tYXhfc3RyZWFtX2RhdGFfYmlkaV9yZW1vdGUgb3IgKDIpIGluaXRpYWxfbWF4X3N0cmVhbXNfdW5pIGFuZCBpbml0aWFsX21heF9zdHJlYW1fZGF0YV91bmkuIEEgc2VydmVyIG1pZ2h0IHByb3ZpZGUgbGFyZ2VyIGluaXRpYWwgc3RyZWFtIGZsb3cgY29udHJvbCBsaW1pdHMgZm9yIHN0cmVhbXMgdGhhbiB0aGUgcmVtZW1iZXJlZCB2YWx1ZXMgdGhhdCBhIGNsaWVudCBhcHBsaWVzIHdoZW4gc2VuZGluZyAwLVJUVC4gT25jZSB0aGUgaGFuZHNoYWtlIGNvbXBsZXRlcywgdGhlIGNsaWVudCB1cGRhdGVzIHRoZSBmbG93IGNvbnRyb2wgbGltaXRzIG9uIGFsbCBzZW5kaW5nIHN0cmVhbXMgdXNpbmcgdGhlIHVwZGF0ZWQgdmFsdWVzIG9mIGluaXRpYWxfbWF4X3N0cmVhbV9kYXRhX2JpZGlfcmVtb3RlIGFuZCBpbml0aWFsX21heF9zdHJlYW1fZGF0YV91bmkuIEEgc2VydmVyIE1BWSBzdG9yZSBhbmQgcmVjb3ZlciB0aGUgcHJldmlvdXNseSBzZW50IHZhbHVlcyBvZiB0aGUgbWF4X2lkbGVfdGltZW91dCwgbWF4X3VkcF9wYXlsb2FkX3NpemUsIGFuZCBkaXNhYmxlX2FjdGl2ZV9taWdyYXRpb24gcGFyYW1ldGVycyBhbmQgcmVqZWN0IDAtUlRUIGlmIGl0IHNlbGVjdHMgc21hbGxlciB2YWx1ZXMuIExvd2VyaW5nIHRoZSB2YWx1ZXMgb2YgdGhlc2UgcGFyYW1ldGVycyB3aGlsZSBhbHNvIGFjY2VwdGluZyAwLVJUVCBkYXRhIGNvdWxkIGRlZ3JhZGUgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBjb25uZWN0aW9uLiBTcGVjaWZpY2FsbHksIGxvd2VyaW5nIHRoZSBtYXhfdWRwX3BheWxvYWRfc2l6ZSBjb3VsZCByZXN1bHQgaW4gZHJvcHBlZCBwYWNrZXRzLCBsZWFkaW5nIHRvIHdvcnNlIHBlcmZvcm1hbmNlIGNvbXBhcmVkIHRvIHJlamVjdGluZyAwLVJUVCBkYXRhIG91dHJpZ2h0LiBBIHNlcnZlciBNVVNUIHJlamVjdCAwLVJUVCBkYXRhIGlmIHRoZSByZXN0b3JlZCB2YWx1ZXMgZm9yIHRyYW5zcG9ydCBwYXJhbWV0ZXJzIGNhbm5vdCBiZSBzdXBwb3J0ZWQuIFdoZW4gc2VuZGluZyBmcmFtZXMgaW4gMC1SVFQgcGFja2V0cywgYSBjbGllbnQgTVVTVCBvbmx5IHVzZSByZW1lbWJlcmVkIHRyYW5zcG9ydCBwYXJhbWV0ZXJzOyBpbXBvcnRhbnRseSwgaXQgTVVTVCBOT1QgdXNlIHVwZGF0ZWQgdmFsdWVzIHRoYXQgaXQgbGVhcm5zIGZyb20gdGhlIHNlcnZlcidzIHVwZGF0ZWQgdHJhbnNwb3J0IHBhcmFtZXRlcnMgb3IgZnJvbSBmcmFtZXMgcmVjZWl2ZWQgaW4gMS1SVFQgcGFja2V0cy4gVXBkYXRlZCB2YWx1ZXMgb2YgdHJhbnNwb3J0IHBhcmFtZXRlcnMgZnJvbSB0aGUgaGFuZHNoYWtlIGFwcGx5IG9ubHkgdG8gMS1SVFQgcGFja2V0cy4gRm9yIGluc3RhbmNlLCBmbG93IGNvbnRyb2wgbGltaXRzIGZyb20gcmVtZW1iZXJlZCB0cmFuc3BvcnQgcGFyYW1ldGVycyBhcHBseSB0byBhbGwgMC1SVFQgcGFja2V0cyBldmVuIGlmIHRob3NlIHZhbHVlcyBhcmUgaW5jcmVhc2VkIGJ5IHRoZSBoYW5kc2hha2Ugb3IgYnkgZnJhbWVzIHNlbnQgaW4gMS1SVFQgcGFja2V0cy4gQSBzZXJ2ZXIgTUFZIHRyZWF0IHRoZSB1c2Ugb2YgdXBkYXRlZCB0cmFuc3BvcnQgcGFyYW1ldGVycyBpbiAwLVJUVCBhcyBhIGNvbm5lY3Rpb24gZXJyb3Igb2YgdHlwZSBQUk9UT0NPTF9WSU9MQVRJT04uIDcuNC4yLiBOZXcgVHJhbnNwb3J0IFBhcmFtZXRlcnMgTmV3IHRyYW5zcG9ydCBwYXJhbWV0ZXJzIGNhbiBiZSB1c2VkIHRvIG5lZ290aWF0ZSBuZXcgcHJvdG9jb2wgYmVoYXZpb3IuIEFuIGVuZHBvaW50IE1VU1QgaWdub3JlIHRyYW5zcG9ydCBwYXJhbWV0ZXJzIHRoYXQgaXQgZG9lcyBub3Qgc3VwcG9ydC4gVGhlIGFic2VuY2Ugb2YgYSB0cmFuc3BvcnQgcGFyYW1ldGVyIHRoZXJlZm9yZSBkaXNhYmxlcyBhbnkgb3B0aW9uYWwgcHJvdG9jb2wgZmVhdHVyZSB0aGF0IGlzIG5lZ290aWF0ZWQgdXNpbmcgdGhlIHBhcmFtZXRlci4gQXMgZGVzY3JpYmVkIGluIFNlY3Rpb24gMTguMSwgc29tZSBpZGVudGlmaWVycyBhcmUgcmVzZXJ2ZWQgaW4gb3JkZXIgdG8gZXhlcmNpc2UgdGhpcyByZXF1aXJlbWVudC4gQSBjbGllbnQgdGhhdCBkb2VzIG5vdCB1bmRlcnN0YW5kIGEgdHJhbnNwb3J0IHBhcmFtZXRlciBjYW4gZGlzY2FyZCBpdCBhbmQgYXR0ZW1wdCAwLVJUVCBvbiBzdWJzZXF1ZW50IGNvbm5lY3Rpb25zLiBIb3dldmVyLCBpZiB0aGUgY2xpZW50IGFkZHMgc3VwcG9ydCBmb3IgYSBkaXNjYXJkZWQgdHJhbnNwb3J0IHBhcmFtZXRlciwgaXQgcmlza3MgdmlvbGF0aW5nIHRoZSBjb25zdHJhaW50cyB0aGF0IHRoZSB0cmFuc3BvcnQgcGFyYW1ldGVyIGVzdGFibGlzaGVzIGlmIGl0IGF0dGVtcHRzIDAtUlRULiBOZXcgdHJhbnNwb3J0IHBhcmFtZXRlcnMgY2FuIGF2b2lkIHRoaXMgcHJvYmxlbSBieSBzZXR0aW5nIGEgZGVmYXVsdCBvZiB0aGUgbW9zdCBjb25zZXJ2YXRpdmUgdmFsdWUuIENsaWVudHMgY2FuIGF2b2lkIHRoaXMgcHJvYmxlbSBieSByZW1lbWJlcmluZyBhbGwgcGFyYW1ldGVycywgZXZlbiB0aG9zZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZC4gTmV3IHRyYW5zcG9ydCBwYXJhbWV0ZXJzIGNhbiBiZSByZWdpc3RlcmVkIGFjY29yZGluZyB0byB0aGUgcnVsZXMgaW4gU2VjdGlvbiAyMi4zLiA3LjUuIENyeXB0b2dyYXBoaWMgTWVzc2FnZSBCdWZmZXJpbmcgSW1wbGVtZW50YXRpb25zIG5lZWQgdG8gbWFpbnRhaW4gYSBidWZmZXIgb2YgQ1JZUFRPIGRhdGEgcmVjZWl2ZWQgb3V0IG9mIG9yZGVyLiBCZWNhdXNlIHRoZXJlIGlzIG5vIGZsb3cgY29udHJvbCBvZiBDUllQVE8gZnJhbWVzLCBhbiBlbmRwb2ludCBjb3VsZCBwb3RlbnRpYWxseSBmb3JjZSBpdHMgcGVlciB0byBidWZmZXIgYW4gdW5ib3VuZGVkIGFtb3VudCBvZiBkYXRhLiBJbXBsZW1lbnRhdGlvbnMgTVVTVCBzdXBwb3J0IGJ1ZmZlcmluZyBhdCBsZWFzdCA0MDk2IGJ5dGVzIG9mIGRhdGEgcmVjZWl2ZWQgaW4gb3V0LW9mLW9yZGVyIENSWVBUTyBmcmFtZXMuIEVuZHBvaW50cyBNQVkgY2hvb3NlIHRvIGFsbG93IG1vcmUgZGF0YSB0byBiZSBidWZmZXJlZCBkdXJpbmcgdGhlIGhhbmRzaGFrZS4gQSBsYXJnZXIgbGltaXQgZHVyaW5nIHRoZSBoYW5kc2hha2UgY291bGQgYWxsb3cgZm9yIGxhcmdlciBrZXlzIG9yIGNyZWRlbnRpYWxzIHRvIGJlIGV4Y2hhbmdlZC4gQW4gZW5kcG9pbnQncyBidWZmZXIgc2l6ZSBkb2VzIG5vdCBuZWVkIHRvIHJlbWFpbiBjb25zdGFudCBkdXJpbmcgdGhlIGxpZmUgb2YgdGhlIGNvbm5lY3Rpb24uIEJlaW5nIHVuYWJsZSB0byBidWZmZXIgQ1JZUFRPIGZyYW1lcyBkdXJpbmcgdGhlIGhhbmRzaGFrZSBjYW4gbGVhZCB0byBhIGNvbm5lY3Rpb24gZmFpbHVyZS4gSWYgYW4gZW5kcG9pbnQncyBidWZmZXIgaXMgZXhjZWVkZWQgZHVyaW5nIHRoZSBoYW5kc2hha2UsIGl0IGNhbiBleHBhbmQgaXRzIGJ1ZmZlciB0ZW1wb3JhcmlseSB0byBjb21wbGV0ZSB0aGUgaGFuZHNoYWtlLiBJZiBhbiBlbmRwb2ludCBkb2VzIG5vdCBleHBhbmQgaXRzIGJ1ZmZlciwgaXQgTVVTVCBjbG9zZSB0aGUgY29ubmVjdGlvbiB3aXRoIGEgQ1JZUFRPX0JVRkZFUl9FWENFRURFRCBlcnJvciBjb2RlLiBPbmNlIHRoZSBoYW5kc2hha2UgY29tcGxldGVzLCBpZiBhbiBlbmRwb2ludCBpcyB1bmFibGUgdG8gYnVmZmVyIGFsbCBkYXRhIGluIGEgQ1JZUFRPIGZyYW1lLCBpdCBNQVkgZGlzY2FyZCB0aGF0IENSWVBUTyBmcmFtZSBhbmQgYWxsIENSWVBUTyBmcmFtZXMgcmVjZWl2ZWQgaW4gdGhlIGZ1dHVyZSwgb3IgaXQgTUFZIGNsb3NlIHRoZSBjb25uZWN0aW9uIHdpdGggYSBDUllQVE9fQlVGRkVSX0VYQ0VFREVEIGVycm9yIGNvZGUuIFBhY2tldHMgY29udGFpbmluZyBkaXNjYXJkZWQgQ1JZUFRPIGZyYW1lcyBNVVNUIGJlIGFja25vd2xlZGdlZCBiZWNhdXNlIHRoZSBwYWNrZXQgaGFzIGJlZW4gcmVjZWl2ZWQgYW5kIHByb2Nlc3NlZCBieSB0aGUgdHJhbnNwb3J0IGV2ZW4gdGhvdWdoIHRoZSBDUllQVE8gZnJhbWUgd2FzIGRpc2NhcmRlZC4gOC4gQWRkcmVzcyBWYWxpZGF0aW9uIEFkZHJlc3MgdmFsaWRhdGlvbiBlbnN1cmVzIHRoYXQgYW4gZW5kcG9pbnQgY2Fubm90IGJlIHVzZWQgZm9yIGEgdHJhZmZpYyBhbXBsaWZpY2F0aW9uIGF0dGFjay4gSW4gc3VjaCBhbiBhdHRhY2ssIGEgcGFja2V0IGlzIHNlbnQgdG8gYSBzZXJ2ZXIgd2l0aCBzcG9vZmVkIHNvdXJjZSBhZGRyZXNzIGluZm9ybWF0aW9uIHRoYXQgaWRlbnRpZmllcyBhIHZpY3RpbS4gSWYgYSBzZXJ2ZXIgZ2VuZXJhdGVzIG1vcmUgb3IgbGFyZ2VyIHBhY2tldHMgaW4gcmVzcG9uc2UgdG8gdGhhdCBwYWNrZXQsIHRoZSBhdHRhY2tlciBjYW4gdXNlIHRoZSBzZXJ2ZXIgdG8gc2VuZCBtb3JlIGRhdGEgdG93YXJkIHRoZSB2aWN0aW0gdGhhbiBpdCB3b3VsZCBiZSBhYmxlIHRvIHNlbmQgb24gaXRzIG93bi4gVGhlIHByaW1hcnkgZGVmZW5zZSBhZ2FpbnN0IGFtcGxpZmljYXRpb24gYXR0YWNrcyBpcyB2ZXJpZnlpbmcgdGhhdCBhIHBlZXIgaXMgYWJsZSB0byByZWNlaXZlIHBhY2tldHMgYXQgdGhlIHRyYW5zcG9ydCBhZGRyZXNzIHRoYXQgaXQgY2xhaW1zLiBUaGVyZWZvcmUsIGFmdGVyIHJlY2VpdmluZyBwYWNrZXRzIGZyb20gYW4gYWRkcmVzcyB0aGF0IGlzIG5vdCB5ZXQgdmFsaWRhdGVkLCBhbiBlbmRwb2ludCBNVVNUIGxpbWl0IHRoZSBhbW91bnQgb2YgZGF0YSBpdCBzZW5kcyB0byB0aGUgdW52YWxpZGF0ZWQgYWRkcmVzcyB0byB0aHJlZSB0aW1lcyB0aGUgYW1vdW50IG9mIGRhdGEgcmVjZWl2ZWQgZnJvbSB0aGF0IGFkZHJlc3MuIFRoaXMgbGltaXQgb24gdGhlIHNpemUgb2YgcmVzcG9uc2VzIGlzIGtub3duIGFzIHRoZSBhbnRpLWFtcGxpZmljYXRpb24gbGltaXQuIEFkZHJlc3MgdmFsaWRhdGlvbiBpcyBwZXJmb3JtZWQgYm90aCBkdXJpbmcgY29ubmVjdGlvbiBlc3RhYmxpc2htZW50IChzZWUgU2VjdGlvbiA4LjEpIGFuZCBkdXJpbmcgY29ubmVjdGlvbiBtaWdyYXRpb24gKHNlZSBTZWN0aW9uIDguMikuIDguMS4gQWRkcmVzcyBWYWxpZGF0aW9uIGR1cmluZyBDb25uZWN0aW9uIEVzdGFibGlzaG1lbnQgQ29ubmVjdGlvbiBlc3RhYmxpc2htZW50IGltcGxpY2l0bHkgcHJvdmlkZXMgYWRkcmVzcyB2YWxpZGF0aW9uIGZvciBib3RoIGVuZHBvaW50cy4gSW4gcGFydGljdWxhciwgcmVjZWlwdCBvZiBhIHBhY2tldCBwcm90ZWN0ZWQgd2l0aCBIYW5kc2hha2Uga2V5cyBjb25maXJtcyB0aGF0IHRoZSBwZWVyIHN1Y2Nlc3NmdWxseSBwcm9jZXNzZWQgYW4gSW5pdGlhbCBwYWNrZXQuIE9uY2UgYW4gZW5kcG9pbnQgaGFzIHN1Y2Nlc3NmdWxseSBwcm9jZXNzZWQgYSBIYW5kc2hha2UgcGFja2V0IGZyb20gdGhlIHBlZXIsIGl0IGNhbiBjb25zaWRlciB0aGUgcGVlciBhZGRyZXNzIHRvIGhhdmUgYmVlbiB2YWxpZGF0ZWQuIEFkZGl0aW9uYWxseSwgYW4gZW5kcG9pbnQgTUFZIGNvbnNpZGVyIHRoZSBwZWVyIGFkZHJlc3MgdmFsaWRhdGVkIGlmIHRoZSBwZWVyIHVzZXMgYSBjb25uZWN0aW9uIElEIGNob3NlbiBieSB0aGUgZW5kcG9pbnQgYW5kIHRoZSBjb25uZWN0aW9uIElEIGNvbnRhaW5zIGF0IGxlYXN0IDY0IGJpdHMgb2YgZW50cm9weS4gRm9yIHRoZSBjbGllbnQsIHRoZSB2YWx1ZSBvZiB0aGUgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBmaWVsZCBpbiBpdHMgZmlyc3QgSW5pdGlhbCBwYWNrZXQgYWxsb3dzIGl0IHRvIHZhbGlkYXRlIHRoZSBzZXJ2ZXIgYWRkcmVzcyBhcyBhIHBhcnQgb2Ygc3VjY2Vzc2Z1bGx5IHByb2Nlc3NpbmcgYW55IHBhY2tldC4gSW5pdGlhbCBwYWNrZXRzIGZyb20gdGhlIHNlcnZlciBhcmUgcHJvdGVjdGVkIHdpdGgga2V5cyB0aGF0IGFyZSBkZXJpdmVkIGZyb20gdGhpcyB2YWx1ZSAoc2VlIFNlY3Rpb24gNS4yIG9mIFtRVUlDLVRMU10pLiBBbHRlcm5hdGl2ZWx5LCB0aGUgdmFsdWUgaXMgZWNob2VkIGJ5IHRoZSBzZXJ2ZXIgaW4gVmVyc2lvbiBOZWdvdGlhdGlvbiBwYWNrZXRzIChTZWN0aW9uIDYpIG9yIGluY2x1ZGVkIGluIHRoZSBJbnRlZ3JpdHkgVGFnIGluIFJldHJ5IHBhY2tldHMgKFNlY3Rpb24gNS44IG9mIFtRVUlDLVRMU10pLiBQcmlvciB0byB2YWxpZGF0aW5nIHRoZSBjbGllbnQgYWRkcmVzcywgc2VydmVycyBNVVNUIE5PVCBzZW5kIG1vcmUgdGhhbiB0aHJlZSB0aW1lcyBhcyBtYW55IGJ5dGVzIGFzIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhleSBoYXZlIHJlY2VpdmVkLiBUaGlzIGxpbWl0cyB0aGUgbWFnbml0dWRlIG9mIGFueSBhbXBsaWZpY2F0aW9uIGF0dGFjayB0aGF0IGNhbiBiZSBtb3VudGVkIHVzaW5nIHNwb29mZWQgc291cmNlIGFkZHJlc3Nlcy4gRm9yIHRoZSBwdXJwb3NlcyBvZiBhdm9pZGluZyBhbXBsaWZpY2F0aW9uIHByaW9yIHRvIGFkZHJlc3MgdmFsaWRhdGlvbiwgc2VydmVycyBNVVNUIGNvdW50IGFsbCBvZiB0aGUgcGF5bG9hZCBieXRlcyByZWNlaXZlZCBpbiBkYXRhZ3JhbXMgdGhhdCBhcmUgdW5pcXVlbHkgYXR0cmlidXRlZCB0byBhIHNpbmdsZSBjb25uZWN0aW9uLiBUaGlzIGluY2x1ZGVzIGRhdGFncmFtcyB0aGF0IGNvbnRhaW4gcGFja2V0cyB0aGF0IGFyZSBzdWNjZXNzZnVsbHkgcHJvY2Vzc2VkIGFuZCBkYXRhZ3JhbXMgdGhhdCBjb250YWluIHBhY2tldHMgdGhhdCBhcmUgYWxsIGRpc2NhcmRlZC4gQ2xpZW50cyBNVVNUIGVuc3VyZSB0aGF0IFVEUCBkYXRhZ3JhbXMgY29udGFpbmluZyBJbml0aWFsIHBhY2tldHMgaGF2ZSBVRFAgcGF5bG9hZHMgb2YgYXQgbGVhc3QgMTIwMCBieXRlcywgYWRkaW5nIFBBRERJTkcgZnJhbWVzIGFzIG5lY2Vzc2FyeS4gQSBjbGllbnQgdGhhdCBzZW5kcyBwYWRkZWQgZGF0YWdyYW1zIGFsbG93cyB0aGUgc2VydmVyIHRvIHNlbmQgbW9yZSBkYXRhIHByaW9yIHRvIGNvbXBsZXRpbmcgYWRkcmVzcyB2YWxpZGF0aW9uLiBMb3NzIG9mIGFuIEluaXRpYWwgb3IgSGFuZHNoYWtlIHBhY2tldCBmcm9tIHRoZSBzZXJ2ZXIgY2FuIGNhdXNlIGEgZGVhZGxvY2sgaWYgdGhlIGNsaWVudCBkb2VzIG5vdCBzZW5kIGFkZGl0aW9uYWwgSW5pdGlhbCBvciBIYW5kc2hha2UgcGFja2V0cy4gQSBkZWFkbG9jayBjb3VsZCBvY2N1ciB3aGVuIHRoZSBzZXJ2ZXIgcmVhY2hlcyBpdHMgYW50aS0gYW1wbGlmaWNhdGlvbiBsaW1pdCBhbmQgdGhlIGNsaWVudCBoYXMgcmVjZWl2ZWQgYWNrbm93bGVkZ21lbnRzIGZvciBhbGwgdGhlIGRhdGEgaXQgaGFzIHNlbnQuIEluIHRoaXMgY2FzZSwgd2hlbiB0aGUgY2xpZW50IGhhcyBubyByZWFzb24gdG8gc2VuZCBhZGRpdGlvbmFsIHBhY2tldHMsIHRoZSBzZXJ2ZXIgd2lsbCBiZSB1bmFibGUgdG8gc2VuZCBtb3JlIGRhdGEgYmVjYXVzZSBpdCBoYXMgbm90IHZhbGlkYXRlZCB0aGUgY2xpZW50J3MgYWRkcmVzcy4gVG8gcHJldmVudCB0aGlzIGRlYWRsb2NrLCBjbGllbnRzIE1VU1Qgc2VuZCBhIHBhY2tldCBvbiBhIFByb2JlIFRpbWVvdXQgKFBUTyk7IHNlZSBTZWN0aW9uIDYuMiBvZiBbUVVJQy1SRUNPVkVSWV0uIFNwZWNpZmljYWxseSwgdGhlIGNsaWVudCBNVVNUIHNlbmQgYW4gSW5pdGlhbCBwYWNrZXQgaW4gYSBVRFAgZGF0YWdyYW0gdGhhdCBjb250YWlucyBhdCBsZWFzdCAxMjAwIGJ5dGVzIGlmIGl0IGRvZXMgbm90IGhhdmUgSGFuZHNoYWtlIGtleXMsIGFuZCBvdGhlcndpc2Ugc2VuZCBhIEhhbmRzaGFrZSBwYWNrZXQuIEEgc2VydmVyIG1pZ2h0IHdpc2ggdG8gdmFsaWRhdGUgdGhlIGNsaWVudCBhZGRyZXNzIGJlZm9yZSBzdGFydGluZyB0aGUgY3J5cHRvZ3JhcGhpYyBoYW5kc2hha2UuIFFVSUMgdXNlcyBhIHRva2VuIGluIHRoZSBJbml0aWFsIHBhY2tldCB0byBwcm92aWRlIGFkZHJlc3MgdmFsaWRhdGlvbiBwcmlvciB0byBjb21wbGV0aW5nIHRoZSBoYW5kc2hha2UuIFRoaXMgdG9rZW4gaXMgZGVsaXZlcmVkIHRvIHRoZSBjbGllbnQgZHVyaW5nIGNvbm5lY3Rpb24gZXN0YWJsaXNobWVudCB3aXRoIGEgUmV0cnkgcGFja2V0IChzZWUgU2VjdGlvbiA4LjEuMikgb3IgaW4gYSBwcmV2aW91cyBjb25uZWN0aW9uIHVzaW5nIHRoZSBORVdfVE9LRU4gZnJhbWUgKHNlZSBTZWN0aW9uIDguMS4zKS4gSW4gYWRkaXRpb24gdG8gc2VuZGluZyBsaW1pdHMgaW1wb3NlZCBwcmlvciB0byBhZGRyZXNzIHZhbGlkYXRpb24sIHNlcnZlcnMgYXJlIGFsc28gY29uc3RyYWluZWQgaW4gd2hhdCB0aGV5IGNhbiBzZW5kIGJ5IHRoZSBsaW1pdHMgc2V0IGJ5IHRoZSBjb25nZXN0aW9uIGNvbnRyb2xsZXIuIENsaWVudHMgYXJlIG9ubHkgY29uc3RyYWluZWQgYnkgdGhlIGNvbmdlc3Rpb24gY29udHJvbGxlci4gOC4xLjEuIFRva2VuIENvbnN0cnVjdGlvbiBBIHRva2VuIHNlbnQgaW4gYSBORVdfVE9LRU4gZnJhbWUgb3IgYSBSZXRyeSBwYWNrZXQgTVVTVCBiZSBjb25zdHJ1Y3RlZCBpbiBhIHdheSB0aGF0IGFsbG93cyB0aGUgc2VydmVyIHRvIGlkZW50aWZ5IGhvdyBpdCB3YXMgcHJvdmlkZWQgdG8gYSBjbGllbnQuIFRoZXNlIHRva2VucyBhcmUgY2FycmllZCBpbiB0aGUgc2FtZSBmaWVsZCBidXQgcmVxdWlyZSBkaWZmZXJlbnQgaGFuZGxpbmcgZnJvbSBzZXJ2ZXJzLiA4LjEuMi4gQWRkcmVzcyBWYWxpZGF0aW9uIFVzaW5nIFJldHJ5IFBhY2tldHMgVXBvbiByZWNlaXZpbmcgdGhlIGNsaWVudCdzIEluaXRpYWwgcGFja2V0LCB0aGUgc2VydmVyIGNhbiByZXF1ZXN0IGFkZHJlc3MgdmFsaWRhdGlvbiBieSBzZW5kaW5nIGEgUmV0cnkgcGFja2V0IChTZWN0aW9uIDE3LjIuNSkgY29udGFpbmluZyBhIHRva2VuLiBUaGlzIHRva2VuIE1VU1QgYmUgcmVwZWF0ZWQgYnkgdGhlIGNsaWVudCBpbiBhbGwgSW5pdGlhbCBwYWNrZXRzIGl0IHNlbmRzIGZvciB0aGF0IGNvbm5lY3Rpb24gYWZ0ZXIgaXQgcmVjZWl2ZXMgdGhlIFJldHJ5IHBhY2tldC4gSW4gcmVzcG9uc2UgdG8gcHJvY2Vzc2luZyBhbiBJbml0aWFsIHBhY2tldCBjb250YWluaW5nIGEgdG9rZW4gdGhhdCB3YXMgcHJvdmlkZWQgaW4gYSBSZXRyeSBwYWNrZXQsIGEgc2VydmVyIGNhbm5vdCBzZW5kIGFub3RoZXIgUmV0cnkgcGFja2V0OyBpdCBjYW4gb25seSByZWZ1c2UgdGhlIGNvbm5lY3Rpb24gb3IgcGVybWl0IGl0IHRvIHByb2NlZWQuIEFzIGxvbmcgYXMgaXQgaXMgbm90IHBvc3NpYmxlIGZvciBhbiBhdHRhY2tlciB0byBnZW5lcmF0ZSBhIHZhbGlkIHRva2VuIGZvciBpdHMgb3duIGFkZHJlc3MgKHNlZSBTZWN0aW9uIDguMS40KSBhbmQgdGhlIGNsaWVudCBpcyBhYmxlIHRvIHJldHVybiB0aGF0IHRva2VuLCBpdCBwcm92ZXMgdG8gdGhlIHNlcnZlciB0aGF0IGl0IHJlY2VpdmVkIHRoZSB0b2tlbi4gQSBzZXJ2ZXIgY2FuIGFsc28gdXNlIGEgUmV0cnkgcGFja2V0IHRvIGRlZmVyIHRoZSBzdGF0ZSBhbmQgcHJvY2Vzc2luZyBjb3N0cyBvZiBjb25uZWN0aW9uIGVzdGFibGlzaG1lbnQuIFJlcXVpcmluZyB0aGUgc2VydmVyIHRvIHByb3ZpZGUgYSBkaWZmZXJlbnQgY29ubmVjdGlvbiBJRCwgYWxvbmcgd2l0aCB0aGUgb3JpZ2luYWxfZGVzdGluYXRpb25fY29ubmVjdGlvbl9pZCB0cmFuc3BvcnQgcGFyYW1ldGVyIGRlZmluZWQgaW4gU2VjdGlvbiAxOC4yLCBmb3JjZXMgdGhlIHNlcnZlciB0byBkZW1vbnN0cmF0ZSB0aGF0IGl0LCBvciBhbiBlbnRpdHkgaXQgY29vcGVyYXRlcyB3aXRoLCByZWNlaXZlZCB0aGUgb3JpZ2luYWwgSW5pdGlhbCBwYWNrZXQgZnJvbSB0aGUgY2xpZW50LiBQcm92aWRpbmcgYSBkaWZmZXJlbnQgY29ubmVjdGlvbiBJRCBhbHNvIGdyYW50cyBhIHNlcnZlciBzb21lIGNvbnRyb2wgb3ZlciBob3cgc3Vic2VxdWVudCBwYWNrZXRzIGFyZSByb3V0ZWQuIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGlyZWN0IGNvbm5lY3Rpb25zIHRvIGEgZGlmZmVyZW50IHNlcnZlciBpbnN0YW5jZS4gSWYgYSBzZXJ2ZXIgcmVjZWl2ZXMgYSBjbGllbnQgSW5pdGlhbCB0aGF0IGNvbnRhaW5zIGFuIGludmFsaWQgUmV0cnkgdG9rZW4gYnV0IGlzIG90aGVyd2lzZSB2YWxpZCwgaXQga25vd3MgdGhlIGNsaWVudCB3aWxsIG5vdCBhY2NlcHQgYW5vdGhlciBSZXRyeSB0b2tlbi4gVGhlIHNlcnZlciBjYW4gZGlzY2FyZCBzdWNoIGEgcGFja2V0IGFuZCBhbGxvdyB0aGUgY2xpZW50IHRvIHRpbWUgb3V0IHRvIGRldGVjdCBoYW5kc2hha2UgZmFpbHVyZSwgYnV0IHRoYXQgY291bGQgaW1wb3NlIGEgc2lnbmlmaWNhbnQgbGF0ZW5jeSBwZW5hbHR5IG9uIHRoZSBjbGllbnQuIEluc3RlYWQsIHRoZSBzZXJ2ZXIgU0hPVUxEIGltbWVkaWF0ZWx5IGNsb3NlIChTZWN0aW9uIDEwLjIpIHRoZSBjb25uZWN0aW9uIHdpdGggYW4gSU5WQUxJRF9UT0tFTiBlcnJvci4gTm90ZSB0aGF0IGEgc2VydmVyIGhhcyBub3QgZXN0YWJsaXNoZWQgYW55IHN0YXRlIGZvciB0aGUgY29ubmVjdGlvbiBhdCB0aGlzIHBvaW50IGFuZCBzbyBkb2VzIG5vdCBlbnRlciB0aGUgY2xvc2luZyBwZXJpb2QuIEEgZmxvdyBzaG93aW5nIHRoZSB1c2Ugb2YgYSBSZXRyeSBwYWNrZXQgaXMgc2hvd24gaW4gRmlndXJlIDkuIENsaWVudCBTZXJ2ZXIgSW5pdGlhbFswXTogQ1JZUFRPW0NIXSAtJmd0OyAmbHQ7LSBSZXRyeStUb2tlbiBJbml0aWFsK1Rva2VuWzFdOiBDUllQVE9bQ0hdIC0mZ3Q7IEluaXRpYWxbMF06IENSWVBUT1tTSF0gQUNLWzFdIEhhbmRzaGFrZVswXTogQ1JZUFRPW0VFLCBDRVJULCBDViwgRklOXSAmbHQ7LSAxLVJUVFswXTogU1RSRUFNWzEsICIuLi4iXSBGaWd1cmUgOTogRXhhbXBsZSBIYW5kc2hha2Ugd2l0aCBSZXRyeSA4LjEuMy4gQWRkcmVzcyBWYWxpZGF0aW9uIGZvciBGdXR1cmUgQ29ubmVjdGlvbnMgQSBzZXJ2ZXIgTUFZIHByb3ZpZGUgY2xpZW50cyB3aXRoIGFuIGFkZHJlc3MgdmFsaWRhdGlvbiB0b2tlbiBkdXJpbmcgb25lIGNvbm5lY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCBvbiBhIHN1YnNlcXVlbnQgY29ubmVjdGlvbi4gQWRkcmVzcyB2YWxpZGF0aW9uIGlzIGVzcGVjaWFsbHkgaW1wb3J0YW50IHdpdGggMC1SVFQgYmVjYXVzZSBhIHNlcnZlciBwb3RlbnRpYWxseSBzZW5kcyBhIHNpZ25pZmljYW50IGFtb3VudCBvZiBkYXRhIHRvIGEgY2xpZW50IGluIHJlc3BvbnNlIHRvIDAtUlRUIGRhdGEuIFRoZSBzZXJ2ZXIgdXNlcyB0aGUgTkVXX1RPS0VOIGZyYW1lIChTZWN0aW9uIDE5LjcpIHRvIHByb3ZpZGUgdGhlIGNsaWVudCB3aXRoIGFuIGFkZHJlc3MgdmFsaWRhdGlvbiB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHZhbGlkYXRlIGZ1dHVyZSBjb25uZWN0aW9ucy4gSW4gYSBmdXR1cmUgY29ubmVjdGlvbiwgdGhlIGNsaWVudCBpbmNsdWRlcyB0aGlzIHRva2VuIGluIEluaXRpYWwgcGFja2V0cyB0byBwcm92aWRlIGFkZHJlc3MgdmFsaWRhdGlvbi4gVGhlIGNsaWVudCBNVVNUIGluY2x1ZGUgdGhlIHRva2VuIGluIGFsbCBJbml0aWFsIHBhY2tldHMgaXQgc2VuZHMsIHVubGVzcyBhIFJldHJ5IHJlcGxhY2VzIHRoZSB0b2tlbiB3aXRoIGEgbmV3ZXIgb25lLiBUaGUgY2xpZW50IE1VU1QgTk9UIHVzZSB0aGUgdG9rZW4gcHJvdmlkZWQgaW4gYSBSZXRyeSBmb3IgZnV0dXJlIGNvbm5lY3Rpb25zLiBTZXJ2ZXJzIE1BWSBkaXNjYXJkIGFueSBJbml0aWFsIHBhY2tldCB0aGF0IGRvZXMgbm90IGNhcnJ5IHRoZSBleHBlY3RlZCB0b2tlbi4gVW5saWtlIHRoZSB0b2tlbiB0aGF0IGlzIGNyZWF0ZWQgZm9yIGEgUmV0cnkgcGFja2V0LCB3aGljaCBpcyB1c2VkIGltbWVkaWF0ZWx5LCB0aGUgdG9rZW4gc2VudCBpbiB0aGUgTkVXX1RPS0VOIGZyYW1lIGNhbiBiZSB1c2VkIGFmdGVyIHNvbWUgcGVyaW9kIG9mIHRpbWUgaGFzIHBhc3NlZC4gVGh1cywgYSB0b2tlbiBTSE9VTEQgaGF2ZSBhbiBleHBpcmF0aW9uIHRpbWUsIHdoaWNoIGNvdWxkIGJlIGVpdGhlciBhbiBleHBsaWNpdCBleHBpcmF0aW9uIHRpbWUgb3IgYW4gaXNzdWVkIHRpbWVzdGFtcCB0aGF0IGNhbiBiZSB1c2VkIHRvIGR5bmFtaWNhbGx5IGNhbGN1bGF0ZSB0aGUgZXhwaXJhdGlvbiB0aW1lLiBBIHNlcnZlciBjYW4gc3RvcmUgdGhlIGV4cGlyYXRpb24gdGltZSBvciBpbmNsdWRlIGl0IGluIGFuIGVuY3J5cHRlZCBmb3JtIGluIHRoZSB0b2tlbi4gQSB0b2tlbiBpc3N1ZWQgd2l0aCBORVdfVE9LRU4gTVVTVCBOT1QgaW5jbHVkZSBpbmZvcm1hdGlvbiB0aGF0IHdvdWxkIGFsbG93IHZhbHVlcyB0byBiZSBsaW5rZWQgYnkgYW4gb2JzZXJ2ZXIgdG8gdGhlIGNvbm5lY3Rpb24gb24gd2hpY2ggaXQgd2FzIGlzc3VlZC4gRm9yIGV4YW1wbGUsIGl0IGNhbm5vdCBpbmNsdWRlIHRoZSBwcmV2aW91cyBjb25uZWN0aW9uIElEIG9yIGFkZHJlc3NpbmcgaW5mb3JtYXRpb24sIHVubGVzcyB0aGUgdmFsdWVzIGFyZSBlbmNyeXB0ZWQuIEEgc2VydmVyIE1VU1QgZW5zdXJlIHRoYXQgZXZlcnkgTkVXX1RPS0VOIGZyYW1lIGl0IHNlbmRzIGlzIHVuaXF1ZSBhY3Jvc3MgYWxsIGNsaWVudHMsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiB0aG9zZSBzZW50IHRvIHJlcGFpciBsb3NzZXMgb2YgcHJldmlvdXNseSBzZW50IE5FV19UT0tFTiBmcmFtZXMuIEluZm9ybWF0aW9uIHRoYXQgYWxsb3dzIHRoZSBzZXJ2ZXIgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0b2tlbnMgZnJvbSBSZXRyeSBhbmQgTkVXX1RPS0VOIE1BWSBiZSBhY2Nlc3NpYmxlIHRvIGVudGl0aWVzIG90aGVyIHRoYW4gdGhlIHNlcnZlci4gSXQgaXMgdW5saWtlbHkgdGhhdCB0aGUgY2xpZW50IHBvcnQgbnVtYmVyIGlzIHRoZSBzYW1lIG9uIHR3byBkaWZmZXJlbnQgY29ubmVjdGlvbnM7IHZhbGlkYXRpbmcgdGhlIHBvcnQgaXMgdGhlcmVmb3JlIHVubGlrZWx5IHRvIGJlIHN1Y2Nlc3NmdWwuIEEgdG9rZW4gcmVjZWl2ZWQgaW4gYSBORVdfVE9LRU4gZnJhbWUgaXMgYXBwbGljYWJsZSB0byBhbnkgc2VydmVyIHRoYXQgdGhlIGNvbm5lY3Rpb24gaXMgY29uc2lkZXJlZCBhdXRob3JpdGF0aXZlIGZvciAoZS5nLiwgc2VydmVyIG5hbWVzIGluY2x1ZGVkIGluIHRoZSBjZXJ0aWZpY2F0ZSkuIFdoZW4gY29ubmVjdGluZyB0byBhIHNlcnZlciBmb3Igd2hpY2ggdGhlIGNsaWVudCByZXRhaW5zIGFuIGFwcGxpY2FibGUgYW5kIHVudXNlZCB0b2tlbiwgaXQgU0hPVUxEIGluY2x1ZGUgdGhhdCB0b2tlbiBpbiB0aGUgVG9rZW4gZmllbGQgb2YgaXRzIEluaXRpYWwgcGFja2V0LiBJbmNsdWRpbmcgYSB0b2tlbiBtaWdodCBhbGxvdyB0aGUgc2VydmVyIHRvIHZhbGlkYXRlIHRoZSBjbGllbnQgYWRkcmVzcyB3aXRob3V0IGFuIGFkZGl0aW9uYWwgcm91bmQgdHJpcC4gQSBjbGllbnQgTVVTVCBOT1QgaW5jbHVkZSBhIHRva2VuIHRoYXQgaXMgbm90IGFwcGxpY2FibGUgdG8gdGhlIHNlcnZlciB0aGF0IGl0IGlzIGNvbm5lY3RpbmcgdG8sIHVubGVzcyB0aGUgY2xpZW50IGhhcyB0aGUga25vd2xlZGdlIHRoYXQgdGhlIHNlcnZlciB0aGF0IGlzc3VlZCB0aGUgdG9rZW4gYW5kIHRoZSBzZXJ2ZXIgdGhlIGNsaWVudCBpcyBjb25uZWN0aW5nIHRvIGFyZSBqb2ludGx5IG1hbmFnaW5nIHRoZSB0b2tlbnMuIEEgY2xpZW50IE1BWSB1c2UgYSB0b2tlbiBmcm9tIGFueSBwcmV2aW91cyBjb25uZWN0aW9uIHRvIHRoYXQgc2VydmVyLiBBIHRva2VuIGFsbG93cyBhIHNlcnZlciB0byBjb3JyZWxhdGUgYWN0aXZpdHkgYmV0d2VlbiB0aGUgY29ubmVjdGlvbiB3aGVyZSB0aGUgdG9rZW4gd2FzIGlzc3VlZCBhbmQgYW55IGNvbm5lY3Rpb24gd2hlcmUgaXQgaXMgdXNlZC4gQ2xpZW50cyB0aGF0IHdhbnQgdG8gYnJlYWsgY29udGludWl0eSBvZiBpZGVudGl0eSB3aXRoIGEgc2VydmVyIGNhbiBkaXNjYXJkIHRva2VucyBwcm92aWRlZCB1c2luZyB0aGUgTkVXX1RPS0VOIGZyYW1lLiBJbiBjb21wYXJpc29uLCBhIHRva2VuIG9idGFpbmVkIGluIGEgUmV0cnkgcGFja2V0IE1VU1QgYmUgdXNlZCBpbW1lZGlhdGVseSBkdXJpbmcgdGhlIGNvbm5lY3Rpb24gYXR0ZW1wdCBhbmQgY2Fubm90IGJlIHVzZWQgaW4gc3Vic2VxdWVudCBjb25uZWN0aW9uIGF0dGVtcHRzLiBBIGNsaWVudCBTSE9VTEQgTk9UIHJldXNlIGEgdG9rZW4gZnJvbSBhIE5FV19UT0tFTiBmcmFtZSBmb3IgZGlmZmVyZW50IGNvbm5lY3Rpb24gYXR0ZW1wdHMuIFJldXNpbmcgYSB0b2tlbiBhbGxvd3MgY29ubmVjdGlvbnMgdG8gYmUgbGlua2VkIGJ5IGVudGl0aWVzIG9uIHRoZSBuZXR3b3JrIHBhdGg7IHNlZSBTZWN0aW9uIDkuNS4gQ2xpZW50cyBtaWdodCByZWNlaXZlIG11bHRpcGxlIHRva2VucyBvbiBhIHNpbmdsZSBjb25uZWN0aW9uLiBBc2lkZSBmcm9tIHByZXZlbnRpbmcgbGlua2FiaWxpdHksIGFueSB0b2tlbiBjYW4gYmUgdXNlZCBpbiBhbnkgY29ubmVjdGlvbiBhdHRlbXB0LiBTZXJ2ZXJzIGNhbiBzZW5kIGFkZGl0aW9uYWwgdG9rZW5zIHRvIGVpdGhlciBlbmFibGUgYWRkcmVzcyB2YWxpZGF0aW9uIGZvciBtdWx0aXBsZSBjb25uZWN0aW9uIGF0dGVtcHRzIG9yIHJlcGxhY2Ugb2xkZXIgdG9rZW5zIHRoYXQgbWlnaHQgYmVjb21lIGludmFsaWQuIEZvciBhIGNsaWVudCwgdGhpcyBhbWJpZ3VpdHkgbWVhbnMgdGhhdCBzZW5kaW5nIHRoZSBtb3N0IHJlY2VudCB1bnVzZWQgdG9rZW4gaXMgbW9zdCBsaWtlbHkgdG8gYmUgZWZmZWN0aXZlLiBUaG91Z2ggc2F2aW5nIGFuZCB1c2luZyBvbGRlciB0b2tlbnMgaGF2ZSBubyBuZWdhdGl2ZSBjb25zZXF1ZW5jZXMsIGNsaWVudHMgY2FuIHJlZ2FyZCBvbGRlciB0b2tlbnMgYXMgYmVpbmcgbGVzcyBsaWtlbHkgdG8gYmUgdXNlZnVsIHRvIHRoZSBzZXJ2ZXIgZm9yIGFkZHJlc3MgdmFsaWRhdGlvbi4gV2hlbiBhIHNlcnZlciByZWNlaXZlcyBhbiBJbml0aWFsIHBhY2tldCB3aXRoIGFuIGFkZHJlc3MgdmFsaWRhdGlvbiB0b2tlbiwgaXQgTVVTVCBhdHRlbXB0IHRvIHZhbGlkYXRlIHRoZSB0b2tlbiwgdW5sZXNzIGl0IGhhcyBhbHJlYWR5IGNvbXBsZXRlZCBhZGRyZXNzIHZhbGlkYXRpb24uIElmIHRoZSB0b2tlbiBpcyBpbnZhbGlkLCB0aGVuIHRoZSBzZXJ2ZXIgU0hPVUxEIHByb2NlZWQgYXMgaWYgdGhlIGNsaWVudCBkaWQgbm90IGhhdmUgYSB2YWxpZGF0ZWQgYWRkcmVzcywgaW5jbHVkaW5nIHBvdGVudGlhbGx5IHNlbmRpbmcgYSBSZXRyeSBwYWNrZXQuIFRva2VucyBwcm92aWRlZCB3aXRoIE5FV19UT0tFTiBmcmFtZXMgYW5kIFJldHJ5IHBhY2tldHMgY2FuIGJlIGRpc3Rpbmd1aXNoZWQgYnkgc2VydmVycyAoc2VlIFNlY3Rpb24gOC4xLjEpLCBhbmQgdGhlIGxhdHRlciBjYW4gYmUgdmFsaWRhdGVkIG1vcmUgc3RyaWN0bHkuIElmIHRoZSB2YWxpZGF0aW9uIHN1Y2NlZWRzLCB0aGUgc2VydmVyIFNIT1VMRCB0aGVuIGFsbG93IHRoZSBoYW5kc2hha2UgdG8gcHJvY2VlZC4gfCBOb3RlOiBUaGUgcmF0aW9uYWxlIGZvciB0cmVhdGluZyB0aGUgY2xpZW50IGFzIHVudmFsaWRhdGVkIHwgcmF0aGVyIHRoYW4gZGlzY2FyZGluZyB0aGUgcGFja2V0IGlzIHRoYXQgdGhlIGNsaWVudCBtaWdodCBoYXZlIHwgcmVjZWl2ZWQgdGhlIHRva2VuIGluIGEgcHJldmlvdXMgY29ubmVjdGlvbiB1c2luZyB0aGUgTkVXX1RPS0VOIHwgZnJhbWUsIGFuZCBpZiB0aGUgc2VydmVyIGhhcyBsb3N0IHN0YXRlLCBpdCBtaWdodCBiZSB1bmFibGUgdG8gfCB2YWxpZGF0ZSB0aGUgdG9rZW4gYXQgYWxsLCBsZWFkaW5nIHRvIGNvbm5lY3Rpb24gZmFpbHVyZSBpZiB0aGUgfCBwYWNrZXQgaXMgZGlzY2FyZGVkLiBJbiBhIHN0YXRlbGVzcyBkZXNpZ24sIGEgc2VydmVyIGNhbiB1c2UgZW5jcnlwdGVkIGFuZCBhdXRoZW50aWNhdGVkIHRva2VucyB0byBwYXNzIGluZm9ybWF0aW9uIHRvIGNsaWVudHMgdGhhdCB0aGUgc2VydmVyIGNhbiBsYXRlciByZWNvdmVyIGFuZCB1c2UgdG8gdmFsaWRhdGUgYSBjbGllbnQgYWRkcmVzcy4gVG9rZW5zIGFyZSBub3QgaW50ZWdyYXRlZCBpbnRvIHRoZSBjcnlwdG9ncmFwaGljIGhhbmRzaGFrZSwgYW5kIHNvIHRoZXkgYXJlIG5vdCBhdXRoZW50aWNhdGVkLiBGb3IgaW5zdGFuY2UsIGEgY2xpZW50IG1pZ2h0IGJlIGFibGUgdG8gcmV1c2UgYSB0b2tlbi4gVG8gYXZvaWQgYXR0YWNrcyB0aGF0IGV4cGxvaXQgdGhpcyBwcm9wZXJ0eSwgYSBzZXJ2ZXIgY2FuIGxpbWl0IGl0cyB1c2Ugb2YgdG9rZW5zIHRvIG9ubHkgdGhlIGluZm9ybWF0aW9uIG5lZWRlZCB0byB2YWxpZGF0ZSBjbGllbnQgYWRkcmVzc2VzLiBDbGllbnRzIE1BWSB1c2UgdG9rZW5zIG9idGFpbmVkIG9uIG9uZSBjb25uZWN0aW9uIGZvciBhbnkgY29ubmVjdGlvbiBhdHRlbXB0IHVzaW5nIHRoZSBzYW1lIHZlcnNpb24uIFdoZW4gc2VsZWN0aW5nIGEgdG9rZW4gdG8gdXNlLCBjbGllbnRzIGRvIG5vdCBuZWVkIHRvIGNvbnNpZGVyIG90aGVyIHByb3BlcnRpZXMgb2YgdGhlIGNvbm5lY3Rpb24gdGhhdCBpcyBiZWluZyBhdHRlbXB0ZWQsIGluY2x1ZGluZyB0aGUgY2hvaWNlIG9mIHBvc3NpYmxlIGFwcGxpY2F0aW9uIHByb3RvY29scywgc2Vzc2lvbiB0aWNrZXRzLCBvciBvdGhlciBjb25uZWN0aW9uIHByb3BlcnRpZXMuIDguMS40LiBBZGRyZXNzIFZhbGlkYXRpb24gVG9rZW4gSW50ZWdyaXR5IEFuIGFkZHJlc3MgdmFsaWRhdGlvbiB0b2tlbiBNVVNUIGJlIGRpZmZpY3VsdCB0byBndWVzcy4gSW5jbHVkaW5nIGEgcmFuZG9tIHZhbHVlIHdpdGggYXQgbGVhc3QgMTI4IGJpdHMgb2YgZW50cm9weSBpbiB0aGUgdG9rZW4gd291bGQgYmUgc3VmZmljaWVudCwgYnV0IHRoaXMgZGVwZW5kcyBvbiB0aGUgc2VydmVyIHJlbWVtYmVyaW5nIHRoZSB2YWx1ZSBpdCBzZW5kcyB0byBjbGllbnRzLiBBIHRva2VuLWJhc2VkIHNjaGVtZSBhbGxvd3MgdGhlIHNlcnZlciB0byBvZmZsb2FkIGFueSBzdGF0ZSBhc3NvY2lhdGVkIHdpdGggdmFsaWRhdGlvbiB0byB0aGUgY2xpZW50LiBGb3IgdGhpcyBkZXNpZ24gdG8gd29yaywgdGhlIHRva2VuIE1VU1QgYmUgY292ZXJlZCBieSBpbnRlZ3JpdHkgcHJvdGVjdGlvbiBhZ2FpbnN0IG1vZGlmaWNhdGlvbiBvciBmYWxzaWZpY2F0aW9uIGJ5IGNsaWVudHMuIFdpdGhvdXQgaW50ZWdyaXR5IHByb3RlY3Rpb24sIG1hbGljaW91cyBjbGllbnRzIGNvdWxkIGdlbmVyYXRlIG9yIGd1ZXNzIHZhbHVlcyBmb3IgdG9rZW5zIHRoYXQgd291bGQgYmUgYWNjZXB0ZWQgYnkgdGhlIHNlcnZlci4gT25seSB0aGUgc2VydmVyIHJlcXVpcmVzIGFjY2VzcyB0byB0aGUgaW50ZWdyaXR5IHByb3RlY3Rpb24ga2V5IGZvciB0b2tlbnMuIFRoZXJlIGlzIG5vIG5lZWQgZm9yIGEgc2luZ2xlIHdlbGwtZGVmaW5lZCBmb3JtYXQgZm9yIHRoZSB0b2tlbiBiZWNhdXNlIHRoZSBzZXJ2ZXIgdGhhdCBnZW5lcmF0ZXMgdGhlIHRva2VuIGFsc28gY29uc3VtZXMgaXQuIFRva2VucyBzZW50IGluIFJldHJ5IHBhY2tldHMgU0hPVUxEIGluY2x1ZGUgaW5mb3JtYXRpb24gdGhhdCBhbGxvd3MgdGhlIHNlcnZlciB0byB2ZXJpZnkgdGhhdCB0aGUgc291cmNlIElQIGFkZHJlc3MgYW5kIHBvcnQgaW4gY2xpZW50IHBhY2tldHMgcmVtYWluIGNvbnN0YW50LiBUb2tlbnMgc2VudCBpbiBORVdfVE9LRU4gZnJhbWVzIE1VU1QgaW5jbHVkZSBpbmZvcm1hdGlvbiB0aGF0IGFsbG93cyB0aGUgc2VydmVyIHRvIHZlcmlmeSB0aGF0IHRoZSBjbGllbnQgSVAgYWRkcmVzcyBoYXMgbm90IGNoYW5nZWQgZnJvbSB3aGVuIHRoZSB0b2tlbiB3YXMgaXNzdWVkLiBTZXJ2ZXJzIGNhbiB1c2UgdG9rZW5zIGZyb20gTkVXX1RPS0VOIGZyYW1lcyBpbiBkZWNpZGluZyBub3QgdG8gc2VuZCBhIFJldHJ5IHBhY2tldCwgZXZlbiBpZiB0aGUgY2xpZW50IGFkZHJlc3MgaGFzIGNoYW5nZWQuIElmIHRoZSBjbGllbnQgSVAgYWRkcmVzcyBoYXMgY2hhbmdlZCwgdGhlIHNlcnZlciBNVVNUIGFkaGVyZSB0byB0aGUgYW50aS1hbXBsaWZpY2F0aW9uIGxpbWl0OyBzZWUgU2VjdGlvbiA4LiBOb3RlIHRoYXQgaW4gdGhlIHByZXNlbmNlIG9mIE5BVCwgdGhpcyByZXF1aXJlbWVudCBtaWdodCBiZSBpbnN1ZmZpY2llbnQgdG8gcHJvdGVjdCBvdGhlciBob3N0cyB0aGF0IHNoYXJlIHRoZSBOQVQgZnJvbSBhbXBsaWZpY2F0aW9uIGF0dGFja3MuIEF0dGFja2VycyBjb3VsZCByZXBsYXkgdG9rZW5zIHRvIHVzZSBzZXJ2ZXJzIGFzIGFtcGxpZmllcnMgaW4gRERvUyBhdHRhY2tzLiBUbyBwcm90ZWN0IGFnYWluc3Qgc3VjaCBhdHRhY2tzLCBzZXJ2ZXJzIE1VU1QgZW5zdXJlIHRoYXQgcmVwbGF5IG9mIHRva2VucyBpcyBwcmV2ZW50ZWQgb3IgbGltaXRlZC4gU2VydmVycyBTSE9VTEQgZW5zdXJlIHRoYXQgdG9rZW5zIHNlbnQgaW4gUmV0cnkgcGFja2V0cyBhcmUgb25seSBhY2NlcHRlZCBmb3IgYSBzaG9ydCB0aW1lLCBhcyB0aGV5IGFyZSByZXR1cm5lZCBpbW1lZGlhdGVseSBieSBjbGllbnRzLiBUb2tlbnMgdGhhdCBhcmUgcHJvdmlkZWQgaW4gTkVXX1RPS0VOIGZyYW1lcyAoU2VjdGlvbiAxOS43KSBuZWVkIHRvIGJlIHZhbGlkIGZvciBsb25nZXIgYnV0IFNIT1VMRCBOT1QgYmUgYWNjZXB0ZWQgbXVsdGlwbGUgdGltZXMuIFNlcnZlcnMgYXJlIGVuY291cmFnZWQgdG8gYWxsb3cgdG9rZW5zIHRvIGJlIHVzZWQgb25seSBvbmNlLCBpZiBwb3NzaWJsZTsgdG9rZW5zIE1BWSBpbmNsdWRlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgY2xpZW50cyB0byBmdXJ0aGVyIG5hcnJvdyBhcHBsaWNhYmlsaXR5IG9yIHJldXNlLiA4LjIuIFBhdGggVmFsaWRhdGlvbiBQYXRoIHZhbGlkYXRpb24gaXMgdXNlZCBieSBib3RoIHBlZXJzIGR1cmluZyBjb25uZWN0aW9uIG1pZ3JhdGlvbiAoc2VlIFNlY3Rpb24gOSkgdG8gdmVyaWZ5IHJlYWNoYWJpbGl0eSBhZnRlciBhIGNoYW5nZSBvZiBhZGRyZXNzLiBJbiBwYXRoIHZhbGlkYXRpb24sIGVuZHBvaW50cyB0ZXN0IHJlYWNoYWJpbGl0eSBiZXR3ZWVuIGEgc3BlY2lmaWMgbG9jYWwgYWRkcmVzcyBhbmQgYSBzcGVjaWZpYyBwZWVyIGFkZHJlc3MsIHdoZXJlIGFuIGFkZHJlc3MgaXMgdGhlIDItdHVwbGUgb2YgSVAgYWRkcmVzcyBhbmQgcG9ydC4gUGF0aCB2YWxpZGF0aW9uIHRlc3RzIHRoYXQgcGFja2V0cyBzZW50IG9uIGEgcGF0aCB0byBhIHBlZXIgYXJlIHJlY2VpdmVkIGJ5IHRoYXQgcGVlci4gUGF0aCB2YWxpZGF0aW9uIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgcGFja2V0cyByZWNlaXZlZCBmcm9tIGEgbWlncmF0aW5nIHBlZXIgZG8gbm90IGNhcnJ5IGEgc3Bvb2ZlZCBzb3VyY2UgYWRkcmVzcy4gUGF0aCB2YWxpZGF0aW9uIGRvZXMgbm90IHZhbGlkYXRlIHRoYXQgYSBwZWVyIGNhbiBzZW5kIGluIHRoZSByZXR1cm4gZGlyZWN0aW9uLiBBY2tub3dsZWRnbWVudHMgY2Fubm90IGJlIHVzZWQgZm9yIHJldHVybiBwYXRoIHZhbGlkYXRpb24gYmVjYXVzZSB0aGV5IGNvbnRhaW4gaW5zdWZmaWNpZW50IGVudHJvcHkgYW5kIG1pZ2h0IGJlIHNwb29mZWQuIEVuZHBvaW50cyBpbmRlcGVuZGVudGx5IGRldGVybWluZSByZWFjaGFiaWxpdHkgb24gZWFjaCBkaXJlY3Rpb24gb2YgYSBwYXRoLCBhbmQgdGhlcmVmb3JlIHJldHVybiByZWFjaGFiaWxpdHkgY2FuIG9ubHkgYmUgZXN0YWJsaXNoZWQgYnkgdGhlIHBlZXIuIFBhdGggdmFsaWRhdGlvbiBjYW4gYmUgdXNlZCBhdCBhbnkgdGltZSBieSBlaXRoZXIgZW5kcG9pbnQuIEZvciBpbnN0YW5jZSwgYW4gZW5kcG9pbnQgbWlnaHQgY2hlY2sgdGhhdCBhIHBlZXIgaXMgc3RpbGwgaW4gcG9zc2Vzc2lvbiBvZiBpdHMgYWRkcmVzcyBhZnRlciBhIHBlcmlvZCBvZiBxdWllc2NlbmNlLiBQYXRoIHZhbGlkYXRpb24gaXMgbm90IGRlc2lnbmVkIGFzIGEgTkFUIHRyYXZlcnNhbCBtZWNoYW5pc20uIFRob3VnaCB0aGUgbWVjaGFuaXNtIGRlc2NyaWJlZCBoZXJlIG1pZ2h0IGJlIGVmZmVjdGl2ZSBmb3IgdGhlIGNyZWF0aW9uIG9mIE5BVCBiaW5kaW5ncyB0aGF0IHN1cHBvcnQgTkFUIHRyYXZlcnNhbCwgdGhlIGV4cGVjdGF0aW9uIGlzIHRoYXQgb25lIGVuZHBvaW50IGlzIGFibGUgdG8gcmVjZWl2ZSBwYWNrZXRzIHdpdGhvdXQgZmlyc3QgaGF2aW5nIHNlbnQgYSBwYWNrZXQgb24gdGhhdCBwYXRoLiBFZmZlY3RpdmUgTkFUIHRyYXZlcnNhbCBuZWVkcyBhZGRpdGlvbmFsIHN5bmNocm9uaXphdGlvbiBtZWNoYW5pc21zIHRoYXQgYXJlIG5vdCBwcm92aWRlZCBoZXJlLiBBbiBlbmRwb2ludCBNQVkgaW5jbHVkZSBvdGhlciBmcmFtZXMgd2l0aCB0aGUgUEFUSF9DSEFMTEVOR0UgYW5kIFBBVEhfUkVTUE9OU0UgZnJhbWVzIHVzZWQgZm9yIHBhdGggdmFsaWRhdGlvbi4gSW4gcGFydGljdWxhciwgYW4gZW5kcG9pbnQgY2FuIGluY2x1ZGUgUEFERElORyBmcmFtZXMgd2l0aCBhIFBBVEhfQ0hBTExFTkdFIGZyYW1lIGZvciBQYXRoIE1heGltdW0gVHJhbnNtaXNzaW9uIFVuaXQgRGlzY292ZXJ5IChQTVRVRCk7IHNlZSBTZWN0aW9uIDE0LjIuMS4gQW4gZW5kcG9pbnQgY2FuIGFsc28gaW5jbHVkZSBpdHMgb3duIFBBVEhfQ0hBTExFTkdFIGZyYW1lIHdoZW4gc2VuZGluZyBhIFBBVEhfUkVTUE9OU0UgZnJhbWUuIEFuIGVuZHBvaW50IHVzZXMgYSBuZXcgY29ubmVjdGlvbiBJRCBmb3IgcHJvYmVzIHNlbnQgZnJvbSBhIG5ldyBsb2NhbCBhZGRyZXNzOyBzZWUgU2VjdGlvbiA5LjUuIFdoZW4gcHJvYmluZyBhIG5ldyBwYXRoLCBhbiBlbmRwb2ludCBjYW4gZW5zdXJlIHRoYXQgaXRzIHBlZXIgaGFzIGFuIHVudXNlZCBjb25uZWN0aW9uIElEIGF2YWlsYWJsZSBmb3IgcmVzcG9uc2VzLiBTZW5kaW5nIE5FV19DT05ORUNUSU9OX0lEIGFuZCBQQVRIX0NIQUxMRU5HRSBmcmFtZXMgaW4gdGhlIHNhbWUgcGFja2V0LCBpZiB0aGUgcGVlcidzIGFjdGl2ZV9jb25uZWN0aW9uX2lkX2xpbWl0IHBlcm1pdHMsIGVuc3VyZXMgdGhhdCBhbiB1bnVzZWQgY29ubmVjdGlvbiBJRCB3aWxsIGJlIGF2YWlsYWJsZSB0byB0aGUgcGVlciB3aGVuIHNlbmRpbmcgYSByZXNwb25zZS4gQW4gZW5kcG9pbnQgY2FuIGNob29zZSB0byBzaW11bHRhbmVvdXNseSBwcm9iZSBtdWx0aXBsZSBwYXRocy4gVGhlIG51bWJlciBvZiBzaW11bHRhbmVvdXMgcGF0aHMgdXNlZCBmb3IgcHJvYmVzIGlzIGxpbWl0ZWQgYnkgdGhlIG51bWJlciBvZiBleHRyYSBjb25uZWN0aW9uIElEcyBpdHMgcGVlciBoYXMgcHJldmlvdXNseSBzdXBwbGllZCwgc2luY2UgZWFjaCBuZXcgbG9jYWwgYWRkcmVzcyB1c2VkIGZvciBhIHByb2JlIHJlcXVpcmVzIGEgcHJldmlvdXNseSB1bnVzZWQgY29ubmVjdGlvbiBJRC4gOC4yLjEuIEluaXRpYXRpbmcgUGF0aCBWYWxpZGF0aW9uIFRvIGluaXRpYXRlIHBhdGggdmFsaWRhdGlvbiwgYW4gZW5kcG9pbnQgc2VuZHMgYSBQQVRIX0NIQUxMRU5HRSBmcmFtZSBjb250YWluaW5nIGFuIHVucHJlZGljdGFibGUgcGF5bG9hZCBvbiB0aGUgcGF0aCB0byBiZSB2YWxpZGF0ZWQuIEFuIGVuZHBvaW50IE1BWSBzZW5kIG11bHRpcGxlIFBBVEhfQ0hBTExFTkdFIGZyYW1lcyB0byBndWFyZCBhZ2FpbnN0IHBhY2tldCBsb3NzLiBIb3dldmVyLCBhbiBlbmRwb2ludCBTSE9VTEQgTk9UIHNlbmQgbXVsdGlwbGUgUEFUSF9DSEFMTEVOR0UgZnJhbWVzIGluIGEgc2luZ2xlIHBhY2tldC4gQW4gZW5kcG9pbnQgU0hPVUxEIE5PVCBwcm9iZSBhIG5ldyBwYXRoIHdpdGggcGFja2V0cyBjb250YWluaW5nIGEgUEFUSF9DSEFMTEVOR0UgZnJhbWUgbW9yZSBmcmVxdWVudGx5IHRoYW4gaXQgd291bGQgc2VuZCBhbiBJbml0aWFsIHBhY2tldC4gVGhpcyBlbnN1cmVzIHRoYXQgY29ubmVjdGlvbiBtaWdyYXRpb24gaXMgbm8gbW9yZSBsb2FkIG9uIGEgbmV3IHBhdGggdGhhbiBlc3RhYmxpc2hpbmcgYSBuZXcgY29ubmVjdGlvbi4gVGhlIGVuZHBvaW50IE1VU1QgdXNlIHVucHJlZGljdGFibGUgZGF0YSBpbiBldmVyeSBQQVRIX0NIQUxMRU5HRSBmcmFtZSBzbyB0aGF0IGl0IGNhbiBhc3NvY2lhdGUgdGhlIHBlZXIncyByZXNwb25zZSB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIFBBVEhfQ0hBTExFTkdFLiBBbiBlbmRwb2ludCBNVVNUIGV4cGFuZCBkYXRhZ3JhbXMgdGhhdCBjb250YWluIGEgUEFUSF9DSEFMTEVOR0UgZnJhbWUgdG8gYXQgbGVhc3QgdGhlIHNtYWxsZXN0IGFsbG93ZWQgbWF4aW11bSBkYXRhZ3JhbSBzaXplIG9mIDEyMDAgYnl0ZXMsIHVubGVzcyB0aGUgYW50aS1hbXBsaWZpY2F0aW9uIGxpbWl0IGZvciB0aGUgcGF0aCBkb2VzIG5vdCBwZXJtaXQgc2VuZGluZyBhIGRhdGFncmFtIG9mIHRoaXMgc2l6ZS4gU2VuZGluZyBVRFAgZGF0YWdyYW1zIG9mIHRoaXMgc2l6ZSBlbnN1cmVzIHRoYXQgdGhlIG5ldHdvcmsgcGF0aCBmcm9tIHRoZSBlbmRwb2ludCB0byB0aGUgcGVlciBjYW4gYmUgdXNlZCBmb3IgUVVJQzsgc2VlIFNlY3Rpb24gMTQuIFdoZW4gYW4gZW5kcG9pbnQgaXMgdW5hYmxlIHRvIGV4cGFuZCB0aGUgZGF0YWdyYW0gc2l6ZSB0byAxMjAwIGJ5dGVzIGR1ZSB0byB0aGUgYW50aS1hbXBsaWZpY2F0aW9uIGxpbWl0LCB0aGUgcGF0aCBNVFUgd2lsbCBub3QgYmUgdmFsaWRhdGVkLiBUbyBlbnN1cmUgdGhhdCB0aGUgcGF0aCBNVFUgaXMgbGFyZ2UgZW5vdWdoLCB0aGUgZW5kcG9pbnQgTVVTVCBwZXJmb3JtIGEgc2Vjb25kIHBhdGggdmFsaWRhdGlvbiBieSBzZW5kaW5nIGEgUEFUSF9DSEFMTEVOR0UgZnJhbWUgaW4gYSBkYXRhZ3JhbSBvZiBhdCBsZWFzdCAxMjAwIGJ5dGVzLiBUaGlzIGFkZGl0aW9uYWwgdmFsaWRhdGlvbiBjYW4gYmUgcGVyZm9ybWVkIGFmdGVyIGEgUEFUSF9SRVNQT05TRSBpcyBzdWNjZXNzZnVsbHkgcmVjZWl2ZWQgb3Igd2hlbiBlbm91Z2ggYnl0ZXMgaGF2ZSBiZWVuIHJlY2VpdmVkIG9uIHRoZSBwYXRoIHRoYXQgc2VuZGluZyB0aGUgbGFyZ2VyIGRhdGFncmFtIHdpbGwgbm90IHJlc3VsdCBpbiBleGNlZWRpbmcgdGhlIGFudGktIGFtcGxpZmljYXRpb24gbGltaXQuIFVubGlrZSBvdGhlciBjYXNlcyB3aGVyZSBkYXRhZ3JhbXMgYXJlIGV4cGFuZGVkLCBlbmRwb2ludHMgTVVTVCBOT1QgZGlzY2FyZCBkYXRhZ3JhbXMgdGhhdCBhcHBlYXIgdG8gYmUgdG9vIHNtYWxsIHdoZW4gdGhleSBjb250YWluIFBBVEhfQ0hBTExFTkdFIG9yIFBBVEhfUkVTUE9OU0UuIDguMi4yLiBQYXRoIFZhbGlkYXRpb24gUmVzcG9uc2VzIE9uIHJlY2VpdmluZyBhIFBBVEhfQ0hBTExFTkdFIGZyYW1lLCBhbiBlbmRwb2ludCBNVVNUIHJlc3BvbmQgYnkgZWNob2luZyB0aGUgZGF0YSBjb250YWluZWQgaW4gdGhlIFBBVEhfQ0hBTExFTkdFIGZyYW1lIGluIGEgUEFUSF9SRVNQT05TRSBmcmFtZS4gQW4gZW5kcG9pbnQgTVVTVCBOT1QgZGVsYXkgdHJhbnNtaXNzaW9uIG9mIGEgcGFja2V0IGNvbnRhaW5pbmcgYSBQQVRIX1JFU1BPTlNFIGZyYW1lIHVubGVzcyBjb25zdHJhaW5lZCBieSBjb25nZXN0aW9uIGNvbnRyb2wuIEEgUEFUSF9SRVNQT05TRSBmcmFtZSBNVVNUIGJlIHNlbnQgb24gdGhlIG5ldHdvcmsgcGF0aCB3aGVyZSB0aGUgUEFUSF9DSEFMTEVOR0UgZnJhbWUgd2FzIHJlY2VpdmVkLiBUaGlzIGVuc3VyZXMgdGhhdCBwYXRoIHZhbGlkYXRpb24gYnkgYSBwZWVyIG9ubHkgc3VjY2VlZHMgaWYgdGhlIHBhdGggaXMgZnVuY3Rpb25hbCBpbiBib3RoIGRpcmVjdGlvbnMuIFRoaXMgcmVxdWlyZW1lbnQgTVVTVCBOT1QgYmUgZW5mb3JjZWQgYnkgdGhlIGVuZHBvaW50IHRoYXQgaW5pdGlhdGVzIHBhdGggdmFsaWRhdGlvbiwgYXMgdGhhdCB3b3VsZCBlbmFibGUgYW4gYXR0YWNrIG9uIG1pZ3JhdGlvbjsgc2VlIFNlY3Rpb24gOS4zLjMuIEFuIGVuZHBvaW50IE1VU1QgZXhwYW5kIGRhdGFncmFtcyB0aGF0IGNvbnRhaW4gYSBQQVRIX1JFU1BPTlNFIGZyYW1lIHRvIGF0IGxlYXN0IHRoZSBzbWFsbGVzdCBhbGxvd2VkIG1heGltdW0gZGF0YWdyYW0gc2l6ZSBvZiAxMjAwIGJ5dGVzLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIHBhdGggaXMgYWJsZSB0byBjYXJyeSBkYXRhZ3JhbXMgb2YgdGhpcyBzaXplIGluIGJvdGggZGlyZWN0aW9ucy4gSG93ZXZlciwgYW4gZW5kcG9pbnQgTVVTVCBOT1QgZXhwYW5kIHRoZSBkYXRhZ3JhbSBjb250YWluaW5nIHRoZSBQQVRIX1JFU1BPTlNFIGlmIHRoZSByZXN1bHRpbmcgZGF0YSBleGNlZWRzIHRoZSBhbnRpLWFtcGxpZmljYXRpb24gbGltaXQuIFRoaXMgaXMgZXhwZWN0ZWQgdG8gb25seSBvY2N1ciBpZiB0aGUgcmVjZWl2ZWQgUEFUSF9DSEFMTEVOR0Ugd2FzIG5vdCBzZW50IGluIGFuIGV4cGFuZGVkIGRhdGFncmFtLiBBbiBlbmRwb2ludCBNVVNUIE5PVCBzZW5kIG1vcmUgdGhhbiBvbmUgUEFUSF9SRVNQT05TRSBmcmFtZSBpbiByZXNwb25zZSB0byBvbmUgUEFUSF9DSEFMTEVOR0UgZnJhbWU7IHNlZSBTZWN0aW9uIDEzLjMuIFRoZSBwZWVyIGlzIGV4cGVjdGVkIHRvIHNlbmQgbW9yZSBQQVRIX0NIQUxMRU5HRSBmcmFtZXMgYXMgbmVjZXNzYXJ5IHRvIGV2b2tlIGFkZGl0aW9uYWwgUEFUSF9SRVNQT05TRSBmcmFtZXMuIDguMi4zLiBTdWNjZXNzZnVsIFBhdGggVmFsaWRhdGlvbiBQYXRoIHZhbGlkYXRpb24gc3VjY2VlZHMgd2hlbiBhIFBBVEhfUkVTUE9OU0UgZnJhbWUgaXMgcmVjZWl2ZWQgdGhhdCBjb250YWlucyB0aGUgZGF0YSB0aGF0IHdhcyBzZW50IGluIGEgcHJldmlvdXMgUEFUSF9DSEFMTEVOR0UgZnJhbWUuIEEgUEFUSF9SRVNQT05TRSBmcmFtZSByZWNlaXZlZCBvbiBhbnkgbmV0d29yayBwYXRoIHZhbGlkYXRlcyB0aGUgcGF0aCBvbiB3aGljaCB0aGUgUEFUSF9DSEFMTEVOR0Ugd2FzIHNlbnQuIElmIGFuIGVuZHBvaW50IHNlbmRzIGEgUEFUSF9DSEFMTEVOR0UgZnJhbWUgaW4gYSBkYXRhZ3JhbSB0aGF0IGlzIG5vdCBleHBhbmRlZCB0byBhdCBsZWFzdCAxMjAwIGJ5dGVzIGFuZCBpZiB0aGUgcmVzcG9uc2UgdG8gaXQgdmFsaWRhdGVzIHRoZSBwZWVyIGFkZHJlc3MsIHRoZSBwYXRoIGlzIHZhbGlkYXRlZCBidXQgbm90IHRoZSBwYXRoIE1UVS4gQXMgYSByZXN1bHQsIHRoZSBlbmRwb2ludCBjYW4gbm93IHNlbmQgbW9yZSB0aGFuIHRocmVlIHRpbWVzIHRoZSBhbW91bnQgb2YgZGF0YSB0aGF0IGhhcyBiZWVuIHJlY2VpdmVkLiBIb3dldmVyLCB0aGUgZW5kcG9pbnQgTVVTVCBpbml0aWF0ZSBhbm90aGVyIHBhdGggdmFsaWRhdGlvbiB3aXRoIGFuIGV4cGFuZGVkIGRhdGFncmFtIHRvIHZlcmlmeSB0aGF0IHRoZSBwYXRoIHN1cHBvcnRzIHRoZSByZXF1aXJlZCBNVFUuIFJlY2VpcHQgb2YgYW4gYWNrbm93bGVkZ21lbnQgZm9yIGEgcGFja2V0IGNvbnRhaW5pbmcgYSBQQVRIX0NIQUxMRU5HRSBmcmFtZSBpcyBub3QgYWRlcXVhdGUgdmFsaWRhdGlvbiwgc2luY2UgdGhlIGFja25vd2xlZGdtZW50IGNhbiBiZSBzcG9vZmVkIGJ5IGEgbWFsaWNpb3VzIHBlZXIuIDguMi40LiBGYWlsZWQgUGF0aCBWYWxpZGF0aW9uIFBhdGggdmFsaWRhdGlvbiBvbmx5IGZhaWxzIHdoZW4gdGhlIGVuZHBvaW50IGF0dGVtcHRpbmcgdG8gdmFsaWRhdGUgdGhlIHBhdGggYWJhbmRvbnMgaXRzIGF0dGVtcHQgdG8gdmFsaWRhdGUgdGhlIHBhdGguIEVuZHBvaW50cyBTSE9VTEQgYWJhbmRvbiBwYXRoIHZhbGlkYXRpb24gYmFzZWQgb24gYSB0aW1lci4gV2hlbiBzZXR0aW5nIHRoaXMgdGltZXIsIGltcGxlbWVudGF0aW9ucyBhcmUgY2F1dGlvbmVkIHRoYXQgdGhlIG5ldyBwYXRoIGNvdWxkIGhhdmUgYSBsb25nZXIgcm91bmQtdHJpcCB0aW1lIHRoYW4gdGhlIG9yaWdpbmFsLiBBIHZhbHVlIG9mIHRocmVlIHRpbWVzIHRoZSBsYXJnZXIgb2YgdGhlIGN1cnJlbnQgUFRPIG9yIHRoZSBQVE8gZm9yIHRoZSBuZXcgcGF0aCAodXNpbmcga0luaXRpYWxSdHQsIGFzIGRlZmluZWQgaW4gW1FVSUMtUkVDT1ZFUlldKSBpcyBSRUNPTU1FTkRFRC4gVGhpcyB0aW1lb3V0IGFsbG93cyBmb3IgbXVsdGlwbGUgUFRPcyB0byBleHBpcmUgcHJpb3IgdG8gZmFpbGluZyBwYXRoIHZhbGlkYXRpb24sIHNvIHRoYXQgbG9zcyBvZiBhIHNpbmdsZSBQQVRIX0NIQUxMRU5HRSBvciBQQVRIX1JFU1BPTlNFIGZyYW1lIGRvZXMgbm90IGNhdXNlIHBhdGggdmFsaWRhdGlvbiBmYWlsdXJlLiBOb3RlIHRoYXQgdGhlIGVuZHBvaW50IG1pZ2h0IHJlY2VpdmUgcGFja2V0cyBjb250YWluaW5nIG90aGVyIGZyYW1lcyBvbiB0aGUgbmV3IHBhdGgsIGJ1dCBhIFBBVEhfUkVTUE9OU0UgZnJhbWUgd2l0aCBhcHByb3ByaWF0ZSBkYXRhIGlzIHJlcXVpcmVkIGZvciBwYXRoIHZhbGlkYXRpb24gdG8gc3VjY2VlZC4gV2hlbiBhbiBlbmRwb2ludCBhYmFuZG9ucyBwYXRoIHZhbGlkYXRpb24sIGl0IGRldGVybWluZXMgdGhhdCB0aGUgcGF0aCBpcyB1bnVzYWJsZS4gVGhpcyBkb2VzIG5vdCBuZWNlc3NhcmlseSBpbXBseSBhIGZhaWx1cmUgb2YgdGhlIGNvbm5lY3Rpb24gLS0gZW5kcG9pbnRzIGNhbiBjb250aW51ZSBzZW5kaW5nIHBhY2tldHMgb3ZlciBvdGhlciBwYXRocyBhcyBhcHByb3ByaWF0ZS4gSWYgbm8gcGF0aHMgYXJlIGF2YWlsYWJsZSwgYW4gZW5kcG9pbnQgY2FuIHdhaXQgZm9yIGEgbmV3IHBhdGggdG8gYmVjb21lIGF2YWlsYWJsZSBvciBjbG9zZSB0aGUgY29ubmVjdGlvbi4gQW4gZW5kcG9pbnQgdGhhdCBoYXMgbm8gdmFsaWQgbmV0d29yayBwYXRoIHRvIGl0cyBwZWVyIE1BWSBzaWduYWwgdGhpcyB1c2luZyB0aGUgTk9fVklBQkxFX1BBVEggY29ubmVjdGlvbiBlcnJvciwgbm90aW5nIHRoYXQgdGhpcyBpcyBvbmx5IHBvc3NpYmxlIGlmIHRoZSBuZXR3b3JrIHBhdGggZXhpc3RzIGJ1dCBkb2VzIG5vdCBzdXBwb3J0IHRoZSByZXF1aXJlZCBNVFUgKFNlY3Rpb24gMTQpLiBBIHBhdGggdmFsaWRhdGlvbiBtaWdodCBiZSBhYmFuZG9uZWQgZm9yIG90aGVyIHJlYXNvbnMgYmVzaWRlcyBmYWlsdXJlLiBQcmltYXJpbHksIHRoaXMgaGFwcGVucyBpZiBhIGNvbm5lY3Rpb24gbWlncmF0aW9uIHRvIGEgbmV3IHBhdGggaXMgaW5pdGlhdGVkIHdoaWxlIGEgcGF0aCB2YWxpZGF0aW9uIG9uIHRoZSBvbGQgcGF0aCBpcyBpbiBwcm9ncmVzcy4gOS4gQ29ubmVjdGlvbiBNaWdyYXRpb24gVGhlIHVzZSBvZiBhIGNvbm5lY3Rpb24gSUQgYWxsb3dzIGNvbm5lY3Rpb25zIHRvIHN1cnZpdmUgY2hhbmdlcyB0byBlbmRwb2ludCBhZGRyZXNzZXMgKElQIGFkZHJlc3MgYW5kIHBvcnQpLCBzdWNoIGFzIHRob3NlIGNhdXNlZCBieSBhbiBlbmRwb2ludCBtaWdyYXRpbmcgdG8gYSBuZXcgbmV0d29yay4gVGhpcyBzZWN0aW9uIGRlc2NyaWJlcyB0aGUgcHJvY2VzcyBieSB3aGljaCBhbiBlbmRwb2ludCBtaWdyYXRlcyB0byBhIG5ldyBhZGRyZXNzLiBUaGUgZGVzaWduIG9mIFFVSUMgcmVsaWVzIG9uIGVuZHBvaW50cyByZXRhaW5pbmcgYSBzdGFibGUgYWRkcmVzcyBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBoYW5kc2hha2UuIEFuIGVuZHBvaW50IE1VU1QgTk9UIGluaXRpYXRlIGNvbm5lY3Rpb24gbWlncmF0aW9uIGJlZm9yZSB0aGUgaGFuZHNoYWtlIGlzIGNvbmZpcm1lZCwgYXMgZGVmaW5lZCBpbiBTZWN0aW9uIDQuMS4yIG9mIFtRVUlDLVRMU10uIElmIHRoZSBwZWVyIHNlbnQgdGhlIGRpc2FibGVfYWN0aXZlX21pZ3JhdGlvbiB0cmFuc3BvcnQgcGFyYW1ldGVyLCBhbiBlbmRwb2ludCBhbHNvIE1VU1QgTk9UIHNlbmQgcGFja2V0cyAoaW5jbHVkaW5nIHByb2JpbmcgcGFja2V0czsgc2VlIFNlY3Rpb24gOS4xKSBmcm9tIGEgZGlmZmVyZW50IGxvY2FsIGFkZHJlc3MgdG8gdGhlIGFkZHJlc3MgdGhlIHBlZXIgdXNlZCBkdXJpbmcgdGhlIGhhbmRzaGFrZSwgdW5sZXNzIHRoZSBlbmRwb2ludCBoYXMgYWN0ZWQgb24gYSBwcmVmZXJyZWRfYWRkcmVzcyB0cmFuc3BvcnQgcGFyYW1ldGVyIGZyb20gdGhlIHBlZXIuIElmIHRoZSBwZWVyIHZpb2xhdGVzIHRoaXMgcmVxdWlyZW1lbnQsIHRoZSBlbmRwb2ludCBNVVNUIGVpdGhlciBkcm9wIHRoZSBpbmNvbWluZyBwYWNrZXRzIG9uIHRoYXQgcGF0aCB3aXRob3V0IGdlbmVyYXRpbmcgYSBTdGF0ZWxlc3MgUmVzZXQgb3IgcHJvY2VlZCB3aXRoIHBhdGggdmFsaWRhdGlvbiBhbmQgYWxsb3cgdGhlIHBlZXIgdG8gbWlncmF0ZS4gR2VuZXJhdGluZyBhIFN0YXRlbGVzcyBSZXNldCBvciBjbG9zaW5nIHRoZSBjb25uZWN0aW9uIHdvdWxkIGFsbG93IHRoaXJkIHBhcnRpZXMgaW4gdGhlIG5ldHdvcmsgdG8gY2F1c2UgY29ubmVjdGlvbnMgdG8gY2xvc2UgYnkgc3Bvb2Zpbmcgb3Igb3RoZXJ3aXNlIG1hbmlwdWxhdGluZyBvYnNlcnZlZCB0cmFmZmljLiBOb3QgYWxsIGNoYW5nZXMgb2YgcGVlciBhZGRyZXNzIGFyZSBpbnRlbnRpb25hbCwgb3IgYWN0aXZlLCBtaWdyYXRpb25zLiBUaGUgcGVlciBjb3VsZCBleHBlcmllbmNlIE5BVCByZWJpbmRpbmc6IGEgY2hhbmdlIG9mIGFkZHJlc3MgZHVlIHRvIGEgbWlkZGxlYm94LCB1c3VhbGx5IGEgTkFULCBhbGxvY2F0aW5nIGEgbmV3IG91dGdvaW5nIHBvcnQgb3IgZXZlbiBhIG5ldyBvdXRnb2luZyBJUCBhZGRyZXNzIGZvciBhIGZsb3cuIEFuIGVuZHBvaW50IE1VU1QgcGVyZm9ybSBwYXRoIHZhbGlkYXRpb24gKFNlY3Rpb24gOC4yKSBpZiBpdCBkZXRlY3RzIGFueSBjaGFuZ2UgdG8gYSBwZWVyJ3MgYWRkcmVzcywgdW5sZXNzIGl0IGhhcyBwcmV2aW91c2x5IHZhbGlkYXRlZCB0aGF0IGFkZHJlc3MuIFdoZW4gYW4gZW5kcG9pbnQgaGFzIG5vIHZhbGlkYXRlZCBwYXRoIG9uIHdoaWNoIHRvIHNlbmQgcGFja2V0cywgaXQgTUFZIGRpc2NhcmQgY29ubmVjdGlvbiBzdGF0ZS4gQW4gZW5kcG9pbnQgY2FwYWJsZSBvZiBjb25uZWN0aW9uIG1pZ3JhdGlvbiBNQVkgd2FpdCBmb3IgYSBuZXcgcGF0aCB0byBiZWNvbWUgYXZhaWxhYmxlIGJlZm9yZSBkaXNjYXJkaW5nIGNvbm5lY3Rpb24gc3RhdGUuIFRoaXMgZG9jdW1lbnQgbGltaXRzIG1pZ3JhdGlvbiBvZiBjb25uZWN0aW9ucyB0byBuZXcgY2xpZW50IGFkZHJlc3NlcywgZXhjZXB0IGFzIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDkuNi4gQ2xpZW50cyBhcmUgcmVzcG9uc2libGUgZm9yIGluaXRpYXRpbmcgYWxsIG1pZ3JhdGlvbnMuIFNlcnZlcnMgZG8gbm90IHNlbmQgbm9uLSBwcm9iaW5nIHBhY2tldHMgKHNlZSBTZWN0aW9uIDkuMSkgdG93YXJkIGEgY2xpZW50IGFkZHJlc3MgdW50aWwgdGhleSBzZWUgYSBub24tcHJvYmluZyBwYWNrZXQgZnJvbSB0aGF0IGFkZHJlc3MuIElmIGEgY2xpZW50IHJlY2VpdmVzIHBhY2tldHMgZnJvbSBhbiB1bmtub3duIHNlcnZlciBhZGRyZXNzLCB0aGUgY2xpZW50IE1VU1QgZGlzY2FyZCB0aGVzZSBwYWNrZXRzLiA5LjEuIFByb2JpbmcgYSBOZXcgUGF0aCBBbiBlbmRwb2ludCBNQVkgcHJvYmUgZm9yIHBlZXIgcmVhY2hhYmlsaXR5IGZyb20gYSBuZXcgbG9jYWwgYWRkcmVzcyB1c2luZyBwYXRoIHZhbGlkYXRpb24gKFNlY3Rpb24gOC4yKSBwcmlvciB0byBtaWdyYXRpbmcgdGhlIGNvbm5lY3Rpb24gdG8gdGhlIG5ldyBsb2NhbCBhZGRyZXNzLiBGYWlsdXJlIG9mIHBhdGggdmFsaWRhdGlvbiBzaW1wbHkgbWVhbnMgdGhhdCB0aGUgbmV3IHBhdGggaXMgbm90IHVzYWJsZSBmb3IgdGhpcyBjb25uZWN0aW9uLiBGYWlsdXJlIHRvIHZhbGlkYXRlIGEgcGF0aCBkb2VzIG5vdCBjYXVzZSB0aGUgY29ubmVjdGlvbiB0byBlbmQgdW5sZXNzIHRoZXJlIGFyZSBubyB2YWxpZCBhbHRlcm5hdGl2ZSBwYXRocyBhdmFpbGFibGUuIFBBVEhfQ0hBTExFTkdFLCBQQVRIX1JFU1BPTlNFLCBORVdfQ09OTkVDVElPTl9JRCwgYW5kIFBBRERJTkcgZnJhbWVzIGFyZSAicHJvYmluZyBmcmFtZXMiLCBhbmQgYWxsIG90aGVyIGZyYW1lcyBhcmUgIm5vbi1wcm9iaW5nIGZyYW1lcyIuIEEgcGFja2V0IGNvbnRhaW5pbmcgb25seSBwcm9iaW5nIGZyYW1lcyBpcyBhICJwcm9iaW5nIHBhY2tldCIsIGFuZCBhIHBhY2tldCBjb250YWluaW5nIGFueSBvdGhlciBmcmFtZSBpcyBhICJub24tcHJvYmluZyBwYWNrZXQiLiA5LjIuIEluaXRpYXRpbmcgQ29ubmVjdGlvbiBNaWdyYXRpb24gQW4gZW5kcG9pbnQgY2FuIG1pZ3JhdGUgYSBjb25uZWN0aW9uIHRvIGEgbmV3IGxvY2FsIGFkZHJlc3MgYnkgc2VuZGluZyBwYWNrZXRzIGNvbnRhaW5pbmcgbm9uLXByb2JpbmcgZnJhbWVzIGZyb20gdGhhdCBhZGRyZXNzLiBFYWNoIGVuZHBvaW50IHZhbGlkYXRlcyBpdHMgcGVlcidzIGFkZHJlc3MgZHVyaW5nIGNvbm5lY3Rpb24gZXN0YWJsaXNobWVudC4gVGhlcmVmb3JlLCBhIG1pZ3JhdGluZyBlbmRwb2ludCBjYW4gc2VuZCB0byBpdHMgcGVlciBrbm93aW5nIHRoYXQgdGhlIHBlZXIgaXMgd2lsbGluZyB0byByZWNlaXZlIGF0IHRoZSBwZWVyJ3MgY3VycmVudCBhZGRyZXNzLiBUaHVzLCBhbiBlbmRwb2ludCBjYW4gbWlncmF0ZSB0byBhIG5ldyBsb2NhbCBhZGRyZXNzIHdpdGhvdXQgZmlyc3QgdmFsaWRhdGluZyB0aGUgcGVlcidzIGFkZHJlc3MuIFRvIGVzdGFibGlzaCByZWFjaGFiaWxpdHkgb24gdGhlIG5ldyBwYXRoLCBhbiBlbmRwb2ludCBpbml0aWF0ZXMgcGF0aCB2YWxpZGF0aW9uIChTZWN0aW9uIDguMikgb24gdGhlIG5ldyBwYXRoLiBBbiBlbmRwb2ludCBNQVkgZGVmZXIgcGF0aCB2YWxpZGF0aW9uIHVudGlsIGFmdGVyIGEgcGVlciBzZW5kcyB0aGUgbmV4dCBub24tcHJvYmluZyBmcmFtZSB0byBpdHMgbmV3IGFkZHJlc3MuIFdoZW4gbWlncmF0aW5nLCB0aGUgbmV3IHBhdGggbWlnaHQgbm90IHN1cHBvcnQgdGhlIGVuZHBvaW50J3MgY3VycmVudCBzZW5kaW5nIHJhdGUuIFRoZXJlZm9yZSwgdGhlIGVuZHBvaW50IHJlc2V0cyBpdHMgY29uZ2VzdGlvbiBjb250cm9sbGVyIGFuZCBSVFQgZXN0aW1hdGUsIGFzIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDkuNC4gVGhlIG5ldyBwYXRoIG1pZ2h0IG5vdCBoYXZlIHRoZSBzYW1lIEVDTiBjYXBhYmlsaXR5LiBUaGVyZWZvcmUsIHRoZSBlbmRwb2ludCB2YWxpZGF0ZXMgRUNOIGNhcGFiaWxpdHkgYXMgZGVzY3JpYmVkIGluIFNlY3Rpb24gMTMuNC4gOS4zLiBSZXNwb25kaW5nIHRvIENvbm5lY3Rpb24gTWlncmF0aW9uIFJlY2VpdmluZyBhIHBhY2tldCBmcm9tIGEgbmV3IHBlZXIgYWRkcmVzcyBjb250YWluaW5nIGEgbm9uLXByb2JpbmcgZnJhbWUgaW5kaWNhdGVzIHRoYXQgdGhlIHBlZXIgaGFzIG1pZ3JhdGVkIHRvIHRoYXQgYWRkcmVzcy4gSWYgdGhlIHJlY2lwaWVudCBwZXJtaXRzIHRoZSBtaWdyYXRpb24sIGl0IE1VU1Qgc2VuZCBzdWJzZXF1ZW50IHBhY2tldHMgdG8gdGhlIG5ldyBwZWVyIGFkZHJlc3MgYW5kIE1VU1QgaW5pdGlhdGUgcGF0aCB2YWxpZGF0aW9uIChTZWN0aW9uIDguMikgdG8gdmVyaWZ5IHRoZSBwZWVyJ3Mgb3duZXJzaGlwIG9mIHRoZSBhZGRyZXNzIGlmIHZhbGlkYXRpb24gaXMgbm90IGFscmVhZHkgdW5kZXJ3YXkuIElmIHRoZSByZWNpcGllbnQgaGFzIG5vIHVudXNlZCBjb25uZWN0aW9uIElEcyBmcm9tIHRoZSBwZWVyLCBpdCB3aWxsIG5vdCBiZSBhYmxlIHRvIHNlbmQgYW55dGhpbmcgb24gdGhlIG5ldyBwYXRoIHVudGlsIHRoZSBwZWVyIHByb3ZpZGVzIG9uZTsgc2VlIFNlY3Rpb24gOS41LiBBbiBlbmRwb2ludCBvbmx5IGNoYW5nZXMgdGhlIGFkZHJlc3MgdG8gd2hpY2ggaXQgc2VuZHMgcGFja2V0cyBpbiByZXNwb25zZSB0byB0aGUgaGlnaGVzdC1udW1iZXJlZCBub24tcHJvYmluZyBwYWNrZXQuIFRoaXMgZW5zdXJlcyB0aGF0IGFuIGVuZHBvaW50IGRvZXMgbm90IHNlbmQgcGFja2V0cyB0byBhbiBvbGQgcGVlciBhZGRyZXNzIGluIHRoZSBjYXNlIHRoYXQgaXQgcmVjZWl2ZXMgcmVvcmRlcmVkIHBhY2tldHMuIEFuIGVuZHBvaW50IE1BWSBzZW5kIGRhdGEgdG8gYW4gdW52YWxpZGF0ZWQgcGVlciBhZGRyZXNzLCBidXQgaXQgTVVTVCBwcm90ZWN0IGFnYWluc3QgcG90ZW50aWFsIGF0dGFja3MgYXMgZGVzY3JpYmVkIGluIFNlY3Rpb25zIDkuMy4xIGFuZCA5LjMuMi4gQW4gZW5kcG9pbnQgTUFZIHNraXAgdmFsaWRhdGlvbiBvZiBhIHBlZXIgYWRkcmVzcyBpZiB0aGF0IGFkZHJlc3MgaGFzIGJlZW4gc2VlbiByZWNlbnRseS4gSW4gcGFydGljdWxhciwgaWYgYW4gZW5kcG9pbnQgcmV0dXJucyB0byBhIHByZXZpb3VzbHkgdmFsaWRhdGVkIHBhdGggYWZ0ZXIgZGV0ZWN0aW5nIHNvbWUgZm9ybSBvZiBzcHVyaW91cyBtaWdyYXRpb24sIHNraXBwaW5nIGFkZHJlc3MgdmFsaWRhdGlvbiBhbmQgcmVzdG9yaW5nIGxvc3MgZGV0ZWN0aW9uIGFuZCBjb25nZXN0aW9uIHN0YXRlIGNhbiByZWR1Y2UgdGhlIHBlcmZvcm1hbmNlIGltcGFjdCBvZiB0aGUgYXR0YWNrLiBBZnRlciBjaGFuZ2luZyB0aGUgYWRkcmVzcyB0byB3aGljaCBpdCBzZW5kcyBub24tcHJvYmluZyBwYWNrZXRzLCBhbiBlbmRwb2ludCBjYW4gYWJhbmRvbiBhbnkgcGF0aCB2YWxpZGF0aW9uIGZvciBvdGhlciBhZGRyZXNzZXMuIFJlY2VpdmluZyBhIHBhY2tldCBmcm9tIGEgbmV3IHBlZXIgYWRkcmVzcyBjb3VsZCBiZSB0aGUgcmVzdWx0IG9mIGEgTkFUIHJlYmluZGluZyBhdCB0aGUgcGVlci4gQWZ0ZXIgdmVyaWZ5aW5nIGEgbmV3IGNsaWVudCBhZGRyZXNzLCB0aGUgc2VydmVyIFNIT1VMRCBzZW5kIG5ldyBhZGRyZXNzIHZhbGlkYXRpb24gdG9rZW5zIChTZWN0aW9uIDgpIHRvIHRoZSBjbGllbnQuIDkuMy4xLiBQZWVyIEFkZHJlc3MgU3Bvb2ZpbmcgSXQgaXMgcG9zc2libGUgdGhhdCBhIHBlZXIgaXMgc3Bvb2ZpbmcgaXRzIHNvdXJjZSBhZGRyZXNzIHRvIGNhdXNlIGFuIGVuZHBvaW50IHRvIHNlbmQgZXhjZXNzaXZlIGFtb3VudHMgb2YgZGF0YSB0byBhbiB1bndpbGxpbmcgaG9zdC4gSWYgdGhlIGVuZHBvaW50IHNlbmRzIHNpZ25pZmljYW50bHkgbW9yZSBkYXRhIHRoYW4gdGhlIHNwb29maW5nIHBlZXIsIGNvbm5lY3Rpb24gbWlncmF0aW9uIG1pZ2h0IGJlIHVzZWQgdG8gYW1wbGlmeSB0aGUgdm9sdW1lIG9mIGRhdGEgdGhhdCBhbiBhdHRhY2tlciBjYW4gZ2VuZXJhdGUgdG93YXJkIGEgdmljdGltLiBBcyBkZXNjcmliZWQgaW4gU2VjdGlvbiA5LjMsIGFuIGVuZHBvaW50IGlzIHJlcXVpcmVkIHRvIHZhbGlkYXRlIGEgcGVlcidzIG5ldyBhZGRyZXNzIHRvIGNvbmZpcm0gdGhlIHBlZXIncyBwb3NzZXNzaW9uIG9mIHRoZSBuZXcgYWRkcmVzcy4gVW50aWwgYSBwZWVyJ3MgYWRkcmVzcyBpcyBkZWVtZWQgdmFsaWQsIGFuIGVuZHBvaW50IGxpbWl0cyB0aGUgYW1vdW50IG9mIGRhdGEgaXQgc2VuZHMgdG8gdGhhdCBhZGRyZXNzOyBzZWUgU2VjdGlvbiA4LiBJbiB0aGUgYWJzZW5jZSBvZiB0aGlzIGxpbWl0LCBhbiBlbmRwb2ludCByaXNrcyBiZWluZyB1c2VkIGZvciBhIGRlbmlhbC1vZi0gc2VydmljZSBhdHRhY2sgYWdhaW5zdCBhbiB1bnN1c3BlY3RpbmcgdmljdGltLiBJZiBhbiBlbmRwb2ludCBza2lwcyB2YWxpZGF0aW9uIG9mIGEgcGVlciBhZGRyZXNzIGFzIGRlc2NyaWJlZCBhYm92ZSwgaXQgZG9lcyBub3QgbmVlZCB0byBsaW1pdCBpdHMgc2VuZGluZyByYXRlLiA5LjMuMi4gT24tUGF0aCBBZGRyZXNzIFNwb29maW5nIEFuIG9uLXBhdGggYXR0YWNrZXIgY291bGQgY2F1c2UgYSBzcHVyaW91cyBjb25uZWN0aW9uIG1pZ3JhdGlvbiBieSBjb3B5aW5nIGFuZCBmb3J3YXJkaW5nIGEgcGFja2V0IHdpdGggYSBzcG9vZmVkIGFkZHJlc3Mgc3VjaCB0aGF0IGl0IGFycml2ZXMgYmVmb3JlIHRoZSBvcmlnaW5hbCBwYWNrZXQuIFRoZSBwYWNrZXQgd2l0aCB0aGUgc3Bvb2ZlZCBhZGRyZXNzIHdpbGwgYmUgc2VlbiB0byBjb21lIGZyb20gYSBtaWdyYXRpbmcgY29ubmVjdGlvbiwgYW5kIHRoZSBvcmlnaW5hbCBwYWNrZXQgd2lsbCBiZSBzZWVuIGFzIGEgZHVwbGljYXRlIGFuZCBkcm9wcGVkLiBBZnRlciBhIHNwdXJpb3VzIG1pZ3JhdGlvbiwgdmFsaWRhdGlvbiBvZiB0aGUgc291cmNlIGFkZHJlc3Mgd2lsbCBmYWlsIGJlY2F1c2UgdGhlIGVudGl0eSBhdCB0aGUgc291cmNlIGFkZHJlc3MgZG9lcyBub3QgaGF2ZSB0aGUgbmVjZXNzYXJ5IGNyeXB0b2dyYXBoaWMga2V5cyB0byByZWFkIG9yIHJlc3BvbmQgdG8gdGhlIFBBVEhfQ0hBTExFTkdFIGZyYW1lIHRoYXQgaXMgc2VudCB0byBpdCBldmVuIGlmIGl0IHdhbnRlZCB0by4gVG8gcHJvdGVjdCB0aGUgY29ubmVjdGlvbiBmcm9tIGZhaWxpbmcgZHVlIHRvIHN1Y2ggYSBzcHVyaW91cyBtaWdyYXRpb24sIGFuIGVuZHBvaW50IE1VU1QgcmV2ZXJ0IHRvIHVzaW5nIHRoZSBsYXN0IHZhbGlkYXRlZCBwZWVyIGFkZHJlc3Mgd2hlbiB2YWxpZGF0aW9uIG9mIGEgbmV3IHBlZXIgYWRkcmVzcyBmYWlscy4gQWRkaXRpb25hbGx5LCByZWNlaXB0IG9mIHBhY2tldHMgd2l0aCBoaWdoZXIgcGFja2V0IG51bWJlcnMgZnJvbSB0aGUgbGVnaXRpbWF0ZSBwZWVyIGFkZHJlc3Mgd2lsbCB0cmlnZ2VyIGFub3RoZXIgY29ubmVjdGlvbiBtaWdyYXRpb24uIFRoaXMgd2lsbCBjYXVzZSB0aGUgdmFsaWRhdGlvbiBvZiB0aGUgYWRkcmVzcyBvZiB0aGUgc3B1cmlvdXMgbWlncmF0aW9uIHRvIGJlIGFiYW5kb25lZCwgdGh1cyBjb250YWluaW5nIG1pZ3JhdGlvbnMgaW5pdGlhdGVkIGJ5IHRoZSBhdHRhY2tlciBpbmplY3RpbmcgYSBzaW5nbGUgcGFja2V0LiBJZiBhbiBlbmRwb2ludCBoYXMgbm8gc3RhdGUgYWJvdXQgdGhlIGxhc3QgdmFsaWRhdGVkIHBlZXIgYWRkcmVzcywgaXQgTVVTVCBjbG9zZSB0aGUgY29ubmVjdGlvbiBzaWxlbnRseSBieSBkaXNjYXJkaW5nIGFsbCBjb25uZWN0aW9uIHN0YXRlLiBUaGlzIHJlc3VsdHMgaW4gbmV3IHBhY2tldHMgb24gdGhlIGNvbm5lY3Rpb24gYmVpbmcgaGFuZGxlZCBnZW5lcmljYWxseS4gRm9yIGluc3RhbmNlLCBhbiBlbmRwb2ludCBNQVkgc2VuZCBhIFN0YXRlbGVzcyBSZXNldCBpbiByZXNwb25zZSB0byBhbnkgZnVydGhlciBpbmNvbWluZyBwYWNrZXRzLiA5LjMuMy4gT2ZmLVBhdGggUGFja2V0IEZvcndhcmRpbmcgQW4gb2ZmLXBhdGggYXR0YWNrZXIgdGhhdCBjYW4gb2JzZXJ2ZSBwYWNrZXRzIG1pZ2h0IGZvcndhcmQgY29waWVzIG9mIGdlbnVpbmUgcGFja2V0cyB0byBlbmRwb2ludHMuIElmIHRoZSBjb3BpZWQgcGFja2V0IGFycml2ZXMgYmVmb3JlIHRoZSBnZW51aW5lIHBhY2tldCwgdGhpcyB3aWxsIGFwcGVhciBhcyBhIE5BVCByZWJpbmRpbmcuIEFueSBnZW51aW5lIHBhY2tldCB3aWxsIGJlIGRpc2NhcmRlZCBhcyBhIGR1cGxpY2F0ZS4gSWYgdGhlIGF0dGFja2VyIGlzIGFibGUgdG8gY29udGludWUgZm9yd2FyZGluZyBwYWNrZXRzLCBpdCBtaWdodCBiZSBhYmxlIHRvIGNhdXNlIG1pZ3JhdGlvbiB0byBhIHBhdGggdmlhIHRoZSBhdHRhY2tlci4gVGhpcyBwbGFjZXMgdGhlIGF0dGFja2VyIG9uLXBhdGgsIGdpdmluZyBpdCB0aGUgYWJpbGl0eSB0byBvYnNlcnZlIG9yIGRyb3AgYWxsIHN1YnNlcXVlbnQgcGFja2V0cy4gVGhpcyBzdHlsZSBvZiBhdHRhY2sgcmVsaWVzIG9uIHRoZSBhdHRhY2tlciB1c2luZyBhIHBhdGggdGhhdCBoYXMgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBjaGFyYWN0ZXJpc3RpY3MgYXMgdGhlIGRpcmVjdCBwYXRoIGJldHdlZW4gZW5kcG9pbnRzLiBUaGUgYXR0YWNrIGlzIG1vcmUgcmVsaWFibGUgaWYgcmVsYXRpdmVseSBmZXcgcGFja2V0cyBhcmUgc2VudCBvciBpZiBwYWNrZXQgbG9zcyBjb2luY2lkZXMgd2l0aCB0aGUgYXR0ZW1wdGVkIGF0dGFjay4gQSBub24tcHJvYmluZyBwYWNrZXQgcmVjZWl2ZWQgb24gdGhlIG9yaWdpbmFsIHBhdGggdGhhdCBpbmNyZWFzZXMgdGhlIG1heGltdW0gcmVjZWl2ZWQgcGFja2V0IG51bWJlciB3aWxsIGNhdXNlIHRoZSBlbmRwb2ludCB0byBtb3ZlIGJhY2sgdG8gdGhhdCBwYXRoLiBFbGljaXRpbmcgcGFja2V0cyBvbiB0aGlzIHBhdGggaW5jcmVhc2VzIHRoZSBsaWtlbGlob29kIHRoYXQgdGhlIGF0dGFjayBpcyB1bnN1Y2Nlc3NmdWwuIFRoZXJlZm9yZSwgbWl0aWdhdGlvbiBvZiB0aGlzIGF0dGFjayByZWxpZXMgb24gdHJpZ2dlcmluZyB0aGUgZXhjaGFuZ2Ugb2YgcGFja2V0cy4gSW4gcmVzcG9uc2UgdG8gYW4gYXBwYXJlbnQgbWlncmF0aW9uLCBlbmRwb2ludHMgTVVTVCB2YWxpZGF0ZSB0aGUgcHJldmlvdXNseSBhY3RpdmUgcGF0aCB1c2luZyBhIFBBVEhfQ0hBTExFTkdFIGZyYW1lLiBUaGlzIGluZHVjZXMgdGhlIHNlbmRpbmcgb2YgbmV3IHBhY2tldHMgb24gdGhhdCBwYXRoLiBJZiB0aGUgcGF0aCBpcyBubyBsb25nZXIgdmlhYmxlLCB0aGUgdmFsaWRhdGlvbiBhdHRlbXB0IHdpbGwgdGltZSBvdXQgYW5kIGZhaWw7IGlmIHRoZSBwYXRoIGlzIHZpYWJsZSBidXQgbm8gbG9uZ2VyIGRlc2lyZWQsIHRoZSB2YWxpZGF0aW9uIHdpbGwgc3VjY2VlZCBidXQgb25seSByZXN1bHRzIGluIHByb2JpbmcgcGFja2V0cyBiZWluZyBzZW50IG9uIHRoZSBwYXRoLiBBbiBlbmRwb2ludCB0aGF0IHJlY2VpdmVzIGEgUEFUSF9DSEFMTEVOR0Ugb24gYW4gYWN0aXZlIHBhdGggU0hPVUxEIHNlbmQgYSBub24tcHJvYmluZyBwYWNrZXQgaW4gcmVzcG9uc2UuIElmIHRoZSBub24tcHJvYmluZyBwYWNrZXQgYXJyaXZlcyBiZWZvcmUgYW55IGNvcHkgbWFkZSBieSBhbiBhdHRhY2tlciwgdGhpcyByZXN1bHRzIGluIHRoZSBjb25uZWN0aW9uIGJlaW5nIG1pZ3JhdGVkIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHBhdGguIEFueSBzdWJzZXF1ZW50IG1pZ3JhdGlvbiB0byBhbm90aGVyIHBhdGggcmVzdGFydHMgdGhpcyBlbnRpcmUgcHJvY2Vzcy4gVGhpcyBkZWZlbnNlIGlzIGltcGVyZmVjdCwgYnV0IHRoaXMgaXMgbm90IGNvbnNpZGVyZWQgYSBzZXJpb3VzIHByb2JsZW0uIElmIHRoZSBwYXRoIHZpYSB0aGUgYXR0YWNrIGlzIHJlbGlhYmx5IGZhc3RlciB0aGFuIHRoZSBvcmlnaW5hbCBwYXRoIGRlc3BpdGUgbXVsdGlwbGUgYXR0ZW1wdHMgdG8gdXNlIHRoYXQgb3JpZ2luYWwgcGF0aCwgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gYW4gYXR0YWNrIGFuZCBhbiBpbXByb3ZlbWVudCBpbiByb3V0aW5nLiBBbiBlbmRwb2ludCBjb3VsZCBhbHNvIHVzZSBoZXVyaXN0aWNzIHRvIGltcHJvdmUgZGV0ZWN0aW9uIG9mIHRoaXMgc3R5bGUgb2YgYXR0YWNrLiBGb3IgaW5zdGFuY2UsIE5BVCByZWJpbmRpbmcgaXMgaW1wcm9iYWJsZSBpZiBwYWNrZXRzIHdlcmUgcmVjZW50bHkgcmVjZWl2ZWQgb24gdGhlIG9sZCBwYXRoOyBzaW1pbGFybHksIHJlYmluZGluZyBpcyByYXJlIG9uIElQdjYgcGF0aHMuIEVuZHBvaW50cyBjYW4gYWxzbyBsb29rIGZvciBkdXBsaWNhdGVkIHBhY2tldHMuIENvbnZlcnNlbHksIGEgY2hhbmdlIGluIGNvbm5lY3Rpb24gSUQgaXMgbW9yZSBsaWtlbHkgdG8gaW5kaWNhdGUgYW4gaW50ZW50aW9uYWwgbWlncmF0aW9uIHJhdGhlciB0aGFuIGFuIGF0dGFjay4gOS40LiBMb3NzIERldGVjdGlvbiBhbmQgQ29uZ2VzdGlvbiBDb250cm9sIFRoZSBjYXBhY2l0eSBhdmFpbGFibGUgb24gdGhlIG5ldyBwYXRoIG1pZ2h0IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgb2xkIHBhdGguIFBhY2tldHMgc2VudCBvbiB0aGUgb2xkIHBhdGggTVVTVCBOT1QgY29udHJpYnV0ZSB0byBjb25nZXN0aW9uIGNvbnRyb2wgb3IgUlRUIGVzdGltYXRpb24gZm9yIHRoZSBuZXcgcGF0aC4gT24gY29uZmlybWluZyBhIHBlZXIncyBvd25lcnNoaXAgb2YgaXRzIG5ldyBhZGRyZXNzLCBhbiBlbmRwb2ludCBNVVNUIGltbWVkaWF0ZWx5IHJlc2V0IHRoZSBjb25nZXN0aW9uIGNvbnRyb2xsZXIgYW5kIHJvdW5kLXRyaXAgdGltZSBlc3RpbWF0b3IgZm9yIHRoZSBuZXcgcGF0aCB0byBpbml0aWFsIHZhbHVlcyAoc2VlIEFwcGVuZGljZXMgQS4zIGFuZCBCLjMgb2YgW1FVSUMtUkVDT1ZFUlldKSB1bmxlc3MgdGhlIG9ubHkgY2hhbmdlIGluIHRoZSBwZWVyJ3MgYWRkcmVzcyBpcyBpdHMgcG9ydCBudW1iZXIuIEJlY2F1c2UgcG9ydC1vbmx5IGNoYW5nZXMgYXJlIGNvbW1vbmx5IHRoZSByZXN1bHQgb2YgTkFUIHJlYmluZGluZyBvciBvdGhlciBtaWRkbGVib3ggYWN0aXZpdHksIHRoZSBlbmRwb2ludCBNQVkgaW5zdGVhZCByZXRhaW4gaXRzIGNvbmdlc3Rpb24gY29udHJvbCBzdGF0ZSBhbmQgcm91bmQtdHJpcCBlc3RpbWF0ZSBpbiB0aG9zZSBjYXNlcyBpbnN0ZWFkIG9mIHJldmVydGluZyB0byBpbml0aWFsIHZhbHVlcy4gSW4gY2FzZXMgd2hlcmUgY29uZ2VzdGlvbiBjb250cm9sIHN0YXRlIHJldGFpbmVkIGZyb20gYW4gb2xkIHBhdGggaXMgdXNlZCBvbiBhIG5ldyBwYXRoIHdpdGggc3Vic3RhbnRpYWxseSBkaWZmZXJlbnQgY2hhcmFjdGVyaXN0aWNzLCBhIHNlbmRlciBjb3VsZCB0cmFuc21pdCB0b28gYWdncmVzc2l2ZWx5IHVudGlsIHRoZSBjb25nZXN0aW9uIGNvbnRyb2xsZXIgYW5kIHRoZSBSVFQgZXN0aW1hdG9yIGhhdmUgYWRhcHRlZC4gR2VuZXJhbGx5LCBpbXBsZW1lbnRhdGlvbnMgYXJlIGFkdmlzZWQgdG8gYmUgY2F1dGlvdXMgd2hlbiB1c2luZyBwcmV2aW91cyB2YWx1ZXMgb24gYSBuZXcgcGF0aC4gVGhlcmUgY291bGQgYmUgYXBwYXJlbnQgcmVvcmRlcmluZyBhdCB0aGUgcmVjZWl2ZXIgd2hlbiBhbiBlbmRwb2ludCBzZW5kcyBkYXRhIGFuZCBwcm9iZXMgZnJvbS90byBtdWx0aXBsZSBhZGRyZXNzZXMgZHVyaW5nIHRoZSBtaWdyYXRpb24gcGVyaW9kLCBzaW5jZSB0aGUgdHdvIHJlc3VsdGluZyBwYXRocyBjb3VsZCBoYXZlIGRpZmZlcmVudCByb3VuZC10cmlwIHRpbWVzLiBBIHJlY2VpdmVyIG9mIHBhY2tldHMgb24gbXVsdGlwbGUgcGF0aHMgd2lsbCBzdGlsbCBzZW5kIEFDSyBmcmFtZXMgY292ZXJpbmcgYWxsIHJlY2VpdmVkIHBhY2tldHMuIFdoaWxlIG11bHRpcGxlIHBhdGhzIG1pZ2h0IGJlIHVzZWQgZHVyaW5nIGNvbm5lY3Rpb24gbWlncmF0aW9uLCBhIHNpbmdsZSBjb25nZXN0aW9uIGNvbnRyb2wgY29udGV4dCBhbmQgYSBzaW5nbGUgbG9zcyByZWNvdmVyeSBjb250ZXh0IChhcyBkZXNjcmliZWQgaW4gW1FVSUMtUkVDT1ZFUlldKSBjb3VsZCBiZSBhZGVxdWF0ZS4gRm9yIGluc3RhbmNlLCBhbiBlbmRwb2ludCBtaWdodCBkZWxheSBzd2l0Y2hpbmcgdG8gYSBuZXcgY29uZ2VzdGlvbiBjb250cm9sIGNvbnRleHQgdW50aWwgaXQgaXMgY29uZmlybWVkIHRoYXQgYW4gb2xkIHBhdGggaXMgbm8gbG9uZ2VyIG5lZWRlZCAoc3VjaCBhcyB0aGUgY2FzZSBkZXNjcmliZWQgaW4gU2VjdGlvbiA5LjMuMykuIEEgc2VuZGVyIGNhbiBtYWtlIGV4Y2VwdGlvbnMgZm9yIHByb2JlIHBhY2tldHMgc28gdGhhdCB0aGVpciBsb3NzIGRldGVjdGlvbiBpcyBpbmRlcGVuZGVudCBhbmQgZG9lcyBub3QgdW5kdWx5IGNhdXNlIHRoZSBjb25nZXN0aW9uIGNvbnRyb2xsZXIgdG8gcmVkdWNlIGl0cyBzZW5kaW5nIHJhdGUuIEFuIGVuZHBvaW50IG1pZ2h0IHNldCBhIHNlcGFyYXRlIHRpbWVyIHdoZW4gYSBQQVRIX0NIQUxMRU5HRSBpcyBzZW50LCB3aGljaCBpcyBjYW5jZWxlZCBpZiB0aGUgY29ycmVzcG9uZGluZyBQQVRIX1JFU1BPTlNFIGlzIHJlY2VpdmVkLiBJZiB0aGUgdGltZXIgZmlyZXMgYmVmb3JlIHRoZSBQQVRIX1JFU1BPTlNFIGlzIHJlY2VpdmVkLCB0aGUgZW5kcG9pbnQgbWlnaHQgc2VuZCBhIG5ldyBQQVRIX0NIQUxMRU5HRSBhbmQgcmVzdGFydCB0aGUgdGltZXIgZm9yIGEgbG9uZ2VyIHBlcmlvZCBvZiB0aW1lLiBUaGlzIHRpbWVyIFNIT1VMRCBiZSBzZXQgYXMgZGVzY3JpYmVkIGluIFNlY3Rpb24gNi4yLjEgb2YgW1FVSUMtUkVDT1ZFUlldIGFuZCBNVVNUIE5PVCBiZSBtb3JlIGFnZ3Jlc3NpdmUuIDkuNS4gUHJpdmFjeSBJbXBsaWNhdGlvbnMgb2YgQ29ubmVjdGlvbiBNaWdyYXRpb24gVXNpbmcgYSBzdGFibGUgY29ubmVjdGlvbiBJRCBvbiBtdWx0aXBsZSBuZXR3b3JrIHBhdGhzIHdvdWxkIGFsbG93IGEgcGFzc2l2ZSBvYnNlcnZlciB0byBjb3JyZWxhdGUgYWN0aXZpdHkgYmV0d2VlbiB0aG9zZSBwYXRocy4gQW4gZW5kcG9pbnQgdGhhdCBtb3ZlcyBiZXR3ZWVuIG5ldHdvcmtzIG1pZ2h0IG5vdCB3aXNoIHRvIGhhdmUgdGhlaXIgYWN0aXZpdHkgY29ycmVsYXRlZCBieSBhbnkgZW50aXR5IG90aGVyIHRoYW4gdGhlaXIgcGVlciwgc28gZGlmZmVyZW50IGNvbm5lY3Rpb24gSURzIGFyZSB1c2VkIHdoZW4gc2VuZGluZyBmcm9tIGRpZmZlcmVudCBsb2NhbCBhZGRyZXNzZXMsIGFzIGRpc2N1c3NlZCBpbiBTZWN0aW9uIDUuMS4gRm9yIHRoaXMgdG8gYmUgZWZmZWN0aXZlLCBlbmRwb2ludHMgbmVlZCB0byBlbnN1cmUgdGhhdCBjb25uZWN0aW9uIElEcyB0aGV5IHByb3ZpZGUgY2Fubm90IGJlIGxpbmtlZCBieSBhbnkgb3RoZXIgZW50aXR5LiBBdCBhbnkgdGltZSwgZW5kcG9pbnRzIE1BWSBjaGFuZ2UgdGhlIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgdGhleSB0cmFuc21pdCB3aXRoIHRvIGEgdmFsdWUgdGhhdCBoYXMgbm90IGJlZW4gdXNlZCBvbiBhbm90aGVyIHBhdGguIEFuIGVuZHBvaW50IE1VU1QgTk9UIHJldXNlIGEgY29ubmVjdGlvbiBJRCB3aGVuIHNlbmRpbmcgZnJvbSBtb3JlIHRoYW4gb25lIGxvY2FsIGFkZHJlc3MgLS0gZm9yIGV4YW1wbGUsIHdoZW4gaW5pdGlhdGluZyBjb25uZWN0aW9uIG1pZ3JhdGlvbiBhcyBkZXNjcmliZWQgaW4gU2VjdGlvbiA5LjIgb3Igd2hlbiBwcm9iaW5nIGEgbmV3IG5ldHdvcmsgcGF0aCBhcyBkZXNjcmliZWQgaW4gU2VjdGlvbiA5LjEuIFNpbWlsYXJseSwgYW4gZW5kcG9pbnQgTVVTVCBOT1QgcmV1c2UgYSBjb25uZWN0aW9uIElEIHdoZW4gc2VuZGluZyB0byBtb3JlIHRoYW4gb25lIGRlc3RpbmF0aW9uIGFkZHJlc3MuIER1ZSB0byBuZXR3b3JrIGNoYW5nZXMgb3V0c2lkZSB0aGUgY29udHJvbCBvZiBpdHMgcGVlciwgYW4gZW5kcG9pbnQgbWlnaHQgcmVjZWl2ZSBwYWNrZXRzIGZyb20gYSBuZXcgc291cmNlIGFkZHJlc3Mgd2l0aCB0aGUgc2FtZSBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEIGZpZWxkIHZhbHVlLCBpbiB3aGljaCBjYXNlIGl0IE1BWSBjb250aW51ZSB0byB1c2UgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBJRCB3aXRoIHRoZSBuZXcgcmVtb3RlIGFkZHJlc3Mgd2hpbGUgc3RpbGwgc2VuZGluZyBmcm9tIHRoZSBzYW1lIGxvY2FsIGFkZHJlc3MuIFRoZXNlIHJlcXVpcmVtZW50cyByZWdhcmRpbmcgY29ubmVjdGlvbiBJRCByZXVzZSBhcHBseSBvbmx5IHRvIHRoZSBzZW5kaW5nIG9mIHBhY2tldHMsIGFzIHVuaW50ZW50aW9uYWwgY2hhbmdlcyBpbiBwYXRoIHdpdGhvdXQgYSBjaGFuZ2UgaW4gY29ubmVjdGlvbiBJRCBhcmUgcG9zc2libGUuIEZvciBleGFtcGxlLCBhZnRlciBhIHBlcmlvZCBvZiBuZXR3b3JrIGluYWN0aXZpdHksIE5BVCByZWJpbmRpbmcgbWlnaHQgY2F1c2UgcGFja2V0cyB0byBiZSBzZW50IG9uIGEgbmV3IHBhdGggd2hlbiB0aGUgY2xpZW50IHJlc3VtZXMgc2VuZGluZy4gQW4gZW5kcG9pbnQgcmVzcG9uZHMgdG8gc3VjaCBhbiBldmVudCBhcyBkZXNjcmliZWQgaW4gU2VjdGlvbiA5LjMuIFVzaW5nIGRpZmZlcmVudCBjb25uZWN0aW9uIElEcyBmb3IgcGFja2V0cyBzZW50IGluIGJvdGggZGlyZWN0aW9ucyBvbiBlYWNoIG5ldyBuZXR3b3JrIHBhdGggZWxpbWluYXRlcyB0aGUgdXNlIG9mIHRoZSBjb25uZWN0aW9uIElEIGZvciBsaW5raW5nIHBhY2tldHMgZnJvbSB0aGUgc2FtZSBjb25uZWN0aW9uIGFjcm9zcyBkaWZmZXJlbnQgbmV0d29yayBwYXRocy4gSGVhZGVyIHByb3RlY3Rpb24gZW5zdXJlcyB0aGF0IHBhY2tldCBudW1iZXJzIGNhbm5vdCBiZSB1c2VkIHRvIGNvcnJlbGF0ZSBhY3Rpdml0eS4gVGhpcyBkb2VzIG5vdCBwcmV2ZW50IG90aGVyIHByb3BlcnRpZXMgb2YgcGFja2V0cywgc3VjaCBhcyB0aW1pbmcgYW5kIHNpemUsIGZyb20gYmVpbmcgdXNlZCB0byBjb3JyZWxhdGUgYWN0aXZpdHkuIEFuIGVuZHBvaW50IFNIT1VMRCBOT1QgaW5pdGlhdGUgbWlncmF0aW9uIHdpdGggYSBwZWVyIHRoYXQgaGFzIHJlcXVlc3RlZCBhIHplcm8tbGVuZ3RoIGNvbm5lY3Rpb24gSUQsIGJlY2F1c2UgdHJhZmZpYyBvdmVyIHRoZSBuZXcgcGF0aCBtaWdodCBiZSB0cml2aWFsbHkgbGlua2FibGUgdG8gdHJhZmZpYyBvdmVyIHRoZSBvbGQgb25lLiBJZiB0aGUgc2VydmVyIGlzIGFibGUgdG8gYXNzb2NpYXRlIHBhY2tldHMgd2l0aCBhIHplcm8tbGVuZ3RoIGNvbm5lY3Rpb24gSUQgdG8gdGhlIHJpZ2h0IGNvbm5lY3Rpb24sIGl0IG1lYW5zIHRoYXQgdGhlIHNlcnZlciBpcyB1c2luZyBvdGhlciBpbmZvcm1hdGlvbiB0byBkZW11bHRpcGxleCBwYWNrZXRzLiBGb3IgZXhhbXBsZSwgYSBzZXJ2ZXIgbWlnaHQgcHJvdmlkZSBhIHVuaXF1ZSBhZGRyZXNzIHRvIGV2ZXJ5IGNsaWVudCAtLSBmb3IgaW5zdGFuY2UsIHVzaW5nIEhUVFAgYWx0ZXJuYXRpdmUgc2VydmljZXMgW0FMVFNWQ10uIEluZm9ybWF0aW9uIHRoYXQgbWlnaHQgYWxsb3cgY29ycmVjdCByb3V0aW5nIG9mIHBhY2tldHMgYWNyb3NzIG11bHRpcGxlIG5ldHdvcmsgcGF0aHMgd2lsbCBhbHNvIGFsbG93IGFjdGl2aXR5IG9uIHRob3NlIHBhdGhzIHRvIGJlIGxpbmtlZCBieSBlbnRpdGllcyBvdGhlciB0aGFuIHRoZSBwZWVyLiBBIGNsaWVudCBtaWdodCB3aXNoIHRvIHJlZHVjZSBsaW5rYWJpbGl0eSBieSBzd2l0Y2hpbmcgdG8gYSBuZXcgY29ubmVjdGlvbiBJRCwgc291cmNlIFVEUCBwb3J0LCBvciBJUCBhZGRyZXNzIChzZWUgW1JGQzg5ODFdKSB3aGVuIHNlbmRpbmcgdHJhZmZpYyBhZnRlciBhIHBlcmlvZCBvZiBpbmFjdGl2aXR5LiBDaGFuZ2luZyB0aGUgYWRkcmVzcyBmcm9tIHdoaWNoIGl0IHNlbmRzIHBhY2tldHMgYXQgdGhlIHNhbWUgdGltZSBtaWdodCBjYXVzZSB0aGUgc2VydmVyIHRvIGRldGVjdCBhIGNvbm5lY3Rpb24gbWlncmF0aW9uLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgbWVjaGFuaXNtcyB0aGF0IHN1cHBvcnQgbWlncmF0aW9uIGFyZSBleGVyY2lzZWQgZXZlbiBmb3IgY2xpZW50cyB0aGF0IGRvIG5vdCBleHBlcmllbmNlIE5BVCByZWJpbmRpbmdzIG9yIGdlbnVpbmUgbWlncmF0aW9ucy4gQ2hhbmdpbmcgYWRkcmVzcyBjYW4gY2F1c2UgYSBwZWVyIHRvIHJlc2V0IGl0cyBjb25nZXN0aW9uIGNvbnRyb2wgc3RhdGUgKHNlZSBTZWN0aW9uIDkuNCksIHNvIGFkZHJlc3NlcyBTSE9VTEQgb25seSBiZSBjaGFuZ2VkIGluZnJlcXVlbnRseS4gQW4gZW5kcG9pbnQgdGhhdCBleGhhdXN0cyBhdmFpbGFibGUgY29ubmVjdGlvbiBJRHMgY2Fubm90IHByb2JlIG5ldyBwYXRocyBvciBpbml0aWF0ZSBtaWdyYXRpb24sIG5vciBjYW4gaXQgcmVzcG9uZCB0byBwcm9iZXMgb3IgYXR0ZW1wdHMgYnkgaXRzIHBlZXIgdG8gbWlncmF0ZS4gVG8gZW5zdXJlIHRoYXQgbWlncmF0aW9uIGlzIHBvc3NpYmxlIGFuZCBwYWNrZXRzIHNlbnQgb24gZGlmZmVyZW50IHBhdGhzIGNhbm5vdCBiZSBjb3JyZWxhdGVkLCBlbmRwb2ludHMgU0hPVUxEIHByb3ZpZGUgbmV3IGNvbm5lY3Rpb24gSURzIGJlZm9yZSBwZWVycyBtaWdyYXRlOyBzZWUgU2VjdGlvbiA1LjEuMS4gSWYgYSBwZWVyIG1pZ2h0IGhhdmUgZXhoYXVzdGVkIGF2YWlsYWJsZSBjb25uZWN0aW9uIElEcywgYSBtaWdyYXRpbmcgZW5kcG9pbnQgY291bGQgaW5jbHVkZSBhIE5FV19DT05ORUNUSU9OX0lEIGZyYW1lIGluIGFsbCBwYWNrZXRzIHNlbnQgb24gYSBuZXcgbmV0d29yayBwYXRoLiA5LjYuIFNlcnZlcidzIFByZWZlcnJlZCBBZGRyZXNzIFFVSUMgYWxsb3dzIHNlcnZlcnMgdG8gYWNjZXB0IGNvbm5lY3Rpb25zIG9uIG9uZSBJUCBhZGRyZXNzIGFuZCBhdHRlbXB0IHRvIHRyYW5zZmVyIHRoZXNlIGNvbm5lY3Rpb25zIHRvIGEgbW9yZSBwcmVmZXJyZWQgYWRkcmVzcyBzaG9ydGx5IGFmdGVyIHRoZSBoYW5kc2hha2UuIFRoaXMgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCB3aGVuIGNsaWVudHMgaW5pdGlhbGx5IGNvbm5lY3QgdG8gYW4gYWRkcmVzcyBzaGFyZWQgYnkgbXVsdGlwbGUgc2VydmVycyBidXQgd291bGQgcHJlZmVyIHRvIHVzZSBhIHVuaWNhc3QgYWRkcmVzcyB0byBlbnN1cmUgY29ubmVjdGlvbiBzdGFiaWxpdHkuIFRoaXMgc2VjdGlvbiBkZXNjcmliZXMgdGhlIHByb3RvY29sIGZvciBtaWdyYXRpbmcgYSBjb25uZWN0aW9uIHRvIGEgcHJlZmVycmVkIHNlcnZlciBhZGRyZXNzLiBNaWdyYXRpbmcgYSBjb25uZWN0aW9uIHRvIGEgbmV3IHNlcnZlciBhZGRyZXNzIG1pZC1jb25uZWN0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIHZlcnNpb24gb2YgUVVJQyBzcGVjaWZpZWQgaW4gdGhpcyBkb2N1bWVudC4gSWYgYSBjbGllbnQgcmVjZWl2ZXMgcGFja2V0cyBmcm9tIGEgbmV3IHNlcnZlciBhZGRyZXNzIHdoZW4gdGhlIGNsaWVudCBoYXMgbm90IGluaXRpYXRlZCBhIG1pZ3JhdGlvbiB0byB0aGF0IGFkZHJlc3MsIHRoZSBjbGllbnQgU0hPVUxEIGRpc2NhcmQgdGhlc2UgcGFja2V0cy4gOS42LjEuIENvbW11bmljYXRpbmcgYSBQcmVmZXJyZWQgQWRkcmVzcyBBIHNlcnZlciBjb252ZXlzIGEgcHJlZmVycmVkIGFkZHJlc3MgYnkgaW5jbHVkaW5nIHRoZSBwcmVmZXJyZWRfYWRkcmVzcyB0cmFuc3BvcnQgcGFyYW1ldGVyIGluIHRoZSBUTFMgaGFuZHNoYWtlLiBTZXJ2ZXJzIE1BWSBjb21tdW5pY2F0ZSBhIHByZWZlcnJlZCBhZGRyZXNzIG9mIGVhY2ggYWRkcmVzcyBmYW1pbHkgKElQdjQgYW5kIElQdjYpIHRvIGFsbG93IGNsaWVudHMgdG8gcGljayB0aGUgb25lIG1vc3Qgc3VpdGVkIHRvIHRoZWlyIG5ldHdvcmsgYXR0YWNobWVudC4gT25jZSB0aGUgaGFuZHNoYWtlIGlzIGNvbmZpcm1lZCwgdGhlIGNsaWVudCBTSE9VTEQgc2VsZWN0IG9uZSBvZiB0aGUgdHdvIGFkZHJlc3NlcyBwcm92aWRlZCBieSB0aGUgc2VydmVyIGFuZCBpbml0aWF0ZSBwYXRoIHZhbGlkYXRpb24gKHNlZSBTZWN0aW9uIDguMikuIEEgY2xpZW50IGNvbnN0cnVjdHMgcGFja2V0cyB1c2luZyBhbnkgcHJldmlvdXNseSB1bnVzZWQgYWN0aXZlIGNvbm5lY3Rpb24gSUQsIHRha2VuIGZyb20gZWl0aGVyIHRoZSBwcmVmZXJyZWRfYWRkcmVzcyB0cmFuc3BvcnQgcGFyYW1ldGVyIG9yIGEgTkVXX0NPTk5FQ1RJT05fSUQgZnJhbWUuIEFzIHNvb24gYXMgcGF0aCB2YWxpZGF0aW9uIHN1Y2NlZWRzLCB0aGUgY2xpZW50IFNIT1VMRCBiZWdpbiBzZW5kaW5nIGFsbCBmdXR1cmUgcGFja2V0cyB0byB0aGUgbmV3IHNlcnZlciBhZGRyZXNzIHVzaW5nIHRoZSBuZXcgY29ubmVjdGlvbiBJRCBhbmQgZGlzY29udGludWUgdXNlIG9mIHRoZSBvbGQgc2VydmVyIGFkZHJlc3MuIElmIHBhdGggdmFsaWRhdGlvbiBmYWlscywgdGhlIGNsaWVudCBNVVNUIGNvbnRpbnVlIHNlbmRpbmcgYWxsIGZ1dHVyZSBwYWNrZXRzIHRvIHRoZSBzZXJ2ZXIncyBvcmlnaW5hbCBJUCBhZGRyZXNzLiA5LjYuMi4gTWlncmF0aW9uIHRvIGEgUHJlZmVycmVkIEFkZHJlc3MgQSBjbGllbnQgdGhhdCBtaWdyYXRlcyB0byBhIHByZWZlcnJlZCBhZGRyZXNzIE1VU1QgdmFsaWRhdGUgdGhlIGFkZHJlc3MgaXQgY2hvb3NlcyBiZWZvcmUgbWlncmF0aW5nOyBzZWUgU2VjdGlvbiAyMS41LjMuIEEgc2VydmVyIG1pZ2h0IHJlY2VpdmUgYSBwYWNrZXQgYWRkcmVzc2VkIHRvIGl0cyBwcmVmZXJyZWQgSVAgYWRkcmVzcyBhdCBhbnkgdGltZSBhZnRlciBpdCBhY2NlcHRzIGEgY29ubmVjdGlvbi4gSWYgdGhpcyBwYWNrZXQgY29udGFpbnMgYSBQQVRIX0NIQUxMRU5HRSBmcmFtZSwgdGhlIHNlcnZlciBzZW5kcyBhIHBhY2tldCBjb250YWluaW5nIGEgUEFUSF9SRVNQT05TRSBmcmFtZSBhcyBwZXIgU2VjdGlvbiA4LjIuIFRoZSBzZXJ2ZXIgTVVTVCBzZW5kIG5vbi0gcHJvYmluZyBwYWNrZXRzIGZyb20gaXRzIG9yaWdpbmFsIGFkZHJlc3MgdW50aWwgaXQgcmVjZWl2ZXMgYSBub24tIHByb2JpbmcgcGFja2V0IGZyb20gdGhlIGNsaWVudCBhdCBpdHMgcHJlZmVycmVkIGFkZHJlc3MgYW5kIHVudGlsIHRoZSBzZXJ2ZXIgaGFzIHZhbGlkYXRlZCB0aGUgbmV3IHBhdGguIFRoZSBzZXJ2ZXIgTVVTVCBwcm9iZSBvbiB0aGUgcGF0aCB0b3dhcmQgdGhlIGNsaWVudCBmcm9tIGl0cyBwcmVmZXJyZWQgYWRkcmVzcy4gVGhpcyBoZWxwcyB0byBndWFyZCBhZ2FpbnN0IHNwdXJpb3VzIG1pZ3JhdGlvbiBpbml0aWF0ZWQgYnkgYW4gYXR0YWNrZXIuIE9uY2UgdGhlIHNlcnZlciBoYXMgY29tcGxldGVkIGl0cyBwYXRoIHZhbGlkYXRpb24gYW5kIGhhcyByZWNlaXZlZCBhIG5vbi1wcm9iaW5nIHBhY2tldCB3aXRoIGEgbmV3IGxhcmdlc3QgcGFja2V0IG51bWJlciBvbiBpdHMgcHJlZmVycmVkIGFkZHJlc3MsIHRoZSBzZXJ2ZXIgYmVnaW5zIHNlbmRpbmcgbm9uLXByb2JpbmcgcGFja2V0cyB0byB0aGUgY2xpZW50IGV4Y2x1c2l2ZWx5IGZyb20gaXRzIHByZWZlcnJlZCBJUCBhZGRyZXNzLiBUaGUgc2VydmVyIFNIT1VMRCBkcm9wIG5ld2VyIHBhY2tldHMgZm9yIHRoaXMgY29ubmVjdGlvbiB0aGF0IGFyZSByZWNlaXZlZCBvbiB0aGUgb2xkIElQIGFkZHJlc3MuIFRoZSBzZXJ2ZXIgTUFZIGNvbnRpbnVlIHRvIHByb2Nlc3MgZGVsYXllZCBwYWNrZXRzIHRoYXQgYXJlIHJlY2VpdmVkIG9uIHRoZSBvbGQgSVAgYWRkcmVzcy4gVGhlIGFkZHJlc3NlcyB0aGF0IGEgc2VydmVyIHByb3ZpZGVzIGluIHRoZSBwcmVmZXJyZWRfYWRkcmVzcyB0cmFuc3BvcnQgcGFyYW1ldGVyIGFyZSBvbmx5IHZhbGlkIGZvciB0aGUgY29ubmVjdGlvbiBpbiB3aGljaCB0aGV5IGFyZSBwcm92aWRlZC4gQSBjbGllbnQgTVVTVCBOT1QgdXNlIHRoZXNlIGZvciBvdGhlciBjb25uZWN0aW9ucywgaW5jbHVkaW5nIGNvbm5lY3Rpb25zIHRoYXQgYXJlIHJlc3VtZWQgZnJvbSB0aGUgY3VycmVudCBjb25uZWN0aW9uLiA5LjYuMy4gSW50ZXJhY3Rpb24gb2YgQ2xpZW50IE1pZ3JhdGlvbiBhbmQgUHJlZmVycmVkIEFkZHJlc3MgQSBjbGllbnQgbWlnaHQgbmVlZCB0byBwZXJmb3JtIGEgY29ubmVjdGlvbiBtaWdyYXRpb24gYmVmb3JlIGl0IGhhcyBtaWdyYXRlZCB0byB0aGUgc2VydmVyJ3MgcHJlZmVycmVkIGFkZHJlc3MuIEluIHRoaXMgY2FzZSwgdGhlIGNsaWVudCBTSE9VTEQgcGVyZm9ybSBwYXRoIHZhbGlkYXRpb24gdG8gYm90aCB0aGUgb3JpZ2luYWwgYW5kIHByZWZlcnJlZCBzZXJ2ZXIgYWRkcmVzcyBmcm9tIHRoZSBjbGllbnQncyBuZXcgYWRkcmVzcyBjb25jdXJyZW50bHkuIElmIHBhdGggdmFsaWRhdGlvbiBvZiB0aGUgc2VydmVyJ3MgcHJlZmVycmVkIGFkZHJlc3Mgc3VjY2VlZHMsIHRoZSBjbGllbnQgTVVTVCBhYmFuZG9uIHZhbGlkYXRpb24gb2YgdGhlIG9yaWdpbmFsIGFkZHJlc3MgYW5kIG1pZ3JhdGUgdG8gdXNpbmcgdGhlIHNlcnZlcidzIHByZWZlcnJlZCBhZGRyZXNzLiBJZiBwYXRoIHZhbGlkYXRpb24gb2YgdGhlIHNlcnZlcidzIHByZWZlcnJlZCBhZGRyZXNzIGZhaWxzIGJ1dCB2YWxpZGF0aW9uIG9mIHRoZSBzZXJ2ZXIncyBvcmlnaW5hbCBhZGRyZXNzIHN1Y2NlZWRzLCB0aGUgY2xpZW50IE1BWSBtaWdyYXRlIHRvIGl0cyBuZXcgYWRkcmVzcyBhbmQgY29udGludWUgc2VuZGluZyB0byB0aGUgc2VydmVyJ3Mgb3JpZ2luYWwgYWRkcmVzcy4gSWYgcGFja2V0cyByZWNlaXZlZCBhdCB0aGUgc2VydmVyJ3MgcHJlZmVycmVkIGFkZHJlc3MgaGF2ZSBhIGRpZmZlcmVudCBzb3VyY2UgYWRkcmVzcyB0aGFuIG9ic2VydmVkIGZyb20gdGhlIGNsaWVudCBkdXJpbmcgdGhlIGhhbmRzaGFrZSwgdGhlIHNlcnZlciBNVVNUIHByb3RlY3QgYWdhaW5zdCBwb3RlbnRpYWwgYXR0YWNrcyBhcyBkZXNjcmliZWQgaW4gU2VjdGlvbnMgOS4zLjEgYW5kIDkuMy4yLiBJbiBhZGRpdGlvbiB0byBpbnRlbnRpb25hbCBzaW11bHRhbmVvdXMgbWlncmF0aW9uLCB0aGlzIG1pZ2h0IGFsc28gb2NjdXIgYmVjYXVzZSB0aGUgY2xpZW50J3MgYWNjZXNzIG5ldHdvcmsgdXNlZCBhIGRpZmZlcmVudCBOQVQgYmluZGluZyBmb3IgdGhlIHNlcnZlcidzIHByZWZlcnJlZCBhZGRyZXNzLiBTZXJ2ZXJzIFNIT1VMRCBpbml0aWF0ZSBwYXRoIHZhbGlkYXRpb24gdG8gdGhlIGNsaWVudCdzIG5ldyBhZGRyZXNzIHVwb24gcmVjZWl2aW5nIGEgcHJvYmUgcGFja2V0IGZyb20gYSBkaWZmZXJlbnQgYWRkcmVzczsgc2VlIFNlY3Rpb24gOC4gQSBjbGllbnQgdGhhdCBtaWdyYXRlcyB0byBhIG5ldyBhZGRyZXNzIFNIT1VMRCB1c2UgYSBwcmVmZXJyZWQgYWRkcmVzcyBmcm9tIHRoZSBzYW1lIGFkZHJlc3MgZmFtaWx5IGZvciB0aGUgc2VydmVyLiBUaGUgY29ubmVjdGlvbiBJRCBwcm92aWRlZCBpbiB0aGUgcHJlZmVycmVkX2FkZHJlc3MgdHJhbnNwb3J0IHBhcmFtZXRlciBpcyBub3Qgc3BlY2lmaWMgdG8gdGhlIGFkZHJlc3NlcyB0aGF0IGFyZSBwcm92aWRlZC4gVGhpcyBjb25uZWN0aW9uIElEIGlzIHByb3ZpZGVkIHRvIGVuc3VyZSB0aGF0IHRoZSBjbGllbnQgaGFzIGEgY29ubmVjdGlvbiBJRCBhdmFpbGFibGUgZm9yIG1pZ3JhdGlvbiwgYnV0IHRoZSBjbGllbnQgTUFZIHVzZSB0aGlzIGNvbm5lY3Rpb24gSUQgb24gYW55IHBhdGguIDkuNy4gVXNlIG9mIElQdjYgRmxvdyBMYWJlbCBhbmQgTWlncmF0aW9uIEVuZHBvaW50cyB0aGF0IHNlbmQgZGF0YSB1c2luZyBJUHY2IFNIT1VMRCBhcHBseSBhbiBJUHY2IGZsb3cgbGFiZWwgaW4gY29tcGxpYW5jZSB3aXRoIFtSRkM2NDM3XSwgdW5sZXNzIHRoZSBsb2NhbCBBUEkgZG9lcyBub3QgYWxsb3cgc2V0dGluZyBJUHY2IGZsb3cgbGFiZWxzLiBUaGUgZmxvdyBsYWJlbCBnZW5lcmF0aW9uIE1VU1QgYmUgZGVzaWduZWQgdG8gbWluaW1pemUgdGhlIGNoYW5jZXMgb2YgbGlua2FiaWxpdHkgd2l0aCBhIHByZXZpb3VzbHkgdXNlZCBmbG93IGxhYmVsLCBhcyBhIHN0YWJsZSBmbG93IGxhYmVsIHdvdWxkIGVuYWJsZSBjb3JyZWxhdGluZyBhY3Rpdml0eSBvbiBtdWx0aXBsZSBwYXRoczsgc2VlIFNlY3Rpb24gOS41LiBbUkZDNjQzN10gc3VnZ2VzdHMgZGVyaXZpbmcgdmFsdWVzIHVzaW5nIGEgcHNldWRvcmFuZG9tIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGZsb3cgbGFiZWxzLiBJbmNsdWRpbmcgdGhlIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgZmllbGQgaW4gYWRkaXRpb24gdG8gc291cmNlIGFuZCBkZXN0aW5hdGlvbiBhZGRyZXNzZXMgd2hlbiBnZW5lcmF0aW5nIGZsb3cgbGFiZWxzIGVuc3VyZXMgdGhhdCBjaGFuZ2VzIGFyZSBzeW5jaHJvbml6ZWQgd2l0aCBjaGFuZ2VzIGluIG90aGVyIG9ic2VydmFibGUgaWRlbnRpZmllcnMuIEEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uIHRoYXQgY29tYmluZXMgdGhlc2UgaW5wdXRzIHdpdGggYSBsb2NhbCBzZWNyZXQgaXMgb25lIHdheSB0aGlzIG1pZ2h0IGJlIGltcGxlbWVudGVkLiAxMC4gQ29ubmVjdGlvbiBUZXJtaW5hdGlvbiBBbiBlc3RhYmxpc2hlZCBRVUlDIGNvbm5lY3Rpb24gY2FuIGJlIHRlcm1pbmF0ZWQgaW4gb25lIG9mIHRocmVlIHdheXM6ICogaWRsZSB0aW1lb3V0IChTZWN0aW9uIDEwLjEpICogaW1tZWRpYXRlIGNsb3NlIChTZWN0aW9uIDEwLjIpICogc3RhdGVsZXNzIHJlc2V0IChTZWN0aW9uIDEwLjMpIEFuIGVuZHBvaW50IE1BWSBkaXNjYXJkIGNvbm5lY3Rpb24gc3RhdGUgaWYgaXQgZG9lcyBub3QgaGF2ZSBhIHZhbGlkYXRlZCBwYXRoIG9uIHdoaWNoIGl0IGNhbiBzZW5kIHBhY2tldHM7IHNlZSBTZWN0aW9uIDguMi4gMTAuMS4gSWRsZSBUaW1lb3V0IElmIGEgbWF4X2lkbGVfdGltZW91dCBpcyBzcGVjaWZpZWQgYnkgZWl0aGVyIGVuZHBvaW50IGluIGl0cyB0cmFuc3BvcnQgcGFyYW1ldGVycyAoU2VjdGlvbiAxOC4yKSwgdGhlIGNvbm5lY3Rpb24gaXMgc2lsZW50bHkgY2xvc2VkIGFuZCBpdHMgc3RhdGUgaXMgZGlzY2FyZGVkIHdoZW4gaXQgcmVtYWlucyBpZGxlIGZvciBsb25nZXIgdGhhbiB0aGUgbWluaW11bSBvZiB0aGUgbWF4X2lkbGVfdGltZW91dCB2YWx1ZSBhZHZlcnRpc2VkIGJ5IGJvdGggZW5kcG9pbnRzLiBFYWNoIGVuZHBvaW50IGFkdmVydGlzZXMgYSBtYXhfaWRsZV90aW1lb3V0LCBidXQgdGhlIGVmZmVjdGl2ZSB2YWx1ZSBhdCBhbiBlbmRwb2ludCBpcyBjb21wdXRlZCBhcyB0aGUgbWluaW11bSBvZiB0aGUgdHdvIGFkdmVydGlzZWQgdmFsdWVzIChvciB0aGUgc29sZSBhZHZlcnRpc2VkIHZhbHVlLCBpZiBvbmx5IG9uZSBlbmRwb2ludCBhZHZlcnRpc2VzIGEgbm9uLXplcm8gdmFsdWUpLiBCeSBhbm5vdW5jaW5nIGEgbWF4X2lkbGVfdGltZW91dCwgYW4gZW5kcG9pbnQgY29tbWl0cyB0byBpbml0aWF0aW5nIGFuIGltbWVkaWF0ZSBjbG9zZSAoU2VjdGlvbiAxMC4yKSBpZiBpdCBhYmFuZG9ucyB0aGUgY29ubmVjdGlvbiBwcmlvciB0byB0aGUgZWZmZWN0aXZlIHZhbHVlLiBBbiBlbmRwb2ludCByZXN0YXJ0cyBpdHMgaWRsZSB0aW1lciB3aGVuIGEgcGFja2V0IGZyb20gaXRzIHBlZXIgaXMgcmVjZWl2ZWQgYW5kIHByb2Nlc3NlZCBzdWNjZXNzZnVsbHkuIEFuIGVuZHBvaW50IGFsc28gcmVzdGFydHMgaXRzIGlkbGUgdGltZXIgd2hlbiBzZW5kaW5nIGFuIGFjay1lbGljaXRpbmcgcGFja2V0IGlmIG5vIG90aGVyIGFjay0gZWxpY2l0aW5nIHBhY2tldHMgaGF2ZSBiZWVuIHNlbnQgc2luY2UgbGFzdCByZWNlaXZpbmcgYW5kIHByb2Nlc3NpbmcgYSBwYWNrZXQuIFJlc3RhcnRpbmcgdGhpcyB0aW1lciB3aGVuIHNlbmRpbmcgYSBwYWNrZXQgZW5zdXJlcyB0aGF0IGNvbm5lY3Rpb25zIGFyZSBub3QgY2xvc2VkIGFmdGVyIG5ldyBhY3Rpdml0eSBpcyBpbml0aWF0ZWQuIFRvIGF2b2lkIGV4Y2Vzc2l2ZWx5IHNtYWxsIGlkbGUgdGltZW91dCBwZXJpb2RzLCBlbmRwb2ludHMgTVVTVCBpbmNyZWFzZSB0aGUgaWRsZSB0aW1lb3V0IHBlcmlvZCB0byBiZSBhdCBsZWFzdCB0aHJlZSB0aW1lcyB0aGUgY3VycmVudCBQcm9iZSBUaW1lb3V0IChQVE8pLiBUaGlzIGFsbG93cyBmb3IgbXVsdGlwbGUgUFRPcyB0byBleHBpcmUsIGFuZCB0aGVyZWZvcmUgbXVsdGlwbGUgcHJvYmVzIHRvIGJlIHNlbnQgYW5kIGxvc3QsIHByaW9yIHRvIGlkbGUgdGltZW91dC4gMTAuMS4xLiBMaXZlbmVzcyBUZXN0aW5nIEFuIGVuZHBvaW50IHRoYXQgc2VuZHMgcGFja2V0cyBjbG9zZSB0byB0aGUgZWZmZWN0aXZlIHRpbWVvdXQgcmlza3MgaGF2aW5nIHRoZW0gYmUgZGlzY2FyZGVkIGF0IHRoZSBwZWVyLCBzaW5jZSB0aGUgaWRsZSB0aW1lb3V0IHBlcmlvZCBtaWdodCBoYXZlIGV4cGlyZWQgYXQgdGhlIHBlZXIgYmVmb3JlIHRoZXNlIHBhY2tldHMgYXJyaXZlLiBBbiBlbmRwb2ludCBjYW4gc2VuZCBhIFBJTkcgb3IgYW5vdGhlciBhY2stZWxpY2l0aW5nIGZyYW1lIHRvIHRlc3QgdGhlIGNvbm5lY3Rpb24gZm9yIGxpdmVuZXNzIGlmIHRoZSBwZWVyIGNvdWxkIHRpbWUgb3V0IHNvb24sIHN1Y2ggYXMgd2l0aGluIGEgUFRPOyBzZWUgU2VjdGlvbiA2LjIgb2YgW1FVSUMtUkVDT1ZFUlldLiBUaGlzIGlzIGVzcGVjaWFsbHkgdXNlZnVsIGlmIGFueSBhdmFpbGFibGUgYXBwbGljYXRpb24gZGF0YSBjYW5ub3QgYmUgc2FmZWx5IHJldHJpZWQuIE5vdGUgdGhhdCB0aGUgYXBwbGljYXRpb24gZGV0ZXJtaW5lcyB3aGF0IGRhdGEgaXMgc2FmZSB0byByZXRyeS4gMTAuMS4yLiBEZWZlcnJpbmcgSWRsZSBUaW1lb3V0IEFuIGVuZHBvaW50IG1pZ2h0IG5lZWQgdG8gc2VuZCBhY2stZWxpY2l0aW5nIHBhY2tldHMgdG8gYXZvaWQgYW4gaWRsZSB0aW1lb3V0IGlmIGl0IGlzIGV4cGVjdGluZyByZXNwb25zZSBkYXRhIGJ1dCBkb2VzIG5vdCBoYXZlIG9yIGlzIHVuYWJsZSB0byBzZW5kIGFwcGxpY2F0aW9uIGRhdGEuIEFuIGltcGxlbWVudGF0aW9uIG9mIFFVSUMgbWlnaHQgcHJvdmlkZSBhcHBsaWNhdGlvbnMgd2l0aCBhbiBvcHRpb24gdG8gZGVmZXIgYW4gaWRsZSB0aW1lb3V0LiBUaGlzIGZhY2lsaXR5IGNvdWxkIGJlIHVzZWQgd2hlbiB0aGUgYXBwbGljYXRpb24gd2lzaGVzIHRvIGF2b2lkIGxvc2luZyBzdGF0ZSB0aGF0IGhhcyBiZWVuIGFzc29jaWF0ZWQgd2l0aCBhbiBvcGVuIGNvbm5lY3Rpb24gYnV0IGRvZXMgbm90IGV4cGVjdCB0byBleGNoYW5nZSBhcHBsaWNhdGlvbiBkYXRhIGZvciBzb21lIHRpbWUuIFdpdGggdGhpcyBvcHRpb24sIGFuIGVuZHBvaW50IGNvdWxkIHNlbmQgYSBQSU5HIGZyYW1lIChTZWN0aW9uIDE5LjIpIHBlcmlvZGljYWxseSwgd2hpY2ggd2lsbCBjYXVzZSB0aGUgcGVlciB0byByZXN0YXJ0IGl0cyBpZGxlIHRpbWVvdXQgcGVyaW9kLiBTZW5kaW5nIGEgcGFja2V0IGNvbnRhaW5pbmcgYSBQSU5HIGZyYW1lIHJlc3RhcnRzIHRoZSBpZGxlIHRpbWVvdXQgZm9yIHRoaXMgZW5kcG9pbnQgYWxzbyBpZiB0aGlzIGlzIHRoZSBmaXJzdCBhY2stZWxpY2l0aW5nIHBhY2tldCBzZW50IHNpbmNlIHJlY2VpdmluZyBhIHBhY2tldC4gU2VuZGluZyBhIFBJTkcgZnJhbWUgY2F1c2VzIHRoZSBwZWVyIHRvIHJlc3BvbmQgd2l0aCBhbiBhY2tub3dsZWRnbWVudCwgd2hpY2ggYWxzbyByZXN0YXJ0cyB0aGUgaWRsZSB0aW1lb3V0IGZvciB0aGUgZW5kcG9pbnQuIEFwcGxpY2F0aW9uIHByb3RvY29scyB0aGF0IHVzZSBRVUlDIFNIT1VMRCBwcm92aWRlIGd1aWRhbmNlIG9uIHdoZW4gZGVmZXJyaW5nIGFuIGlkbGUgdGltZW91dCBpcyBhcHByb3ByaWF0ZS4gVW5uZWNlc3Nhcnkgc2VuZGluZyBvZiBQSU5HIGZyYW1lcyBjb3VsZCBoYXZlIGEgZGV0cmltZW50YWwgZWZmZWN0IG9uIHBlcmZvcm1hbmNlLiBBIGNvbm5lY3Rpb24gd2lsbCB0aW1lIG91dCBpZiBubyBwYWNrZXRzIGFyZSBzZW50IG9yIHJlY2VpdmVkIGZvciBhIHBlcmlvZCBsb25nZXIgdGhhbiB0aGUgdGltZSBuZWdvdGlhdGVkIHVzaW5nIHRoZSBtYXhfaWRsZV90aW1lb3V0IHRyYW5zcG9ydCBwYXJhbWV0ZXI7IHNlZSBTZWN0aW9uIDEwLiBIb3dldmVyLCBzdGF0ZSBpbiBtaWRkbGVib3hlcyBtaWdodCB0aW1lIG91dCBlYXJsaWVyIHRoYW4gdGhhdC4gVGhvdWdoIFJFUS01IGluIFtSRkM0Nzg3XSByZWNvbW1lbmRzIGEgMi1taW51dGUgdGltZW91dCBpbnRlcnZhbCwgZXhwZXJpZW5jZSBzaG93cyB0aGF0IHNlbmRpbmcgcGFja2V0cyBldmVyeSAzMCBzZWNvbmRzIGlzIG5lY2Vzc2FyeSB0byBwcmV2ZW50IHRoZSBtYWpvcml0eSBvZiBtaWRkbGVib3hlcyBmcm9tIGxvc2luZyBzdGF0ZSBmb3IgVURQIGZsb3dzIFtHQVRFV0FZXS4gMTAuMi4gSW1tZWRpYXRlIENsb3NlIEFuIGVuZHBvaW50IHNlbmRzIGEgQ09OTkVDVElPTl9DTE9TRSBmcmFtZSAoU2VjdGlvbiAxOS4xOSkgdG8gdGVybWluYXRlIHRoZSBjb25uZWN0aW9uIGltbWVkaWF0ZWx5LiBBIENPTk5FQ1RJT05fQ0xPU0UgZnJhbWUgY2F1c2VzIGFsbCBzdHJlYW1zIHRvIGltbWVkaWF0ZWx5IGJlY29tZSBjbG9zZWQ7IG9wZW4gc3RyZWFtcyBjYW4gYmUgYXNzdW1lZCB0byBiZSBpbXBsaWNpdGx5IHJlc2V0LiBBZnRlciBzZW5kaW5nIGEgQ09OTkVDVElPTl9DTE9TRSBmcmFtZSwgYW4gZW5kcG9pbnQgaW1tZWRpYXRlbHkgZW50ZXJzIHRoZSBjbG9zaW5nIHN0YXRlOyBzZWUgU2VjdGlvbiAxMC4yLjEuIEFmdGVyIHJlY2VpdmluZyBhIENPTk5FQ1RJT05fQ0xPU0UgZnJhbWUsIGVuZHBvaW50cyBlbnRlciB0aGUgZHJhaW5pbmcgc3RhdGU7IHNlZSBTZWN0aW9uIDEwLjIuMi4gVmlvbGF0aW9ucyBvZiB0aGUgcHJvdG9jb2wgbGVhZCB0byBhbiBpbW1lZGlhdGUgY2xvc2UuIEFuIGltbWVkaWF0ZSBjbG9zZSBjYW4gYmUgdXNlZCBhZnRlciBhbiBhcHBsaWNhdGlvbiBwcm90b2NvbCBoYXMgYXJyYW5nZWQgdG8gY2xvc2UgYSBjb25uZWN0aW9uLiBUaGlzIG1pZ2h0IGJlIGFmdGVyIHRoZSBhcHBsaWNhdGlvbiBwcm90b2NvbCBuZWdvdGlhdGVzIGEgZ3JhY2VmdWwgc2h1dGRvd24uIFRoZSBhcHBsaWNhdGlvbiBwcm90b2NvbCBjYW4gZXhjaGFuZ2UgbWVzc2FnZXMgdGhhdCBhcmUgbmVlZGVkIGZvciBib3RoIGFwcGxpY2F0aW9uIGVuZHBvaW50cyB0byBhZ3JlZSB0aGF0IHRoZSBjb25uZWN0aW9uIGNhbiBiZSBjbG9zZWQsIGFmdGVyIHdoaWNoIHRoZSBhcHBsaWNhdGlvbiByZXF1ZXN0cyB0aGF0IFFVSUMgY2xvc2UgdGhlIGNvbm5lY3Rpb24uIFdoZW4gUVVJQyBjb25zZXF1ZW50bHkgY2xvc2VzIHRoZSBjb25uZWN0aW9uLCBhIENPTk5FQ1RJT05fQ0xPU0UgZnJhbWUgd2l0aCBhbiBhcHBsaWNhdGlvbi1zdXBwbGllZCBlcnJvciBjb2RlIHdpbGwgYmUgdXNlZCB0byBzaWduYWwgY2xvc3VyZSB0byB0aGUgcGVlci4gVGhlIGNsb3NpbmcgYW5kIGRyYWluaW5nIGNvbm5lY3Rpb24gc3RhdGVzIGV4aXN0IHRvIGVuc3VyZSB0aGF0IGNvbm5lY3Rpb25zIGNsb3NlIGNsZWFubHkgYW5kIHRoYXQgZGVsYXllZCBvciByZW9yZGVyZWQgcGFja2V0cyBhcmUgcHJvcGVybHkgZGlzY2FyZGVkLiBUaGVzZSBzdGF0ZXMgU0hPVUxEIHBlcnNpc3QgZm9yIGF0IGxlYXN0IHRocmVlIHRpbWVzIHRoZSBjdXJyZW50IFBUTyBpbnRlcnZhbCBhcyBkZWZpbmVkIGluIFtRVUlDLVJFQ09WRVJZXS4gRGlzcG9zaW5nIG9mIGNvbm5lY3Rpb24gc3RhdGUgcHJpb3IgdG8gZXhpdGluZyB0aGUgY2xvc2luZyBvciBkcmFpbmluZyBzdGF0ZSBjb3VsZCByZXN1bHQgaW4gYW4gZW5kcG9pbnQgZ2VuZXJhdGluZyBhIFN0YXRlbGVzcyBSZXNldCB1bm5lY2Vzc2FyaWx5IHdoZW4gaXQgcmVjZWl2ZXMgYSBsYXRlLWFycml2aW5nIHBhY2tldC4gRW5kcG9pbnRzIHRoYXQgaGF2ZSBzb21lIGFsdGVybmF0aXZlIG1lYW5zIHRvIGVuc3VyZSB0aGF0IGxhdGUtIGFycml2aW5nIHBhY2tldHMgZG8gbm90IGluZHVjZSBhIHJlc3BvbnNlLCBzdWNoIGFzIHRob3NlIHRoYXQgYXJlIGFibGUgdG8gY2xvc2UgdGhlIFVEUCBzb2NrZXQsIE1BWSBlbmQgdGhlc2Ugc3RhdGVzIGVhcmxpZXIgdG8gYWxsb3cgZm9yIGZhc3RlciByZXNvdXJjZSByZWNvdmVyeS4gU2VydmVycyB0aGF0IHJldGFpbiBhbiBvcGVuIHNvY2tldCBmb3IgYWNjZXB0aW5nIG5ldyBjb25uZWN0aW9ucyBTSE9VTEQgTk9UIGVuZCB0aGUgY2xvc2luZyBvciBkcmFpbmluZyBzdGF0ZSBlYXJseS4gT25jZSBpdHMgY2xvc2luZyBvciBkcmFpbmluZyBzdGF0ZSBlbmRzLCBhbiBlbmRwb2ludCBTSE9VTEQgZGlzY2FyZCBhbGwgY29ubmVjdGlvbiBzdGF0ZS4gVGhlIGVuZHBvaW50IE1BWSBzZW5kIGEgU3RhdGVsZXNzIFJlc2V0IGluIHJlc3BvbnNlIHRvIGFueSBmdXJ0aGVyIGluY29taW5nIHBhY2tldHMgYmVsb25naW5nIHRvIHRoaXMgY29ubmVjdGlvbi4gMTAuMi4xLiBDbG9zaW5nIENvbm5lY3Rpb24gU3RhdGUgQW4gZW5kcG9pbnQgZW50ZXJzIHRoZSBjbG9zaW5nIHN0YXRlIGFmdGVyIGluaXRpYXRpbmcgYW4gaW1tZWRpYXRlIGNsb3NlLiBJbiB0aGUgY2xvc2luZyBzdGF0ZSwgYW4gZW5kcG9pbnQgcmV0YWlucyBvbmx5IGVub3VnaCBpbmZvcm1hdGlvbiB0byBnZW5lcmF0ZSBhIHBhY2tldCBjb250YWluaW5nIGEgQ09OTkVDVElPTl9DTE9TRSBmcmFtZSBhbmQgdG8gaWRlbnRpZnkgcGFja2V0cyBhcyBiZWxvbmdpbmcgdG8gdGhlIGNvbm5lY3Rpb24uIEFuIGVuZHBvaW50IGluIHRoZSBjbG9zaW5nIHN0YXRlIHNlbmRzIGEgcGFja2V0IGNvbnRhaW5pbmcgYSBDT05ORUNUSU9OX0NMT1NFIGZyYW1lIGluIHJlc3BvbnNlIHRvIGFueSBpbmNvbWluZyBwYWNrZXQgdGhhdCBpdCBhdHRyaWJ1dGVzIHRvIHRoZSBjb25uZWN0aW9uLiBBbiBlbmRwb2ludCBTSE9VTEQgbGltaXQgdGhlIHJhdGUgYXQgd2hpY2ggaXQgZ2VuZXJhdGVzIHBhY2tldHMgaW4gdGhlIGNsb3Npbmcgc3RhdGUuIEZvciBpbnN0YW5jZSwgYW4gZW5kcG9pbnQgY291bGQgd2FpdCBmb3IgYSBwcm9ncmVzc2l2ZWx5IGluY3JlYXNpbmcgbnVtYmVyIG9mIHJlY2VpdmVkIHBhY2tldHMgb3IgYW1vdW50IG9mIHRpbWUgYmVmb3JlIHJlc3BvbmRpbmcgdG8gcmVjZWl2ZWQgcGFja2V0cy4gQW4gZW5kcG9pbnQncyBzZWxlY3RlZCBjb25uZWN0aW9uIElEIGFuZCB0aGUgUVVJQyB2ZXJzaW9uIGFyZSBzdWZmaWNpZW50IGluZm9ybWF0aW9uIHRvIGlkZW50aWZ5IHBhY2tldHMgZm9yIGEgY2xvc2luZyBjb25uZWN0aW9uOyB0aGUgZW5kcG9pbnQgTUFZIGRpc2NhcmQgYWxsIG90aGVyIGNvbm5lY3Rpb24gc3RhdGUuIEFuIGVuZHBvaW50IHRoYXQgaXMgY2xvc2luZyBpcyBub3QgcmVxdWlyZWQgdG8gcHJvY2VzcyBhbnkgcmVjZWl2ZWQgZnJhbWUuIEFuIGVuZHBvaW50IE1BWSByZXRhaW4gcGFja2V0IHByb3RlY3Rpb24ga2V5cyBmb3IgaW5jb21pbmcgcGFja2V0cyB0byBhbGxvdyBpdCB0byByZWFkIGFuZCBwcm9jZXNzIGEgQ09OTkVDVElPTl9DTE9TRSBmcmFtZS4gQW4gZW5kcG9pbnQgTUFZIGRyb3AgcGFja2V0IHByb3RlY3Rpb24ga2V5cyB3aGVuIGVudGVyaW5nIHRoZSBjbG9zaW5nIHN0YXRlIGFuZCBzZW5kIGEgcGFja2V0IGNvbnRhaW5pbmcgYSBDT05ORUNUSU9OX0NMT1NFIGZyYW1lIGluIHJlc3BvbnNlIHRvIGFueSBVRFAgZGF0YWdyYW0gdGhhdCBpcyByZWNlaXZlZC4gSG93ZXZlciwgYW4gZW5kcG9pbnQgdGhhdCBkaXNjYXJkcyBwYWNrZXQgcHJvdGVjdGlvbiBrZXlzIGNhbm5vdCBpZGVudGlmeSBhbmQgZGlzY2FyZCBpbnZhbGlkIHBhY2tldHMuIFRvIGF2b2lkIGJlaW5nIHVzZWQgZm9yIGFuIGFtcGxpZmljYXRpb24gYXR0YWNrLCBzdWNoIGVuZHBvaW50cyBNVVNUIGxpbWl0IHRoZSBjdW11bGF0aXZlIHNpemUgb2YgcGFja2V0cyBpdCBzZW5kcyB0byB0aHJlZSB0aW1lcyB0aGUgY3VtdWxhdGl2ZSBzaXplIG9mIHRoZSBwYWNrZXRzIHRoYXQgYXJlIHJlY2VpdmVkIGFuZCBhdHRyaWJ1dGVkIHRvIHRoZSBjb25uZWN0aW9uLiBUbyBtaW5pbWl6ZSB0aGUgc3RhdGUgdGhhdCBhbiBlbmRwb2ludCBtYWludGFpbnMgZm9yIGEgY2xvc2luZyBjb25uZWN0aW9uLCBlbmRwb2ludHMgTUFZIHNlbmQgdGhlIGV4YWN0IHNhbWUgcGFja2V0IGluIHJlc3BvbnNlIHRvIGFueSByZWNlaXZlZCBwYWNrZXQuIHwgTm90ZTogQWxsb3dpbmcgcmV0cmFuc21pc3Npb24gb2YgYSBjbG9zaW5nIHBhY2tldCBpcyBhbiB8IGV4Y2VwdGlvbiB0byB0aGUgcmVxdWlyZW1lbnQgdGhhdCBhIG5ldyBwYWNrZXQgbnVtYmVyIGJlIHVzZWQgfCBmb3IgZWFjaCBwYWNrZXQ7IHNlZSBTZWN0aW9uIDEyLjMuIFNlbmRpbmcgbmV3IHBhY2tldCBudW1iZXJzIHwgaXMgcHJpbWFyaWx5IG9mIGFkdmFudGFnZSB0byBsb3NzIHJlY292ZXJ5IGFuZCBjb25nZXN0aW9uIHwgY29udHJvbCwgd2hpY2ggYXJlIG5vdCBleHBlY3RlZCB0byBiZSByZWxldmFudCBmb3IgYSBjbG9zZWQgfCBjb25uZWN0aW9uLiBSZXRyYW5zbWl0dGluZyB0aGUgZmluYWwgcGFja2V0IHJlcXVpcmVzIGxlc3MgfCBzdGF0ZS4gV2hpbGUgaW4gdGhlIGNsb3Npbmcgc3RhdGUsIGFuIGVuZHBvaW50IGNvdWxkIHJlY2VpdmUgcGFja2V0cyBmcm9tIGEgbmV3IHNvdXJjZSBhZGRyZXNzLCBwb3NzaWJseSBpbmRpY2F0aW5nIGEgY29ubmVjdGlvbiBtaWdyYXRpb247IHNlZSBTZWN0aW9uIDkuIEFuIGVuZHBvaW50IGluIHRoZSBjbG9zaW5nIHN0YXRlIE1VU1QgZWl0aGVyIGRpc2NhcmQgcGFja2V0cyByZWNlaXZlZCBmcm9tIGFuIHVudmFsaWRhdGVkIGFkZHJlc3Mgb3IgbGltaXQgdGhlIGN1bXVsYXRpdmUgc2l6ZSBvZiBwYWNrZXRzIGl0IHNlbmRzIHRvIGFuIHVudmFsaWRhdGVkIGFkZHJlc3MgdG8gdGhyZWUgdGltZXMgdGhlIHNpemUgb2YgcGFja2V0cyBpdCByZWNlaXZlcyBmcm9tIHRoYXQgYWRkcmVzcy4gQW4gZW5kcG9pbnQgaXMgbm90IGV4cGVjdGVkIHRvIGhhbmRsZSBrZXkgdXBkYXRlcyB3aGVuIGl0IGlzIGNsb3NpbmcgKFNlY3Rpb24gNiBvZiBbUVVJQy1UTFNdKS4gQSBrZXkgdXBkYXRlIG1pZ2h0IHByZXZlbnQgdGhlIGVuZHBvaW50IGZyb20gbW92aW5nIGZyb20gdGhlIGNsb3Npbmcgc3RhdGUgdG8gdGhlIGRyYWluaW5nIHN0YXRlLCBhcyB0aGUgZW5kcG9pbnQgd2lsbCBub3QgYmUgYWJsZSB0byBwcm9jZXNzIHN1YnNlcXVlbnRseSByZWNlaXZlZCBwYWNrZXRzLCBidXQgaXQgb3RoZXJ3aXNlIGhhcyBubyBpbXBhY3QuIDEwLjIuMi4gRHJhaW5pbmcgQ29ubmVjdGlvbiBTdGF0ZSBUaGUgZHJhaW5pbmcgc3RhdGUgaXMgZW50ZXJlZCBvbmNlIGFuIGVuZHBvaW50IHJlY2VpdmVzIGEgQ09OTkVDVElPTl9DTE9TRSBmcmFtZSwgd2hpY2ggaW5kaWNhdGVzIHRoYXQgaXRzIHBlZXIgaXMgY2xvc2luZyBvciBkcmFpbmluZy4gV2hpbGUgb3RoZXJ3aXNlIGlkZW50aWNhbCB0byB0aGUgY2xvc2luZyBzdGF0ZSwgYW4gZW5kcG9pbnQgaW4gdGhlIGRyYWluaW5nIHN0YXRlIE1VU1QgTk9UIHNlbmQgYW55IHBhY2tldHMuIFJldGFpbmluZyBwYWNrZXQgcHJvdGVjdGlvbiBrZXlzIGlzIHVubmVjZXNzYXJ5IG9uY2UgYSBjb25uZWN0aW9uIGlzIGluIHRoZSBkcmFpbmluZyBzdGF0ZS4gQW4gZW5kcG9pbnQgdGhhdCByZWNlaXZlcyBhIENPTk5FQ1RJT05fQ0xPU0UgZnJhbWUgTUFZIHNlbmQgYSBzaW5nbGUgcGFja2V0IGNvbnRhaW5pbmcgYSBDT05ORUNUSU9OX0NMT1NFIGZyYW1lIGJlZm9yZSBlbnRlcmluZyB0aGUgZHJhaW5pbmcgc3RhdGUsIHVzaW5nIGEgTk9fRVJST1IgY29kZSBpZiBhcHByb3ByaWF0ZS4gQW4gZW5kcG9pbnQgTVVTVCBOT1Qgc2VuZCBmdXJ0aGVyIHBhY2tldHMuIERvaW5nIHNvIGNvdWxkIHJlc3VsdCBpbiBhIGNvbnN0YW50IGV4Y2hhbmdlIG9mIENPTk5FQ1RJT05fQ0xPU0UgZnJhbWVzIHVudGlsIG9uZSBvZiB0aGUgZW5kcG9pbnRzIGV4aXRzIHRoZSBjbG9zaW5nIHN0YXRlLiBBbiBlbmRwb2ludCBNQVkgZW50ZXIgdGhlIGRyYWluaW5nIHN0YXRlIGZyb20gdGhlIGNsb3Npbmcgc3RhdGUgaWYgaXQgcmVjZWl2ZXMgYSBDT05ORUNUSU9OX0NMT1NFIGZyYW1lLCB3aGljaCBpbmRpY2F0ZXMgdGhhdCB0aGUgcGVlciBpcyBhbHNvIGNsb3Npbmcgb3IgZHJhaW5pbmcuIEluIHRoaXMgY2FzZSwgdGhlIGRyYWluaW5nIHN0YXRlIGVuZHMgd2hlbiB0aGUgY2xvc2luZyBzdGF0ZSB3b3VsZCBoYXZlIGVuZGVkLiBJbiBvdGhlciB3b3JkcywgdGhlIGVuZHBvaW50IHVzZXMgdGhlIHNhbWUgZW5kIHRpbWUgYnV0IGNlYXNlcyB0cmFuc21pc3Npb24gb2YgYW55IHBhY2tldHMgb24gdGhpcyBjb25uZWN0aW9uLiAxMC4yLjMuIEltbWVkaWF0ZSBDbG9zZSBkdXJpbmcgdGhlIEhhbmRzaGFrZSBXaGVuIHNlbmRpbmcgYSBDT05ORUNUSU9OX0NMT1NFIGZyYW1lLCB0aGUgZ29hbCBpcyB0byBlbnN1cmUgdGhhdCB0aGUgcGVlciB3aWxsIHByb2Nlc3MgdGhlIGZyYW1lLiBHZW5lcmFsbHksIHRoaXMgbWVhbnMgc2VuZGluZyB0aGUgZnJhbWUgaW4gYSBwYWNrZXQgd2l0aCB0aGUgaGlnaGVzdCBsZXZlbCBvZiBwYWNrZXQgcHJvdGVjdGlvbiB0byBhdm9pZCB0aGUgcGFja2V0IGJlaW5nIGRpc2NhcmRlZC4gQWZ0ZXIgdGhlIGhhbmRzaGFrZSBpcyBjb25maXJtZWQgKHNlZSBTZWN0aW9uIDQuMS4yIG9mIFtRVUlDLVRMU10pLCBhbiBlbmRwb2ludCBNVVNUIHNlbmQgYW55IENPTk5FQ1RJT05fQ0xPU0UgZnJhbWVzIGluIGEgMS1SVFQgcGFja2V0LiBIb3dldmVyLCBwcmlvciB0byBjb25maXJtaW5nIHRoZSBoYW5kc2hha2UsIGl0IGlzIHBvc3NpYmxlIHRoYXQgbW9yZSBhZHZhbmNlZCBwYWNrZXQgcHJvdGVjdGlvbiBrZXlzIGFyZSBub3QgYXZhaWxhYmxlIHRvIHRoZSBwZWVyLCBzbyBhbm90aGVyIENPTk5FQ1RJT05fQ0xPU0UgZnJhbWUgTUFZIGJlIHNlbnQgaW4gYSBwYWNrZXQgdGhhdCB1c2VzIGEgbG93ZXIgcGFja2V0IHByb3RlY3Rpb24gbGV2ZWwuIE1vcmUgc3BlY2lmaWNhbGx5OiAqIEEgY2xpZW50IHdpbGwgYWx3YXlzIGtub3cgd2hldGhlciB0aGUgc2VydmVyIGhhcyBIYW5kc2hha2Uga2V5cyAoc2VlIFNlY3Rpb24gMTcuMi4yLjEpLCBidXQgaXQgaXMgcG9zc2libGUgdGhhdCBhIHNlcnZlciBkb2VzIG5vdCBrbm93IHdoZXRoZXIgdGhlIGNsaWVudCBoYXMgSGFuZHNoYWtlIGtleXMuIFVuZGVyIHRoZXNlIGNpcmN1bXN0YW5jZXMsIGEgc2VydmVyIFNIT1VMRCBzZW5kIGEgQ09OTkVDVElPTl9DTE9TRSBmcmFtZSBpbiBib3RoIEhhbmRzaGFrZSBhbmQgSW5pdGlhbCBwYWNrZXRzIHRvIGVuc3VyZSB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVtIGlzIHByb2Nlc3NhYmxlIGJ5IHRoZSBjbGllbnQuICogQSBjbGllbnQgdGhhdCBzZW5kcyBhIENPTk5FQ1RJT05fQ0xPU0UgZnJhbWUgaW4gYSAwLVJUVCBwYWNrZXQgY2Fubm90IGJlIGFzc3VyZWQgdGhhdCB0aGUgc2VydmVyIGhhcyBhY2NlcHRlZCAwLVJUVC4gU2VuZGluZyBhIENPTk5FQ1RJT05fQ0xPU0UgZnJhbWUgaW4gYW4gSW5pdGlhbCBwYWNrZXQgbWFrZXMgaXQgbW9yZSBsaWtlbHkgdGhhdCB0aGUgc2VydmVyIGNhbiByZWNlaXZlIHRoZSBjbG9zZSBzaWduYWwsIGV2ZW4gaWYgdGhlIGFwcGxpY2F0aW9uIGVycm9yIGNvZGUgbWlnaHQgbm90IGJlIHJlY2VpdmVkLiAqIFByaW9yIHRvIGNvbmZpcm1pbmcgdGhlIGhhbmRzaGFrZSwgYSBwZWVyIG1pZ2h0IGJlIHVuYWJsZSB0byBwcm9jZXNzIDEtUlRUIHBhY2tldHMsIHNvIGFuIGVuZHBvaW50IFNIT1VMRCBzZW5kIGEgQ09OTkVDVElPTl9DTE9TRSBmcmFtZSBpbiBib3RoIEhhbmRzaGFrZSBhbmQgMS1SVFQgcGFja2V0cy4gQSBzZXJ2ZXIgU0hPVUxEIGFsc28gc2VuZCBhIENPTk5FQ1RJT05fQ0xPU0UgZnJhbWUgaW4gYW4gSW5pdGlhbCBwYWNrZXQuIFNlbmRpbmcgYSBDT05ORUNUSU9OX0NMT1NFIG9mIHR5cGUgMHgxZCBpbiBhbiBJbml0aWFsIG9yIEhhbmRzaGFrZSBwYWNrZXQgY291bGQgZXhwb3NlIGFwcGxpY2F0aW9uIHN0YXRlIG9yIGJlIHVzZWQgdG8gYWx0ZXIgYXBwbGljYXRpb24gc3RhdGUuIEEgQ09OTkVDVElPTl9DTE9TRSBvZiB0eXBlIDB4MWQgTVVTVCBiZSByZXBsYWNlZCBieSBhIENPTk5FQ1RJT05fQ0xPU0Ugb2YgdHlwZSAweDFjIHdoZW4gc2VuZGluZyB0aGUgZnJhbWUgaW4gSW5pdGlhbCBvciBIYW5kc2hha2UgcGFja2V0cy4gT3RoZXJ3aXNlLCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYXBwbGljYXRpb24gc3RhdGUgbWlnaHQgYmUgcmV2ZWFsZWQuIEVuZHBvaW50cyBNVVNUIGNsZWFyIHRoZSB2YWx1ZSBvZiB0aGUgUmVhc29uIFBocmFzZSBmaWVsZCBhbmQgU0hPVUxEIHVzZSB0aGUgQVBQTElDQVRJT05fRVJST1IgY29kZSB3aGVuIGNvbnZlcnRpbmcgdG8gYSBDT05ORUNUSU9OX0NMT1NFIG9mIHR5cGUgMHgxYy4gQ09OTkVDVElPTl9DTE9TRSBmcmFtZXMgc2VudCBpbiBtdWx0aXBsZSBwYWNrZXQgdHlwZXMgY2FuIGJlIGNvYWxlc2NlZCBpbnRvIGEgc2luZ2xlIFVEUCBkYXRhZ3JhbTsgc2VlIFNlY3Rpb24gMTIuMi4gQW4gZW5kcG9pbnQgY2FuIHNlbmQgYSBDT05ORUNUSU9OX0NMT1NFIGZyYW1lIGluIGFuIEluaXRpYWwgcGFja2V0LiBUaGlzIG1pZ2h0IGJlIGluIHJlc3BvbnNlIHRvIHVuYXV0aGVudGljYXRlZCBpbmZvcm1hdGlvbiByZWNlaXZlZCBpbiBJbml0aWFsIG9yIEhhbmRzaGFrZSBwYWNrZXRzLiBTdWNoIGFuIGltbWVkaWF0ZSBjbG9zZSBtaWdodCBleHBvc2UgbGVnaXRpbWF0ZSBjb25uZWN0aW9ucyB0byBhIGRlbmlhbCBvZiBzZXJ2aWNlLiBRVUlDIGRvZXMgbm90IGluY2x1ZGUgZGVmZW5zaXZlIG1lYXN1cmVzIGZvciBvbi1wYXRoIGF0dGFja3MgZHVyaW5nIHRoZSBoYW5kc2hha2U7IHNlZSBTZWN0aW9uIDIxLjIuIEhvd2V2ZXIsIGF0IHRoZSBjb3N0IG9mIHJlZHVjaW5nIGZlZWRiYWNrIGFib3V0IGVycm9ycyBmb3IgbGVnaXRpbWF0ZSBwZWVycywgc29tZSBmb3JtcyBvZiBkZW5pYWwgb2Ygc2VydmljZSBjYW4gYmUgbWFkZSBtb3JlIGRpZmZpY3VsdCBmb3IgYW4gYXR0YWNrZXIgaWYgZW5kcG9pbnRzIGRpc2NhcmQgaWxsZWdhbCBwYWNrZXRzIHJhdGhlciB0aGFuIHRlcm1pbmF0aW5nIGEgY29ubmVjdGlvbiB3aXRoIENPTk5FQ1RJT05fQ0xPU0UuIEZvciB0aGlzIHJlYXNvbiwgZW5kcG9pbnRzIE1BWSBkaXNjYXJkIHBhY2tldHMgcmF0aGVyIHRoYW4gaW1tZWRpYXRlbHkgY2xvc2UgaWYgZXJyb3JzIGFyZSBkZXRlY3RlZCBpbiBwYWNrZXRzIHRoYXQgbGFjayBhdXRoZW50aWNhdGlvbi4gQW4gZW5kcG9pbnQgdGhhdCBoYXMgbm90IGVzdGFibGlzaGVkIHN0YXRlLCBzdWNoIGFzIGEgc2VydmVyIHRoYXQgZGV0ZWN0cyBhbiBlcnJvciBpbiBhbiBJbml0aWFsIHBhY2tldCwgZG9lcyBub3QgZW50ZXIgdGhlIGNsb3Npbmcgc3RhdGUuIEFuIGVuZHBvaW50IHRoYXQgaGFzIG5vIHN0YXRlIGZvciB0aGUgY29ubmVjdGlvbiBkb2VzIG5vdCBlbnRlciBhIGNsb3Npbmcgb3IgZHJhaW5pbmcgcGVyaW9kIG9uIHNlbmRpbmcgYSBDT05ORUNUSU9OX0NMT1NFIGZyYW1lLiAxMC4zLiBTdGF0ZWxlc3MgUmVzZXQgQSBzdGF0ZWxlc3MgcmVzZXQgaXMgcHJvdmlkZWQgYXMgYW4gb3B0aW9uIG9mIGxhc3QgcmVzb3J0IGZvciBhbiBlbmRwb2ludCB0aGF0IGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvIHRoZSBzdGF0ZSBvZiBhIGNvbm5lY3Rpb24uIEEgY3Jhc2ggb3Igb3V0YWdlIG1pZ2h0IHJlc3VsdCBpbiBwZWVycyBjb250aW51aW5nIHRvIHNlbmQgZGF0YSB0byBhbiBlbmRwb2ludCB0aGF0IGlzIHVuYWJsZSB0byBwcm9wZXJseSBjb250aW51ZSB0aGUgY29ubmVjdGlvbi4gQW4gZW5kcG9pbnQgTUFZIHNlbmQgYSBTdGF0ZWxlc3MgUmVzZXQgaW4gcmVzcG9uc2UgdG8gcmVjZWl2aW5nIGEgcGFja2V0IHRoYXQgaXQgY2Fubm90IGFzc29jaWF0ZSB3aXRoIGFuIGFjdGl2ZSBjb25uZWN0aW9uLiBBIHN0YXRlbGVzcyByZXNldCBpcyBub3QgYXBwcm9wcmlhdGUgZm9yIGluZGljYXRpbmcgZXJyb3JzIGluIGFjdGl2ZSBjb25uZWN0aW9ucy4gQW4gZW5kcG9pbnQgdGhhdCB3aXNoZXMgdG8gY29tbXVuaWNhdGUgYSBmYXRhbCBjb25uZWN0aW9uIGVycm9yIE1VU1QgdXNlIGEgQ09OTkVDVElPTl9DTE9TRSBmcmFtZSBpZiBpdCBpcyBhYmxlLiBUbyBzdXBwb3J0IHRoaXMgcHJvY2VzcywgYW4gZW5kcG9pbnQgaXNzdWVzIGEgc3RhdGVsZXNzIHJlc2V0IHRva2VuLCB3aGljaCBpcyBhIDE2LWJ5dGUgdmFsdWUgdGhhdCBpcyBoYXJkIHRvIGd1ZXNzLiBJZiB0aGUgcGVlciBzdWJzZXF1ZW50bHkgcmVjZWl2ZXMgYSBTdGF0ZWxlc3MgUmVzZXQsIHdoaWNoIGlzIGEgVURQIGRhdGFncmFtIHRoYXQgZW5kcyBpbiB0aGF0IHN0YXRlbGVzcyByZXNldCB0b2tlbiwgdGhlIHBlZXIgd2lsbCBpbW1lZGlhdGVseSBlbmQgdGhlIGNvbm5lY3Rpb24uIEEgc3RhdGVsZXNzIHJlc2V0IHRva2VuIGlzIHNwZWNpZmljIHRvIGEgY29ubmVjdGlvbiBJRC4gQW4gZW5kcG9pbnQgaXNzdWVzIGEgc3RhdGVsZXNzIHJlc2V0IHRva2VuIGJ5IGluY2x1ZGluZyB0aGUgdmFsdWUgaW4gdGhlIFN0YXRlbGVzcyBSZXNldCBUb2tlbiBmaWVsZCBvZiBhIE5FV19DT05ORUNUSU9OX0lEIGZyYW1lLiBTZXJ2ZXJzIGNhbiBhbHNvIGlzc3VlIGEgc3RhdGVsZXNzX3Jlc2V0X3Rva2VuIHRyYW5zcG9ydCBwYXJhbWV0ZXIgZHVyaW5nIHRoZSBoYW5kc2hha2UgdGhhdCBhcHBsaWVzIHRvIHRoZSBjb25uZWN0aW9uIElEIHRoYXQgaXQgc2VsZWN0ZWQgZHVyaW5nIHRoZSBoYW5kc2hha2UuIFRoZXNlIGV4Y2hhbmdlcyBhcmUgcHJvdGVjdGVkIGJ5IGVuY3J5cHRpb24sIHNvIG9ubHkgY2xpZW50IGFuZCBzZXJ2ZXIga25vdyB0aGVpciB2YWx1ZS4gTm90ZSB0aGF0IGNsaWVudHMgY2Fubm90IHVzZSB0aGUgc3RhdGVsZXNzX3Jlc2V0X3Rva2VuIHRyYW5zcG9ydCBwYXJhbWV0ZXIgYmVjYXVzZSB0aGVpciB0cmFuc3BvcnQgcGFyYW1ldGVycyBkbyBub3QgaGF2ZSBjb25maWRlbnRpYWxpdHkgcHJvdGVjdGlvbi4gVG9rZW5zIGFyZSBpbnZhbGlkYXRlZCB3aGVuIHRoZWlyIGFzc29jaWF0ZWQgY29ubmVjdGlvbiBJRCBpcyByZXRpcmVkIHZpYSBhIFJFVElSRV9DT05ORUNUSU9OX0lEIGZyYW1lIChTZWN0aW9uIDE5LjE2KS4gQW4gZW5kcG9pbnQgdGhhdCByZWNlaXZlcyBwYWNrZXRzIHRoYXQgaXQgY2Fubm90IHByb2Nlc3Mgc2VuZHMgYSBwYWNrZXQgaW4gdGhlIGZvbGxvd2luZyBsYXlvdXQgKHNlZSBTZWN0aW9uIDEuMyk6IFN0YXRlbGVzcyBSZXNldCB7IEZpeGVkIEJpdHMgKDIpID0gMSwgVW5wcmVkaWN0YWJsZSBCaXRzICgzOC4uKSwgU3RhdGVsZXNzIFJlc2V0IFRva2VuICgxMjgpLCB9IEZpZ3VyZSAxMDogU3RhdGVsZXNzIFJlc2V0IFRoaXMgZGVzaWduIGVuc3VyZXMgdGhhdCBhIFN0YXRlbGVzcyBSZXNldCBpcyAtLSB0byB0aGUgZXh0ZW50IHBvc3NpYmxlIC0tIGluZGlzdGluZ3Vpc2hhYmxlIGZyb20gYSByZWd1bGFyIHBhY2tldCB3aXRoIGEgc2hvcnQgaGVhZGVyLiBBIFN0YXRlbGVzcyBSZXNldCB1c2VzIGFuIGVudGlyZSBVRFAgZGF0YWdyYW0sIHN0YXJ0aW5nIHdpdGggdGhlIGZpcnN0IHR3byBiaXRzIG9mIHRoZSBwYWNrZXQgaGVhZGVyLiBUaGUgcmVtYWluZGVyIG9mIHRoZSBmaXJzdCBieXRlIGFuZCBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIGJ5dGVzIGZvbGxvd2luZyBpdCBhcmUgc2V0IHRvIHZhbHVlcyB0aGF0IFNIT1VMRCBiZSBpbmRpc3Rpbmd1aXNoYWJsZSBmcm9tIHJhbmRvbS4gVGhlIGxhc3QgMTYgYnl0ZXMgb2YgdGhlIGRhdGFncmFtIGNvbnRhaW4gYSBzdGF0ZWxlc3MgcmVzZXQgdG9rZW4uIFRvIGVudGl0aWVzIG90aGVyIHRoYW4gaXRzIGludGVuZGVkIHJlY2lwaWVudCwgYSBTdGF0ZWxlc3MgUmVzZXQgd2lsbCBhcHBlYXIgdG8gYmUgYSBwYWNrZXQgd2l0aCBhIHNob3J0IGhlYWRlci4gRm9yIHRoZSBTdGF0ZWxlc3MgUmVzZXQgdG8gYXBwZWFyIGFzIGEgdmFsaWQgUVVJQyBwYWNrZXQsIHRoZSBVbnByZWRpY3RhYmxlIEJpdHMgZmllbGQgbmVlZHMgdG8gaW5jbHVkZSBhdCBsZWFzdCAzOCBiaXRzIG9mIGRhdGEgKG9yIDUgYnl0ZXMsIGxlc3MgdGhlIHR3byBmaXhlZCBiaXRzKS4gVGhlIHJlc3VsdGluZyBtaW5pbXVtIHNpemUgb2YgMjEgYnl0ZXMgZG9lcyBub3QgZ3VhcmFudGVlIHRoYXQgYSBTdGF0ZWxlc3MgUmVzZXQgaXMgZGlmZmljdWx0IHRvIGRpc3Rpbmd1aXNoIGZyb20gb3RoZXIgcGFja2V0cyBpZiB0aGUgcmVjaXBpZW50IHJlcXVpcmVzIHRoZSB1c2Ugb2YgYSBjb25uZWN0aW9uIElELiBUbyBhY2hpZXZlIHRoYXQgZW5kLCB0aGUgZW5kcG9pbnQgU0hPVUxEIGVuc3VyZSB0aGF0IGFsbCBwYWNrZXRzIGl0IHNlbmRzIGFyZSBhdCBsZWFzdCAyMiBieXRlcyBsb25nZXIgdGhhbiB0aGUgbWluaW11bSBjb25uZWN0aW9uIElEIGxlbmd0aCB0aGF0IGl0IHJlcXVlc3RzIHRoZSBwZWVyIHRvIGluY2x1ZGUgaW4gaXRzIHBhY2tldHMsIGFkZGluZyBQQURESU5HIGZyYW1lcyBhcyBuZWNlc3NhcnkuIFRoaXMgZW5zdXJlcyB0aGF0IGFueSBTdGF0ZWxlc3MgUmVzZXQgc2VudCBieSB0aGUgcGVlciBpcyBpbmRpc3Rpbmd1aXNoYWJsZSBmcm9tIGEgdmFsaWQgcGFja2V0IHNlbnQgdG8gdGhlIGVuZHBvaW50LiBBbiBlbmRwb2ludCB0aGF0IHNlbmRzIGEgU3RhdGVsZXNzIFJlc2V0IGluIHJlc3BvbnNlIHRvIGEgcGFja2V0IHRoYXQgaXMgNDMgYnl0ZXMgb3Igc2hvcnRlciBTSE9VTEQgc2VuZCBhIFN0YXRlbGVzcyBSZXNldCB0aGF0IGlzIG9uZSBieXRlIHNob3J0ZXIgdGhhbiB0aGUgcGFja2V0IGl0IHJlc3BvbmRzIHRvLiBUaGVzZSB2YWx1ZXMgYXNzdW1lIHRoYXQgdGhlIHN0YXRlbGVzcyByZXNldCB0b2tlbiBpcyB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIG1pbmltdW0gZXhwYW5zaW9uIG9mIHRoZSBwYWNrZXQgcHJvdGVjdGlvbiBBRUFELiBBZGRpdGlvbmFsIHVucHJlZGljdGFibGUgYnl0ZXMgYXJlIG5lY2Vzc2FyeSBpZiB0aGUgZW5kcG9pbnQgY291bGQgaGF2ZSBuZWdvdGlhdGVkIGEgcGFja2V0IHByb3RlY3Rpb24gc2NoZW1lIHdpdGggYSBsYXJnZXIgbWluaW11bSBleHBhbnNpb24uIEFuIGVuZHBvaW50IE1VU1QgTk9UIHNlbmQgYSBTdGF0ZWxlc3MgUmVzZXQgdGhhdCBpcyB0aHJlZSB0aW1lcyBvciBtb3JlIGxhcmdlciB0aGFuIHRoZSBwYWNrZXQgaXQgcmVjZWl2ZXMgdG8gYXZvaWQgYmVpbmcgdXNlZCBmb3IgYW1wbGlmaWNhdGlvbi4gU2VjdGlvbiAxMC4zLjMgZGVzY3JpYmVzIGFkZGl0aW9uYWwgbGltaXRzIG9uIFN0YXRlbGVzcyBSZXNldCBzaXplLiBFbmRwb2ludHMgTVVTVCBkaXNjYXJkIHBhY2tldHMgdGhhdCBhcmUgdG9vIHNtYWxsIHRvIGJlIHZhbGlkIFFVSUMgcGFja2V0cy4gVG8gZ2l2ZSBhbiBleGFtcGxlLCB3aXRoIHRoZSBzZXQgb2YgQUVBRCBmdW5jdGlvbnMgZGVmaW5lZCBpbiBbUVVJQy1UTFNdLCBzaG9ydCBoZWFkZXIgcGFja2V0cyB0aGF0IGFyZSBzbWFsbGVyIHRoYW4gMjEgYnl0ZXMgYXJlIG5ldmVyIHZhbGlkLiBFbmRwb2ludHMgTVVTVCBzZW5kIFN0YXRlbGVzcyBSZXNldHMgZm9ybWF0dGVkIGFzIGEgcGFja2V0IHdpdGggYSBzaG9ydCBoZWFkZXIuIEhvd2V2ZXIsIGVuZHBvaW50cyBNVVNUIHRyZWF0IGFueSBwYWNrZXQgZW5kaW5nIGluIGEgdmFsaWQgc3RhdGVsZXNzIHJlc2V0IHRva2VuIGFzIGEgU3RhdGVsZXNzIFJlc2V0LCBhcyBvdGhlciBRVUlDIHZlcnNpb25zIG1pZ2h0IGFsbG93IHRoZSB1c2Ugb2YgYSBsb25nIGhlYWRlci4gQW4gZW5kcG9pbnQgTUFZIHNlbmQgYSBTdGF0ZWxlc3MgUmVzZXQgaW4gcmVzcG9uc2UgdG8gYSBwYWNrZXQgd2l0aCBhIGxvbmcgaGVhZGVyLiBTZW5kaW5nIGEgU3RhdGVsZXNzIFJlc2V0IGlzIG5vdCBlZmZlY3RpdmUgcHJpb3IgdG8gdGhlIHN0YXRlbGVzcyByZXNldCB0b2tlbiBiZWluZyBhdmFpbGFibGUgdG8gYSBwZWVyLiBJbiB0aGlzIFFVSUMgdmVyc2lvbiwgcGFja2V0cyB3aXRoIGEgbG9uZyBoZWFkZXIgYXJlIG9ubHkgdXNlZCBkdXJpbmcgY29ubmVjdGlvbiBlc3RhYmxpc2htZW50LiBCZWNhdXNlIHRoZSBzdGF0ZWxlc3MgcmVzZXQgdG9rZW4gaXMgbm90IGF2YWlsYWJsZSB1bnRpbCBjb25uZWN0aW9uIGVzdGFibGlzaG1lbnQgaXMgY29tcGxldGUgb3IgbmVhciBjb21wbGV0aW9uLCBpZ25vcmluZyBhbiB1bmtub3duIHBhY2tldCB3aXRoIGEgbG9uZyBoZWFkZXIgbWlnaHQgYmUgYXMgZWZmZWN0aXZlIGFzIHNlbmRpbmcgYSBTdGF0ZWxlc3MgUmVzZXQuIEFuIGVuZHBvaW50IGNhbm5vdCBkZXRlcm1pbmUgdGhlIFNvdXJjZSBDb25uZWN0aW9uIElEIGZyb20gYSBwYWNrZXQgd2l0aCBhIHNob3J0IGhlYWRlcjsgdGhlcmVmb3JlLCBpdCBjYW5ub3Qgc2V0IHRoZSBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEIGluIHRoZSBTdGF0ZWxlc3MgUmVzZXQuIFRoZSBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEIHdpbGwgdGhlcmVmb3JlIGRpZmZlciBmcm9tIHRoZSB2YWx1ZSB1c2VkIGluIHByZXZpb3VzIHBhY2tldHMuIEEgcmFuZG9tIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgbWFrZXMgdGhlIGNvbm5lY3Rpb24gSUQgYXBwZWFyIHRvIGJlIHRoZSByZXN1bHQgb2YgbW92aW5nIHRvIGEgbmV3IGNvbm5lY3Rpb24gSUQgdGhhdCB3YXMgcHJvdmlkZWQgdXNpbmcgYSBORVdfQ09OTkVDVElPTl9JRCBmcmFtZTsgc2VlIFNlY3Rpb24gMTkuMTUuIFVzaW5nIGEgcmFuZG9taXplZCBjb25uZWN0aW9uIElEIHJlc3VsdHMgaW4gdHdvIHByb2JsZW1zOiAqIFRoZSBwYWNrZXQgbWlnaHQgbm90IHJlYWNoIHRoZSBwZWVyLiBJZiB0aGUgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBpcyBjcml0aWNhbCBmb3Igcm91dGluZyB0b3dhcmQgdGhlIHBlZXIsIHRoZW4gdGhpcyBwYWNrZXQgY291bGQgYmUgaW5jb3JyZWN0bHkgcm91dGVkLiBUaGlzIG1pZ2h0IGFsc28gdHJpZ2dlciBhbm90aGVyIFN0YXRlbGVzcyBSZXNldCBpbiByZXNwb25zZTsgc2VlIFNlY3Rpb24gMTAuMy4zLiBBIFN0YXRlbGVzcyBSZXNldCB0aGF0IGlzIG5vdCBjb3JyZWN0bHkgcm91dGVkIGlzIGFuIGluZWZmZWN0aXZlIGVycm9yIGRldGVjdGlvbiBhbmQgcmVjb3ZlcnkgbWVjaGFuaXNtLiBJbiB0aGlzIGNhc2UsIGVuZHBvaW50cyB3aWxsIG5lZWQgdG8gcmVseSBvbiBvdGhlciBtZXRob2RzIC0tIHN1Y2ggYXMgdGltZXJzIC0tIHRvIGRldGVjdCB0aGF0IHRoZSBjb25uZWN0aW9uIGhhcyBmYWlsZWQuICogVGhlIHJhbmRvbWx5IGdlbmVyYXRlZCBjb25uZWN0aW9uIElEIGNhbiBiZSB1c2VkIGJ5IGVudGl0aWVzIG90aGVyIHRoYW4gdGhlIHBlZXIgdG8gaWRlbnRpZnkgdGhpcyBhcyBhIHBvdGVudGlhbCBTdGF0ZWxlc3MgUmVzZXQuIEFuIGVuZHBvaW50IHRoYXQgb2NjYXNpb25hbGx5IHVzZXMgZGlmZmVyZW50IGNvbm5lY3Rpb24gSURzIG1pZ2h0IGludHJvZHVjZSBzb21lIHVuY2VydGFpbnR5IGFib3V0IHRoaXMuIFRoaXMgc3RhdGVsZXNzIHJlc2V0IGRlc2lnbiBpcyBzcGVjaWZpYyB0byBRVUlDIHZlcnNpb24gMS4gQW4gZW5kcG9pbnQgdGhhdCBzdXBwb3J0cyBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBRVUlDIG5lZWRzIHRvIGdlbmVyYXRlIGEgU3RhdGVsZXNzIFJlc2V0IHRoYXQgd2lsbCBiZSBhY2NlcHRlZCBieSBwZWVycyB0aGF0IHN1cHBvcnQgYW55IHZlcnNpb24gdGhhdCB0aGUgZW5kcG9pbnQgbWlnaHQgc3VwcG9ydCAob3IgbWlnaHQgaGF2ZSBzdXBwb3J0ZWQgcHJpb3IgdG8gbG9zaW5nIHN0YXRlKS4gRGVzaWduZXJzIG9mIG5ldyB2ZXJzaW9ucyBvZiBRVUlDIG5lZWQgdG8gYmUgYXdhcmUgb2YgdGhpcyBhbmQgZWl0aGVyICgxKSByZXVzZSB0aGlzIGRlc2lnbiBvciAoMikgdXNlIGEgcG9ydGlvbiBvZiB0aGUgcGFja2V0IG90aGVyIHRoYW4gdGhlIGxhc3QgMTYgYnl0ZXMgZm9yIGNhcnJ5aW5nIGRhdGEuIDEwLjMuMS4gRGV0ZWN0aW5nIGEgU3RhdGVsZXNzIFJlc2V0IEFuIGVuZHBvaW50IGRldGVjdHMgYSBwb3RlbnRpYWwgU3RhdGVsZXNzIFJlc2V0IHVzaW5nIHRoZSB0cmFpbGluZyAxNiBieXRlcyBvZiB0aGUgVURQIGRhdGFncmFtLiBBbiBlbmRwb2ludCByZW1lbWJlcnMgYWxsIHN0YXRlbGVzcyByZXNldCB0b2tlbnMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb25uZWN0aW9uIElEcyBhbmQgcmVtb3RlIGFkZHJlc3NlcyBmb3IgZGF0YWdyYW1zIGl0IGhhcyByZWNlbnRseSBzZW50LiBUaGlzIGluY2x1ZGVzIFN0YXRlbGVzcyBSZXNldCBUb2tlbiBmaWVsZCB2YWx1ZXMgZnJvbSBORVdfQ09OTkVDVElPTl9JRCBmcmFtZXMgYW5kIHRoZSBzZXJ2ZXIncyB0cmFuc3BvcnQgcGFyYW1ldGVycyBidXQgZXhjbHVkZXMgc3RhdGVsZXNzIHJlc2V0IHRva2VucyBhc3NvY2lhdGVkIHdpdGggY29ubmVjdGlvbiBJRHMgdGhhdCBhcmUgZWl0aGVyIHVudXNlZCBvciByZXRpcmVkLiBUaGUgZW5kcG9pbnQgaWRlbnRpZmllcyBhIHJlY2VpdmVkIGRhdGFncmFtIGFzIGEgU3RhdGVsZXNzIFJlc2V0IGJ5IGNvbXBhcmluZyB0aGUgbGFzdCAxNiBieXRlcyBvZiB0aGUgZGF0YWdyYW0gd2l0aCBhbGwgc3RhdGVsZXNzIHJlc2V0IHRva2VucyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlbW90ZSBhZGRyZXNzIG9uIHdoaWNoIHRoZSBkYXRhZ3JhbSB3YXMgcmVjZWl2ZWQuIFRoaXMgY29tcGFyaXNvbiBjYW4gYmUgcGVyZm9ybWVkIGZvciBldmVyeSBpbmJvdW5kIGRhdGFncmFtLiBFbmRwb2ludHMgTUFZIHNraXAgdGhpcyBjaGVjayBpZiBhbnkgcGFja2V0IGZyb20gYSBkYXRhZ3JhbSBpcyBzdWNjZXNzZnVsbHkgcHJvY2Vzc2VkLiBIb3dldmVyLCB0aGUgY29tcGFyaXNvbiBNVVNUIGJlIHBlcmZvcm1lZCB3aGVuIHRoZSBmaXJzdCBwYWNrZXQgaW4gYW4gaW5jb21pbmcgZGF0YWdyYW0gZWl0aGVyIGNhbm5vdCBiZSBhc3NvY2lhdGVkIHdpdGggYSBjb25uZWN0aW9uIG9yIGNhbm5vdCBiZSBkZWNyeXB0ZWQuIEFuIGVuZHBvaW50IE1VU1QgTk9UIGNoZWNrIGZvciBhbnkgc3RhdGVsZXNzIHJlc2V0IHRva2VucyBhc3NvY2lhdGVkIHdpdGggY29ubmVjdGlvbiBJRHMgaXQgaGFzIG5vdCB1c2VkIG9yIGZvciBjb25uZWN0aW9uIElEcyB0aGF0IGhhdmUgYmVlbiByZXRpcmVkLiBXaGVuIGNvbXBhcmluZyBhIGRhdGFncmFtIHRvIHN0YXRlbGVzcyByZXNldCB0b2tlbiB2YWx1ZXMsIGVuZHBvaW50cyBNVVNUIHBlcmZvcm0gdGhlIGNvbXBhcmlzb24gd2l0aG91dCBsZWFraW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSB2YWx1ZSBvZiB0aGUgdG9rZW4uIEZvciBleGFtcGxlLCBwZXJmb3JtaW5nIHRoaXMgY29tcGFyaXNvbiBpbiBjb25zdGFudCB0aW1lIHByb3RlY3RzIHRoZSB2YWx1ZSBvZiBpbmRpdmlkdWFsIHN0YXRlbGVzcyByZXNldCB0b2tlbnMgZnJvbSBpbmZvcm1hdGlvbiBsZWFrYWdlIHRocm91Z2ggdGltaW5nIHNpZGUgY2hhbm5lbHMuIEFub3RoZXIgYXBwcm9hY2ggd291bGQgYmUgdG8gc3RvcmUgYW5kIGNvbXBhcmUgdGhlIHRyYW5zZm9ybWVkIHZhbHVlcyBvZiBzdGF0ZWxlc3MgcmVzZXQgdG9rZW5zIGluc3RlYWQgb2YgdGhlIHJhdyB0b2tlbiB2YWx1ZXMsIHdoZXJlIHRoZSB0cmFuc2Zvcm1hdGlvbiBpcyBkZWZpbmVkIGFzIGEgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHBzZXVkb3JhbmRvbSBmdW5jdGlvbiB1c2luZyBhIHNlY3JldCBrZXkgKGUuZy4sIGJsb2NrIGNpcGhlciwgSGFzaGVkIE1lc3NhZ2UgQXV0aGVudGljYXRpb24gQ29kZSAoSE1BQykgW1JGQzIxMDRdKS4gQW4gZW5kcG9pbnQgaXMgbm90IGV4cGVjdGVkIHRvIHByb3RlY3QgaW5mb3JtYXRpb24gYWJvdXQgd2hldGhlciBhIHBhY2tldCB3YXMgc3VjY2Vzc2Z1bGx5IGRlY3J5cHRlZCBvciB0aGUgbnVtYmVyIG9mIHZhbGlkIHN0YXRlbGVzcyByZXNldCB0b2tlbnMuIElmIHRoZSBsYXN0IDE2IGJ5dGVzIG9mIHRoZSBkYXRhZ3JhbSBhcmUgaWRlbnRpY2FsIGluIHZhbHVlIHRvIGEgc3RhdGVsZXNzIHJlc2V0IHRva2VuLCB0aGUgZW5kcG9pbnQgTVVTVCBlbnRlciB0aGUgZHJhaW5pbmcgcGVyaW9kIGFuZCBub3Qgc2VuZCBhbnkgZnVydGhlciBwYWNrZXRzIG9uIHRoaXMgY29ubmVjdGlvbi4gMTAuMy4yLiBDYWxjdWxhdGluZyBhIFN0YXRlbGVzcyBSZXNldCBUb2tlbiBUaGUgc3RhdGVsZXNzIHJlc2V0IHRva2VuIE1VU1QgYmUgZGlmZmljdWx0IHRvIGd1ZXNzLiBJbiBvcmRlciB0byBjcmVhdGUgYSBzdGF0ZWxlc3MgcmVzZXQgdG9rZW4sIGFuIGVuZHBvaW50IGNvdWxkIHJhbmRvbWx5IGdlbmVyYXRlIFtSQU5ET01dIGEgc2VjcmV0IGZvciBldmVyeSBjb25uZWN0aW9uIHRoYXQgaXQgY3JlYXRlcy4gSG93ZXZlciwgdGhpcyBwcmVzZW50cyBhIGNvb3JkaW5hdGlvbiBwcm9ibGVtIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGluc3RhbmNlcyBpbiBhIGNsdXN0ZXIgb3IgYSBzdG9yYWdlIHByb2JsZW0gZm9yIGFuIGVuZHBvaW50IHRoYXQgbWlnaHQgbG9zZSBzdGF0ZS4gU3RhdGVsZXNzIHJlc2V0IHNwZWNpZmljYWxseSBleGlzdHMgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHN0YXRlIGlzIGxvc3QsIHNvIHRoaXMgYXBwcm9hY2ggaXMgc3Vib3B0aW1hbC4gQSBzaW5nbGUgc3RhdGljIGtleSBjYW4gYmUgdXNlZCBhY3Jvc3MgYWxsIGNvbm5lY3Rpb25zIHRvIHRoZSBzYW1lIGVuZHBvaW50IGJ5IGdlbmVyYXRpbmcgdGhlIHByb29mIHVzaW5nIGEgcHNldWRvcmFuZG9tIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzdGF0aWMga2V5IGFuZCB0aGUgY29ubmVjdGlvbiBJRCBjaG9zZW4gYnkgdGhlIGVuZHBvaW50IChzZWUgU2VjdGlvbiA1LjEpIGFzIGlucHV0LiBBbiBlbmRwb2ludCBjb3VsZCB1c2UgSE1BQyBbUkZDMjEwNF0gKGZvciBleGFtcGxlLCBITUFDKHN0YXRpY19rZXksIGNvbm5lY3Rpb25faWQpKSBvciB0aGUgSE1BQy1iYXNlZCBLZXkgRGVyaXZhdGlvbiBGdW5jdGlvbiAoSEtERikgW1JGQzU4NjldIChmb3IgZXhhbXBsZSwgdXNpbmcgdGhlIHN0YXRpYyBrZXkgYXMgaW5wdXQga2V5aW5nIG1hdGVyaWFsLCB3aXRoIHRoZSBjb25uZWN0aW9uIElEIGFzIHNhbHQpLiBUaGUgb3V0cHV0IG9mIHRoaXMgZnVuY3Rpb24gaXMgdHJ1bmNhdGVkIHRvIDE2IGJ5dGVzIHRvIHByb2R1Y2UgdGhlIHN0YXRlbGVzcyByZXNldCB0b2tlbiBmb3IgdGhhdCBjb25uZWN0aW9uLiBBbiBlbmRwb2ludCB0aGF0IGxvc2VzIHN0YXRlIGNhbiB1c2UgdGhlIHNhbWUgbWV0aG9kIHRvIGdlbmVyYXRlIGEgdmFsaWQgc3RhdGVsZXNzIHJlc2V0IHRva2VuLiBUaGUgY29ubmVjdGlvbiBJRCBjb21lcyBmcm9tIHRoZSBwYWNrZXQgdGhhdCB0aGUgZW5kcG9pbnQgcmVjZWl2ZXMuIFRoaXMgZGVzaWduIHJlbGllcyBvbiB0aGUgcGVlciBhbHdheXMgc2VuZGluZyBhIGNvbm5lY3Rpb24gSUQgaW4gaXRzIHBhY2tldHMgc28gdGhhdCB0aGUgZW5kcG9pbnQgY2FuIHVzZSB0aGUgY29ubmVjdGlvbiBJRCBmcm9tIGEgcGFja2V0IHRvIHJlc2V0IHRoZSBjb25uZWN0aW9uLiBBbiBlbmRwb2ludCB0aGF0IHVzZXMgdGhpcyBkZXNpZ24gTVVTVCBlaXRoZXIgdXNlIHRoZSBzYW1lIGNvbm5lY3Rpb24gSUQgbGVuZ3RoIGZvciBhbGwgY29ubmVjdGlvbnMgb3IgZW5jb2RlIHRoZSBsZW5ndGggb2YgdGhlIGNvbm5lY3Rpb24gSUQgc3VjaCB0aGF0IGl0IGNhbiBiZSByZWNvdmVyZWQgd2l0aG91dCBzdGF0ZS4gSW4gYWRkaXRpb24sIGl0IGNhbm5vdCBwcm92aWRlIGEgemVyby1sZW5ndGggY29ubmVjdGlvbiBJRC4gUmV2ZWFsaW5nIHRoZSBzdGF0ZWxlc3MgcmVzZXQgdG9rZW4gYWxsb3dzIGFueSBlbnRpdHkgdG8gdGVybWluYXRlIHRoZSBjb25uZWN0aW9uLCBzbyBhIHZhbHVlIGNhbiBvbmx5IGJlIHVzZWQgb25jZS4gVGhpcyBtZXRob2QgZm9yIGNob29zaW5nIHRoZSBzdGF0ZWxlc3MgcmVzZXQgdG9rZW4gbWVhbnMgdGhhdCB0aGUgY29tYmluYXRpb24gb2YgY29ubmVjdGlvbiBJRCBhbmQgc3RhdGljIGtleSBNVVNUIE5PVCBiZSB1c2VkIGZvciBhbm90aGVyIGNvbm5lY3Rpb24uIEEgZGVuaWFsLW9mLXNlcnZpY2UgYXR0YWNrIGlzIHBvc3NpYmxlIGlmIHRoZSBzYW1lIGNvbm5lY3Rpb24gSUQgaXMgdXNlZCBieSBpbnN0YW5jZXMgdGhhdCBzaGFyZSBhIHN0YXRpYyBrZXkgb3IgaWYgYW4gYXR0YWNrZXIgY2FuIGNhdXNlIGEgcGFja2V0IHRvIGJlIHJvdXRlZCB0byBhbiBpbnN0YW5jZSB0aGF0IGhhcyBubyBzdGF0ZSBidXQgdGhlIHNhbWUgc3RhdGljIGtleTsgc2VlIFNlY3Rpb24gMjEuMTEuIEEgY29ubmVjdGlvbiBJRCBmcm9tIGEgY29ubmVjdGlvbiB0aGF0IGlzIHJlc2V0IGJ5IHJldmVhbGluZyB0aGUgc3RhdGVsZXNzIHJlc2V0IHRva2VuIE1VU1QgTk9UIGJlIHJldXNlZCBmb3IgbmV3IGNvbm5lY3Rpb25zIGF0IG5vZGVzIHRoYXQgc2hhcmUgYSBzdGF0aWMga2V5LiBUaGUgc2FtZSBzdGF0ZWxlc3MgcmVzZXQgdG9rZW4gTVVTVCBOT1QgYmUgdXNlZCBmb3IgbXVsdGlwbGUgY29ubmVjdGlvbiBJRHMuIEVuZHBvaW50cyBhcmUgbm90IHJlcXVpcmVkIHRvIGNvbXBhcmUgbmV3IHZhbHVlcyBhZ2FpbnN0IGFsbCBwcmV2aW91cyB2YWx1ZXMsIGJ1dCBhIGR1cGxpY2F0ZSB2YWx1ZSBNQVkgYmUgdHJlYXRlZCBhcyBhIGNvbm5lY3Rpb24gZXJyb3Igb2YgdHlwZSBQUk9UT0NPTF9WSU9MQVRJT04uIE5vdGUgdGhhdCBTdGF0ZWxlc3MgUmVzZXRzIGRvIG5vdCBoYXZlIGFueSBjcnlwdG9ncmFwaGljIHByb3RlY3Rpb24uIDEwLjMuMy4gTG9vcGluZyBUaGUgZGVzaWduIG9mIGEgU3RhdGVsZXNzIFJlc2V0IGlzIHN1Y2ggdGhhdCB3aXRob3V0IGtub3dpbmcgdGhlIHN0YXRlbGVzcyByZXNldCB0b2tlbiBpdCBpcyBpbmRpc3Rpbmd1aXNoYWJsZSBmcm9tIGEgdmFsaWQgcGFja2V0LiBGb3IgaW5zdGFuY2UsIGlmIGEgc2VydmVyIHNlbmRzIGEgU3RhdGVsZXNzIFJlc2V0IHRvIGFub3RoZXIgc2VydmVyLCBpdCBtaWdodCByZWNlaXZlIGFub3RoZXIgU3RhdGVsZXNzIFJlc2V0IGluIHJlc3BvbnNlLCB3aGljaCBjb3VsZCBsZWFkIHRvIGFuIGluZmluaXRlIGV4Y2hhbmdlLiBBbiBlbmRwb2ludCBNVVNUIGVuc3VyZSB0aGF0IGV2ZXJ5IFN0YXRlbGVzcyBSZXNldCB0aGF0IGl0IHNlbmRzIGlzIHNtYWxsZXIgdGhhbiB0aGUgcGFja2V0IHRoYXQgdHJpZ2dlcmVkIGl0LCB1bmxlc3MgaXQgbWFpbnRhaW5zIHN0YXRlIHN1ZmZpY2llbnQgdG8gcHJldmVudCBsb29waW5nLiBJbiB0aGUgZXZlbnQgb2YgYSBsb29wLCB0aGlzIHJlc3VsdHMgaW4gcGFja2V0cyBldmVudHVhbGx5IGJlaW5nIHRvbyBzbWFsbCB0byB0cmlnZ2VyIGEgcmVzcG9uc2UuIEFuIGVuZHBvaW50IGNhbiByZW1lbWJlciB0aGUgbnVtYmVyIG9mIFN0YXRlbGVzcyBSZXNldHMgdGhhdCBpdCBoYXMgc2VudCBhbmQgc3RvcCBnZW5lcmF0aW5nIG5ldyBTdGF0ZWxlc3MgUmVzZXRzIG9uY2UgYSBsaW1pdCBpcyByZWFjaGVkLiBVc2luZyBzZXBhcmF0ZSBsaW1pdHMgZm9yIGRpZmZlcmVudCByZW1vdGUgYWRkcmVzc2VzIHdpbGwgZW5zdXJlIHRoYXQgU3RhdGVsZXNzIFJlc2V0cyBjYW4gYmUgdXNlZCB0byBjbG9zZSBjb25uZWN0aW9ucyB3aGVuIG90aGVyIHBlZXJzIG9yIGNvbm5lY3Rpb25zIGhhdmUgZXhoYXVzdGVkIGxpbWl0cy4gQSBTdGF0ZWxlc3MgUmVzZXQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gNDEgYnl0ZXMgbWlnaHQgYmUgaWRlbnRpZmlhYmxlIGFzIGEgU3RhdGVsZXNzIFJlc2V0IGJ5IGFuIG9ic2VydmVyLCBkZXBlbmRpbmcgdXBvbiB0aGUgbGVuZ3RoIG9mIHRoZSBwZWVyJ3MgY29ubmVjdGlvbiBJRHMuIENvbnZlcnNlbHksIG5vdCBzZW5kaW5nIGEgU3RhdGVsZXNzIFJlc2V0IGluIHJlc3BvbnNlIHRvIGEgc21hbGwgcGFja2V0IG1pZ2h0IHJlc3VsdCBpbiBTdGF0ZWxlc3MgUmVzZXRzIG5vdCBiZWluZyB1c2VmdWwgaW4gZGV0ZWN0aW5nIGNhc2VzIG9mIGJyb2tlbiBjb25uZWN0aW9ucyB3aGVyZSBvbmx5IHZlcnkgc21hbGwgcGFja2V0cyBhcmUgc2VudDsgc3VjaCBmYWlsdXJlcyBtaWdodCBvbmx5IGJlIGRldGVjdGVkIGJ5IG90aGVyIG1lYW5zLCBzdWNoIGFzIHRpbWVycy4gMTEuIEVycm9yIEhhbmRsaW5nIEFuIGVuZHBvaW50IHRoYXQgZGV0ZWN0cyBhbiBlcnJvciBTSE9VTEQgc2lnbmFsIHRoZSBleGlzdGVuY2Ugb2YgdGhhdCBlcnJvciB0byBpdHMgcGVlci4gQm90aCB0cmFuc3BvcnQtbGV2ZWwgYW5kIGFwcGxpY2F0aW9uLWxldmVsIGVycm9ycyBjYW4gYWZmZWN0IGFuIGVudGlyZSBjb25uZWN0aW9uOyBzZWUgU2VjdGlvbiAxMS4xLiBPbmx5IGFwcGxpY2F0aW9uLSBsZXZlbCBlcnJvcnMgY2FuIGJlIGlzb2xhdGVkIHRvIGEgc2luZ2xlIHN0cmVhbTsgc2VlIFNlY3Rpb24gMTEuMi4gVGhlIG1vc3QgYXBwcm9wcmlhdGUgZXJyb3IgY29kZSAoU2VjdGlvbiAyMCkgU0hPVUxEIGJlIGluY2x1ZGVkIGluIHRoZSBmcmFtZSB0aGF0IHNpZ25hbHMgdGhlIGVycm9yLiBXaGVyZSB0aGlzIHNwZWNpZmljYXRpb24gaWRlbnRpZmllcyBlcnJvciBjb25kaXRpb25zLCBpdCBhbHNvIGlkZW50aWZpZXMgdGhlIGVycm9yIGNvZGUgdGhhdCBpcyB1c2VkOyB0aG91Z2ggdGhlc2UgYXJlIHdvcmRlZCBhcyByZXF1aXJlbWVudHMsIGRpZmZlcmVudCBpbXBsZW1lbnRhdGlvbiBzdHJhdGVnaWVzIG1pZ2h0IGxlYWQgdG8gZGlmZmVyZW50IGVycm9ycyBiZWluZyByZXBvcnRlZC4gSW4gcGFydGljdWxhciwgYW4gZW5kcG9pbnQgTUFZIHVzZSBhbnkgYXBwbGljYWJsZSBlcnJvciBjb2RlIHdoZW4gaXQgZGV0ZWN0cyBhbiBlcnJvciBjb25kaXRpb247IGEgZ2VuZXJpYyBlcnJvciBjb2RlIChzdWNoIGFzIFBST1RPQ09MX1ZJT0xBVElPTiBvciBJTlRFUk5BTF9FUlJPUikgY2FuIGFsd2F5cyBiZSB1c2VkIGluIHBsYWNlIG9mIHNwZWNpZmljIGVycm9yIGNvZGVzLiBBIHN0YXRlbGVzcyByZXNldCAoU2VjdGlvbiAxMC4zKSBpcyBub3Qgc3VpdGFibGUgZm9yIGFueSBlcnJvciB0aGF0IGNhbiBiZSBzaWduYWxlZCB3aXRoIGEgQ09OTkVDVElPTl9DTE9TRSBvciBSRVNFVF9TVFJFQU0gZnJhbWUuIEEgc3RhdGVsZXNzIHJlc2V0IE1VU1QgTk9UIGJlIHVzZWQgYnkgYW4gZW5kcG9pbnQgdGhhdCBoYXMgdGhlIHN0YXRlIG5lY2Vzc2FyeSB0byBzZW5kIGEgZnJhbWUgb24gdGhlIGNvbm5lY3Rpb24uIDExLjEuIENvbm5lY3Rpb24gRXJyb3JzIEVycm9ycyB0aGF0IHJlc3VsdCBpbiB0aGUgY29ubmVjdGlvbiBiZWluZyB1bnVzYWJsZSwgc3VjaCBhcyBhbiBvYnZpb3VzIHZpb2xhdGlvbiBvZiBwcm90b2NvbCBzZW1hbnRpY3Mgb3IgY29ycnVwdGlvbiBvZiBzdGF0ZSB0aGF0IGFmZmVjdHMgYW4gZW50aXJlIGNvbm5lY3Rpb24sIE1VU1QgYmUgc2lnbmFsZWQgdXNpbmcgYSBDT05ORUNUSU9OX0NMT1NFIGZyYW1lIChTZWN0aW9uIDE5LjE5KS4gQXBwbGljYXRpb24tc3BlY2lmaWMgcHJvdG9jb2wgZXJyb3JzIGFyZSBzaWduYWxlZCB1c2luZyB0aGUgQ09OTkVDVElPTl9DTE9TRSBmcmFtZSB3aXRoIGEgZnJhbWUgdHlwZSBvZiAweDFkLiBFcnJvcnMgdGhhdCBhcmUgc3BlY2lmaWMgdG8gdGhlIHRyYW5zcG9ydCwgaW5jbHVkaW5nIGFsbCB0aG9zZSBkZXNjcmliZWQgaW4gdGhpcyBkb2N1bWVudCwgYXJlIGNhcnJpZWQgaW4gdGhlIENPTk5FQ1RJT05fQ0xPU0UgZnJhbWUgd2l0aCBhIGZyYW1lIHR5cGUgb2YgMHgxYy4gQSBDT05ORUNUSU9OX0NMT1NFIGZyYW1lIGNvdWxkIGJlIHNlbnQgaW4gYSBwYWNrZXQgdGhhdCBpcyBsb3N0LiBBbiBlbmRwb2ludCBTSE9VTEQgYmUgcHJlcGFyZWQgdG8gcmV0cmFuc21pdCBhIHBhY2tldCBjb250YWluaW5nIGEgQ09OTkVDVElPTl9DTE9TRSBmcmFtZSBpZiBpdCByZWNlaXZlcyBtb3JlIHBhY2tldHMgb24gYSB0ZXJtaW5hdGVkIGNvbm5lY3Rpb24uIExpbWl0aW5nIHRoZSBudW1iZXIgb2YgcmV0cmFuc21pc3Npb25zIGFuZCB0aGUgdGltZSBvdmVyIHdoaWNoIHRoaXMgZmluYWwgcGFja2V0IGlzIHNlbnQgbGltaXRzIHRoZSBlZmZvcnQgZXhwZW5kZWQgb24gdGVybWluYXRlZCBjb25uZWN0aW9ucy4gQW4gZW5kcG9pbnQgdGhhdCBjaG9vc2VzIG5vdCB0byByZXRyYW5zbWl0IHBhY2tldHMgY29udGFpbmluZyBhIENPTk5FQ1RJT05fQ0xPU0UgZnJhbWUgcmlza3MgYSBwZWVyIG1pc3NpbmcgdGhlIGZpcnN0IHN1Y2ggcGFja2V0LiBUaGUgb25seSBtZWNoYW5pc20gYXZhaWxhYmxlIHRvIGFuIGVuZHBvaW50IHRoYXQgY29udGludWVzIHRvIHJlY2VpdmUgZGF0YSBmb3IgYSB0ZXJtaW5hdGVkIGNvbm5lY3Rpb24gaXMgdG8gYXR0ZW1wdCB0aGUgc3RhdGVsZXNzIHJlc2V0IHByb2Nlc3MgKFNlY3Rpb24gMTAuMykuIEFzIHRoZSBBRUFEIGZvciBJbml0aWFsIHBhY2tldHMgZG9lcyBub3QgcHJvdmlkZSBzdHJvbmcgYXV0aGVudGljYXRpb24sIGFuIGVuZHBvaW50IE1BWSBkaXNjYXJkIGFuIGludmFsaWQgSW5pdGlhbCBwYWNrZXQuIERpc2NhcmRpbmcgYW4gSW5pdGlhbCBwYWNrZXQgaXMgcGVybWl0dGVkIGV2ZW4gd2hlcmUgdGhpcyBzcGVjaWZpY2F0aW9uIG90aGVyd2lzZSBtYW5kYXRlcyBhIGNvbm5lY3Rpb24gZXJyb3IuIEFuIGVuZHBvaW50IGNhbiBvbmx5IGRpc2NhcmQgYSBwYWNrZXQgaWYgaXQgZG9lcyBub3QgcHJvY2VzcyB0aGUgZnJhbWVzIGluIHRoZSBwYWNrZXQgb3IgcmV2ZXJ0cyB0aGUgZWZmZWN0cyBvZiBhbnkgcHJvY2Vzc2luZy4gRGlzY2FyZGluZyBpbnZhbGlkIEluaXRpYWwgcGFja2V0cyBtaWdodCBiZSB1c2VkIHRvIHJlZHVjZSBleHBvc3VyZSB0byBkZW5pYWwgb2Ygc2VydmljZTsgc2VlIFNlY3Rpb24gMjEuMi4gMTEuMi4gU3RyZWFtIEVycm9ycyBJZiBhbiBhcHBsaWNhdGlvbi1sZXZlbCBlcnJvciBhZmZlY3RzIGEgc2luZ2xlIHN0cmVhbSBidXQgb3RoZXJ3aXNlIGxlYXZlcyB0aGUgY29ubmVjdGlvbiBpbiBhIHJlY292ZXJhYmxlIHN0YXRlLCB0aGUgZW5kcG9pbnQgY2FuIHNlbmQgYSBSRVNFVF9TVFJFQU0gZnJhbWUgKFNlY3Rpb24gMTkuNCkgd2l0aCBhbiBhcHByb3ByaWF0ZSBlcnJvciBjb2RlIHRvIHRlcm1pbmF0ZSBqdXN0IHRoZSBhZmZlY3RlZCBzdHJlYW0uIFJlc2V0dGluZyBhIHN0cmVhbSB3aXRob3V0IHRoZSBpbnZvbHZlbWVudCBvZiB0aGUgYXBwbGljYXRpb24gcHJvdG9jb2wgY291bGQgY2F1c2UgdGhlIGFwcGxpY2F0aW9uIHByb3RvY29sIHRvIGVudGVyIGFuIHVucmVjb3ZlcmFibGUgc3RhdGUuIFJFU0VUX1NUUkVBTSBNVVNUIG9ubHkgYmUgaW5zdGlnYXRlZCBieSB0aGUgYXBwbGljYXRpb24gcHJvdG9jb2wgdGhhdCB1c2VzIFFVSUMuIFRoZSBzZW1hbnRpY3Mgb2YgdGhlIGFwcGxpY2F0aW9uIGVycm9yIGNvZGUgY2FycmllZCBpbiBSRVNFVF9TVFJFQU0gYXJlIGRlZmluZWQgYnkgdGhlIGFwcGxpY2F0aW9uIHByb3RvY29sLiBPbmx5IHRoZSBhcHBsaWNhdGlvbiBwcm90b2NvbCBpcyBhYmxlIHRvIGNhdXNlIGEgc3RyZWFtIHRvIGJlIHRlcm1pbmF0ZWQuIEEgbG9jYWwgaW5zdGFuY2Ugb2YgdGhlIGFwcGxpY2F0aW9uIHByb3RvY29sIHVzZXMgYSBkaXJlY3QgQVBJIGNhbGwsIGFuZCBhIHJlbW90ZSBpbnN0YW5jZSB1c2VzIHRoZSBTVE9QX1NFTkRJTkcgZnJhbWUsIHdoaWNoIHRyaWdnZXJzIGFuIGF1dG9tYXRpYyBSRVNFVF9TVFJFQU0uIEFwcGxpY2F0aW9uIHByb3RvY29scyBTSE9VTEQgZGVmaW5lIHJ1bGVzIGZvciBoYW5kbGluZyBzdHJlYW1zIHRoYXQgYXJlIHByZW1hdHVyZWx5IGNhbmNlbGVkIGJ5IGVpdGhlciBlbmRwb2ludC4gMTIuIFBhY2tldHMgYW5kIEZyYW1lcyBRVUlDIGVuZHBvaW50cyBjb21tdW5pY2F0ZSBieSBleGNoYW5naW5nIHBhY2tldHMuIFBhY2tldHMgaGF2ZSBjb25maWRlbnRpYWxpdHkgYW5kIGludGVncml0eSBwcm90ZWN0aW9uOyBzZWUgU2VjdGlvbiAxMi4xLiBQYWNrZXRzIGFyZSBjYXJyaWVkIGluIFVEUCBkYXRhZ3JhbXM7IHNlZSBTZWN0aW9uIDEyLjIuIFRoaXMgdmVyc2lvbiBvZiBRVUlDIHVzZXMgdGhlIGxvbmcgcGFja2V0IGhlYWRlciBkdXJpbmcgY29ubmVjdGlvbiBlc3RhYmxpc2htZW50OyBzZWUgU2VjdGlvbiAxNy4yLiBQYWNrZXRzIHdpdGggdGhlIGxvbmcgaGVhZGVyIGFyZSBJbml0aWFsIChTZWN0aW9uIDE3LjIuMiksIDAtUlRUIChTZWN0aW9uIDE3LjIuMyksIEhhbmRzaGFrZSAoU2VjdGlvbiAxNy4yLjQpLCBhbmQgUmV0cnkgKFNlY3Rpb24gMTcuMi41KS4gVmVyc2lvbiBuZWdvdGlhdGlvbiB1c2VzIGEgdmVyc2lvbi1pbmRlcGVuZGVudCBwYWNrZXQgd2l0aCBhIGxvbmcgaGVhZGVyOyBzZWUgU2VjdGlvbiAxNy4yLjEuIFBhY2tldHMgd2l0aCB0aGUgc2hvcnQgaGVhZGVyIGFyZSBkZXNpZ25lZCBmb3IgbWluaW1hbCBvdmVyaGVhZCBhbmQgYXJlIHVzZWQgYWZ0ZXIgYSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkIGFuZCAxLVJUVCBrZXlzIGFyZSBhdmFpbGFibGU7IHNlZSBTZWN0aW9uIDE3LjMuIDEyLjEuIFByb3RlY3RlZCBQYWNrZXRzIFFVSUMgcGFja2V0cyBoYXZlIGRpZmZlcmVudCBsZXZlbHMgb2YgY3J5cHRvZ3JhcGhpYyBwcm90ZWN0aW9uIGJhc2VkIG9uIHRoZSB0eXBlIG9mIHBhY2tldC4gRGV0YWlscyBvZiBwYWNrZXQgcHJvdGVjdGlvbiBhcmUgZm91bmQgaW4gW1FVSUMtVExTXTsgdGhpcyBzZWN0aW9uIGluY2x1ZGVzIGFuIG92ZXJ2aWV3IG9mIHRoZSBwcm90ZWN0aW9ucyB0aGF0IGFyZSBwcm92aWRlZC4gVmVyc2lvbiBOZWdvdGlhdGlvbiBwYWNrZXRzIGhhdmUgbm8gY3J5cHRvZ3JhcGhpYyBwcm90ZWN0aW9uOyBzZWUgW1FVSUMtSU5WQVJJQU5UU10uIFJldHJ5IHBhY2tldHMgdXNlIGFuIEFFQUQgZnVuY3Rpb24gW0FFQURdIHRvIHByb3RlY3QgYWdhaW5zdCBhY2NpZGVudGFsIG1vZGlmaWNhdGlvbi4gSW5pdGlhbCBwYWNrZXRzIHVzZSBhbiBBRUFEIGZ1bmN0aW9uLCB0aGUga2V5cyBmb3Igd2hpY2ggYXJlIGRlcml2ZWQgdXNpbmcgYSB2YWx1ZSB0aGF0IGlzIHZpc2libGUgb24gdGhlIHdpcmUuIEluaXRpYWwgcGFja2V0cyB0aGVyZWZvcmUgZG8gbm90IGhhdmUgZWZmZWN0aXZlIGNvbmZpZGVudGlhbGl0eSBwcm90ZWN0aW9uLiBJbml0aWFsIHByb3RlY3Rpb24gZXhpc3RzIHRvIGVuc3VyZSB0aGF0IHRoZSBzZW5kZXIgb2YgdGhlIHBhY2tldCBpcyBvbiB0aGUgbmV0d29yayBwYXRoLiBBbnkgZW50aXR5IHRoYXQgcmVjZWl2ZXMgYW4gSW5pdGlhbCBwYWNrZXQgZnJvbSBhIGNsaWVudCBjYW4gcmVjb3ZlciB0aGUga2V5cyB0aGF0IHdpbGwgYWxsb3cgdGhlbSB0byBib3RoIHJlYWQgdGhlIGNvbnRlbnRzIG9mIHRoZSBwYWNrZXQgYW5kIGdlbmVyYXRlIEluaXRpYWwgcGFja2V0cyB0aGF0IHdpbGwgYmUgc3VjY2Vzc2Z1bGx5IGF1dGhlbnRpY2F0ZWQgYXQgZWl0aGVyIGVuZHBvaW50LiBUaGUgQUVBRCBhbHNvIHByb3RlY3RzIEluaXRpYWwgcGFja2V0cyBhZ2FpbnN0IGFjY2lkZW50YWwgbW9kaWZpY2F0aW9uLiBBbGwgb3RoZXIgcGFja2V0cyBhcmUgcHJvdGVjdGVkIHdpdGgga2V5cyBkZXJpdmVkIGZyb20gdGhlIGNyeXB0b2dyYXBoaWMgaGFuZHNoYWtlLiBUaGUgY3J5cHRvZ3JhcGhpYyBoYW5kc2hha2UgZW5zdXJlcyB0aGF0IG9ubHkgdGhlIGNvbW11bmljYXRpbmcgZW5kcG9pbnRzIHJlY2VpdmUgdGhlIGNvcnJlc3BvbmRpbmcga2V5cyBmb3IgSGFuZHNoYWtlLCAwLVJUVCwgYW5kIDEtUlRUIHBhY2tldHMuIFBhY2tldHMgcHJvdGVjdGVkIHdpdGggMC1SVFQgYW5kIDEtUlRUIGtleXMgaGF2ZSBzdHJvbmcgY29uZmlkZW50aWFsaXR5IGFuZCBpbnRlZ3JpdHkgcHJvdGVjdGlvbi4gVGhlIFBhY2tldCBOdW1iZXIgZmllbGQgdGhhdCBhcHBlYXJzIGluIHNvbWUgcGFja2V0IHR5cGVzIGhhcyBhbHRlcm5hdGl2ZSBjb25maWRlbnRpYWxpdHkgcHJvdGVjdGlvbiB0aGF0IGlzIGFwcGxpZWQgYXMgcGFydCBvZiBoZWFkZXIgcHJvdGVjdGlvbjsgc2VlIFNlY3Rpb24gNS40IG9mIFtRVUlDLVRMU10gZm9yIGRldGFpbHMuIFRoZSB1bmRlcmx5aW5nIHBhY2tldCBudW1iZXIgaW5jcmVhc2VzIHdpdGggZWFjaCBwYWNrZXQgc2VudCBpbiBhIGdpdmVuIHBhY2tldCBudW1iZXIgc3BhY2U7IHNlZSBTZWN0aW9uIDEyLjMgZm9yIGRldGFpbHMuIDEyLjIuIENvYWxlc2NpbmcgUGFja2V0cyBJbml0aWFsIChTZWN0aW9uIDE3LjIuMiksIDAtUlRUIChTZWN0aW9uIDE3LjIuMyksIGFuZCBIYW5kc2hha2UgKFNlY3Rpb24gMTcuMi40KSBwYWNrZXRzIGNvbnRhaW4gYSBMZW5ndGggZmllbGQgdGhhdCBkZXRlcm1pbmVzIHRoZSBlbmQgb2YgdGhlIHBhY2tldC4gVGhlIGxlbmd0aCBpbmNsdWRlcyBib3RoIHRoZSBQYWNrZXQgTnVtYmVyIGFuZCBQYXlsb2FkIGZpZWxkcywgYm90aCBvZiB3aGljaCBhcmUgY29uZmlkZW50aWFsaXR5IHByb3RlY3RlZCBhbmQgaW5pdGlhbGx5IG9mIHVua25vd24gbGVuZ3RoLiBUaGUgbGVuZ3RoIG9mIHRoZSBQYXlsb2FkIGZpZWxkIGlzIGxlYXJuZWQgb25jZSBoZWFkZXIgcHJvdGVjdGlvbiBpcyByZW1vdmVkLiBVc2luZyB0aGUgTGVuZ3RoIGZpZWxkLCBhIHNlbmRlciBjYW4gY29hbGVzY2UgbXVsdGlwbGUgUVVJQyBwYWNrZXRzIGludG8gb25lIFVEUCBkYXRhZ3JhbS4gVGhpcyBjYW4gcmVkdWNlIHRoZSBudW1iZXIgb2YgVURQIGRhdGFncmFtcyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIGNyeXB0b2dyYXBoaWMgaGFuZHNoYWtlIGFuZCBzdGFydCBzZW5kaW5nIGRhdGEuIFRoaXMgY2FuIGFsc28gYmUgdXNlZCB0byBjb25zdHJ1Y3QgUGF0aCBNYXhpbXVtIFRyYW5zbWlzc2lvbiBVbml0IChQTVRVKSBwcm9iZXM7IHNlZSBTZWN0aW9uIDE0LjQuMS4gUmVjZWl2ZXJzIE1VU1QgYmUgYWJsZSB0byBwcm9jZXNzIGNvYWxlc2NlZCBwYWNrZXRzLiBDb2FsZXNjaW5nIHBhY2tldHMgaW4gb3JkZXIgb2YgaW5jcmVhc2luZyBlbmNyeXB0aW9uIGxldmVscyAoSW5pdGlhbCwgMC1SVFQsIEhhbmRzaGFrZSwgMS1SVFQ7IHNlZSBTZWN0aW9uIDQuMS40IG9mIFtRVUlDLVRMU10pIG1ha2VzIGl0IG1vcmUgbGlrZWx5IHRoYXQgdGhlIHJlY2VpdmVyIHdpbGwgYmUgYWJsZSB0byBwcm9jZXNzIGFsbCB0aGUgcGFja2V0cyBpbiBhIHNpbmdsZSBwYXNzLiBBIHBhY2tldCB3aXRoIGEgc2hvcnQgaGVhZGVyIGRvZXMgbm90IGluY2x1ZGUgYSBsZW5ndGgsIHNvIGl0IGNhbiBvbmx5IGJlIHRoZSBsYXN0IHBhY2tldCBpbmNsdWRlZCBpbiBhIFVEUCBkYXRhZ3JhbS4gQW4gZW5kcG9pbnQgU0hPVUxEIGluY2x1ZGUgbXVsdGlwbGUgZnJhbWVzIGluIGEgc2luZ2xlIHBhY2tldCBpZiB0aGV5IGFyZSB0byBiZSBzZW50IGF0IHRoZSBzYW1lIGVuY3J5cHRpb24gbGV2ZWwsIGluc3RlYWQgb2YgY29hbGVzY2luZyBtdWx0aXBsZSBwYWNrZXRzIGF0IHRoZSBzYW1lIGVuY3J5cHRpb24gbGV2ZWwuIFJlY2VpdmVycyBNQVkgcm91dGUgYmFzZWQgb24gdGhlIGluZm9ybWF0aW9uIGluIHRoZSBmaXJzdCBwYWNrZXQgY29udGFpbmVkIGluIGEgVURQIGRhdGFncmFtLiBTZW5kZXJzIE1VU1QgTk9UIGNvYWxlc2NlIFFVSUMgcGFja2V0cyB3aXRoIGRpZmZlcmVudCBjb25uZWN0aW9uIElEcyBpbnRvIGEgc2luZ2xlIFVEUCBkYXRhZ3JhbS4gUmVjZWl2ZXJzIFNIT1VMRCBpZ25vcmUgYW55IHN1YnNlcXVlbnQgcGFja2V0cyB3aXRoIGEgZGlmZmVyZW50IERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgdGhhbiB0aGUgZmlyc3QgcGFja2V0IGluIHRoZSBkYXRhZ3JhbS4gRXZlcnkgUVVJQyBwYWNrZXQgdGhhdCBpcyBjb2FsZXNjZWQgaW50byBhIHNpbmdsZSBVRFAgZGF0YWdyYW0gaXMgc2VwYXJhdGUgYW5kIGNvbXBsZXRlLiBUaGUgcmVjZWl2ZXIgb2YgY29hbGVzY2VkIFFVSUMgcGFja2V0cyBNVVNUIGluZGl2aWR1YWxseSBwcm9jZXNzIGVhY2ggUVVJQyBwYWNrZXQgYW5kIHNlcGFyYXRlbHkgYWNrbm93bGVkZ2UgdGhlbSwgYXMgaWYgdGhleSB3ZXJlIHJlY2VpdmVkIGFzIHRoZSBwYXlsb2FkIG9mIGRpZmZlcmVudCBVRFAgZGF0YWdyYW1zLiBGb3IgZXhhbXBsZSwgaWYgZGVjcnlwdGlvbiBmYWlscyAoYmVjYXVzZSB0aGUga2V5cyBhcmUgbm90IGF2YWlsYWJsZSBvciBmb3IgYW55IG90aGVyIHJlYXNvbiksIHRoZSByZWNlaXZlciBNQVkgZWl0aGVyIGRpc2NhcmQgb3IgYnVmZmVyIHRoZSBwYWNrZXQgZm9yIGxhdGVyIHByb2Nlc3NpbmcgYW5kIE1VU1QgYXR0ZW1wdCB0byBwcm9jZXNzIHRoZSByZW1haW5pbmcgcGFja2V0cy4gUmV0cnkgcGFja2V0cyAoU2VjdGlvbiAxNy4yLjUpLCBWZXJzaW9uIE5lZ290aWF0aW9uIHBhY2tldHMgKFNlY3Rpb24gMTcuMi4xKSwgYW5kIHBhY2tldHMgd2l0aCBhIHNob3J0IGhlYWRlciAoU2VjdGlvbiAxNy4zKSBkbyBub3QgY29udGFpbiBhIExlbmd0aCBmaWVsZCBhbmQgc28gY2Fubm90IGJlIGZvbGxvd2VkIGJ5IG90aGVyIHBhY2tldHMgaW4gdGhlIHNhbWUgVURQIGRhdGFncmFtLiBOb3RlIGFsc28gdGhhdCB0aGVyZSBpcyBubyBzaXR1YXRpb24gd2hlcmUgYSBSZXRyeSBvciBWZXJzaW9uIE5lZ290aWF0aW9uIHBhY2tldCBpcyBjb2FsZXNjZWQgd2l0aCBhbm90aGVyIHBhY2tldC4gMTIuMy4gUGFja2V0IE51bWJlcnMgVGhlIHBhY2tldCBudW1iZXIgaXMgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2UgMCB0byAyXjYyLTEuIFRoaXMgbnVtYmVyIGlzIHVzZWQgaW4gZGV0ZXJtaW5pbmcgdGhlIGNyeXB0b2dyYXBoaWMgbm9uY2UgZm9yIHBhY2tldCBwcm90ZWN0aW9uLiBFYWNoIGVuZHBvaW50IG1haW50YWlucyBhIHNlcGFyYXRlIHBhY2tldCBudW1iZXIgZm9yIHNlbmRpbmcgYW5kIHJlY2VpdmluZy4gUGFja2V0IG51bWJlcnMgYXJlIGxpbWl0ZWQgdG8gdGhpcyByYW5nZSBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSByZXByZXNlbnRhYmxlIGluIHdob2xlIGluIHRoZSBMYXJnZXN0IEFja25vd2xlZGdlZCBmaWVsZCBvZiBhbiBBQ0sgZnJhbWUgKFNlY3Rpb24gMTkuMykuIFdoZW4gcHJlc2VudCBpbiBhIGxvbmcgb3Igc2hvcnQgaGVhZGVyLCBob3dldmVyLCBwYWNrZXQgbnVtYmVycyBhcmUgcmVkdWNlZCBhbmQgZW5jb2RlZCBpbiAxIHRvIDQgYnl0ZXM7IHNlZSBTZWN0aW9uIDE3LjEuIFZlcnNpb24gTmVnb3RpYXRpb24gKFNlY3Rpb24gMTcuMi4xKSBhbmQgUmV0cnkgKFNlY3Rpb24gMTcuMi41KSBwYWNrZXRzIGRvIG5vdCBpbmNsdWRlIGEgcGFja2V0IG51bWJlci4gUGFja2V0IG51bWJlcnMgYXJlIGRpdmlkZWQgaW50byB0aHJlZSBzcGFjZXMgaW4gUVVJQzogSW5pdGlhbCBzcGFjZTogQWxsIEluaXRpYWwgcGFja2V0cyAoU2VjdGlvbiAxNy4yLjIpIGFyZSBpbiB0aGlzIHNwYWNlLiBIYW5kc2hha2Ugc3BhY2U6IEFsbCBIYW5kc2hha2UgcGFja2V0cyAoU2VjdGlvbiAxNy4yLjQpIGFyZSBpbiB0aGlzIHNwYWNlLiBBcHBsaWNhdGlvbiBkYXRhIHNwYWNlOiBBbGwgMC1SVFQgKFNlY3Rpb24gMTcuMi4zKSBhbmQgMS1SVFQgKFNlY3Rpb24gMTcuMy4xKSBwYWNrZXRzIGFyZSBpbiB0aGlzIHNwYWNlLiBBcyBkZXNjcmliZWQgaW4gW1FVSUMtVExTXSwgZWFjaCBwYWNrZXQgdHlwZSB1c2VzIGRpZmZlcmVudCBwcm90ZWN0aW9uIGtleXMuIENvbmNlcHR1YWxseSwgYSBwYWNrZXQgbnVtYmVyIHNwYWNlIGlzIHRoZSBjb250ZXh0IGluIHdoaWNoIGEgcGFja2V0IGNhbiBiZSBwcm9jZXNzZWQgYW5kIGFja25vd2xlZGdlZC4gSW5pdGlhbCBwYWNrZXRzIGNhbiBvbmx5IGJlIHNlbnQgd2l0aCBJbml0aWFsIHBhY2tldCBwcm90ZWN0aW9uIGtleXMgYW5kIGFja25vd2xlZGdlZCBpbiBwYWNrZXRzIHRoYXQgYXJlIGFsc28gSW5pdGlhbCBwYWNrZXRzLiBTaW1pbGFybHksIEhhbmRzaGFrZSBwYWNrZXRzIGFyZSBzZW50IGF0IHRoZSBIYW5kc2hha2UgZW5jcnlwdGlvbiBsZXZlbCBhbmQgY2FuIG9ubHkgYmUgYWNrbm93bGVkZ2VkIGluIEhhbmRzaGFrZSBwYWNrZXRzLiBUaGlzIGVuZm9yY2VzIGNyeXB0b2dyYXBoaWMgc2VwYXJhdGlvbiBiZXR3ZWVuIHRoZSBkYXRhIHNlbnQgaW4gdGhlIGRpZmZlcmVudCBwYWNrZXQgbnVtYmVyIHNwYWNlcy4gUGFja2V0IG51bWJlcnMgaW4gZWFjaCBzcGFjZSBzdGFydCBhdCBwYWNrZXQgbnVtYmVyIDAuIFN1YnNlcXVlbnQgcGFja2V0cyBzZW50IGluIHRoZSBzYW1lIHBhY2tldCBudW1iZXIgc3BhY2UgTVVTVCBpbmNyZWFzZSB0aGUgcGFja2V0IG51bWJlciBieSBhdCBsZWFzdCBvbmUuIDAtUlRUIGFuZCAxLVJUVCBkYXRhIGV4aXN0IGluIHRoZSBzYW1lIHBhY2tldCBudW1iZXIgc3BhY2UgdG8gbWFrZSBsb3NzIHJlY292ZXJ5IGFsZ29yaXRobXMgZWFzaWVyIHRvIGltcGxlbWVudCBiZXR3ZWVuIHRoZSB0d28gcGFja2V0IHR5cGVzLiBBIFFVSUMgZW5kcG9pbnQgTVVTVCBOT1QgcmV1c2UgYSBwYWNrZXQgbnVtYmVyIHdpdGhpbiB0aGUgc2FtZSBwYWNrZXQgbnVtYmVyIHNwYWNlIGluIG9uZSBjb25uZWN0aW9uLiBJZiB0aGUgcGFja2V0IG51bWJlciBmb3Igc2VuZGluZyByZWFjaGVzIDJeNjItMSwgdGhlIHNlbmRlciBNVVNUIGNsb3NlIHRoZSBjb25uZWN0aW9uIHdpdGhvdXQgc2VuZGluZyBhIENPTk5FQ1RJT05fQ0xPU0UgZnJhbWUgb3IgYW55IGZ1cnRoZXIgcGFja2V0czsgYW4gZW5kcG9pbnQgTUFZIHNlbmQgYSBTdGF0ZWxlc3MgUmVzZXQgKFNlY3Rpb24gMTAuMykgaW4gcmVzcG9uc2UgdG8gZnVydGhlciBwYWNrZXRzIHRoYXQgaXQgcmVjZWl2ZXMuIEEgcmVjZWl2ZXIgTVVTVCBkaXNjYXJkIGEgbmV3bHkgdW5wcm90ZWN0ZWQgcGFja2V0IHVubGVzcyBpdCBpcyBjZXJ0YWluIHRoYXQgaXQgaGFzIG5vdCBwcm9jZXNzZWQgYW5vdGhlciBwYWNrZXQgd2l0aCB0aGUgc2FtZSBwYWNrZXQgbnVtYmVyIGZyb20gdGhlIHNhbWUgcGFja2V0IG51bWJlciBzcGFjZS4gRHVwbGljYXRlIHN1cHByZXNzaW9uIE1VU1QgaGFwcGVuIGFmdGVyIHJlbW92aW5nIHBhY2tldCBwcm90ZWN0aW9uIGZvciB0aGUgcmVhc29ucyBkZXNjcmliZWQgaW4gU2VjdGlvbiA5LjUgb2YgW1FVSUMtVExTXS4gRW5kcG9pbnRzIHRoYXQgdHJhY2sgYWxsIGluZGl2aWR1YWwgcGFja2V0cyBmb3IgdGhlIHB1cnBvc2VzIG9mIGRldGVjdGluZyBkdXBsaWNhdGVzIGFyZSBhdCByaXNrIG9mIGFjY3VtdWxhdGluZyBleGNlc3NpdmUgc3RhdGUuIFRoZSBkYXRhIHJlcXVpcmVkIGZvciBkZXRlY3RpbmcgZHVwbGljYXRlcyBjYW4gYmUgbGltaXRlZCBieSBtYWludGFpbmluZyBhIG1pbmltdW0gcGFja2V0IG51bWJlciBiZWxvdyB3aGljaCBhbGwgcGFja2V0cyBhcmUgaW1tZWRpYXRlbHkgZHJvcHBlZC4gQW55IG1pbmltdW0gbmVlZHMgdG8gYWNjb3VudCBmb3IgbGFyZ2UgdmFyaWF0aW9ucyBpbiByb3VuZC10cmlwIHRpbWUsIHdoaWNoIGluY2x1ZGVzIHRoZSBwb3NzaWJpbGl0eSB0aGF0IGEgcGVlciBtaWdodCBwcm9iZSBuZXR3b3JrIHBhdGhzIHdpdGggbXVjaCBsYXJnZXIgcm91bmQtdHJpcCB0aW1lczsgc2VlIFNlY3Rpb24gOS4gUGFja2V0IG51bWJlciBlbmNvZGluZyBhdCBhIHNlbmRlciBhbmQgZGVjb2RpbmcgYXQgYSByZWNlaXZlciBhcmUgZGVzY3JpYmVkIGluIFNlY3Rpb24gMTcuMS4gMTIuNC4gRnJhbWVzIGFuZCBGcmFtZSBUeXBlcyBUaGUgcGF5bG9hZCBvZiBRVUlDIHBhY2tldHMsIGFmdGVyIHJlbW92aW5nIHBhY2tldCBwcm90ZWN0aW9uLCBjb25zaXN0cyBvZiBhIHNlcXVlbmNlIG9mIGNvbXBsZXRlIGZyYW1lcywgYXMgc2hvd24gaW4gRmlndXJlIDExLiBWZXJzaW9uIE5lZ290aWF0aW9uLCBTdGF0ZWxlc3MgUmVzZXQsIGFuZCBSZXRyeSBwYWNrZXRzIGRvIG5vdCBjb250YWluIGZyYW1lcy4gUGFja2V0IFBheWxvYWQgeyBGcmFtZSAoOC4uKSAuLi4sIH0gRmlndXJlIDExOiBRVUlDIFBheWxvYWQgVGhlIHBheWxvYWQgb2YgYSBwYWNrZXQgdGhhdCBjb250YWlucyBmcmFtZXMgTVVTVCBjb250YWluIGF0IGxlYXN0IG9uZSBmcmFtZSwgYW5kIE1BWSBjb250YWluIG11bHRpcGxlIGZyYW1lcyBhbmQgbXVsdGlwbGUgZnJhbWUgdHlwZXMuIEFuIGVuZHBvaW50IE1VU1QgdHJlYXQgcmVjZWlwdCBvZiBhIHBhY2tldCBjb250YWluaW5nIG5vIGZyYW1lcyBhcyBhIGNvbm5lY3Rpb24gZXJyb3Igb2YgdHlwZSBQUk9UT0NPTF9WSU9MQVRJT04uIEZyYW1lcyBhbHdheXMgZml0IHdpdGhpbiBhIHNpbmdsZSBRVUlDIHBhY2tldCBhbmQgY2Fubm90IHNwYW4gbXVsdGlwbGUgcGFja2V0cy4gRWFjaCBmcmFtZSBiZWdpbnMgd2l0aCBhIEZyYW1lIFR5cGUsIGluZGljYXRpbmcgaXRzIHR5cGUsIGZvbGxvd2VkIGJ5IGFkZGl0aW9uYWwgdHlwZS1kZXBlbmRlbnQgZmllbGRzOiBGcmFtZSB7IEZyYW1lIFR5cGUgKGkpLCBUeXBlLURlcGVuZGVudCBGaWVsZHMgKC4uKSwgfSBGaWd1cmUgMTI6IEdlbmVyaWMgRnJhbWUgTGF5b3V0IFRhYmxlIDMgbGlzdHMgYW5kIHN1bW1hcml6ZXMgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBmcmFtZSB0eXBlIHRoYXQgaXMgZGVmaW5lZCBpbiB0aGlzIHNwZWNpZmljYXRpb24uIEEgZGVzY3JpcHRpb24gb2YgdGhpcyBzdW1tYXJ5IGlzIGluY2x1ZGVkIGFmdGVyIHRoZSB0YWJsZS4gKz09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PSs9PT09PT0rPT09PT09KyB8IFR5cGUgVmFsdWUgfCBGcmFtZSBUeXBlIE5hbWUgfCBEZWZpbml0aW9uIHwgUGt0cyB8IFNwZWMgfCArPT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09Kz09PT09PSs9PT09PT0rIHwgMHgwMCB8IFBBRERJTkcgfCBTZWN0aW9uIDE5LjEgfCBJSDAxIHwgTlAgfCArLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLSstLS0tLS0rIHwgMHgwMSB8IFBJTkcgfCBTZWN0aW9uIDE5LjIgfCBJSDAxIHwgfCArLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLSstLS0tLS0rIHwgMHgwMi0weDAzIHwgQUNLIHwgU2VjdGlvbiAxOS4zIHwgSUhfMSB8IE5DIHwgKy0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0rLS0tLS0tKyB8IDB4MDQgfCBSRVNFVF9TVFJFQU0gfCBTZWN0aW9uIDE5LjQgfCBfXzAxIHwgfCArLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLSstLS0tLS0rIHwgMHgwNSB8IFNUT1BfU0VORElORyB8IFNlY3Rpb24gMTkuNSB8IF9fMDEgfCB8ICstLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tKy0tLS0tLSsgfCAweDA2IHwgQ1JZUFRPIHwgU2VjdGlvbiAxOS42IHwgSUhfMSB8IHwgKy0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0rLS0tLS0tKyB8IDB4MDcgfCBORVdfVE9LRU4gfCBTZWN0aW9uIDE5LjcgfCBfX18xIHwgfCArLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLSstLS0tLS0rIHwgMHgwOC0weDBmIHwgU1RSRUFNIHwgU2VjdGlvbiAxOS44IHwgX18wMSB8IEYgfCArLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLSstLS0tLS0rIHwgMHgxMCB8IE1BWF9EQVRBIHwgU2VjdGlvbiAxOS45IHwgX18wMSB8IHwgKy0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0rLS0tLS0tKyB8IDB4MTEgfCBNQVhfU1RSRUFNX0RBVEEgfCBTZWN0aW9uIDE5LjEwIHwgX18wMSB8IHwgKy0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0rLS0tLS0tKyB8IDB4MTItMHgxMyB8IE1BWF9TVFJFQU1TIHwgU2VjdGlvbiAxOS4xMSB8IF9fMDEgfCB8ICstLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tKy0tLS0tLSsgfCAweDE0IHwgREFUQV9CTE9DS0VEIHwgU2VjdGlvbiAxOS4xMiB8IF9fMDEgfCB8ICstLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tKy0tLS0tLSsgfCAweDE1IHwgU1RSRUFNX0RBVEFfQkxPQ0tFRCB8IFNlY3Rpb24gMTkuMTMgfCBfXzAxIHwgfCArLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLSstLS0tLS0rIHwgMHgxNi0weDE3IHwgU1RSRUFNU19CTE9DS0VEIHwgU2VjdGlvbiAxOS4xNCB8IF9fMDEgfCB8ICstLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tKy0tLS0tLSsgfCAweDE4IHwgTkVXX0NPTk5FQ1RJT05fSUQgfCBTZWN0aW9uIDE5LjE1IHwgX18wMSB8IFAgfCArLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLSstLS0tLS0rIHwgMHgxOSB8IFJFVElSRV9DT05ORUNUSU9OX0lEIHwgU2VjdGlvbiAxOS4xNiB8IF9fMDEgfCB8ICstLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tKy0tLS0tLSsgfCAweDFhIHwgUEFUSF9DSEFMTEVOR0UgfCBTZWN0aW9uIDE5LjE3IHwgX18wMSB8IFAgfCArLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLSstLS0tLS0rIHwgMHgxYiB8IFBBVEhfUkVTUE9OU0UgfCBTZWN0aW9uIDE5LjE4IHwgX19fMSB8IFAgfCArLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLSstLS0tLS0rIHwgMHgxYy0weDFkIHwgQ09OTkVDVElPTl9DTE9TRSB8IFNlY3Rpb24gMTkuMTkgfCBpaDAxIHwgTiB8ICstLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tKy0tLS0tLSsgfCAweDFlIHwgSEFORFNIQUtFX0RPTkUgfCBTZWN0aW9uIDE5LjIwIHwgX19fMSB8IHwgKy0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0rLS0tLS0tKyBUYWJsZSAzOiBGcmFtZSBUeXBlcyBUaGUgZm9ybWF0IGFuZCBzZW1hbnRpY3Mgb2YgZWFjaCBmcmFtZSB0eXBlIGFyZSBleHBsYWluZWQgaW4gbW9yZSBkZXRhaWwgaW4gU2VjdGlvbiAxOS4gVGhlIHJlbWFpbmRlciBvZiB0aGlzIHNlY3Rpb24gcHJvdmlkZXMgYSBzdW1tYXJ5IG9mIGltcG9ydGFudCBhbmQgZ2VuZXJhbCBpbmZvcm1hdGlvbi4gVGhlIEZyYW1lIFR5cGUgaW4gQUNLLCBTVFJFQU0sIE1BWF9TVFJFQU1TLCBTVFJFQU1TX0JMT0NLRUQsIGFuZCBDT05ORUNUSU9OX0NMT1NFIGZyYW1lcyBpcyB1c2VkIHRvIGNhcnJ5IG90aGVyIGZyYW1lLXNwZWNpZmljIGZsYWdzLiBGb3IgYWxsIG90aGVyIGZyYW1lcywgdGhlIEZyYW1lIFR5cGUgZmllbGQgc2ltcGx5IGlkZW50aWZpZXMgdGhlIGZyYW1lLiBUaGUgIlBrdHMiIGNvbHVtbiBpbiBUYWJsZSAzIGxpc3RzIHRoZSB0eXBlcyBvZiBwYWNrZXRzIHRoYXQgZWFjaCBmcmFtZSB0eXBlIGNvdWxkIGFwcGVhciBpbiwgaW5kaWNhdGVkIGJ5IHRoZSBmb2xsb3dpbmcgY2hhcmFjdGVyczogSTogSW5pdGlhbCAoU2VjdGlvbiAxNy4yLjIpIEg6IEhhbmRzaGFrZSAoU2VjdGlvbiAxNy4yLjQpIDA6IDAtUlRUIChTZWN0aW9uIDE3LjIuMykgMTogMS1SVFQgKFNlY3Rpb24gMTcuMy4xKSBpaDogT25seSBhIENPTk5FQ1RJT05fQ0xPU0UgZnJhbWUgb2YgdHlwZSAweDFjIGNhbiBhcHBlYXIgaW4gSW5pdGlhbCBvciBIYW5kc2hha2UgcGFja2V0cy4gRm9yIG1vcmUgZGV0YWlscyBhYm91dCB0aGVzZSByZXN0cmljdGlvbnMsIHNlZSBTZWN0aW9uIDEyLjUuIE5vdGUgdGhhdCBhbGwgZnJhbWVzIGNhbiBhcHBlYXIgaW4gMS1SVFQgcGFja2V0cy4gQW4gZW5kcG9pbnQgTVVTVCB0cmVhdCByZWNlaXB0IG9mIGEgZnJhbWUgaW4gYSBwYWNrZXQgdHlwZSB0aGF0IGlzIG5vdCBwZXJtaXR0ZWQgYXMgYSBjb25uZWN0aW9uIGVycm9yIG9mIHR5cGUgUFJPVE9DT0xfVklPTEFUSU9OLiBUaGUgIlNwZWMiIGNvbHVtbiBpbiBUYWJsZSAzIHN1bW1hcml6ZXMgYW55IHNwZWNpYWwgcnVsZXMgZ292ZXJuaW5nIHRoZSBwcm9jZXNzaW5nIG9yIGdlbmVyYXRpb24gb2YgdGhlIGZyYW1lIHR5cGUsIGFzIGluZGljYXRlZCBieSB0aGUgZm9sbG93aW5nIGNoYXJhY3RlcnM6IE46IFBhY2tldHMgY29udGFpbmluZyBvbmx5IGZyYW1lcyB3aXRoIHRoaXMgbWFya2luZyBhcmUgbm90IGFjay0gZWxpY2l0aW5nOyBzZWUgU2VjdGlvbiAxMy4yLiBDOiBQYWNrZXRzIGNvbnRhaW5pbmcgb25seSBmcmFtZXMgd2l0aCB0aGlzIG1hcmtpbmcgZG8gbm90IGNvdW50IHRvd2FyZCBieXRlcyBpbiBmbGlnaHQgZm9yIGNvbmdlc3Rpb24gY29udHJvbCBwdXJwb3Nlczsgc2VlIFtRVUlDLVJFQ09WRVJZXS4gUDogUGFja2V0cyBjb250YWluaW5nIG9ubHkgZnJhbWVzIHdpdGggdGhpcyBtYXJraW5nIGNhbiBiZSB1c2VkIHRvIHByb2JlIG5ldyBuZXR3b3JrIHBhdGhzIGR1cmluZyBjb25uZWN0aW9uIG1pZ3JhdGlvbjsgc2VlIFNlY3Rpb24gOS4xLiBGOiBUaGUgY29udGVudHMgb2YgZnJhbWVzIHdpdGggdGhpcyBtYXJraW5nIGFyZSBmbG93IGNvbnRyb2xsZWQ7IHNlZSBTZWN0aW9uIDQuIFRoZSAiUGt0cyIgYW5kICJTcGVjIiBjb2x1bW5zIGluIFRhYmxlIDMgZG8gbm90IGZvcm0gcGFydCBvZiB0aGUgSUFOQSByZWdpc3RyeTsgc2VlIFNlY3Rpb24gMjIuNC4gQW4gZW5kcG9pbnQgTVVTVCB0cmVhdCB0aGUgcmVjZWlwdCBvZiBhIGZyYW1lIG9mIHVua25vd24gdHlwZSBhcyBhIGNvbm5lY3Rpb24gZXJyb3Igb2YgdHlwZSBGUkFNRV9FTkNPRElOR19FUlJPUi4gQWxsIGZyYW1lcyBhcmUgaWRlbXBvdGVudCBpbiB0aGlzIHZlcnNpb24gb2YgUVVJQy4gVGhhdCBpcywgYSB2YWxpZCBmcmFtZSBkb2VzIG5vdCBjYXVzZSB1bmRlc2lyYWJsZSBzaWRlIGVmZmVjdHMgb3IgZXJyb3JzIHdoZW4gcmVjZWl2ZWQgbW9yZSB0aGFuIG9uY2UuIFRoZSBGcmFtZSBUeXBlIGZpZWxkIHVzZXMgYSB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBlbmNvZGluZyAoc2VlIFNlY3Rpb24gMTYpLCB3aXRoIG9uZSBleGNlcHRpb24uIFRvIGVuc3VyZSBzaW1wbGUgYW5kIGVmZmljaWVudCBpbXBsZW1lbnRhdGlvbnMgb2YgZnJhbWUgcGFyc2luZywgYSBmcmFtZSB0eXBlIE1VU1QgdXNlIHRoZSBzaG9ydGVzdCBwb3NzaWJsZSBlbmNvZGluZy4gRm9yIGZyYW1lIHR5cGVzIGRlZmluZWQgaW4gdGhpcyBkb2N1bWVudCwgdGhpcyBtZWFucyBhIHNpbmdsZS1ieXRlIGVuY29kaW5nLCBldmVuIHRob3VnaCBpdCBpcyBwb3NzaWJsZSB0byBlbmNvZGUgdGhlc2UgdmFsdWVzIGFzIGEgdHdvLSwgZm91ci0sIG9yIGVpZ2h0LWJ5dGUgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuIEZvciBpbnN0YW5jZSwgdGhvdWdoIDB4NDAwMSBpcyBhIGxlZ2l0aW1hdGUgdHdvLWJ5dGUgZW5jb2RpbmcgZm9yIGEgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgd2l0aCBhIHZhbHVlIG9mIDEsIFBJTkcgZnJhbWVzIGFyZSBhbHdheXMgZW5jb2RlZCBhcyBhIHNpbmdsZSBieXRlIHdpdGggdGhlIHZhbHVlIDB4MDEuIFRoaXMgcnVsZSBhcHBsaWVzIHRvIGFsbCBjdXJyZW50IGFuZCBmdXR1cmUgUVVJQyBmcmFtZSB0eXBlcy4gQW4gZW5kcG9pbnQgTUFZIHRyZWF0IHRoZSByZWNlaXB0IG9mIGEgZnJhbWUgdHlwZSB0aGF0IHVzZXMgYSBsb25nZXIgZW5jb2RpbmcgdGhhbiBuZWNlc3NhcnkgYXMgYSBjb25uZWN0aW9uIGVycm9yIG9mIHR5cGUgUFJPVE9DT0xfVklPTEFUSU9OLiAxMi41LiBGcmFtZXMgYW5kIE51bWJlciBTcGFjZXMgU29tZSBmcmFtZXMgYXJlIHByb2hpYml0ZWQgaW4gZGlmZmVyZW50IHBhY2tldCBudW1iZXIgc3BhY2VzLiBUaGUgcnVsZXMgaGVyZSBnZW5lcmFsaXplIHRob3NlIG9mIFRMUywgaW4gdGhhdCBmcmFtZXMgYXNzb2NpYXRlZCB3aXRoIGVzdGFibGlzaGluZyB0aGUgY29ubmVjdGlvbiBjYW4gdXN1YWxseSBhcHBlYXIgaW4gcGFja2V0cyBpbiBhbnkgcGFja2V0IG51bWJlciBzcGFjZSwgd2hlcmVhcyB0aG9zZSBhc3NvY2lhdGVkIHdpdGggdHJhbnNmZXJyaW5nIGRhdGEgY2FuIG9ubHkgYXBwZWFyIGluIHRoZSBhcHBsaWNhdGlvbiBkYXRhIHBhY2tldCBudW1iZXIgc3BhY2U6ICogUEFERElORywgUElORywgYW5kIENSWVBUTyBmcmFtZXMgTUFZIGFwcGVhciBpbiBhbnkgcGFja2V0IG51bWJlciBzcGFjZS4gKiBDT05ORUNUSU9OX0NMT1NFIGZyYW1lcyBzaWduYWxpbmcgZXJyb3JzIGF0IHRoZSBRVUlDIGxheWVyICh0eXBlIDB4MWMpIE1BWSBhcHBlYXIgaW4gYW55IHBhY2tldCBudW1iZXIgc3BhY2UuIENPTk5FQ1RJT05fQ0xPU0UgZnJhbWVzIHNpZ25hbGluZyBhcHBsaWNhdGlvbiBlcnJvcnMgKHR5cGUgMHgxZCkgTVVTVCBvbmx5IGFwcGVhciBpbiB0aGUgYXBwbGljYXRpb24gZGF0YSBwYWNrZXQgbnVtYmVyIHNwYWNlLiAqIEFDSyBmcmFtZXMgTUFZIGFwcGVhciBpbiBhbnkgcGFja2V0IG51bWJlciBzcGFjZSBidXQgY2FuIG9ubHkgYWNrbm93bGVkZ2UgcGFja2V0cyB0aGF0IGFwcGVhcmVkIGluIHRoYXQgcGFja2V0IG51bWJlciBzcGFjZS4gSG93ZXZlciwgYXMgbm90ZWQgYmVsb3csIDAtUlRUIHBhY2tldHMgY2Fubm90IGNvbnRhaW4gQUNLIGZyYW1lcy4gKiBBbGwgb3RoZXIgZnJhbWUgdHlwZXMgTVVTVCBvbmx5IGJlIHNlbnQgaW4gdGhlIGFwcGxpY2F0aW9uIGRhdGEgcGFja2V0IG51bWJlciBzcGFjZS4gTm90ZSB0aGF0IGl0IGlzIG5vdCBwb3NzaWJsZSB0byBzZW5kIHRoZSBmb2xsb3dpbmcgZnJhbWVzIGluIDAtUlRUIHBhY2tldHMgZm9yIHZhcmlvdXMgcmVhc29uczogQUNLLCBDUllQVE8sIEhBTkRTSEFLRV9ET05FLCBORVdfVE9LRU4sIFBBVEhfUkVTUE9OU0UsIGFuZCBSRVRJUkVfQ09OTkVDVElPTl9JRC4gQSBzZXJ2ZXIgTUFZIHRyZWF0IHJlY2VpcHQgb2YgdGhlc2UgZnJhbWVzIGluIDAtUlRUIHBhY2tldHMgYXMgYSBjb25uZWN0aW9uIGVycm9yIG9mIHR5cGUgUFJPVE9DT0xfVklPTEFUSU9OLiAxMy4gUGFja2V0aXphdGlvbiBhbmQgUmVsaWFiaWxpdHkgQSBzZW5kZXIgc2VuZHMgb25lIG9yIG1vcmUgZnJhbWVzIGluIGEgUVVJQyBwYWNrZXQ7IHNlZSBTZWN0aW9uIDEyLjQuIEEgc2VuZGVyIGNhbiBtaW5pbWl6ZSBwZXItcGFja2V0IGJhbmR3aWR0aCBhbmQgY29tcHV0YXRpb25hbCBjb3N0cyBieSBpbmNsdWRpbmcgYXMgbWFueSBmcmFtZXMgYXMgcG9zc2libGUgaW4gZWFjaCBRVUlDIHBhY2tldC4gQSBzZW5kZXIgTUFZIHdhaXQgZm9yIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgdG8gY29sbGVjdCBtdWx0aXBsZSBmcmFtZXMgYmVmb3JlIHNlbmRpbmcgYSBwYWNrZXQgdGhhdCBpcyBub3QgbWF4aW1hbGx5IHBhY2tlZCwgdG8gYXZvaWQgc2VuZGluZyBvdXQgbGFyZ2UgbnVtYmVycyBvZiBzbWFsbCBwYWNrZXRzLiBBbiBpbXBsZW1lbnRhdGlvbiBNQVkgdXNlIGtub3dsZWRnZSBhYm91dCBhcHBsaWNhdGlvbiBzZW5kaW5nIGJlaGF2aW9yIG9yIGhldXJpc3RpY3MgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYW5kIGZvciBob3cgbG9uZyB0byB3YWl0LiBUaGlzIHdhaXRpbmcgcGVyaW9kIGlzIGFuIGltcGxlbWVudGF0aW9uIGRlY2lzaW9uLCBhbmQgYW4gaW1wbGVtZW50YXRpb24gc2hvdWxkIGJlIGNhcmVmdWwgdG8gZGVsYXkgY29uc2VydmF0aXZlbHksIHNpbmNlIGFueSBkZWxheSBpcyBsaWtlbHkgdG8gaW5jcmVhc2UgYXBwbGljYXRpb24tIHZpc2libGUgbGF0ZW5jeS4gU3RyZWFtIG11bHRpcGxleGluZyBpcyBhY2hpZXZlZCBieSBpbnRlcmxlYXZpbmcgU1RSRUFNIGZyYW1lcyBmcm9tIG11bHRpcGxlIHN0cmVhbXMgaW50byBvbmUgb3IgbW9yZSBRVUlDIHBhY2tldHMuIEEgc2luZ2xlIFFVSUMgcGFja2V0IGNhbiBpbmNsdWRlIG11bHRpcGxlIFNUUkVBTSBmcmFtZXMgZnJvbSBvbmUgb3IgbW9yZSBzdHJlYW1zLiBPbmUgb2YgdGhlIGJlbmVmaXRzIG9mIFFVSUMgaXMgYXZvaWRhbmNlIG9mIGhlYWQtb2YtbGluZSBibG9ja2luZyBhY3Jvc3MgbXVsdGlwbGUgc3RyZWFtcy4gV2hlbiBhIHBhY2tldCBsb3NzIG9jY3Vycywgb25seSBzdHJlYW1zIHdpdGggZGF0YSBpbiB0aGF0IHBhY2tldCBhcmUgYmxvY2tlZCB3YWl0aW5nIGZvciBhIHJldHJhbnNtaXNzaW9uIHRvIGJlIHJlY2VpdmVkLCB3aGlsZSBvdGhlciBzdHJlYW1zIGNhbiBjb250aW51ZSBtYWtpbmcgcHJvZ3Jlc3MuIE5vdGUgdGhhdCB3aGVuIGRhdGEgZnJvbSBtdWx0aXBsZSBzdHJlYW1zIGlzIGluY2x1ZGVkIGluIGEgc2luZ2xlIFFVSUMgcGFja2V0LCBsb3NzIG9mIHRoYXQgcGFja2V0IGJsb2NrcyBhbGwgdGhvc2Ugc3RyZWFtcyBmcm9tIG1ha2luZyBwcm9ncmVzcy4gSW1wbGVtZW50YXRpb25zIGFyZSBhZHZpc2VkIHRvIGluY2x1ZGUgYXMgZmV3IHN0cmVhbXMgYXMgbmVjZXNzYXJ5IGluIG91dGdvaW5nIHBhY2tldHMgd2l0aG91dCBsb3NpbmcgdHJhbnNtaXNzaW9uIGVmZmljaWVuY3kgdG8gdW5kZXJmaWxsZWQgcGFja2V0cy4gMTMuMS4gUGFja2V0IFByb2Nlc3NpbmcgQSBwYWNrZXQgTVVTVCBOT1QgYmUgYWNrbm93bGVkZ2VkIHVudGlsIHBhY2tldCBwcm90ZWN0aW9uIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSByZW1vdmVkIGFuZCBhbGwgZnJhbWVzIGNvbnRhaW5lZCBpbiB0aGUgcGFja2V0IGhhdmUgYmVlbiBwcm9jZXNzZWQuIEZvciBTVFJFQU0gZnJhbWVzLCB0aGlzIG1lYW5zIHRoZSBkYXRhIGhhcyBiZWVuIGVucXVldWVkIGluIHByZXBhcmF0aW9uIHRvIGJlIHJlY2VpdmVkIGJ5IHRoZSBhcHBsaWNhdGlvbiBwcm90b2NvbCwgYnV0IGl0IGRvZXMgbm90IHJlcXVpcmUgdGhhdCBkYXRhIGJlIGRlbGl2ZXJlZCBhbmQgY29uc3VtZWQuIE9uY2UgdGhlIHBhY2tldCBoYXMgYmVlbiBmdWxseSBwcm9jZXNzZWQsIGEgcmVjZWl2ZXIgYWNrbm93bGVkZ2VzIHJlY2VpcHQgYnkgc2VuZGluZyBvbmUgb3IgbW9yZSBBQ0sgZnJhbWVzIGNvbnRhaW5pbmcgdGhlIHBhY2tldCBudW1iZXIgb2YgdGhlIHJlY2VpdmVkIHBhY2tldC4gQW4gZW5kcG9pbnQgU0hPVUxEIHRyZWF0IHJlY2VpcHQgb2YgYW4gYWNrbm93bGVkZ21lbnQgZm9yIGEgcGFja2V0IGl0IGRpZCBub3Qgc2VuZCBhcyBhIGNvbm5lY3Rpb24gZXJyb3Igb2YgdHlwZSBQUk9UT0NPTF9WSU9MQVRJT04sIGlmIGl0IGlzIGFibGUgdG8gZGV0ZWN0IHRoZSBjb25kaXRpb24uIEZvciBmdXJ0aGVyIGRpc2N1c3Npb24gb2YgaG93IHRoaXMgbWlnaHQgYmUgYWNoaWV2ZWQsIHNlZSBTZWN0aW9uIDIxLjQuIDEzLjIuIEdlbmVyYXRpbmcgQWNrbm93bGVkZ21lbnRzIEVuZHBvaW50cyBhY2tub3dsZWRnZSBhbGwgcGFja2V0cyB0aGV5IHJlY2VpdmUgYW5kIHByb2Nlc3MuIEhvd2V2ZXIsIG9ubHkgYWNrLWVsaWNpdGluZyBwYWNrZXRzIGNhdXNlIGFuIEFDSyBmcmFtZSB0byBiZSBzZW50IHdpdGhpbiB0aGUgbWF4aW11bSBhY2sgZGVsYXkuIFBhY2tldHMgdGhhdCBhcmUgbm90IGFjay1lbGljaXRpbmcgYXJlIG9ubHkgYWNrbm93bGVkZ2VkIHdoZW4gYW4gQUNLIGZyYW1lIGlzIHNlbnQgZm9yIG90aGVyIHJlYXNvbnMuIFdoZW4gc2VuZGluZyBhIHBhY2tldCBmb3IgYW55IHJlYXNvbiwgYW4gZW5kcG9pbnQgU0hPVUxEIGF0dGVtcHQgdG8gaW5jbHVkZSBhbiBBQ0sgZnJhbWUgaWYgb25lIGhhcyBub3QgYmVlbiBzZW50IHJlY2VudGx5LiBEb2luZyBzbyBoZWxwcyB3aXRoIHRpbWVseSBsb3NzIGRldGVjdGlvbiBhdCB0aGUgcGVlci4gSW4gZ2VuZXJhbCwgZnJlcXVlbnQgZmVlZGJhY2sgZnJvbSBhIHJlY2VpdmVyIGltcHJvdmVzIGxvc3MgYW5kIGNvbmdlc3Rpb24gcmVzcG9uc2UsIGJ1dCB0aGlzIGhhcyB0byBiZSBiYWxhbmNlZCBhZ2FpbnN0IGV4Y2Vzc2l2ZSBsb2FkIGdlbmVyYXRlZCBieSBhIHJlY2VpdmVyIHRoYXQgc2VuZHMgYW4gQUNLIGZyYW1lIGluIHJlc3BvbnNlIHRvIGV2ZXJ5IGFjay1lbGljaXRpbmcgcGFja2V0LiBUaGUgZ3VpZGFuY2Ugb2ZmZXJlZCBiZWxvdyBzZWVrcyB0byBzdHJpa2UgdGhpcyBiYWxhbmNlLiAxMy4yLjEuIFNlbmRpbmcgQUNLIEZyYW1lcyBFdmVyeSBwYWNrZXQgU0hPVUxEIGJlIGFja25vd2xlZGdlZCBhdCBsZWFzdCBvbmNlLCBhbmQgYWNrLWVsaWNpdGluZyBwYWNrZXRzIE1VU1QgYmUgYWNrbm93bGVkZ2VkIGF0IGxlYXN0IG9uY2Ugd2l0aGluIHRoZSBtYXhpbXVtIGRlbGF5IGFuIGVuZHBvaW50IGNvbW11bmljYXRlZCB1c2luZyB0aGUgbWF4X2Fja19kZWxheSB0cmFuc3BvcnQgcGFyYW1ldGVyOyBzZWUgU2VjdGlvbiAxOC4yLiBtYXhfYWNrX2RlbGF5IGRlY2xhcmVzIGFuIGV4cGxpY2l0IGNvbnRyYWN0OiBhbiBlbmRwb2ludCBwcm9taXNlcyB0byBuZXZlciBpbnRlbnRpb25hbGx5IGRlbGF5IGFja25vd2xlZGdtZW50cyBvZiBhbiBhY2stZWxpY2l0aW5nIHBhY2tldCBieSBtb3JlIHRoYW4gdGhlIGluZGljYXRlZCB2YWx1ZS4gSWYgaXQgZG9lcywgYW55IGV4Y2VzcyBhY2NydWVzIHRvIHRoZSBSVFQgZXN0aW1hdGUgYW5kIGNvdWxkIHJlc3VsdCBpbiBzcHVyaW91cyBvciBkZWxheWVkIHJldHJhbnNtaXNzaW9ucyBmcm9tIHRoZSBwZWVyLiBBIHNlbmRlciB1c2VzIHRoZSByZWNlaXZlcidzIG1heF9hY2tfZGVsYXkgdmFsdWUgaW4gZGV0ZXJtaW5pbmcgdGltZW91dHMgZm9yIHRpbWVyLSBiYXNlZCByZXRyYW5zbWlzc2lvbiwgYXMgZGV0YWlsZWQgaW4gU2VjdGlvbiA2LjIgb2YgW1FVSUMtUkVDT1ZFUlldLiBBbiBlbmRwb2ludCBNVVNUIGFja25vd2xlZGdlIGFsbCBhY2stZWxpY2l0aW5nIEluaXRpYWwgYW5kIEhhbmRzaGFrZSBwYWNrZXRzIGltbWVkaWF0ZWx5IGFuZCBhbGwgYWNrLWVsaWNpdGluZyAwLVJUVCBhbmQgMS1SVFQgcGFja2V0cyB3aXRoaW4gaXRzIGFkdmVydGlzZWQgbWF4X2Fja19kZWxheSwgd2l0aCB0aGUgZm9sbG93aW5nIGV4Y2VwdGlvbi4gUHJpb3IgdG8gaGFuZHNoYWtlIGNvbmZpcm1hdGlvbiwgYW4gZW5kcG9pbnQgbWlnaHQgbm90IGhhdmUgcGFja2V0IHByb3RlY3Rpb24ga2V5cyBmb3IgZGVjcnlwdGluZyBIYW5kc2hha2UsIDAtUlRULCBvciAxLVJUVCBwYWNrZXRzIHdoZW4gdGhleSBhcmUgcmVjZWl2ZWQuIEl0IG1pZ2h0IHRoZXJlZm9yZSBidWZmZXIgdGhlbSBhbmQgYWNrbm93bGVkZ2UgdGhlbSB3aGVuIHRoZSByZXF1aXNpdGUga2V5cyBiZWNvbWUgYXZhaWxhYmxlLiBTaW5jZSBwYWNrZXRzIGNvbnRhaW5pbmcgb25seSBBQ0sgZnJhbWVzIGFyZSBub3QgY29uZ2VzdGlvbiBjb250cm9sbGVkLCBhbiBlbmRwb2ludCBNVVNUIE5PVCBzZW5kIG1vcmUgdGhhbiBvbmUgc3VjaCBwYWNrZXQgaW4gcmVzcG9uc2UgdG8gcmVjZWl2aW5nIGFuIGFjay1lbGljaXRpbmcgcGFja2V0LiBBbiBlbmRwb2ludCBNVVNUIE5PVCBzZW5kIGEgbm9uLWFjay1lbGljaXRpbmcgcGFja2V0IGluIHJlc3BvbnNlIHRvIGEgbm9uLWFjay1lbGljaXRpbmcgcGFja2V0LCBldmVuIGlmIHRoZXJlIGFyZSBwYWNrZXQgZ2FwcyB0aGF0IHByZWNlZGUgdGhlIHJlY2VpdmVkIHBhY2tldC4gVGhpcyBhdm9pZHMgYW4gaW5maW5pdGUgZmVlZGJhY2sgbG9vcCBvZiBhY2tub3dsZWRnbWVudHMsIHdoaWNoIGNvdWxkIHByZXZlbnQgdGhlIGNvbm5lY3Rpb24gZnJvbSBldmVyIGJlY29taW5nIGlkbGUuIE5vbi1hY2stZWxpY2l0aW5nIHBhY2tldHMgYXJlIGV2ZW50dWFsbHkgYWNrbm93bGVkZ2VkIHdoZW4gdGhlIGVuZHBvaW50IHNlbmRzIGFuIEFDSyBmcmFtZSBpbiByZXNwb25zZSB0byBvdGhlciBldmVudHMuIEFuIGVuZHBvaW50IHRoYXQgaXMgb25seSBzZW5kaW5nIEFDSyBmcmFtZXMgd2lsbCBub3QgcmVjZWl2ZSBhY2tub3dsZWRnbWVudHMgZnJvbSBpdHMgcGVlciB1bmxlc3MgdGhvc2UgYWNrbm93bGVkZ21lbnRzIGFyZSBpbmNsdWRlZCBpbiBwYWNrZXRzIHdpdGggYWNrLWVsaWNpdGluZyBmcmFtZXMuIEFuIGVuZHBvaW50IFNIT1VMRCBzZW5kIGFuIEFDSyBmcmFtZSB3aXRoIG90aGVyIGZyYW1lcyB3aGVuIHRoZXJlIGFyZSBuZXcgYWNrLWVsaWNpdGluZyBwYWNrZXRzIHRvIGFja25vd2xlZGdlLiBXaGVuIG9ubHkgbm9uLWFjay1lbGljaXRpbmcgcGFja2V0cyBuZWVkIHRvIGJlIGFja25vd2xlZGdlZCwgYW4gZW5kcG9pbnQgTUFZIGNob29zZSBub3QgdG8gc2VuZCBhbiBBQ0sgZnJhbWUgd2l0aCBvdXRnb2luZyBmcmFtZXMgdW50aWwgYW4gYWNrLWVsaWNpdGluZyBwYWNrZXQgaGFzIGJlZW4gcmVjZWl2ZWQuIEFuIGVuZHBvaW50IHRoYXQgaXMgb25seSBzZW5kaW5nIG5vbi1hY2stZWxpY2l0aW5nIHBhY2tldHMgbWlnaHQgY2hvb3NlIHRvIG9jY2FzaW9uYWxseSBhZGQgYW4gYWNrLWVsaWNpdGluZyBmcmFtZSB0byB0aG9zZSBwYWNrZXRzIHRvIGVuc3VyZSB0aGF0IGl0IHJlY2VpdmVzIGFuIGFja25vd2xlZGdtZW50OyBzZWUgU2VjdGlvbiAxMy4yLjQuIEluIHRoYXQgY2FzZSwgYW4gZW5kcG9pbnQgTVVTVCBOT1Qgc2VuZCBhbiBhY2stZWxpY2l0aW5nIGZyYW1lIGluIGFsbCBwYWNrZXRzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGJlIG5vbi1hY2stZWxpY2l0aW5nLCB0byBhdm9pZCBhbiBpbmZpbml0ZSBmZWVkYmFjayBsb29wIG9mIGFja25vd2xlZGdtZW50cy4gSW4gb3JkZXIgdG8gYXNzaXN0IGxvc3MgZGV0ZWN0aW9uIGF0IHRoZSBzZW5kZXIsIGFuIGVuZHBvaW50IFNIT1VMRCBnZW5lcmF0ZSBhbmQgc2VuZCBhbiBBQ0sgZnJhbWUgd2l0aG91dCBkZWxheSB3aGVuIGl0IHJlY2VpdmVzIGFuIGFjay0gZWxpY2l0aW5nIHBhY2tldCBlaXRoZXI6ICogd2hlbiB0aGUgcmVjZWl2ZWQgcGFja2V0IGhhcyBhIHBhY2tldCBudW1iZXIgbGVzcyB0aGFuIGFub3RoZXIgYWNrLWVsaWNpdGluZyBwYWNrZXQgdGhhdCBoYXMgYmVlbiByZWNlaXZlZCwgb3IgKiB3aGVuIHRoZSBwYWNrZXQgaGFzIGEgcGFja2V0IG51bWJlciBsYXJnZXIgdGhhbiB0aGUgaGlnaGVzdC0gbnVtYmVyZWQgYWNrLWVsaWNpdGluZyBwYWNrZXQgdGhhdCBoYXMgYmVlbiByZWNlaXZlZCBhbmQgdGhlcmUgYXJlIG1pc3NpbmcgcGFja2V0cyBiZXR3ZWVuIHRoYXQgcGFja2V0IGFuZCB0aGlzIHBhY2tldC4gU2ltaWxhcmx5LCBwYWNrZXRzIG1hcmtlZCB3aXRoIHRoZSBFQ04gQ29uZ2VzdGlvbiBFeHBlcmllbmNlZCAoQ0UpIGNvZGVwb2ludCBpbiB0aGUgSVAgaGVhZGVyIFNIT1VMRCBiZSBhY2tub3dsZWRnZWQgaW1tZWRpYXRlbHksIHRvIHJlZHVjZSB0aGUgcGVlcidzIHJlc3BvbnNlIHRpbWUgdG8gY29uZ2VzdGlvbiBldmVudHMuIFRoZSBhbGdvcml0aG1zIGluIFtRVUlDLVJFQ09WRVJZXSBhcmUgZXhwZWN0ZWQgdG8gYmUgcmVzaWxpZW50IHRvIHJlY2VpdmVycyB0aGF0IGRvIG5vdCBmb2xsb3cgdGhlIGd1aWRhbmNlIG9mZmVyZWQgYWJvdmUuIEhvd2V2ZXIsIGFuIGltcGxlbWVudGF0aW9uIHNob3VsZCBvbmx5IGRldmlhdGUgZnJvbSB0aGVzZSByZXF1aXJlbWVudHMgYWZ0ZXIgY2FyZWZ1bCBjb25zaWRlcmF0aW9uIG9mIHRoZSBwZXJmb3JtYW5jZSBpbXBsaWNhdGlvbnMgb2YgYSBjaGFuZ2UsIGZvciBjb25uZWN0aW9ucyBtYWRlIGJ5IHRoZSBlbmRwb2ludCBhbmQgZm9yIG90aGVyIHVzZXJzIG9mIHRoZSBuZXR3b3JrLiAxMy4yLjIuIEFja25vd2xlZGdtZW50IEZyZXF1ZW5jeSBBIHJlY2VpdmVyIGRldGVybWluZXMgaG93IGZyZXF1ZW50bHkgdG8gc2VuZCBhY2tub3dsZWRnbWVudHMgaW4gcmVzcG9uc2UgdG8gYWNrLWVsaWNpdGluZyBwYWNrZXRzLiBUaGlzIGRldGVybWluYXRpb24gaW52b2x2ZXMgYSB0cmFkZS1vZmYuIEVuZHBvaW50cyByZWx5IG9uIHRpbWVseSBhY2tub3dsZWRnbWVudCB0byBkZXRlY3QgbG9zczsgc2VlIFNlY3Rpb24gNiBvZiBbUVVJQy1SRUNPVkVSWV0uIFdpbmRvdy1iYXNlZCBjb25nZXN0aW9uIGNvbnRyb2xsZXJzLCBzdWNoIGFzIHRoZSBvbmUgZGVzY3JpYmVkIGluIFNlY3Rpb24gNyBvZiBbUVVJQy1SRUNPVkVSWV0sIHJlbHkgb24gYWNrbm93bGVkZ21lbnRzIHRvIG1hbmFnZSB0aGVpciBjb25nZXN0aW9uIHdpbmRvdy4gSW4gYm90aCBjYXNlcywgZGVsYXlpbmcgYWNrbm93bGVkZ21lbnRzIGNhbiBhZHZlcnNlbHkgYWZmZWN0IHBlcmZvcm1hbmNlLiBPbiB0aGUgb3RoZXIgaGFuZCwgcmVkdWNpbmcgdGhlIGZyZXF1ZW5jeSBvZiBwYWNrZXRzIHRoYXQgY2Fycnkgb25seSBhY2tub3dsZWRnbWVudHMgcmVkdWNlcyBwYWNrZXQgdHJhbnNtaXNzaW9uIGFuZCBwcm9jZXNzaW5nIGNvc3QgYXQgYm90aCBlbmRwb2ludHMuIEl0IGNhbiBpbXByb3ZlIGNvbm5lY3Rpb24gdGhyb3VnaHB1dCBvbiBzZXZlcmVseSBhc3ltbWV0cmljIGxpbmtzIGFuZCByZWR1Y2UgdGhlIHZvbHVtZSBvZiBhY2tub3dsZWRnbWVudCB0cmFmZmljIHVzaW5nIHJldHVybiBwYXRoIGNhcGFjaXR5OyBzZWUgU2VjdGlvbiAzIG9mIFtSRkMzNDQ5XS4gQSByZWNlaXZlciBTSE9VTEQgc2VuZCBhbiBBQ0sgZnJhbWUgYWZ0ZXIgcmVjZWl2aW5nIGF0IGxlYXN0IHR3byBhY2stIGVsaWNpdGluZyBwYWNrZXRzLiBUaGlzIHJlY29tbWVuZGF0aW9uIGlzIGdlbmVyYWwgaW4gbmF0dXJlIGFuZCBjb25zaXN0ZW50IHdpdGggcmVjb21tZW5kYXRpb25zIGZvciBUQ1AgZW5kcG9pbnQgYmVoYXZpb3IgW1JGQzU2ODFdLiBLbm93bGVkZ2Ugb2YgbmV0d29yayBjb25kaXRpb25zLCBrbm93bGVkZ2Ugb2YgdGhlIHBlZXIncyBjb25nZXN0aW9uIGNvbnRyb2xsZXIsIG9yIGZ1cnRoZXIgcmVzZWFyY2ggYW5kIGV4cGVyaW1lbnRhdGlvbiBtaWdodCBzdWdnZXN0IGFsdGVybmF0aXZlIGFja25vd2xlZGdtZW50IHN0cmF0ZWdpZXMgd2l0aCBiZXR0ZXIgcGVyZm9ybWFuY2UgY2hhcmFjdGVyaXN0aWNzLiBBIHJlY2VpdmVyIE1BWSBwcm9jZXNzIG11bHRpcGxlIGF2YWlsYWJsZSBwYWNrZXRzIGJlZm9yZSBkZXRlcm1pbmluZyB3aGV0aGVyIHRvIHNlbmQgYW4gQUNLIGZyYW1lIGluIHJlc3BvbnNlLiAxMy4yLjMuIE1hbmFnaW5nIEFDSyBSYW5nZXMgV2hlbiBhbiBBQ0sgZnJhbWUgaXMgc2VudCwgb25lIG9yIG1vcmUgcmFuZ2VzIG9mIGFja25vd2xlZGdlZCBwYWNrZXRzIGFyZSBpbmNsdWRlZC4gSW5jbHVkaW5nIGFja25vd2xlZGdtZW50cyBmb3Igb2xkZXIgcGFja2V0cyByZWR1Y2VzIHRoZSBjaGFuY2Ugb2Ygc3B1cmlvdXMgcmV0cmFuc21pc3Npb25zIGNhdXNlZCBieSBsb3NpbmcgcHJldmlvdXNseSBzZW50IEFDSyBmcmFtZXMsIGF0IHRoZSBjb3N0IG9mIGxhcmdlciBBQ0sgZnJhbWVzLiBBQ0sgZnJhbWVzIFNIT1VMRCBhbHdheXMgYWNrbm93bGVkZ2UgdGhlIG1vc3QgcmVjZW50bHkgcmVjZWl2ZWQgcGFja2V0cywgYW5kIHRoZSBtb3JlIG91dCBvZiBvcmRlciB0aGUgcGFja2V0cyBhcmUsIHRoZSBtb3JlIGltcG9ydGFudCBpdCBpcyB0byBzZW5kIGFuIHVwZGF0ZWQgQUNLIGZyYW1lIHF1aWNrbHksIHRvIHByZXZlbnQgdGhlIHBlZXIgZnJvbSBkZWNsYXJpbmcgYSBwYWNrZXQgYXMgbG9zdCBhbmQgc3B1cmlvdXNseSByZXRyYW5zbWl0dGluZyB0aGUgZnJhbWVzIGl0IGNvbnRhaW5zLiBBbiBBQ0sgZnJhbWUgaXMgZXhwZWN0ZWQgdG8gZml0IHdpdGhpbiBhIHNpbmdsZSBRVUlDIHBhY2tldC4gSWYgaXQgZG9lcyBub3QsIHRoZW4gb2xkZXIgcmFuZ2VzICh0aG9zZSB3aXRoIHRoZSBzbWFsbGVzdCBwYWNrZXQgbnVtYmVycykgYXJlIG9taXR0ZWQuIEEgcmVjZWl2ZXIgbGltaXRzIHRoZSBudW1iZXIgb2YgQUNLIFJhbmdlcyAoU2VjdGlvbiAxOS4zLjEpIGl0IHJlbWVtYmVycyBhbmQgc2VuZHMgaW4gQUNLIGZyYW1lcywgYm90aCB0byBsaW1pdCB0aGUgc2l6ZSBvZiBBQ0sgZnJhbWVzIGFuZCB0byBhdm9pZCByZXNvdXJjZSBleGhhdXN0aW9uLiBBZnRlciByZWNlaXZpbmcgYWNrbm93bGVkZ21lbnRzIGZvciBhbiBBQ0sgZnJhbWUsIHRoZSByZWNlaXZlciBTSE9VTEQgc3RvcCB0cmFja2luZyB0aG9zZSBhY2tub3dsZWRnZWQgQUNLIFJhbmdlcy4gU2VuZGVycyBjYW4gZXhwZWN0IGFja25vd2xlZGdtZW50cyBmb3IgbW9zdCBwYWNrZXRzLCBidXQgUVVJQyBkb2VzIG5vdCBndWFyYW50ZWUgcmVjZWlwdCBvZiBhbiBhY2tub3dsZWRnbWVudCBmb3IgZXZlcnkgcGFja2V0IHRoYXQgdGhlIHJlY2VpdmVyIHByb2Nlc3Nlcy4gSXQgaXMgcG9zc2libGUgdGhhdCByZXRhaW5pbmcgbWFueSBBQ0sgUmFuZ2VzIGNvdWxkIGNhdXNlIGFuIEFDSyBmcmFtZSB0byBiZWNvbWUgdG9vIGxhcmdlLiBBIHJlY2VpdmVyIGNhbiBkaXNjYXJkIHVuYWNrbm93bGVkZ2VkIEFDSyBSYW5nZXMgdG8gbGltaXQgQUNLIGZyYW1lIHNpemUsIGF0IHRoZSBjb3N0IG9mIGluY3JlYXNlZCByZXRyYW5zbWlzc2lvbnMgZnJvbSB0aGUgc2VuZGVyLiBUaGlzIGlzIG5lY2Vzc2FyeSBpZiBhbiBBQ0sgZnJhbWUgd291bGQgYmUgdG9vIGxhcmdlIHRvIGZpdCBpbiBhIHBhY2tldC4gUmVjZWl2ZXJzIE1BWSBhbHNvIGxpbWl0IEFDSyBmcmFtZSBzaXplIGZ1cnRoZXIgdG8gcHJlc2VydmUgc3BhY2UgZm9yIG90aGVyIGZyYW1lcyBvciB0byBsaW1pdCB0aGUgY2FwYWNpdHkgdGhhdCBhY2tub3dsZWRnbWVudHMgY29uc3VtZS4gQSByZWNlaXZlciBNVVNUIHJldGFpbiBhbiBBQ0sgUmFuZ2UgdW5sZXNzIGl0IGNhbiBlbnN1cmUgdGhhdCBpdCB3aWxsIG5vdCBzdWJzZXF1ZW50bHkgYWNjZXB0IHBhY2tldHMgd2l0aCBudW1iZXJzIGluIHRoYXQgcmFuZ2UuIE1haW50YWluaW5nIGEgbWluaW11bSBwYWNrZXQgbnVtYmVyIHRoYXQgaW5jcmVhc2VzIGFzIHJhbmdlcyBhcmUgZGlzY2FyZGVkIGlzIG9uZSB3YXkgdG8gYWNoaWV2ZSB0aGlzIHdpdGggbWluaW1hbCBzdGF0ZS4gUmVjZWl2ZXJzIGNhbiBkaXNjYXJkIGFsbCBBQ0sgUmFuZ2VzLCBidXQgdGhleSBNVVNUIHJldGFpbiB0aGUgbGFyZ2VzdCBwYWNrZXQgbnVtYmVyIHRoYXQgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IHByb2Nlc3NlZCwgYXMgdGhhdCBpcyB1c2VkIHRvIHJlY292ZXIgcGFja2V0IG51bWJlcnMgZnJvbSBzdWJzZXF1ZW50IHBhY2tldHM7IHNlZSBTZWN0aW9uIDE3LjEuIEEgcmVjZWl2ZXIgU0hPVUxEIGluY2x1ZGUgYW4gQUNLIFJhbmdlIGNvbnRhaW5pbmcgdGhlIGxhcmdlc3QgcmVjZWl2ZWQgcGFja2V0IG51bWJlciBpbiBldmVyeSBBQ0sgZnJhbWUuIFRoZSBMYXJnZXN0IEFja25vd2xlZGdlZCBmaWVsZCBpcyB1c2VkIGluIEVDTiB2YWxpZGF0aW9uIGF0IGEgc2VuZGVyLCBhbmQgaW5jbHVkaW5nIGEgbG93ZXIgdmFsdWUgdGhhbiB3aGF0IHdhcyBpbmNsdWRlZCBpbiBhIHByZXZpb3VzIEFDSyBmcmFtZSBjb3VsZCBjYXVzZSBFQ04gdG8gYmUgdW5uZWNlc3NhcmlseSBkaXNhYmxlZDsgc2VlIFNlY3Rpb24gMTMuNC4yLiBTZWN0aW9uIDEzLjIuNCBkZXNjcmliZXMgYW4gZXhlbXBsYXJ5IGFwcHJvYWNoIGZvciBkZXRlcm1pbmluZyB3aGF0IHBhY2tldHMgdG8gYWNrbm93bGVkZ2UgaW4gZWFjaCBBQ0sgZnJhbWUuIFRob3VnaCB0aGUgZ29hbCBvZiB0aGlzIGFsZ29yaXRobSBpcyB0byBnZW5lcmF0ZSBhbiBhY2tub3dsZWRnbWVudCBmb3IgZXZlcnkgcGFja2V0IHRoYXQgaXMgcHJvY2Vzc2VkLCBpdCBpcyBzdGlsbCBwb3NzaWJsZSBmb3IgYWNrbm93bGVkZ21lbnRzIHRvIGJlIGxvc3QuIDEzLjIuNC4gTGltaXRpbmcgUmFuZ2VzIGJ5IFRyYWNraW5nIEFDSyBGcmFtZXMgV2hlbiBhIHBhY2tldCBjb250YWluaW5nIGFuIEFDSyBmcmFtZSBpcyBzZW50LCB0aGUgTGFyZ2VzdCBBY2tub3dsZWRnZWQgZmllbGQgaW4gdGhhdCBmcmFtZSBjYW4gYmUgc2F2ZWQuIFdoZW4gYSBwYWNrZXQgY29udGFpbmluZyBhbiBBQ0sgZnJhbWUgaXMgYWNrbm93bGVkZ2VkLCB0aGUgcmVjZWl2ZXIgY2FuIHN0b3AgYWNrbm93bGVkZ2luZyBwYWNrZXRzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgTGFyZ2VzdCBBY2tub3dsZWRnZWQgZmllbGQgaW4gdGhlIHNlbnQgQUNLIGZyYW1lLiBBIHJlY2VpdmVyIHRoYXQgc2VuZHMgb25seSBub24tYWNrLWVsaWNpdGluZyBwYWNrZXRzLCBzdWNoIGFzIEFDSyBmcmFtZXMsIG1pZ2h0IG5vdCByZWNlaXZlIGFuIGFja25vd2xlZGdtZW50IGZvciBhIGxvbmcgcGVyaW9kIG9mIHRpbWUuIFRoaXMgY291bGQgY2F1c2UgdGhlIHJlY2VpdmVyIHRvIG1haW50YWluIHN0YXRlIGZvciBhIGxhcmdlIG51bWJlciBvZiBBQ0sgZnJhbWVzIGZvciBhIGxvbmcgcGVyaW9kIG9mIHRpbWUsIGFuZCBBQ0sgZnJhbWVzIGl0IHNlbmRzIGNvdWxkIGJlIHVubmVjZXNzYXJpbHkgbGFyZ2UuIEluIHN1Y2ggYSBjYXNlLCBhIHJlY2VpdmVyIGNvdWxkIHNlbmQgYSBQSU5HIG9yIG90aGVyIHNtYWxsIGFjay1lbGljaXRpbmcgZnJhbWUgb2NjYXNpb25hbGx5LCBzdWNoIGFzIG9uY2UgcGVyIHJvdW5kIHRyaXAsIHRvIGVsaWNpdCBhbiBBQ0sgZnJvbSB0aGUgcGVlci4gSW4gY2FzZXMgd2l0aG91dCBBQ0sgZnJhbWUgbG9zcywgdGhpcyBhbGdvcml0aG0gYWxsb3dzIGZvciBhIG1pbmltdW0gb2YgMSBSVFQgb2YgcmVvcmRlcmluZy4gSW4gY2FzZXMgd2l0aCBBQ0sgZnJhbWUgbG9zcyBhbmQgcmVvcmRlcmluZywgdGhpcyBhcHByb2FjaCBkb2VzIG5vdCBndWFyYW50ZWUgdGhhdCBldmVyeSBhY2tub3dsZWRnbWVudCBpcyBzZWVuIGJ5IHRoZSBzZW5kZXIgYmVmb3JlIGl0IGlzIG5vIGxvbmdlciBpbmNsdWRlZCBpbiB0aGUgQUNLIGZyYW1lLiBQYWNrZXRzIGNvdWxkIGJlIHJlY2VpdmVkIG91dCBvZiBvcmRlciwgYW5kIGFsbCBzdWJzZXF1ZW50IEFDSyBmcmFtZXMgY29udGFpbmluZyB0aGVtIGNvdWxkIGJlIGxvc3QuIEluIHRoaXMgY2FzZSwgdGhlIGxvc3MgcmVjb3ZlcnkgYWxnb3JpdGhtIGNvdWxkIGNhdXNlIHNwdXJpb3VzIHJldHJhbnNtaXNzaW9ucywgYnV0IHRoZSBzZW5kZXIgd2lsbCBjb250aW51ZSBtYWtpbmcgZm9yd2FyZCBwcm9ncmVzcy4gMTMuMi41LiBNZWFzdXJpbmcgYW5kIFJlcG9ydGluZyBIb3N0IERlbGF5IEFuIGVuZHBvaW50IG1lYXN1cmVzIHRoZSBkZWxheXMgaW50ZW50aW9uYWxseSBpbnRyb2R1Y2VkIGJldHdlZW4gdGhlIHRpbWUgdGhlIHBhY2tldCB3aXRoIHRoZSBsYXJnZXN0IHBhY2tldCBudW1iZXIgaXMgcmVjZWl2ZWQgYW5kIHRoZSB0aW1lIGFuIGFja25vd2xlZGdtZW50IGlzIHNlbnQuIFRoZSBlbmRwb2ludCBlbmNvZGVzIHRoaXMgYWNrbm93bGVkZ21lbnQgZGVsYXkgaW4gdGhlIEFDSyBEZWxheSBmaWVsZCBvZiBhbiBBQ0sgZnJhbWU7IHNlZSBTZWN0aW9uIDE5LjMuIFRoaXMgYWxsb3dzIHRoZSByZWNlaXZlciBvZiB0aGUgQUNLIGZyYW1lIHRvIGFkanVzdCBmb3IgYW55IGludGVudGlvbmFsIGRlbGF5cywgd2hpY2ggaXMgaW1wb3J0YW50IGZvciBnZXR0aW5nIGEgYmV0dGVyIGVzdGltYXRlIG9mIHRoZSBwYXRoIFJUVCB3aGVuIGFja25vd2xlZGdtZW50cyBhcmUgZGVsYXllZC4gQSBwYWNrZXQgbWlnaHQgYmUgaGVsZCBpbiB0aGUgT1Mga2VybmVsIG9yIGVsc2V3aGVyZSBvbiB0aGUgaG9zdCBiZWZvcmUgYmVpbmcgcHJvY2Vzc2VkLiBBbiBlbmRwb2ludCBNVVNUIE5PVCBpbmNsdWRlIGRlbGF5cyB0aGF0IGl0IGRvZXMgbm90IGNvbnRyb2wgd2hlbiBwb3B1bGF0aW5nIHRoZSBBQ0sgRGVsYXkgZmllbGQgaW4gYW4gQUNLIGZyYW1lLiBIb3dldmVyLCBlbmRwb2ludHMgU0hPVUxEIGluY2x1ZGUgYnVmZmVyaW5nIGRlbGF5cyBjYXVzZWQgYnkgdW5hdmFpbGFiaWxpdHkgb2YgZGVjcnlwdGlvbiBrZXlzLCBzaW5jZSB0aGVzZSBkZWxheXMgY2FuIGJlIGxhcmdlIGFuZCBhcmUgbGlrZWx5IHRvIGJlIG5vbi1yZXBlYXRpbmcuIFdoZW4gdGhlIG1lYXN1cmVkIGFja25vd2xlZGdtZW50IGRlbGF5IGlzIGxhcmdlciB0aGFuIGl0cyBtYXhfYWNrX2RlbGF5LCBhbiBlbmRwb2ludCBTSE9VTEQgcmVwb3J0IHRoZSBtZWFzdXJlZCBkZWxheS4gVGhpcyBpbmZvcm1hdGlvbiBpcyBlc3BlY2lhbGx5IHVzZWZ1bCBkdXJpbmcgdGhlIGhhbmRzaGFrZSB3aGVuIGRlbGF5cyBtaWdodCBiZSBsYXJnZTsgc2VlIFNlY3Rpb24gMTMuMi4xLiAxMy4yLjYuIEFDSyBGcmFtZXMgYW5kIFBhY2tldCBQcm90ZWN0aW9uIEFDSyBmcmFtZXMgTVVTVCBvbmx5IGJlIGNhcnJpZWQgaW4gYSBwYWNrZXQgdGhhdCBoYXMgdGhlIHNhbWUgcGFja2V0IG51bWJlciBzcGFjZSBhcyB0aGUgcGFja2V0IGJlaW5nIGFja25vd2xlZGdlZDsgc2VlIFNlY3Rpb24gMTIuMS4gRm9yIGluc3RhbmNlLCBwYWNrZXRzIHRoYXQgYXJlIHByb3RlY3RlZCB3aXRoIDEtUlRUIGtleXMgTVVTVCBiZSBhY2tub3dsZWRnZWQgaW4gcGFja2V0cyB0aGF0IGFyZSBhbHNvIHByb3RlY3RlZCB3aXRoIDEtUlRUIGtleXMuIFBhY2tldHMgdGhhdCBhIGNsaWVudCBzZW5kcyB3aXRoIDAtUlRUIHBhY2tldCBwcm90ZWN0aW9uIE1VU1QgYmUgYWNrbm93bGVkZ2VkIGJ5IHRoZSBzZXJ2ZXIgaW4gcGFja2V0cyBwcm90ZWN0ZWQgYnkgMS1SVFQga2V5cy4gVGhpcyBjYW4gbWVhbiB0aGF0IHRoZSBjbGllbnQgaXMgdW5hYmxlIHRvIHVzZSB0aGVzZSBhY2tub3dsZWRnbWVudHMgaWYgdGhlIHNlcnZlciBjcnlwdG9ncmFwaGljIGhhbmRzaGFrZSBtZXNzYWdlcyBhcmUgZGVsYXllZCBvciBsb3N0LiBOb3RlIHRoYXQgdGhlIHNhbWUgbGltaXRhdGlvbiBhcHBsaWVzIHRvIG90aGVyIGRhdGEgc2VudCBieSB0aGUgc2VydmVyIHByb3RlY3RlZCBieSB0aGUgMS1SVFQga2V5cy4gMTMuMi43LiBQQURESU5HIEZyYW1lcyBDb25zdW1lIENvbmdlc3Rpb24gV2luZG93IFBhY2tldHMgY29udGFpbmluZyBQQURESU5HIGZyYW1lcyBhcmUgY29uc2lkZXJlZCB0byBiZSBpbiBmbGlnaHQgZm9yIGNvbmdlc3Rpb24gY29udHJvbCBwdXJwb3NlcyBbUVVJQy1SRUNPVkVSWV0uIFBhY2tldHMgY29udGFpbmluZyBvbmx5IFBBRERJTkcgZnJhbWVzIHRoZXJlZm9yZSBjb25zdW1lIGNvbmdlc3Rpb24gd2luZG93IGJ1dCBkbyBub3QgZ2VuZXJhdGUgYWNrbm93bGVkZ21lbnRzIHRoYXQgd2lsbCBvcGVuIHRoZSBjb25nZXN0aW9uIHdpbmRvdy4gVG8gYXZvaWQgYSBkZWFkbG9jaywgYSBzZW5kZXIgU0hPVUxEIGVuc3VyZSB0aGF0IG90aGVyIGZyYW1lcyBhcmUgc2VudCBwZXJpb2RpY2FsbHkgaW4gYWRkaXRpb24gdG8gUEFERElORyBmcmFtZXMgdG8gZWxpY2l0IGFja25vd2xlZGdtZW50cyBmcm9tIHRoZSByZWNlaXZlci4gMTMuMy4gUmV0cmFuc21pc3Npb24gb2YgSW5mb3JtYXRpb24gUVVJQyBwYWNrZXRzIHRoYXQgYXJlIGRldGVybWluZWQgdG8gYmUgbG9zdCBhcmUgbm90IHJldHJhbnNtaXR0ZWQgd2hvbGUuIFRoZSBzYW1lIGFwcGxpZXMgdG8gdGhlIGZyYW1lcyB0aGF0IGFyZSBjb250YWluZWQgd2l0aGluIGxvc3QgcGFja2V0cy4gSW5zdGVhZCwgdGhlIGluZm9ybWF0aW9uIHRoYXQgbWlnaHQgYmUgY2FycmllZCBpbiBmcmFtZXMgaXMgc2VudCBhZ2FpbiBpbiBuZXcgZnJhbWVzIGFzIG5lZWRlZC4gTmV3IGZyYW1lcyBhbmQgcGFja2V0cyBhcmUgdXNlZCB0byBjYXJyeSBpbmZvcm1hdGlvbiB0aGF0IGlzIGRldGVybWluZWQgdG8gaGF2ZSBiZWVuIGxvc3QuIEluIGdlbmVyYWwsIGluZm9ybWF0aW9uIGlzIHNlbnQgYWdhaW4gd2hlbiBhIHBhY2tldCBjb250YWluaW5nIHRoYXQgaW5mb3JtYXRpb24gaXMgZGV0ZXJtaW5lZCB0byBiZSBsb3N0LCBhbmQgc2VuZGluZyBjZWFzZXMgd2hlbiBhIHBhY2tldCBjb250YWluaW5nIHRoYXQgaW5mb3JtYXRpb24gaXMgYWNrbm93bGVkZ2VkLiAqIERhdGEgc2VudCBpbiBDUllQVE8gZnJhbWVzIGlzIHJldHJhbnNtaXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBydWxlcyBpbiBbUVVJQy1SRUNPVkVSWV0sIHVudGlsIGFsbCBkYXRhIGhhcyBiZWVuIGFja25vd2xlZGdlZC4gRGF0YSBpbiBDUllQVE8gZnJhbWVzIGZvciBJbml0aWFsIGFuZCBIYW5kc2hha2UgcGFja2V0cyBpcyBkaXNjYXJkZWQgd2hlbiBrZXlzIGZvciB0aGUgY29ycmVzcG9uZGluZyBwYWNrZXQgbnVtYmVyIHNwYWNlIGFyZSBkaXNjYXJkZWQuICogQXBwbGljYXRpb24gZGF0YSBzZW50IGluIFNUUkVBTSBmcmFtZXMgaXMgcmV0cmFuc21pdHRlZCBpbiBuZXcgU1RSRUFNIGZyYW1lcyB1bmxlc3MgdGhlIGVuZHBvaW50IGhhcyBzZW50IGEgUkVTRVRfU1RSRUFNIGZvciB0aGF0IHN0cmVhbS4gT25jZSBhbiBlbmRwb2ludCBzZW5kcyBhIFJFU0VUX1NUUkVBTSBmcmFtZSwgbm8gZnVydGhlciBTVFJFQU0gZnJhbWVzIGFyZSBuZWVkZWQuICogQUNLIGZyYW1lcyBjYXJyeSB0aGUgbW9zdCByZWNlbnQgc2V0IG9mIGFja25vd2xlZGdtZW50cyBhbmQgdGhlIGFja25vd2xlZGdtZW50IGRlbGF5IGZyb20gdGhlIGxhcmdlc3QgYWNrbm93bGVkZ2VkIHBhY2tldCwgYXMgZGVzY3JpYmVkIGluIFNlY3Rpb24gMTMuMi4xLiBEZWxheWluZyB0aGUgdHJhbnNtaXNzaW9uIG9mIHBhY2tldHMgY29udGFpbmluZyBBQ0sgZnJhbWVzIG9yIHJlc2VuZGluZyBvbGQgQUNLIGZyYW1lcyBjYW4gY2F1c2UgdGhlIHBlZXIgdG8gZ2VuZXJhdGUgYW4gaW5mbGF0ZWQgUlRUIHNhbXBsZSBvciB1bm5lY2Vzc2FyaWx5IGRpc2FibGUgRUNOLiAqIENhbmNlbGxhdGlvbiBvZiBzdHJlYW0gdHJhbnNtaXNzaW9uLCBhcyBjYXJyaWVkIGluIGEgUkVTRVRfU1RSRUFNIGZyYW1lLCBpcyBzZW50IHVudGlsIGFja25vd2xlZGdlZCBvciB1bnRpbCBhbGwgc3RyZWFtIGRhdGEgaXMgYWNrbm93bGVkZ2VkIGJ5IHRoZSBwZWVyICh0aGF0IGlzLCBlaXRoZXIgdGhlICJSZXNldCBSZWN2ZCIgb3IgIkRhdGEgUmVjdmQiIHN0YXRlIGlzIHJlYWNoZWQgb24gdGhlIHNlbmRpbmcgcGFydCBvZiB0aGUgc3RyZWFtKS4gVGhlIGNvbnRlbnQgb2YgYSBSRVNFVF9TVFJFQU0gZnJhbWUgTVVTVCBOT1QgY2hhbmdlIHdoZW4gaXQgaXMgc2VudCBhZ2Fpbi4gKiBTaW1pbGFybHksIGEgcmVxdWVzdCB0byBjYW5jZWwgc3RyZWFtIHRyYW5zbWlzc2lvbiwgYXMgZW5jb2RlZCBpbiBhIFNUT1BfU0VORElORyBmcmFtZSwgaXMgc2VudCB1bnRpbCB0aGUgcmVjZWl2aW5nIHBhcnQgb2YgdGhlIHN0cmVhbSBlbnRlcnMgZWl0aGVyIGEgIkRhdGEgUmVjdmQiIG9yICJSZXNldCBSZWN2ZCIgc3RhdGU7IHNlZSBTZWN0aW9uIDMuNS4gKiBDb25uZWN0aW9uIGNsb3NlIHNpZ25hbHMsIGluY2x1ZGluZyBwYWNrZXRzIHRoYXQgY29udGFpbiBDT05ORUNUSU9OX0NMT1NFIGZyYW1lcywgYXJlIG5vdCBzZW50IGFnYWluIHdoZW4gcGFja2V0IGxvc3MgaXMgZGV0ZWN0ZWQuIFJlc2VuZGluZyB0aGVzZSBzaWduYWxzIGlzIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDEwLiAqIFRoZSBjdXJyZW50IGNvbm5lY3Rpb24gbWF4aW11bSBkYXRhIGlzIHNlbnQgaW4gTUFYX0RBVEEgZnJhbWVzLiBBbiB1cGRhdGVkIHZhbHVlIGlzIHNlbnQgaW4gYSBNQVhfREFUQSBmcmFtZSBpZiB0aGUgcGFja2V0IGNvbnRhaW5pbmcgdGhlIG1vc3QgcmVjZW50bHkgc2VudCBNQVhfREFUQSBmcmFtZSBpcyBkZWNsYXJlZCBsb3N0IG9yIHdoZW4gdGhlIGVuZHBvaW50IGRlY2lkZXMgdG8gdXBkYXRlIHRoZSBsaW1pdC4gQ2FyZSBpcyBuZWNlc3NhcnkgdG8gYXZvaWQgc2VuZGluZyB0aGlzIGZyYW1lIHRvbyBvZnRlbiwgYXMgdGhlIGxpbWl0IGNhbiBpbmNyZWFzZSBmcmVxdWVudGx5IGFuZCBjYXVzZSBhbiB1bm5lY2Vzc2FyaWx5IGxhcmdlIG51bWJlciBvZiBNQVhfREFUQSBmcmFtZXMgdG8gYmUgc2VudDsgc2VlIFNlY3Rpb24gNC4yLiAqIFRoZSBjdXJyZW50IG1heGltdW0gc3RyZWFtIGRhdGEgb2Zmc2V0IGlzIHNlbnQgaW4gTUFYX1NUUkVBTV9EQVRBIGZyYW1lcy4gTGlrZSBNQVhfREFUQSwgYW4gdXBkYXRlZCB2YWx1ZSBpcyBzZW50IHdoZW4gdGhlIHBhY2tldCBjb250YWluaW5nIHRoZSBtb3N0IHJlY2VudCBNQVhfU1RSRUFNX0RBVEEgZnJhbWUgZm9yIGEgc3RyZWFtIGlzIGxvc3Qgb3Igd2hlbiB0aGUgbGltaXQgaXMgdXBkYXRlZCwgd2l0aCBjYXJlIHRha2VuIHRvIHByZXZlbnQgdGhlIGZyYW1lIGZyb20gYmVpbmcgc2VudCB0b28gb2Z0ZW4uIEFuIGVuZHBvaW50IFNIT1VMRCBzdG9wIHNlbmRpbmcgTUFYX1NUUkVBTV9EQVRBIGZyYW1lcyB3aGVuIHRoZSByZWNlaXZpbmcgcGFydCBvZiB0aGUgc3RyZWFtIGVudGVycyBhICJTaXplIEtub3duIiBvciAiUmVzZXQgUmVjdmQiIHN0YXRlLiAqIFRoZSBsaW1pdCBvbiBzdHJlYW1zIG9mIGEgZ2l2ZW4gdHlwZSBpcyBzZW50IGluIE1BWF9TVFJFQU1TIGZyYW1lcy4gTGlrZSBNQVhfREFUQSwgYW4gdXBkYXRlZCB2YWx1ZSBpcyBzZW50IHdoZW4gYSBwYWNrZXQgY29udGFpbmluZyB0aGUgbW9zdCByZWNlbnQgTUFYX1NUUkVBTVMgZm9yIGEgc3RyZWFtIHR5cGUgZnJhbWUgaXMgZGVjbGFyZWQgbG9zdCBvciB3aGVuIHRoZSBsaW1pdCBpcyB1cGRhdGVkLCB3aXRoIGNhcmUgdGFrZW4gdG8gcHJldmVudCB0aGUgZnJhbWUgZnJvbSBiZWluZyBzZW50IHRvbyBvZnRlbi4gKiBCbG9ja2VkIHNpZ25hbHMgYXJlIGNhcnJpZWQgaW4gREFUQV9CTE9DS0VELCBTVFJFQU1fREFUQV9CTE9DS0VELCBhbmQgU1RSRUFNU19CTE9DS0VEIGZyYW1lcy4gREFUQV9CTE9DS0VEIGZyYW1lcyBoYXZlIGNvbm5lY3Rpb24gc2NvcGUsIFNUUkVBTV9EQVRBX0JMT0NLRUQgZnJhbWVzIGhhdmUgc3RyZWFtIHNjb3BlLCBhbmQgU1RSRUFNU19CTE9DS0VEIGZyYW1lcyBhcmUgc2NvcGVkIHRvIGEgc3BlY2lmaWMgc3RyZWFtIHR5cGUuIEEgbmV3IGZyYW1lIGlzIHNlbnQgaWYgYSBwYWNrZXQgY29udGFpbmluZyB0aGUgbW9zdCByZWNlbnQgZnJhbWUgZm9yIGEgc2NvcGUgaXMgbG9zdCwgYnV0IG9ubHkgd2hpbGUgdGhlIGVuZHBvaW50IGlzIGJsb2NrZWQgb24gdGhlIGNvcnJlc3BvbmRpbmcgbGltaXQuIFRoZXNlIGZyYW1lcyBhbHdheXMgaW5jbHVkZSB0aGUgbGltaXQgdGhhdCBpcyBjYXVzaW5nIGJsb2NraW5nIGF0IHRoZSB0aW1lIHRoYXQgdGhleSBhcmUgdHJhbnNtaXR0ZWQuICogQSBsaXZlbmVzcyBvciBwYXRoIHZhbGlkYXRpb24gY2hlY2sgdXNpbmcgUEFUSF9DSEFMTEVOR0UgZnJhbWVzIGlzIHNlbnQgcGVyaW9kaWNhbGx5IHVudGlsIGEgbWF0Y2hpbmcgUEFUSF9SRVNQT05TRSBmcmFtZSBpcyByZWNlaXZlZCBvciB1bnRpbCB0aGVyZSBpcyBubyByZW1haW5pbmcgbmVlZCBmb3IgbGl2ZW5lc3Mgb3IgcGF0aCB2YWxpZGF0aW9uIGNoZWNraW5nLiBQQVRIX0NIQUxMRU5HRSBmcmFtZXMgaW5jbHVkZSBhIGRpZmZlcmVudCBwYXlsb2FkIGVhY2ggdGltZSB0aGV5IGFyZSBzZW50LiAqIFJlc3BvbnNlcyB0byBwYXRoIHZhbGlkYXRpb24gdXNpbmcgUEFUSF9SRVNQT05TRSBmcmFtZXMgYXJlIHNlbnQganVzdCBvbmNlLiBUaGUgcGVlciBpcyBleHBlY3RlZCB0byBzZW5kIG1vcmUgUEFUSF9DSEFMTEVOR0UgZnJhbWVzIGFzIG5lY2Vzc2FyeSB0byBldm9rZSBhZGRpdGlvbmFsIFBBVEhfUkVTUE9OU0UgZnJhbWVzLiAqIE5ldyBjb25uZWN0aW9uIElEcyBhcmUgc2VudCBpbiBORVdfQ09OTkVDVElPTl9JRCBmcmFtZXMgYW5kIHJldHJhbnNtaXR0ZWQgaWYgdGhlIHBhY2tldCBjb250YWluaW5nIHRoZW0gaXMgbG9zdC4gUmV0cmFuc21pc3Npb25zIG9mIHRoaXMgZnJhbWUgY2FycnkgdGhlIHNhbWUgc2VxdWVuY2UgbnVtYmVyIHZhbHVlLiBMaWtld2lzZSwgcmV0aXJlZCBjb25uZWN0aW9uIElEcyBhcmUgc2VudCBpbiBSRVRJUkVfQ09OTkVDVElPTl9JRCBmcmFtZXMgYW5kIHJldHJhbnNtaXR0ZWQgaWYgdGhlIHBhY2tldCBjb250YWluaW5nIHRoZW0gaXMgbG9zdC4gKiBORVdfVE9LRU4gZnJhbWVzIGFyZSByZXRyYW5zbWl0dGVkIGlmIHRoZSBwYWNrZXQgY29udGFpbmluZyB0aGVtIGlzIGxvc3QuIE5vIHNwZWNpYWwgc3VwcG9ydCBpcyBtYWRlIGZvciBkZXRlY3RpbmcgcmVvcmRlcmVkIGFuZCBkdXBsaWNhdGVkIE5FV19UT0tFTiBmcmFtZXMgb3RoZXIgdGhhbiBhIGRpcmVjdCBjb21wYXJpc29uIG9mIHRoZSBmcmFtZSBjb250ZW50cy4gKiBQSU5HIGFuZCBQQURESU5HIGZyYW1lcyBjb250YWluIG5vIGluZm9ybWF0aW9uLCBzbyBsb3N0IFBJTkcgb3IgUEFERElORyBmcmFtZXMgZG8gbm90IHJlcXVpcmUgcmVwYWlyLiAqIFRoZSBIQU5EU0hBS0VfRE9ORSBmcmFtZSBNVVNUIGJlIHJldHJhbnNtaXR0ZWQgdW50aWwgaXQgaXMgYWNrbm93bGVkZ2VkLiBFbmRwb2ludHMgU0hPVUxEIHByaW9yaXRpemUgcmV0cmFuc21pc3Npb24gb2YgZGF0YSBvdmVyIHNlbmRpbmcgbmV3IGRhdGEsIHVubGVzcyBwcmlvcml0aWVzIHNwZWNpZmllZCBieSB0aGUgYXBwbGljYXRpb24gaW5kaWNhdGUgb3RoZXJ3aXNlOyBzZWUgU2VjdGlvbiAyLjMuIEV2ZW4gdGhvdWdoIGEgc2VuZGVyIGlzIGVuY291cmFnZWQgdG8gYXNzZW1ibGUgZnJhbWVzIGNvbnRhaW5pbmcgdXAtIHRvLWRhdGUgaW5mb3JtYXRpb24gZXZlcnkgdGltZSBpdCBzZW5kcyBhIHBhY2tldCwgaXQgaXMgbm90IGZvcmJpZGRlbiB0byByZXRyYW5zbWl0IGNvcGllcyBvZiBmcmFtZXMgZnJvbSBsb3N0IHBhY2tldHMuIEEgc2VuZGVyIHRoYXQgcmV0cmFuc21pdHMgY29waWVzIG9mIGZyYW1lcyBuZWVkcyB0byBoYW5kbGUgZGVjcmVhc2VzIGluIGF2YWlsYWJsZSBwYXlsb2FkIHNpemUgZHVlIHRvIGNoYW5nZXMgaW4gcGFja2V0IG51bWJlciBsZW5ndGgsIGNvbm5lY3Rpb24gSUQgbGVuZ3RoLCBhbmQgcGF0aCBNVFUuIEEgcmVjZWl2ZXIgTVVTVCBhY2NlcHQgcGFja2V0cyBjb250YWluaW5nIGFuIG91dGRhdGVkIGZyYW1lLCBzdWNoIGFzIGEgTUFYX0RBVEEgZnJhbWUgY2FycnlpbmcgYSBzbWFsbGVyIG1heGltdW0gZGF0YSB2YWx1ZSB0aGFuIG9uZSBmb3VuZCBpbiBhbiBvbGRlciBwYWNrZXQuIEEgc2VuZGVyIFNIT1VMRCBhdm9pZCByZXRyYW5zbWl0dGluZyBpbmZvcm1hdGlvbiBmcm9tIHBhY2tldHMgb25jZSB0aGV5IGFyZSBhY2tub3dsZWRnZWQuIFRoaXMgaW5jbHVkZXMgcGFja2V0cyB0aGF0IGFyZSBhY2tub3dsZWRnZWQgYWZ0ZXIgYmVpbmcgZGVjbGFyZWQgbG9zdCwgd2hpY2ggY2FuIGhhcHBlbiBpbiB0aGUgcHJlc2VuY2Ugb2YgbmV0d29yayByZW9yZGVyaW5nLiBEb2luZyBzbyByZXF1aXJlcyBzZW5kZXJzIHRvIHJldGFpbiBpbmZvcm1hdGlvbiBhYm91dCBwYWNrZXRzIGFmdGVyIHRoZXkgYXJlIGRlY2xhcmVkIGxvc3QuIEEgc2VuZGVyIGNhbiBkaXNjYXJkIHRoaXMgaW5mb3JtYXRpb24gYWZ0ZXIgYSBwZXJpb2Qgb2YgdGltZSBlbGFwc2VzIHRoYXQgYWRlcXVhdGVseSBhbGxvd3MgZm9yIHJlb3JkZXJpbmcsIHN1Y2ggYXMgYSBQVE8gKFNlY3Rpb24gNi4yIG9mIFtRVUlDLVJFQ09WRVJZXSksIG9yIGJhc2VkIG9uIG90aGVyIGV2ZW50cywgc3VjaCBhcyByZWFjaGluZyBhIG1lbW9yeSBsaW1pdC4gVXBvbiBkZXRlY3RpbmcgbG9zc2VzLCBhIHNlbmRlciBNVVNUIHRha2UgYXBwcm9wcmlhdGUgY29uZ2VzdGlvbiBjb250cm9sIGFjdGlvbi4gVGhlIGRldGFpbHMgb2YgbG9zcyBkZXRlY3Rpb24gYW5kIGNvbmdlc3Rpb24gY29udHJvbCBhcmUgZGVzY3JpYmVkIGluIFtRVUlDLVJFQ09WRVJZXS4gMTMuNC4gRXhwbGljaXQgQ29uZ2VzdGlvbiBOb3RpZmljYXRpb24gUVVJQyBlbmRwb2ludHMgY2FuIHVzZSBFQ04gW1JGQzMxNjhdIHRvIGRldGVjdCBhbmQgcmVzcG9uZCB0byBuZXR3b3JrIGNvbmdlc3Rpb24uIEVDTiBhbGxvd3MgYW4gZW5kcG9pbnQgdG8gc2V0IGFuIEVDTi1DYXBhYmxlIFRyYW5zcG9ydCAoRUNUKSBjb2RlcG9pbnQgaW4gdGhlIEVDTiBmaWVsZCBvZiBhbiBJUCBwYWNrZXQuIEEgbmV0d29yayBub2RlIGNhbiB0aGVuIGluZGljYXRlIGNvbmdlc3Rpb24gYnkgc2V0dGluZyB0aGUgRUNOLUNFIGNvZGVwb2ludCBpbiB0aGUgRUNOIGZpZWxkIGluc3RlYWQgb2YgZHJvcHBpbmcgdGhlIHBhY2tldCBbUkZDODA4N10uIEVuZHBvaW50cyByZWFjdCB0byByZXBvcnRlZCBjb25nZXN0aW9uIGJ5IHJlZHVjaW5nIHRoZWlyIHNlbmRpbmcgcmF0ZSBpbiByZXNwb25zZSwgYXMgZGVzY3JpYmVkIGluIFtRVUlDLVJFQ09WRVJZXS4gVG8gZW5hYmxlIEVDTiwgYSBzZW5kaW5nIFFVSUMgZW5kcG9pbnQgZmlyc3QgZGV0ZXJtaW5lcyB3aGV0aGVyIGEgcGF0aCBzdXBwb3J0cyBFQ04gbWFya2luZyBhbmQgd2hldGhlciB0aGUgcGVlciByZXBvcnRzIHRoZSBFQ04gdmFsdWVzIGluIHJlY2VpdmVkIElQIGhlYWRlcnM7IHNlZSBTZWN0aW9uIDEzLjQuMi4gMTMuNC4xLiBSZXBvcnRpbmcgRUNOIENvdW50cyBUaGUgdXNlIG9mIEVDTiByZXF1aXJlcyB0aGUgcmVjZWl2aW5nIGVuZHBvaW50IHRvIHJlYWQgdGhlIEVDTiBmaWVsZCBmcm9tIGFuIElQIHBhY2tldCwgd2hpY2ggaXMgbm90IHBvc3NpYmxlIG9uIGFsbCBwbGF0Zm9ybXMuIElmIGFuIGVuZHBvaW50IGRvZXMgbm90IGltcGxlbWVudCBFQ04gc3VwcG9ydCBvciBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0byByZWNlaXZlZCBFQ04gZmllbGRzLCBpdCBkb2VzIG5vdCByZXBvcnQgRUNOIGNvdW50cyBmb3IgcGFja2V0cyBpdCByZWNlaXZlcy4gRXZlbiBpZiBhbiBlbmRwb2ludCBkb2VzIG5vdCBzZXQgYW4gRUNUIGZpZWxkIGluIHBhY2tldHMgaXQgc2VuZHMsIHRoZSBlbmRwb2ludCBNVVNUIHByb3ZpZGUgZmVlZGJhY2sgYWJvdXQgRUNOIG1hcmtpbmdzIGl0IHJlY2VpdmVzLCBpZiB0aGVzZSBhcmUgYWNjZXNzaWJsZS4gRmFpbGluZyB0byByZXBvcnQgdGhlIEVDTiBjb3VudHMgd2lsbCBjYXVzZSB0aGUgc2VuZGVyIHRvIGRpc2FibGUgdGhlIHVzZSBvZiBFQ04gZm9yIHRoaXMgY29ubmVjdGlvbi4gT24gcmVjZWl2aW5nIGFuIElQIHBhY2tldCB3aXRoIGFuIEVDVCgwKSwgRUNUKDEpLCBvciBFQ04tQ0UgY29kZXBvaW50LCBhbiBFQ04tZW5hYmxlZCBlbmRwb2ludCBhY2Nlc3NlcyB0aGUgRUNOIGZpZWxkIGFuZCBpbmNyZWFzZXMgdGhlIGNvcnJlc3BvbmRpbmcgRUNUKDApLCBFQ1QoMSksIG9yIEVDTi1DRSBjb3VudC4gVGhlc2UgRUNOIGNvdW50cyBhcmUgaW5jbHVkZWQgaW4gc3Vic2VxdWVudCBBQ0sgZnJhbWVzOyBzZWUgU2VjdGlvbnMgMTMuMiBhbmQgMTkuMy4gRWFjaCBwYWNrZXQgbnVtYmVyIHNwYWNlIG1haW50YWlucyBzZXBhcmF0ZSBhY2tub3dsZWRnbWVudCBzdGF0ZSBhbmQgc2VwYXJhdGUgRUNOIGNvdW50cy4gQ29hbGVzY2VkIFFVSUMgcGFja2V0cyAoc2VlIFNlY3Rpb24gMTIuMikgc2hhcmUgdGhlIHNhbWUgSVAgaGVhZGVyIHNvIHRoZSBFQ04gY291bnRzIGFyZSBpbmNyZW1lbnRlZCBvbmNlIGZvciBlYWNoIGNvYWxlc2NlZCBRVUlDIHBhY2tldC4gRm9yIGV4YW1wbGUsIGlmIG9uZSBlYWNoIG9mIGFuIEluaXRpYWwsIEhhbmRzaGFrZSwgYW5kIDEtUlRUIFFVSUMgcGFja2V0IGFyZSBjb2FsZXNjZWQgaW50byBhIHNpbmdsZSBVRFAgZGF0YWdyYW0sIHRoZSBFQ04gY291bnRzIGZvciBhbGwgdGhyZWUgcGFja2V0IG51bWJlciBzcGFjZXMgd2lsbCBiZSBpbmNyZW1lbnRlZCBieSBvbmUgZWFjaCwgYmFzZWQgb24gdGhlIEVDTiBmaWVsZCBvZiB0aGUgc2luZ2xlIElQIGhlYWRlci4gRUNOIGNvdW50cyBhcmUgb25seSBpbmNyZW1lbnRlZCB3aGVuIFFVSUMgcGFja2V0cyBmcm9tIHRoZSByZWNlaXZlZCBJUCBwYWNrZXQgYXJlIHByb2Nlc3NlZC4gQXMgc3VjaCwgZHVwbGljYXRlIFFVSUMgcGFja2V0cyBhcmUgbm90IHByb2Nlc3NlZCBhbmQgZG8gbm90IGluY3JlYXNlIEVDTiBjb3VudHM7IHNlZSBTZWN0aW9uIDIxLjEwIGZvciByZWxldmFudCBzZWN1cml0eSBjb25jZXJucy4gMTMuNC4yLiBFQ04gVmFsaWRhdGlvbiBJdCBpcyBwb3NzaWJsZSBmb3IgZmF1bHR5IG5ldHdvcmsgZGV2aWNlcyB0byBjb3JydXB0IG9yIGVycm9uZW91c2x5IGRyb3AgcGFja2V0cyB0aGF0IGNhcnJ5IGEgbm9uLXplcm8gRUNOIGNvZGVwb2ludC4gVG8gZW5zdXJlIGNvbm5lY3Rpdml0eSBpbiB0aGUgcHJlc2VuY2Ugb2Ygc3VjaCBkZXZpY2VzLCBhbiBlbmRwb2ludCB2YWxpZGF0ZXMgdGhlIEVDTiBjb3VudHMgZm9yIGVhY2ggbmV0d29yayBwYXRoIGFuZCBkaXNhYmxlcyB0aGUgdXNlIG9mIEVDTiBvbiB0aGF0IHBhdGggaWYgZXJyb3JzIGFyZSBkZXRlY3RlZC4gVG8gcGVyZm9ybSBFQ04gdmFsaWRhdGlvbiBmb3IgYSBuZXcgcGF0aDogKiBUaGUgZW5kcG9pbnQgc2V0cyBhbiBFQ1QoMCkgY29kZXBvaW50IGluIHRoZSBJUCBoZWFkZXIgb2YgZWFybHkgb3V0Z29pbmcgcGFja2V0cyBzZW50IG9uIGEgbmV3IHBhdGggdG8gdGhlIHBlZXIgW1JGQzgzMTFdLiAqIFRoZSBlbmRwb2ludCBtb25pdG9ycyB3aGV0aGVyIGFsbCBwYWNrZXRzIHNlbnQgd2l0aCBhbiBFQ1QgY29kZXBvaW50IGFyZSBldmVudHVhbGx5IGRlZW1lZCBsb3N0IChTZWN0aW9uIDYgb2YgW1FVSUMtUkVDT1ZFUlldKSwgaW5kaWNhdGluZyB0aGF0IEVDTiB2YWxpZGF0aW9uIGhhcyBmYWlsZWQuIElmIGFuIGVuZHBvaW50IGhhcyBjYXVzZSB0byBleHBlY3QgdGhhdCBJUCBwYWNrZXRzIHdpdGggYW4gRUNUIGNvZGVwb2ludCBtaWdodCBiZSBkcm9wcGVkIGJ5IGEgZmF1bHR5IG5ldHdvcmsgZWxlbWVudCwgdGhlIGVuZHBvaW50IGNvdWxkIHNldCBhbiBFQ1QgY29kZXBvaW50IGZvciBvbmx5IHRoZSBmaXJzdCB0ZW4gb3V0Z29pbmcgcGFja2V0cyBvbiBhIHBhdGgsIG9yIGZvciBhIHBlcmlvZCBvZiB0aHJlZSBQVE9zIChzZWUgU2VjdGlvbiA2LjIgb2YgW1FVSUMtUkVDT1ZFUlldKS4gSWYgYWxsIHBhY2tldHMgbWFya2VkIHdpdGggbm9uLXplcm8gRUNOIGNvZGVwb2ludHMgYXJlIHN1YnNlcXVlbnRseSBsb3N0LCBpdCBjYW4gZGlzYWJsZSBtYXJraW5nIG9uIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhlIG1hcmtpbmcgY2F1c2VkIHRoZSBsb3NzLiBBbiBlbmRwb2ludCB0aHVzIGF0dGVtcHRzIHRvIHVzZSBFQ04gYW5kIHZhbGlkYXRlcyB0aGlzIGZvciBlYWNoIG5ldyBjb25uZWN0aW9uLCB3aGVuIHN3aXRjaGluZyB0byBhIHNlcnZlcidzIHByZWZlcnJlZCBhZGRyZXNzLCBhbmQgb24gYWN0aXZlIGNvbm5lY3Rpb24gbWlncmF0aW9uIHRvIGEgbmV3IHBhdGguIEFwcGVuZGl4IEEuNCBkZXNjcmliZXMgb25lIHBvc3NpYmxlIGFsZ29yaXRobS4gT3RoZXIgbWV0aG9kcyBvZiBwcm9iaW5nIHBhdGhzIGZvciBFQ04gc3VwcG9ydCBhcmUgcG9zc2libGUsIGFzIGFyZSBkaWZmZXJlbnQgbWFya2luZyBzdHJhdGVnaWVzLiBJbXBsZW1lbnRhdGlvbnMgTUFZIHVzZSBvdGhlciBtZXRob2RzIGRlZmluZWQgaW4gUkZDczsgc2VlIFtSRkM4MzExXS4gSW1wbGVtZW50YXRpb25zIHRoYXQgdXNlIHRoZSBFQ1QoMSkgY29kZXBvaW50IG5lZWQgdG8gcGVyZm9ybSBFQ04gdmFsaWRhdGlvbiB1c2luZyB0aGUgcmVwb3J0ZWQgRUNUKDEpIGNvdW50cy4gMTMuNC4yLjEuIFJlY2VpdmluZyBBQ0sgRnJhbWVzIHdpdGggRUNOIENvdW50cyBFcnJvbmVvdXMgYXBwbGljYXRpb24gb2YgRUNOLUNFIG1hcmtpbmdzIGJ5IHRoZSBuZXR3b3JrIGNhbiByZXN1bHQgaW4gZGVncmFkZWQgY29ubmVjdGlvbiBwZXJmb3JtYW5jZS4gQW4gZW5kcG9pbnQgdGhhdCByZWNlaXZlcyBhbiBBQ0sgZnJhbWUgd2l0aCBFQ04gY291bnRzIHRoZXJlZm9yZSB2YWxpZGF0ZXMgdGhlIGNvdW50cyBiZWZvcmUgdXNpbmcgdGhlbS4gSXQgcGVyZm9ybXMgdGhpcyB2YWxpZGF0aW9uIGJ5IGNvbXBhcmluZyBuZXdseSByZWNlaXZlZCBjb3VudHMgYWdhaW5zdCB0aG9zZSBmcm9tIHRoZSBsYXN0IHN1Y2Nlc3NmdWxseSBwcm9jZXNzZWQgQUNLIGZyYW1lLiBBbnkgaW5jcmVhc2UgaW4gdGhlIEVDTiBjb3VudHMgaXMgdmFsaWRhdGVkIGJhc2VkIG9uIHRoZSBFQ04gbWFya2luZ3MgdGhhdCB3ZXJlIGFwcGxpZWQgdG8gcGFja2V0cyB0aGF0IGFyZSBuZXdseSBhY2tub3dsZWRnZWQgaW4gdGhlIEFDSyBmcmFtZS4gSWYgYW4gQUNLIGZyYW1lIG5ld2x5IGFja25vd2xlZGdlcyBhIHBhY2tldCB0aGF0IHRoZSBlbmRwb2ludCBzZW50IHdpdGggZWl0aGVyIHRoZSBFQ1QoMCkgb3IgRUNUKDEpIGNvZGVwb2ludCBzZXQsIEVDTiB2YWxpZGF0aW9uIGZhaWxzIGlmIHRoZSBjb3JyZXNwb25kaW5nIEVDTiBjb3VudHMgYXJlIG5vdCBwcmVzZW50IGluIHRoZSBBQ0sgZnJhbWUuIFRoaXMgY2hlY2sgZGV0ZWN0cyBhIG5ldHdvcmsgZWxlbWVudCB0aGF0IHplcm9lcyB0aGUgRUNOIGZpZWxkIG9yIGEgcGVlciB0aGF0IGRvZXMgbm90IHJlcG9ydCBFQ04gbWFya2luZ3MuIEVDTiB2YWxpZGF0aW9uIGFsc28gZmFpbHMgaWYgdGhlIHN1bSBvZiB0aGUgaW5jcmVhc2UgaW4gRUNUKDApIGFuZCBFQ04tQ0UgY291bnRzIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIG5ld2x5IGFja25vd2xlZGdlZCBwYWNrZXRzIHRoYXQgd2VyZSBvcmlnaW5hbGx5IHNlbnQgd2l0aCBhbiBFQ1QoMCkgbWFya2luZy4gU2ltaWxhcmx5LCBFQ04gdmFsaWRhdGlvbiBmYWlscyBpZiB0aGUgc3VtIG9mIHRoZSBpbmNyZWFzZXMgdG8gRUNUKDEpIGFuZCBFQ04tQ0UgY291bnRzIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIG5ld2x5IGFja25vd2xlZGdlZCBwYWNrZXRzIHNlbnQgd2l0aCBhbiBFQ1QoMSkgbWFya2luZy4gVGhlc2UgY2hlY2tzIGNhbiBkZXRlY3QgcmVtYXJraW5nIG9mIEVDTi1DRSBtYXJraW5ncyBieSB0aGUgbmV0d29yay4gQW4gZW5kcG9pbnQgY291bGQgbWlzcyBhY2tub3dsZWRnbWVudHMgZm9yIGEgcGFja2V0IHdoZW4gQUNLIGZyYW1lcyBhcmUgbG9zdC4gSXQgaXMgdGhlcmVmb3JlIHBvc3NpYmxlIGZvciB0aGUgdG90YWwgaW5jcmVhc2UgaW4gRUNUKDApLCBFQ1QoMSksIGFuZCBFQ04tQ0UgY291bnRzIHRvIGJlIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHBhY2tldHMgdGhhdCBhcmUgbmV3bHkgYWNrbm93bGVkZ2VkIGJ5IGFuIEFDSyBmcmFtZS4gVGhpcyBpcyB3aHkgRUNOIGNvdW50cyBhcmUgcGVybWl0dGVkIHRvIGJlIGxhcmdlciB0aGFuIHRoZSB0b3RhbCBudW1iZXIgb2YgcGFja2V0cyB0aGF0IGFyZSBhY2tub3dsZWRnZWQuIFZhbGlkYXRpbmcgRUNOIGNvdW50cyBmcm9tIHJlb3JkZXJlZCBBQ0sgZnJhbWVzIGNhbiByZXN1bHQgaW4gZmFpbHVyZS4gQW4gZW5kcG9pbnQgTVVTVCBOT1QgZmFpbCBFQ04gdmFsaWRhdGlvbiBhcyBhIHJlc3VsdCBvZiBwcm9jZXNzaW5nIGFuIEFDSyBmcmFtZSB0aGF0IGRvZXMgbm90IGluY3JlYXNlIHRoZSBsYXJnZXN0IGFja25vd2xlZGdlZCBwYWNrZXQgbnVtYmVyLiBFQ04gdmFsaWRhdGlvbiBjYW4gZmFpbCBpZiB0aGUgcmVjZWl2ZWQgdG90YWwgY291bnQgZm9yIGVpdGhlciBFQ1QoMCkgb3IgRUNUKDEpIGV4Y2VlZHMgdGhlIHRvdGFsIG51bWJlciBvZiBwYWNrZXRzIHNlbnQgd2l0aCBlYWNoIGNvcnJlc3BvbmRpbmcgRUNUIGNvZGVwb2ludC4gSW4gcGFydGljdWxhciwgdmFsaWRhdGlvbiB3aWxsIGZhaWwgd2hlbiBhbiBlbmRwb2ludCByZWNlaXZlcyBhIG5vbi16ZXJvIEVDTiBjb3VudCBjb3JyZXNwb25kaW5nIHRvIGFuIEVDVCBjb2RlcG9pbnQgdGhhdCBpdCBuZXZlciBhcHBsaWVkLiBUaGlzIGNoZWNrIGRldGVjdHMgd2hlbiBwYWNrZXRzIGFyZSByZW1hcmtlZCB0byBFQ1QoMCkgb3IgRUNUKDEpIGluIHRoZSBuZXR3b3JrLiAxMy40LjIuMi4gRUNOIFZhbGlkYXRpb24gT3V0Y29tZXMgSWYgdmFsaWRhdGlvbiBmYWlscywgdGhlbiB0aGUgZW5kcG9pbnQgTVVTVCBkaXNhYmxlIEVDTi4gSXQgc3RvcHMgc2V0dGluZyB0aGUgRUNUIGNvZGVwb2ludCBpbiBJUCBwYWNrZXRzIHRoYXQgaXQgc2VuZHMsIGFzc3VtaW5nIHRoYXQgZWl0aGVyIHRoZSBuZXR3b3JrIHBhdGggb3IgdGhlIHBlZXIgZG9lcyBub3Qgc3VwcG9ydCBFQ04uIEV2ZW4gaWYgdmFsaWRhdGlvbiBmYWlscywgYW4gZW5kcG9pbnQgTUFZIHJldmFsaWRhdGUgRUNOIGZvciB0aGUgc2FtZSBwYXRoIGF0IGFueSBsYXRlciB0aW1lIGluIHRoZSBjb25uZWN0aW9uLiBBbiBlbmRwb2ludCBjb3VsZCBjb250aW51ZSB0byBwZXJpb2RpY2FsbHkgYXR0ZW1wdCB2YWxpZGF0aW9uLiBVcG9uIHN1Y2Nlc3NmdWwgdmFsaWRhdGlvbiwgYW4gZW5kcG9pbnQgTUFZIGNvbnRpbnVlIHRvIHNldCBhbiBFQ1QgY29kZXBvaW50IGluIHN1YnNlcXVlbnQgcGFja2V0cyBpdCBzZW5kcywgd2l0aCB0aGUgZXhwZWN0YXRpb24gdGhhdCB0aGUgcGF0aCBpcyBFQ04gY2FwYWJsZS4gTmV0d29yayByb3V0aW5nIGFuZCBwYXRoIGVsZW1lbnRzIGNhbiBjaGFuZ2UgbWlkLWNvbm5lY3Rpb247IGFuIGVuZHBvaW50IE1VU1QgZGlzYWJsZSBFQ04gaWYgdmFsaWRhdGlvbiBsYXRlciBmYWlscy4gMTQuIERhdGFncmFtIFNpemUgQSBVRFAgZGF0YWdyYW0gY2FuIGluY2x1ZGUgb25lIG9yIG1vcmUgUVVJQyBwYWNrZXRzLiBUaGUgZGF0YWdyYW0gc2l6ZSByZWZlcnMgdG8gdGhlIHRvdGFsIFVEUCBwYXlsb2FkIHNpemUgb2YgYSBzaW5nbGUgVURQIGRhdGFncmFtIGNhcnJ5aW5nIFFVSUMgcGFja2V0cy4gVGhlIGRhdGFncmFtIHNpemUgaW5jbHVkZXMgb25lIG9yIG1vcmUgUVVJQyBwYWNrZXQgaGVhZGVycyBhbmQgcHJvdGVjdGVkIHBheWxvYWRzLCBidXQgbm90IHRoZSBVRFAgb3IgSVAgaGVhZGVycy4gVGhlIG1heGltdW0gZGF0YWdyYW0gc2l6ZSBpcyBkZWZpbmVkIGFzIHRoZSBsYXJnZXN0IHNpemUgb2YgVURQIHBheWxvYWQgdGhhdCBjYW4gYmUgc2VudCBhY3Jvc3MgYSBuZXR3b3JrIHBhdGggdXNpbmcgYSBzaW5nbGUgVURQIGRhdGFncmFtLiBRVUlDIE1VU1QgTk9UIGJlIHVzZWQgaWYgdGhlIG5ldHdvcmsgcGF0aCBjYW5ub3Qgc3VwcG9ydCBhIG1heGltdW0gZGF0YWdyYW0gc2l6ZSBvZiBhdCBsZWFzdCAxMjAwIGJ5dGVzLiBRVUlDIGFzc3VtZXMgYSBtaW5pbXVtIElQIHBhY2tldCBzaXplIG9mIGF0IGxlYXN0IDEyODAgYnl0ZXMuIFRoaXMgaXMgdGhlIElQdjYgbWluaW11bSBzaXplIFtJUHY2XSBhbmQgaXMgYWxzbyBzdXBwb3J0ZWQgYnkgbW9zdCBtb2Rlcm4gSVB2NCBuZXR3b3Jrcy4gQXNzdW1pbmcgdGhlIG1pbmltdW0gSVAgaGVhZGVyIHNpemUgb2YgNDAgYnl0ZXMgZm9yIElQdjYgYW5kIDIwIGJ5dGVzIGZvciBJUHY0IGFuZCBhIFVEUCBoZWFkZXIgc2l6ZSBvZiA4IGJ5dGVzLCB0aGlzIHJlc3VsdHMgaW4gYSBtYXhpbXVtIGRhdGFncmFtIHNpemUgb2YgMTIzMiBieXRlcyBmb3IgSVB2NiBhbmQgMTI1MiBieXRlcyBmb3IgSVB2NC4gVGh1cywgbW9kZXJuIElQdjQgYW5kIGFsbCBJUHY2IG5ldHdvcmsgcGF0aHMgYXJlIGV4cGVjdGVkIHRvIGJlIGFibGUgdG8gc3VwcG9ydCBRVUlDLiB8IE5vdGU6IFRoaXMgcmVxdWlyZW1lbnQgdG8gc3VwcG9ydCBhIFVEUCBwYXlsb2FkIG9mIDEyMDAgYnl0ZXMgfCBsaW1pdHMgdGhlIHNwYWNlIGF2YWlsYWJsZSBmb3IgSVB2NiBleHRlbnNpb24gaGVhZGVycyB0byAzMiB8IGJ5dGVzIG9yIElQdjQgb3B0aW9ucyB0byA1MiBieXRlcyBpZiB0aGUgcGF0aCBvbmx5IHN1cHBvcnRzIHRoZSB8IElQdjYgbWluaW11bSBNVFUgb2YgMTI4MCBieXRlcy4gVGhpcyBhZmZlY3RzIEluaXRpYWwgcGFja2V0cyB8IGFuZCBwYXRoIHZhbGlkYXRpb24uIEFueSBtYXhpbXVtIGRhdGFncmFtIHNpemUgbGFyZ2VyIHRoYW4gMTIwMCBieXRlcyBjYW4gYmUgZGlzY292ZXJlZCB1c2luZyBQYXRoIE1heGltdW0gVHJhbnNtaXNzaW9uIFVuaXQgRGlzY292ZXJ5IChQTVRVRCkgKHNlZSBTZWN0aW9uIDE0LjIuMSkgb3IgRGF0YWdyYW0gUGFja2V0aXphdGlvbiBMYXllciBQTVRVIERpc2NvdmVyeSAoRFBMUE1UVUQpIChzZWUgU2VjdGlvbiAxNC4zKS4gRW5mb3JjZW1lbnQgb2YgdGhlIG1heF91ZHBfcGF5bG9hZF9zaXplIHRyYW5zcG9ydCBwYXJhbWV0ZXIgKFNlY3Rpb24gMTguMikgbWlnaHQgYWN0IGFzIGFuIGFkZGl0aW9uYWwgbGltaXQgb24gdGhlIG1heGltdW0gZGF0YWdyYW0gc2l6ZS4gQSBzZW5kZXIgY2FuIGF2b2lkIGV4Y2VlZGluZyB0aGlzIGxpbWl0LCBvbmNlIHRoZSB2YWx1ZSBpcyBrbm93bi4gSG93ZXZlciwgcHJpb3IgdG8gbGVhcm5pbmcgdGhlIHZhbHVlIG9mIHRoZSB0cmFuc3BvcnQgcGFyYW1ldGVyLCBlbmRwb2ludHMgcmlzayBkYXRhZ3JhbXMgYmVpbmcgbG9zdCBpZiB0aGV5IHNlbmQgZGF0YWdyYW1zIGxhcmdlciB0aGFuIHRoZSBzbWFsbGVzdCBhbGxvd2VkIG1heGltdW0gZGF0YWdyYW0gc2l6ZSBvZiAxMjAwIGJ5dGVzLiBVRFAgZGF0YWdyYW1zIE1VU1QgTk9UIGJlIGZyYWdtZW50ZWQgYXQgdGhlIElQIGxheWVyLiBJbiBJUHY0IFtJUHY0XSwgdGhlIERvbid0IEZyYWdtZW50IChERikgYml0IE1VU1QgYmUgc2V0IGlmIHBvc3NpYmxlLCB0byBwcmV2ZW50IGZyYWdtZW50YXRpb24gb24gdGhlIHBhdGguIFFVSUMgc29tZXRpbWVzIHJlcXVpcmVzIGRhdGFncmFtcyB0byBiZSBubyBzbWFsbGVyIHRoYW4gYSBjZXJ0YWluIHNpemU7IHNlZSBTZWN0aW9uIDguMSBhcyBhbiBleGFtcGxlLiBIb3dldmVyLCB0aGUgc2l6ZSBvZiBhIGRhdGFncmFtIGlzIG5vdCBhdXRoZW50aWNhdGVkLiBUaGF0IGlzLCBpZiBhbiBlbmRwb2ludCByZWNlaXZlcyBhIGRhdGFncmFtIG9mIGEgY2VydGFpbiBzaXplLCBpdCBjYW5ub3Qga25vdyB0aGF0IHRoZSBzZW5kZXIgc2VudCB0aGUgZGF0YWdyYW0gYXQgdGhlIHNhbWUgc2l6ZS4gVGhlcmVmb3JlLCBhbiBlbmRwb2ludCBNVVNUIE5PVCBjbG9zZSBhIGNvbm5lY3Rpb24gd2hlbiBpdCByZWNlaXZlcyBhIGRhdGFncmFtIHRoYXQgZG9lcyBub3QgbWVldCBzaXplIGNvbnN0cmFpbnRzOyB0aGUgZW5kcG9pbnQgTUFZIGRpc2NhcmQgc3VjaCBkYXRhZ3JhbXMuIDE0LjEuIEluaXRpYWwgRGF0YWdyYW0gU2l6ZSBBIGNsaWVudCBNVVNUIGV4cGFuZCB0aGUgcGF5bG9hZCBvZiBhbGwgVURQIGRhdGFncmFtcyBjYXJyeWluZyBJbml0aWFsIHBhY2tldHMgdG8gYXQgbGVhc3QgdGhlIHNtYWxsZXN0IGFsbG93ZWQgbWF4aW11bSBkYXRhZ3JhbSBzaXplIG9mIDEyMDAgYnl0ZXMgYnkgYWRkaW5nIFBBRERJTkcgZnJhbWVzIHRvIHRoZSBJbml0aWFsIHBhY2tldCBvciBieSBjb2FsZXNjaW5nIHRoZSBJbml0aWFsIHBhY2tldDsgc2VlIFNlY3Rpb24gMTIuMi4gSW5pdGlhbCBwYWNrZXRzIGNhbiBldmVuIGJlIGNvYWxlc2NlZCB3aXRoIGludmFsaWQgcGFja2V0cywgd2hpY2ggYSByZWNlaXZlciB3aWxsIGRpc2NhcmQuIFNpbWlsYXJseSwgYSBzZXJ2ZXIgTVVTVCBleHBhbmQgdGhlIHBheWxvYWQgb2YgYWxsIFVEUCBkYXRhZ3JhbXMgY2FycnlpbmcgYWNrLWVsaWNpdGluZyBJbml0aWFsIHBhY2tldHMgdG8gYXQgbGVhc3QgdGhlIHNtYWxsZXN0IGFsbG93ZWQgbWF4aW11bSBkYXRhZ3JhbSBzaXplIG9mIDEyMDAgYnl0ZXMuIFNlbmRpbmcgVURQIGRhdGFncmFtcyBvZiB0aGlzIHNpemUgZW5zdXJlcyB0aGF0IHRoZSBuZXR3b3JrIHBhdGggc3VwcG9ydHMgYSByZWFzb25hYmxlIFBhdGggTWF4aW11bSBUcmFuc21pc3Npb24gVW5pdCAoUE1UVSksIGluIGJvdGggZGlyZWN0aW9ucy4gQWRkaXRpb25hbGx5LCBhIGNsaWVudCB0aGF0IGV4cGFuZHMgSW5pdGlhbCBwYWNrZXRzIGhlbHBzIHJlZHVjZSB0aGUgYW1wbGl0dWRlIG9mIGFtcGxpZmljYXRpb24gYXR0YWNrcyBjYXVzZWQgYnkgc2VydmVyIHJlc3BvbnNlcyB0b3dhcmQgYW4gdW52ZXJpZmllZCBjbGllbnQgYWRkcmVzczsgc2VlIFNlY3Rpb24gOC4gRGF0YWdyYW1zIGNvbnRhaW5pbmcgSW5pdGlhbCBwYWNrZXRzIE1BWSBleGNlZWQgMTIwMCBieXRlcyBpZiB0aGUgc2VuZGVyIGJlbGlldmVzIHRoYXQgdGhlIG5ldHdvcmsgcGF0aCBhbmQgcGVlciBib3RoIHN1cHBvcnQgdGhlIHNpemUgdGhhdCBpdCBjaG9vc2VzLiBBIHNlcnZlciBNVVNUIGRpc2NhcmQgYW4gSW5pdGlhbCBwYWNrZXQgdGhhdCBpcyBjYXJyaWVkIGluIGEgVURQIGRhdGFncmFtIHdpdGggYSBwYXlsb2FkIHRoYXQgaXMgc21hbGxlciB0aGFuIHRoZSBzbWFsbGVzdCBhbGxvd2VkIG1heGltdW0gZGF0YWdyYW0gc2l6ZSBvZiAxMjAwIGJ5dGVzLiBBIHNlcnZlciBNQVkgYWxzbyBpbW1lZGlhdGVseSBjbG9zZSB0aGUgY29ubmVjdGlvbiBieSBzZW5kaW5nIGEgQ09OTkVDVElPTl9DTE9TRSBmcmFtZSB3aXRoIGFuIGVycm9yIGNvZGUgb2YgUFJPVE9DT0xfVklPTEFUSU9OOyBzZWUgU2VjdGlvbiAxMC4yLjMuIFRoZSBzZXJ2ZXIgTVVTVCBhbHNvIGxpbWl0IHRoZSBudW1iZXIgb2YgYnl0ZXMgaXQgc2VuZHMgYmVmb3JlIHZhbGlkYXRpbmcgdGhlIGFkZHJlc3Mgb2YgdGhlIGNsaWVudDsgc2VlIFNlY3Rpb24gOC4gMTQuMi4gUGF0aCBNYXhpbXVtIFRyYW5zbWlzc2lvbiBVbml0IFRoZSBQTVRVIGlzIHRoZSBtYXhpbXVtIHNpemUgb2YgdGhlIGVudGlyZSBJUCBwYWNrZXQsIGluY2x1ZGluZyB0aGUgSVAgaGVhZGVyLCBVRFAgaGVhZGVyLCBhbmQgVURQIHBheWxvYWQuIFRoZSBVRFAgcGF5bG9hZCBpbmNsdWRlcyBvbmUgb3IgbW9yZSBRVUlDIHBhY2tldCBoZWFkZXJzIGFuZCBwcm90ZWN0ZWQgcGF5bG9hZHMuIFRoZSBQTVRVIGNhbiBkZXBlbmQgb24gcGF0aCBjaGFyYWN0ZXJpc3RpY3MgYW5kIGNhbiB0aGVyZWZvcmUgY2hhbmdlIG92ZXIgdGltZS4gVGhlIGxhcmdlc3QgVURQIHBheWxvYWQgYW4gZW5kcG9pbnQgc2VuZHMgYXQgYW55IGdpdmVuIHRpbWUgaXMgcmVmZXJyZWQgdG8gYXMgdGhlIGVuZHBvaW50J3MgbWF4aW11bSBkYXRhZ3JhbSBzaXplLiBBbiBlbmRwb2ludCBTSE9VTEQgdXNlIERQTFBNVFVEIChTZWN0aW9uIDE0LjMpIG9yIFBNVFVEIChTZWN0aW9uIDE0LjIuMSkgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHBhdGggdG8gYSBkZXN0aW5hdGlvbiB3aWxsIHN1cHBvcnQgYSBkZXNpcmVkIG1heGltdW0gZGF0YWdyYW0gc2l6ZSB3aXRob3V0IGZyYWdtZW50YXRpb24uIEluIHRoZSBhYnNlbmNlIG9mIHRoZXNlIG1lY2hhbmlzbXMsIFFVSUMgZW5kcG9pbnRzIFNIT1VMRCBOT1Qgc2VuZCBkYXRhZ3JhbXMgbGFyZ2VyIHRoYW4gdGhlIHNtYWxsZXN0IGFsbG93ZWQgbWF4aW11bSBkYXRhZ3JhbSBzaXplLiBCb3RoIERQTFBNVFVEIGFuZCBQTVRVRCBzZW5kIGRhdGFncmFtcyB0aGF0IGFyZSBsYXJnZXIgdGhhbiB0aGUgY3VycmVudCBtYXhpbXVtIGRhdGFncmFtIHNpemUsIHJlZmVycmVkIHRvIGFzIFBNVFUgcHJvYmVzLiBBbGwgUVVJQyBwYWNrZXRzIHRoYXQgYXJlIG5vdCBzZW50IGluIGEgUE1UVSBwcm9iZSBTSE9VTEQgYmUgc2l6ZWQgdG8gZml0IHdpdGhpbiB0aGUgbWF4aW11bSBkYXRhZ3JhbSBzaXplIHRvIGF2b2lkIHRoZSBkYXRhZ3JhbSBiZWluZyBmcmFnbWVudGVkIG9yIGRyb3BwZWQgW1JGQzgwODVdLiBJZiBhIFFVSUMgZW5kcG9pbnQgZGV0ZXJtaW5lcyB0aGF0IHRoZSBQTVRVIGJldHdlZW4gYW55IHBhaXIgb2YgbG9jYWwgYW5kIHJlbW90ZSBJUCBhZGRyZXNzZXMgY2Fubm90IHN1cHBvcnQgdGhlIHNtYWxsZXN0IGFsbG93ZWQgbWF4aW11bSBkYXRhZ3JhbSBzaXplIG9mIDEyMDAgYnl0ZXMsIGl0IE1VU1QgaW1tZWRpYXRlbHkgY2Vhc2Ugc2VuZGluZyBRVUlDIHBhY2tldHMsIGV4Y2VwdCBmb3IgdGhvc2UgaW4gUE1UVSBwcm9iZXMgb3IgdGhvc2UgY29udGFpbmluZyBDT05ORUNUSU9OX0NMT1NFIGZyYW1lcywgb24gdGhlIGFmZmVjdGVkIHBhdGguIEFuIGVuZHBvaW50IE1BWSB0ZXJtaW5hdGUgdGhlIGNvbm5lY3Rpb24gaWYgYW4gYWx0ZXJuYXRpdmUgcGF0aCBjYW5ub3QgYmUgZm91bmQuIEVhY2ggcGFpciBvZiBsb2NhbCBhbmQgcmVtb3RlIGFkZHJlc3NlcyBjb3VsZCBoYXZlIGEgZGlmZmVyZW50IFBNVFUuIFFVSUMgaW1wbGVtZW50YXRpb25zIHRoYXQgaW1wbGVtZW50IGFueSBraW5kIG9mIFBNVFUgZGlzY292ZXJ5IHRoZXJlZm9yZSBTSE9VTEQgbWFpbnRhaW4gYSBtYXhpbXVtIGRhdGFncmFtIHNpemUgZm9yIGVhY2ggY29tYmluYXRpb24gb2YgbG9jYWwgYW5kIHJlbW90ZSBJUCBhZGRyZXNzZXMuIEEgUVVJQyBpbXBsZW1lbnRhdGlvbiBNQVkgYmUgbW9yZSBjb25zZXJ2YXRpdmUgaW4gY29tcHV0aW5nIHRoZSBtYXhpbXVtIGRhdGFncmFtIHNpemUgdG8gYWxsb3cgZm9yIHVua25vd24gdHVubmVsIG92ZXJoZWFkcyBvciBJUCBoZWFkZXIgb3B0aW9ucy9leHRlbnNpb25zLiAxNC4yLjEuIEhhbmRsaW5nIG9mIElDTVAgTWVzc2FnZXMgYnkgUE1UVUQgUE1UVUQgW1JGQzExOTFdIFtSRkM4MjAxXSByZWxpZXMgb24gcmVjZXB0aW9uIG9mIElDTVAgbWVzc2FnZXMgKHRoYXQgaXMsIElQdjYgUGFja2V0IFRvbyBCaWcgKFBUQikgbWVzc2FnZXMpIHRoYXQgaW5kaWNhdGUgd2hlbiBhbiBJUCBwYWNrZXQgaXMgZHJvcHBlZCBiZWNhdXNlIGl0IGlzIGxhcmdlciB0aGFuIHRoZSBsb2NhbCByb3V0ZXIgTVRVLiBEUExQTVRVRCBjYW4gYWxzbyBvcHRpb25hbGx5IHVzZSB0aGVzZSBtZXNzYWdlcy4gVGhpcyB1c2Ugb2YgSUNNUCBtZXNzYWdlcyBpcyBwb3RlbnRpYWxseSB2dWxuZXJhYmxlIHRvIGF0dGFja3MgYnkgZW50aXRpZXMgdGhhdCBjYW5ub3Qgb2JzZXJ2ZSBwYWNrZXRzIGJ1dCBtaWdodCBzdWNjZXNzZnVsbHkgZ3Vlc3MgdGhlIGFkZHJlc3NlcyB1c2VkIG9uIHRoZSBwYXRoLiBUaGVzZSBhdHRhY2tzIGNvdWxkIHJlZHVjZSB0aGUgUE1UVSB0byBhIGJhbmR3aWR0aC0gaW5lZmZpY2llbnQgdmFsdWUuIEFuIGVuZHBvaW50IE1VU1QgaWdub3JlIGFuIElDTVAgbWVzc2FnZSB0aGF0IGNsYWltcyB0aGUgUE1UVSBoYXMgZGVjcmVhc2VkIGJlbG93IFFVSUMncyBzbWFsbGVzdCBhbGxvd2VkIG1heGltdW0gZGF0YWdyYW0gc2l6ZS4gVGhlIHJlcXVpcmVtZW50cyBmb3IgZ2VuZXJhdGluZyBJQ01QIFtSRkMxODEyXSBbUkZDNDQ0M10gc3RhdGUgdGhhdCB0aGUgcXVvdGVkIHBhY2tldCBzaG91bGQgY29udGFpbiBhcyBtdWNoIG9mIHRoZSBvcmlnaW5hbCBwYWNrZXQgYXMgcG9zc2libGUgd2l0aG91dCBleGNlZWRpbmcgdGhlIG1pbmltdW0gTVRVIGZvciB0aGUgSVAgdmVyc2lvbi4gVGhlIHNpemUgb2YgdGhlIHF1b3RlZCBwYWNrZXQgY2FuIGFjdHVhbGx5IGJlIHNtYWxsZXIsIG9yIHRoZSBpbmZvcm1hdGlvbiB1bmludGVsbGlnaWJsZSwgYXMgZGVzY3JpYmVkIGluIFNlY3Rpb24gMS4xIG9mIFtEUExQTVRVRF0uIFFVSUMgZW5kcG9pbnRzIHVzaW5nIFBNVFVEIFNIT1VMRCB2YWxpZGF0ZSBJQ01QIG1lc3NhZ2VzIHRvIHByb3RlY3QgZnJvbSBwYWNrZXQgaW5qZWN0aW9uIGFzIHNwZWNpZmllZCBpbiBbUkZDODIwMV0gYW5kIFNlY3Rpb24gNS4yIG9mIFtSRkM4MDg1XS4gVGhpcyB2YWxpZGF0aW9uIFNIT1VMRCB1c2UgdGhlIHF1b3RlZCBwYWNrZXQgc3VwcGxpZWQgaW4gdGhlIHBheWxvYWQgb2YgYW4gSUNNUCBtZXNzYWdlIHRvIGFzc29jaWF0ZSB0aGUgbWVzc2FnZSB3aXRoIGEgY29ycmVzcG9uZGluZyB0cmFuc3BvcnQgY29ubmVjdGlvbiAoc2VlIFNlY3Rpb24gNC42LjEgb2YgW0RQTFBNVFVEXSkuIElDTVAgbWVzc2FnZSB2YWxpZGF0aW9uIE1VU1QgaW5jbHVkZSBtYXRjaGluZyBJUCBhZGRyZXNzZXMgYW5kIFVEUCBwb3J0cyBbUkZDODA4NV0gYW5kLCB3aGVuIHBvc3NpYmxlLCBjb25uZWN0aW9uIElEcyB0byBhbiBhY3RpdmUgUVVJQyBzZXNzaW9uLiBUaGUgZW5kcG9pbnQgU0hPVUxEIGlnbm9yZSBhbGwgSUNNUCBtZXNzYWdlcyB0aGF0IGZhaWwgdmFsaWRhdGlvbi4gQW4gZW5kcG9pbnQgTVVTVCBOT1QgaW5jcmVhc2UgdGhlIFBNVFUgYmFzZWQgb24gSUNNUCBtZXNzYWdlczsgc2VlIEl0ZW0gNiBpbiBTZWN0aW9uIDMgb2YgW0RQTFBNVFVEXS4gQW55IHJlZHVjdGlvbiBpbiBRVUlDJ3MgbWF4aW11bSBkYXRhZ3JhbSBzaXplIGluIHJlc3BvbnNlIHRvIElDTVAgbWVzc2FnZXMgTUFZIGJlIHByb3Zpc2lvbmFsIHVudGlsIFFVSUMncyBsb3NzIGRldGVjdGlvbiBhbGdvcml0aG0gZGV0ZXJtaW5lcyB0aGF0IHRoZSBxdW90ZWQgcGFja2V0IGhhcyBhY3R1YWxseSBiZWVuIGxvc3QuIDE0LjMuIERhdGFncmFtIFBhY2tldGl6YXRpb24gTGF5ZXIgUE1UVSBEaXNjb3ZlcnkgRFBMUE1UVUQgW0RQTFBNVFVEXSByZWxpZXMgb24gdHJhY2tpbmcgbG9zcyBvciBhY2tub3dsZWRnbWVudCBvZiBRVUlDIHBhY2tldHMgdGhhdCBhcmUgY2FycmllZCBpbiBQTVRVIHByb2Jlcy4gUE1UVSBwcm9iZXMgZm9yIERQTFBNVFVEIHRoYXQgdXNlIHRoZSBQQURESU5HIGZyYW1lIGltcGxlbWVudCAiUHJvYmluZyB1c2luZyBwYWRkaW5nIGRhdGEiLCBhcyBkZWZpbmVkIGluIFNlY3Rpb24gNC4xIG9mIFtEUExQTVRVRF0uIEVuZHBvaW50cyBTSE9VTEQgc2V0IHRoZSBpbml0aWFsIHZhbHVlIG9mIEJBU0VfUExQTVRVIChTZWN0aW9uIDUuMSBvZiBbRFBMUE1UVURdKSB0byBiZSBjb25zaXN0ZW50IHdpdGggUVVJQydzIHNtYWxsZXN0IGFsbG93ZWQgbWF4aW11bSBkYXRhZ3JhbSBzaXplLiBUaGUgTUlOX1BMUE1UVSBpcyB0aGUgc2FtZSBhcyB0aGUgQkFTRV9QTFBNVFUuIFFVSUMgZW5kcG9pbnRzIGltcGxlbWVudGluZyBEUExQTVRVRCBtYWludGFpbiBhIERQTFBNVFVEIE1heGltdW0gUGFja2V0IFNpemUgKE1QUykgKFNlY3Rpb24gNC40IG9mIFtEUExQTVRVRF0pIGZvciBlYWNoIGNvbWJpbmF0aW9uIG9mIGxvY2FsIGFuZCByZW1vdGUgSVAgYWRkcmVzc2VzLiBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBtYXhpbXVtIGRhdGFncmFtIHNpemUuIDE0LjMuMS4gRFBMUE1UVUQgYW5kIEluaXRpYWwgQ29ubmVjdGl2aXR5IEZyb20gdGhlIHBlcnNwZWN0aXZlIG9mIERQTFBNVFVELCBRVUlDIGlzIGFuIGFja25vd2xlZGdlZCBQYWNrZXRpemF0aW9uIExheWVyIChQTCkuIEEgUVVJQyBzZW5kZXIgY2FuIHRoZXJlZm9yZSBlbnRlciB0aGUgRFBMUE1UVUQgQkFTRSBzdGF0ZSAoU2VjdGlvbiA1LjIgb2YgW0RQTFBNVFVEXSkgd2hlbiB0aGUgUVVJQyBjb25uZWN0aW9uIGhhbmRzaGFrZSBoYXMgYmVlbiBjb21wbGV0ZWQuIDE0LjMuMi4gVmFsaWRhdGluZyB0aGUgTmV0d29yayBQYXRoIHdpdGggRFBMUE1UVUQgUVVJQyBpcyBhbiBhY2tub3dsZWRnZWQgUEw7IHRoZXJlZm9yZSwgYSBRVUlDIHNlbmRlciBkb2VzIG5vdCBpbXBsZW1lbnQgYSBEUExQTVRVRCBDT05GSVJNQVRJT05fVElNRVIgd2hpbGUgaW4gdGhlIFNFQVJDSF9DT01QTEVURSBzdGF0ZTsgc2VlIFNlY3Rpb24gNS4yIG9mIFtEUExQTVRVRF0uIDE0LjMuMy4gSGFuZGxpbmcgb2YgSUNNUCBNZXNzYWdlcyBieSBEUExQTVRVRCBBbiBlbmRwb2ludCB1c2luZyBEUExQTVRVRCByZXF1aXJlcyB0aGUgdmFsaWRhdGlvbiBvZiBhbnkgcmVjZWl2ZWQgSUNNUCBQVEIgbWVzc2FnZSBiZWZvcmUgdXNpbmcgdGhlIFBUQiBpbmZvcm1hdGlvbiwgYXMgZGVmaW5lZCBpbiBTZWN0aW9uIDQuNiBvZiBbRFBMUE1UVURdLiBJbiBhZGRpdGlvbiB0byBVRFAgcG9ydCB2YWxpZGF0aW9uLCBRVUlDIHZhbGlkYXRlcyBhbiBJQ01QIG1lc3NhZ2UgYnkgdXNpbmcgb3RoZXIgUEwgaW5mb3JtYXRpb24gKGUuZy4sIHZhbGlkYXRpb24gb2YgY29ubmVjdGlvbiBJRHMgaW4gdGhlIHF1b3RlZCBwYWNrZXQgb2YgYW55IHJlY2VpdmVkIElDTVAgbWVzc2FnZSkuIFRoZSBjb25zaWRlcmF0aW9ucyBmb3IgcHJvY2Vzc2luZyBJQ01QIG1lc3NhZ2VzIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDE0LjIuMSBhbHNvIGFwcGx5IGlmIHRoZXNlIG1lc3NhZ2VzIGFyZSB1c2VkIGJ5IERQTFBNVFVELiAxNC40LiBTZW5kaW5nIFFVSUMgUE1UVSBQcm9iZXMgUE1UVSBwcm9iZXMgYXJlIGFjay1lbGljaXRpbmcgcGFja2V0cy4gRW5kcG9pbnRzIGNvdWxkIGxpbWl0IHRoZSBjb250ZW50IG9mIFBNVFUgcHJvYmVzIHRvIFBJTkcgYW5kIFBBRERJTkcgZnJhbWVzLCBzaW5jZSBwYWNrZXRzIHRoYXQgYXJlIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IG1heGltdW0gZGF0YWdyYW0gc2l6ZSBhcmUgbW9yZSBsaWtlbHkgdG8gYmUgZHJvcHBlZCBieSB0aGUgbmV0d29yay4gTG9zcyBvZiBhIFFVSUMgcGFja2V0IHRoYXQgaXMgY2FycmllZCBpbiBhIFBNVFUgcHJvYmUgaXMgdGhlcmVmb3JlIG5vdCBhIHJlbGlhYmxlIGluZGljYXRpb24gb2YgY29uZ2VzdGlvbiBhbmQgU0hPVUxEIE5PVCB0cmlnZ2VyIGEgY29uZ2VzdGlvbiBjb250cm9sIHJlYWN0aW9uOyBzZWUgSXRlbSA3IGluIFNlY3Rpb24gMyBvZiBbRFBMUE1UVURdLiBIb3dldmVyLCBQTVRVIHByb2JlcyBjb25zdW1lIGNvbmdlc3Rpb24gd2luZG93LCB3aGljaCBjb3VsZCBkZWxheSBzdWJzZXF1ZW50IHRyYW5zbWlzc2lvbiBieSBhbiBhcHBsaWNhdGlvbi4gMTQuNC4xLiBQTVRVIFByb2JlcyBDb250YWluaW5nIFNvdXJjZSBDb25uZWN0aW9uIElEIEVuZHBvaW50cyB0aGF0IHJlbHkgb24gdGhlIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgZmllbGQgZm9yIHJvdXRpbmcgaW5jb21pbmcgUVVJQyBwYWNrZXRzIGFyZSBsaWtlbHkgdG8gcmVxdWlyZSB0aGF0IHRoZSBjb25uZWN0aW9uIElEIGJlIGluY2x1ZGVkIGluIFBNVFUgcHJvYmVzIHRvIHJvdXRlIGFueSByZXN1bHRpbmcgSUNNUCBtZXNzYWdlcyAoU2VjdGlvbiAxNC4yLjEpIGJhY2sgdG8gdGhlIGNvcnJlY3QgZW5kcG9pbnQuIEhvd2V2ZXIsIG9ubHkgbG9uZyBoZWFkZXIgcGFja2V0cyAoU2VjdGlvbiAxNy4yKSBjb250YWluIHRoZSBTb3VyY2UgQ29ubmVjdGlvbiBJRCBmaWVsZCwgYW5kIGxvbmcgaGVhZGVyIHBhY2tldHMgYXJlIG5vdCBkZWNyeXB0ZWQgb3IgYWNrbm93bGVkZ2VkIGJ5IHRoZSBwZWVyIG9uY2UgdGhlIGhhbmRzaGFrZSBpcyBjb21wbGV0ZS4gT25lIHdheSB0byBjb25zdHJ1Y3QgYSBQTVRVIHByb2JlIGlzIHRvIGNvYWxlc2NlIChzZWUgU2VjdGlvbiAxMi4yKSBhIHBhY2tldCB3aXRoIGEgbG9uZyBoZWFkZXIsIHN1Y2ggYXMgYSBIYW5kc2hha2Ugb3IgMC1SVFQgcGFja2V0IChTZWN0aW9uIDE3LjIpLCB3aXRoIGEgc2hvcnQgaGVhZGVyIHBhY2tldCBpbiBhIHNpbmdsZSBVRFAgZGF0YWdyYW0uIElmIHRoZSByZXN1bHRpbmcgUE1UVSBwcm9iZSByZWFjaGVzIHRoZSBlbmRwb2ludCwgdGhlIHBhY2tldCB3aXRoIHRoZSBsb25nIGhlYWRlciB3aWxsIGJlIGlnbm9yZWQsIGJ1dCB0aGUgc2hvcnQgaGVhZGVyIHBhY2tldCB3aWxsIGJlIGFja25vd2xlZGdlZC4gSWYgdGhlIFBNVFUgcHJvYmUgY2F1c2VzIGFuIElDTVAgbWVzc2FnZSB0byBiZSBzZW50LCB0aGUgZmlyc3QgcGFydCBvZiB0aGUgcHJvYmUgd2lsbCBiZSBxdW90ZWQgaW4gdGhhdCBtZXNzYWdlLiBJZiB0aGUgU291cmNlIENvbm5lY3Rpb24gSUQgZmllbGQgaXMgd2l0aGluIHRoZSBxdW90ZWQgcG9ydGlvbiBvZiB0aGUgcHJvYmUsIHRoYXQgY291bGQgYmUgdXNlZCBmb3Igcm91dGluZyBvciB2YWxpZGF0aW9uIG9mIHRoZSBJQ01QIG1lc3NhZ2UuIHwgTm90ZTogVGhlIHB1cnBvc2Ugb2YgdXNpbmcgYSBwYWNrZXQgd2l0aCBhIGxvbmcgaGVhZGVyIGlzIG9ubHkgfCB0byBlbnN1cmUgdGhhdCB0aGUgcXVvdGVkIHBhY2tldCBjb250YWluZWQgaW4gdGhlIElDTVAgbWVzc2FnZSB8IGNvbnRhaW5zIGEgU291cmNlIENvbm5lY3Rpb24gSUQgZmllbGQuIFRoaXMgcGFja2V0IGRvZXMgbm90IHwgbmVlZCB0byBiZSBhIHZhbGlkIHBhY2tldCwgYW5kIGl0IGNhbiBiZSBzZW50IGV2ZW4gaWYgdGhlcmUgaXMgfCBubyBjdXJyZW50IHVzZSBmb3IgcGFja2V0cyBvZiB0aGF0IHR5cGUuIDE1LiBWZXJzaW9ucyBRVUlDIHZlcnNpb25zIGFyZSBpZGVudGlmaWVkIHVzaW5nIGEgMzItYml0IHVuc2lnbmVkIG51bWJlci4gVGhlIHZlcnNpb24gMHgwMDAwMDAwMCBpcyByZXNlcnZlZCB0byByZXByZXNlbnQgdmVyc2lvbiBuZWdvdGlhdGlvbi4gVGhpcyB2ZXJzaW9uIG9mIHRoZSBzcGVjaWZpY2F0aW9uIGlzIGlkZW50aWZpZWQgYnkgdGhlIG51bWJlciAweDAwMDAwMDAxLiBPdGhlciB2ZXJzaW9ucyBvZiBRVUlDIG1pZ2h0IGhhdmUgZGlmZmVyZW50IHByb3BlcnRpZXMgZnJvbSB0aGlzIHZlcnNpb24uIFRoZSBwcm9wZXJ0aWVzIG9mIFFVSUMgdGhhdCBhcmUgZ3VhcmFudGVlZCB0byBiZSBjb25zaXN0ZW50IGFjcm9zcyBhbGwgdmVyc2lvbnMgb2YgdGhlIHByb3RvY29sIGFyZSBkZXNjcmliZWQgaW4gW1FVSUMtSU5WQVJJQU5UU10uIFZlcnNpb24gMHgwMDAwMDAwMSBvZiBRVUlDIHVzZXMgVExTIGFzIGEgY3J5cHRvZ3JhcGhpYyBoYW5kc2hha2UgcHJvdG9jb2wsIGFzIGRlc2NyaWJlZCBpbiBbUVVJQy1UTFNdLiBWZXJzaW9ucyB3aXRoIHRoZSBtb3N0IHNpZ25pZmljYW50IDE2IGJpdHMgb2YgdGhlIHZlcnNpb24gbnVtYmVyIGNsZWFyZWQgYXJlIHJlc2VydmVkIGZvciB1c2UgaW4gZnV0dXJlIElFVEYgY29uc2Vuc3VzIGRvY3VtZW50cy4gVmVyc2lvbnMgdGhhdCBmb2xsb3cgdGhlIHBhdHRlcm4gMHg/YT9hP2E/YSBhcmUgcmVzZXJ2ZWQgZm9yIHVzZSBpbiBmb3JjaW5nIHZlcnNpb24gbmVnb3RpYXRpb24gdG8gYmUgZXhlcmNpc2VkIC0tIHRoYXQgaXMsIGFueSB2ZXJzaW9uIG51bWJlciB3aGVyZSB0aGUgbG93IGZvdXIgYml0cyBvZiBhbGwgYnl0ZXMgaXMgMTAxMCAoaW4gYmluYXJ5KS4gQSBjbGllbnQgb3Igc2VydmVyIE1BWSBhZHZlcnRpc2Ugc3VwcG9ydCBmb3IgYW55IG9mIHRoZXNlIHJlc2VydmVkIHZlcnNpb25zLiBSZXNlcnZlZCB2ZXJzaW9uIG51bWJlcnMgd2lsbCBuZXZlciByZXByZXNlbnQgYSByZWFsIHByb3RvY29sOyBhIGNsaWVudCBNQVkgdXNlIG9uZSBvZiB0aGVzZSB2ZXJzaW9uIG51bWJlcnMgd2l0aCB0aGUgZXhwZWN0YXRpb24gdGhhdCB0aGUgc2VydmVyIHdpbGwgaW5pdGlhdGUgdmVyc2lvbiBuZWdvdGlhdGlvbjsgYSBzZXJ2ZXIgTUFZIGFkdmVydGlzZSBzdXBwb3J0IGZvciBvbmUgb2YgdGhlc2UgdmVyc2lvbnMgYW5kIGNhbiBleHBlY3QgdGhhdCBjbGllbnRzIGlnbm9yZSB0aGUgdmFsdWUuIDE2LiBWYXJpYWJsZS1MZW5ndGggSW50ZWdlciBFbmNvZGluZyBRVUlDIHBhY2tldHMgYW5kIGZyYW1lcyBjb21tb25seSB1c2UgYSB2YXJpYWJsZS1sZW5ndGggZW5jb2RpbmcgZm9yIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIHZhbHVlcy4gVGhpcyBlbmNvZGluZyBlbnN1cmVzIHRoYXQgc21hbGxlciBpbnRlZ2VyIHZhbHVlcyBuZWVkIGZld2VyIGJ5dGVzIHRvIGVuY29kZS4gVGhlIFFVSUMgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgZW5jb2RpbmcgcmVzZXJ2ZXMgdGhlIHR3byBtb3N0IHNpZ25pZmljYW50IGJpdHMgb2YgdGhlIGZpcnN0IGJ5dGUgdG8gZW5jb2RlIHRoZSBiYXNlLTIgbG9nYXJpdGhtIG9mIHRoZSBpbnRlZ2VyIGVuY29kaW5nIGxlbmd0aCBpbiBieXRlcy4gVGhlIGludGVnZXIgdmFsdWUgaXMgZW5jb2RlZCBvbiB0aGUgcmVtYWluaW5nIGJpdHMsIGluIG5ldHdvcmsgYnl0ZSBvcmRlci4gVGhpcyBtZWFucyB0aGF0IGludGVnZXJzIGFyZSBlbmNvZGVkIG9uIDEsIDIsIDQsIG9yIDggYnl0ZXMgYW5kIGNhbiBlbmNvZGUgNi0sIDE0LSwgMzAtLCBvciA2Mi1iaXQgdmFsdWVzLCByZXNwZWN0aXZlbHkuIFRhYmxlIDQgc3VtbWFyaXplcyB0aGUgZW5jb2RpbmcgcHJvcGVydGllcy4gKz09PT09PSs9PT09PT09PSs9PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09KyB8IDJNU0IgfCBMZW5ndGggfCBVc2FibGUgQml0cyB8IFJhbmdlIHwgKz09PT09PSs9PT09PT09PSs9PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09KyB8IDAwIHwgMSB8IDYgfCAwLTYzIHwgKy0tLS0tLSstLS0tLS0tLSstLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyB8IDAxIHwgMiB8IDE0IHwgMC0xNjM4MyB8ICstLS0tLS0rLS0tLS0tLS0rLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgfCAxMCB8IDQgfCAzMCB8IDAtMTA3Mzc0MTgyMyB8ICstLS0tLS0rLS0tLS0tLS0rLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgfCAxMSB8IDggfCA2MiB8IDAtNDYxMTY4NjAxODQyNzM4NzkwMyB8ICstLS0tLS0rLS0tLS0tLS0rLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgVGFibGUgNDogU3VtbWFyeSBvZiBJbnRlZ2VyIEVuY29kaW5ncyBBbiBleGFtcGxlIG9mIGEgZGVjb2RpbmcgYWxnb3JpdGhtIGFuZCBzYW1wbGUgZW5jb2RpbmdzIGFyZSBzaG93biBpbiBBcHBlbmRpeCBBLjEuIFZhbHVlcyBkbyBub3QgbmVlZCB0byBiZSBlbmNvZGVkIG9uIHRoZSBtaW5pbXVtIG51bWJlciBvZiBieXRlcyBuZWNlc3NhcnksIHdpdGggdGhlIHNvbGUgZXhjZXB0aW9uIG9mIHRoZSBGcmFtZSBUeXBlIGZpZWxkOyBzZWUgU2VjdGlvbiAxMi40LiBWZXJzaW9ucyAoU2VjdGlvbiAxNSksIHBhY2tldCBudW1iZXJzIHNlbnQgaW4gdGhlIGhlYWRlciAoU2VjdGlvbiAxNy4xKSwgYW5kIHRoZSBsZW5ndGggb2YgY29ubmVjdGlvbiBJRHMgaW4gbG9uZyBoZWFkZXIgcGFja2V0cyAoU2VjdGlvbiAxNy4yKSBhcmUgZGVzY3JpYmVkIHVzaW5nIGludGVnZXJzIGJ1dCBkbyBub3QgdXNlIHRoaXMgZW5jb2RpbmcuIDE3LiBQYWNrZXQgRm9ybWF0cyBBbGwgbnVtZXJpYyB2YWx1ZXMgYXJlIGVuY29kZWQgaW4gbmV0d29yayBieXRlIG9yZGVyICh0aGF0IGlzLCBiaWcgZW5kaWFuKSwgYW5kIGFsbCBmaWVsZCBzaXplcyBhcmUgaW4gYml0cy4gSGV4YWRlY2ltYWwgbm90YXRpb24gaXMgdXNlZCBmb3IgZGVzY3JpYmluZyB0aGUgdmFsdWUgb2YgZmllbGRzLiAxNy4xLiBQYWNrZXQgTnVtYmVyIEVuY29kaW5nIGFuZCBEZWNvZGluZyBQYWNrZXQgbnVtYmVycyBhcmUgaW50ZWdlcnMgaW4gdGhlIHJhbmdlIDAgdG8gMl42Mi0xIChTZWN0aW9uIDEyLjMpLiBXaGVuIHByZXNlbnQgaW4gbG9uZyBvciBzaG9ydCBwYWNrZXQgaGVhZGVycywgdGhleSBhcmUgZW5jb2RlZCBpbiAxIHRvIDQgYnl0ZXMuIFRoZSBudW1iZXIgb2YgYml0cyByZXF1aXJlZCB0byByZXByZXNlbnQgdGhlIHBhY2tldCBudW1iZXIgaXMgcmVkdWNlZCBieSBpbmNsdWRpbmcgb25seSB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyBvZiB0aGUgcGFja2V0IG51bWJlci4gVGhlIGVuY29kZWQgcGFja2V0IG51bWJlciBpcyBwcm90ZWN0ZWQgYXMgZGVzY3JpYmVkIGluIFNlY3Rpb24gNS40IG9mIFtRVUlDLVRMU10uIFByaW9yIHRvIHJlY2VpdmluZyBhbiBhY2tub3dsZWRnbWVudCBmb3IgYSBwYWNrZXQgbnVtYmVyIHNwYWNlLCB0aGUgZnVsbCBwYWNrZXQgbnVtYmVyIE1VU1QgYmUgaW5jbHVkZWQ7IGl0IGlzIG5vdCB0byBiZSB0cnVuY2F0ZWQsIGFzIGRlc2NyaWJlZCBiZWxvdy4gQWZ0ZXIgYW4gYWNrbm93bGVkZ21lbnQgaXMgcmVjZWl2ZWQgZm9yIGEgcGFja2V0IG51bWJlciBzcGFjZSwgdGhlIHNlbmRlciBNVVNUIHVzZSBhIHBhY2tldCBudW1iZXIgc2l6ZSBhYmxlIHRvIHJlcHJlc2VudCBtb3JlIHRoYW4gdHdpY2UgYXMgbGFyZ2UgYSByYW5nZSBhcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBsYXJnZXN0IGFja25vd2xlZGdlZCBwYWNrZXQgbnVtYmVyIGFuZCB0aGUgcGFja2V0IG51bWJlciBiZWluZyBzZW50LiBBIHBlZXIgcmVjZWl2aW5nIHRoZSBwYWNrZXQgd2lsbCB0aGVuIGNvcnJlY3RseSBkZWNvZGUgdGhlIHBhY2tldCBudW1iZXIsIHVubGVzcyB0aGUgcGFja2V0IGlzIGRlbGF5ZWQgaW4gdHJhbnNpdCBzdWNoIHRoYXQgaXQgYXJyaXZlcyBhZnRlciBtYW55IGhpZ2hlci1udW1iZXJlZCBwYWNrZXRzIGhhdmUgYmVlbiByZWNlaXZlZC4gQW4gZW5kcG9pbnQgU0hPVUxEIHVzZSBhIGxhcmdlIGVub3VnaCBwYWNrZXQgbnVtYmVyIGVuY29kaW5nIHRvIGFsbG93IHRoZSBwYWNrZXQgbnVtYmVyIHRvIGJlIHJlY292ZXJlZCBldmVuIGlmIHRoZSBwYWNrZXQgYXJyaXZlcyBhZnRlciBwYWNrZXRzIHRoYXQgYXJlIHNlbnQgYWZ0ZXJ3YXJkcy4gQXMgYSByZXN1bHQsIHRoZSBzaXplIG9mIHRoZSBwYWNrZXQgbnVtYmVyIGVuY29kaW5nIGlzIGF0IGxlYXN0IG9uZSBiaXQgbW9yZSB0aGFuIHRoZSBiYXNlLTIgbG9nYXJpdGhtIG9mIHRoZSBudW1iZXIgb2YgY29udGlndW91cyB1bmFja25vd2xlZGdlZCBwYWNrZXQgbnVtYmVycywgaW5jbHVkaW5nIHRoZSBuZXcgcGFja2V0LiBQc2V1ZG9jb2RlIGFuZCBhbiBleGFtcGxlIGZvciBwYWNrZXQgbnVtYmVyIGVuY29kaW5nIGNhbiBiZSBmb3VuZCBpbiBBcHBlbmRpeCBBLjIuIEF0IGEgcmVjZWl2ZXIsIHByb3RlY3Rpb24gb2YgdGhlIHBhY2tldCBudW1iZXIgaXMgcmVtb3ZlZCBwcmlvciB0byByZWNvdmVyaW5nIHRoZSBmdWxsIHBhY2tldCBudW1iZXIuIFRoZSBmdWxsIHBhY2tldCBudW1iZXIgaXMgdGhlbiByZWNvbnN0cnVjdGVkIGJhc2VkIG9uIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYml0cyBwcmVzZW50LCB0aGUgdmFsdWUgb2YgdGhvc2UgYml0cywgYW5kIHRoZSBsYXJnZXN0IHBhY2tldCBudW1iZXIgcmVjZWl2ZWQgaW4gYSBzdWNjZXNzZnVsbHkgYXV0aGVudGljYXRlZCBwYWNrZXQuIFJlY292ZXJpbmcgdGhlIGZ1bGwgcGFja2V0IG51bWJlciBpcyBuZWNlc3NhcnkgdG8gc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlIHRoZSByZW1vdmFsIG9mIHBhY2tldCBwcm90ZWN0aW9uLiBPbmNlIGhlYWRlciBwcm90ZWN0aW9uIGlzIHJlbW92ZWQsIHRoZSBwYWNrZXQgbnVtYmVyIGlzIGRlY29kZWQgYnkgZmluZGluZyB0aGUgcGFja2V0IG51bWJlciB2YWx1ZSB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIG5leHQgZXhwZWN0ZWQgcGFja2V0LiBUaGUgbmV4dCBleHBlY3RlZCBwYWNrZXQgaXMgdGhlIGhpZ2hlc3QgcmVjZWl2ZWQgcGFja2V0IG51bWJlciBwbHVzIG9uZS4gUHNldWRvY29kZSBhbmQgYW4gZXhhbXBsZSBmb3IgcGFja2V0IG51bWJlciBkZWNvZGluZyBjYW4gYmUgZm91bmQgaW4gQXBwZW5kaXggQS4zLiAxNy4yLiBMb25nIEhlYWRlciBQYWNrZXRzIExvbmcgSGVhZGVyIFBhY2tldCB7IEhlYWRlciBGb3JtICgxKSA9IDEsIEZpeGVkIEJpdCAoMSkgPSAxLCBMb25nIFBhY2tldCBUeXBlICgyKSwgVHlwZS1TcGVjaWZpYyBCaXRzICg0KSwgVmVyc2lvbiAoMzIpLCBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEIExlbmd0aCAoOCksIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgKDAuLjE2MCksIFNvdXJjZSBDb25uZWN0aW9uIElEIExlbmd0aCAoOCksIFNvdXJjZSBDb25uZWN0aW9uIElEICgwLi4xNjApLCBUeXBlLVNwZWNpZmljIFBheWxvYWQgKC4uKSwgfSBGaWd1cmUgMTM6IExvbmcgSGVhZGVyIFBhY2tldCBGb3JtYXQgTG9uZyBoZWFkZXJzIGFyZSB1c2VkIGZvciBwYWNrZXRzIHRoYXQgYXJlIHNlbnQgcHJpb3IgdG8gdGhlIGVzdGFibGlzaG1lbnQgb2YgMS1SVFQga2V5cy4gT25jZSAxLVJUVCBrZXlzIGFyZSBhdmFpbGFibGUsIGEgc2VuZGVyIHN3aXRjaGVzIHRvIHNlbmRpbmcgcGFja2V0cyB1c2luZyB0aGUgc2hvcnQgaGVhZGVyIChTZWN0aW9uIDE3LjMpLiBUaGUgbG9uZyBmb3JtIGFsbG93cyBmb3Igc3BlY2lhbCBwYWNrZXRzIC0tIHN1Y2ggYXMgdGhlIFZlcnNpb24gTmVnb3RpYXRpb24gcGFja2V0IC0tIHRvIGJlIHJlcHJlc2VudGVkIGluIHRoaXMgdW5pZm9ybSBmaXhlZC1sZW5ndGggcGFja2V0IGZvcm1hdC4gUGFja2V0cyB0aGF0IHVzZSB0aGUgbG9uZyBoZWFkZXIgY29udGFpbiB0aGUgZm9sbG93aW5nIGZpZWxkczogSGVhZGVyIEZvcm06IFRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCAoMHg4MCkgb2YgYnl0ZSAwICh0aGUgZmlyc3QgYnl0ZSkgaXMgc2V0IHRvIDEgZm9yIGxvbmcgaGVhZGVycy4gRml4ZWQgQml0OiBUaGUgbmV4dCBiaXQgKDB4NDApIG9mIGJ5dGUgMCBpcyBzZXQgdG8gMSwgdW5sZXNzIHRoZSBwYWNrZXQgaXMgYSBWZXJzaW9uIE5lZ290aWF0aW9uIHBhY2tldC4gUGFja2V0cyBjb250YWluaW5nIGEgemVybyB2YWx1ZSBmb3IgdGhpcyBiaXQgYXJlIG5vdCB2YWxpZCBwYWNrZXRzIGluIHRoaXMgdmVyc2lvbiBhbmQgTVVTVCBiZSBkaXNjYXJkZWQuIEEgdmFsdWUgb2YgMSBmb3IgdGhpcyBiaXQgYWxsb3dzIFFVSUMgdG8gY29leGlzdCB3aXRoIG90aGVyIHByb3RvY29sczsgc2VlIFtSRkM3OTgzXS4gTG9uZyBQYWNrZXQgVHlwZTogVGhlIG5leHQgdHdvIGJpdHMgKHRob3NlIHdpdGggYSBtYXNrIG9mIDB4MzApIG9mIGJ5dGUgMCBjb250YWluIGEgcGFja2V0IHR5cGUuIFBhY2tldCB0eXBlcyBhcmUgbGlzdGVkIGluIFRhYmxlIDUuIFR5cGUtU3BlY2lmaWMgQml0czogVGhlIHNlbWFudGljcyBvZiB0aGUgbG93ZXIgZm91ciBiaXRzICh0aG9zZSB3aXRoIGEgbWFzayBvZiAweDBmKSBvZiBieXRlIDAgYXJlIGRldGVybWluZWQgYnkgdGhlIHBhY2tldCB0eXBlLiBWZXJzaW9uOiBUaGUgUVVJQyBWZXJzaW9uIGlzIGEgMzItYml0IGZpZWxkIHRoYXQgZm9sbG93cyB0aGUgZmlyc3QgYnl0ZS4gVGhpcyBmaWVsZCBpbmRpY2F0ZXMgdGhlIHZlcnNpb24gb2YgUVVJQyB0aGF0IGlzIGluIHVzZSBhbmQgZGV0ZXJtaW5lcyBob3cgdGhlIHJlc3Qgb2YgdGhlIHByb3RvY29sIGZpZWxkcyBhcmUgaW50ZXJwcmV0ZWQuIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgTGVuZ3RoOiBUaGUgYnl0ZSBmb2xsb3dpbmcgdGhlIHZlcnNpb24gY29udGFpbnMgdGhlIGxlbmd0aCBpbiBieXRlcyBvZiB0aGUgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBmaWVsZCB0aGF0IGZvbGxvd3MgaXQuIFRoaXMgbGVuZ3RoIGlzIGVuY29kZWQgYXMgYW4gOC1iaXQgdW5zaWduZWQgaW50ZWdlci4gSW4gUVVJQyB2ZXJzaW9uIDEsIHRoaXMgdmFsdWUgTVVTVCBOT1QgZXhjZWVkIDIwIGJ5dGVzLiBFbmRwb2ludHMgdGhhdCByZWNlaXZlIGEgdmVyc2lvbiAxIGxvbmcgaGVhZGVyIHdpdGggYSB2YWx1ZSBsYXJnZXIgdGhhbiAyMCBNVVNUIGRyb3AgdGhlIHBhY2tldC4gSW4gb3JkZXIgdG8gcHJvcGVybHkgZm9ybSBhIFZlcnNpb24gTmVnb3RpYXRpb24gcGFja2V0LCBzZXJ2ZXJzIFNIT1VMRCBiZSBhYmxlIHRvIHJlYWQgbG9uZ2VyIGNvbm5lY3Rpb24gSURzIGZyb20gb3RoZXIgUVVJQyB2ZXJzaW9ucy4gRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRDogVGhlIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgZmllbGQgZm9sbG93cyB0aGUgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBMZW5ndGggZmllbGQsIHdoaWNoIGluZGljYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgZmllbGQuIFNlY3Rpb24gNy4yIGRlc2NyaWJlcyB0aGUgdXNlIG9mIHRoaXMgZmllbGQgaW4gbW9yZSBkZXRhaWwuIFNvdXJjZSBDb25uZWN0aW9uIElEIExlbmd0aDogVGhlIGJ5dGUgZm9sbG93aW5nIHRoZSBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEIGNvbnRhaW5zIHRoZSBsZW5ndGggaW4gYnl0ZXMgb2YgdGhlIFNvdXJjZSBDb25uZWN0aW9uIElEIGZpZWxkIHRoYXQgZm9sbG93cyBpdC4gVGhpcyBsZW5ndGggaXMgZW5jb2RlZCBhcyBhbiA4LWJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBJbiBRVUlDIHZlcnNpb24gMSwgdGhpcyB2YWx1ZSBNVVNUIE5PVCBleGNlZWQgMjAgYnl0ZXMuIEVuZHBvaW50cyB0aGF0IHJlY2VpdmUgYSB2ZXJzaW9uIDEgbG9uZyBoZWFkZXIgd2l0aCBhIHZhbHVlIGxhcmdlciB0aGFuIDIwIE1VU1QgZHJvcCB0aGUgcGFja2V0LiBJbiBvcmRlciB0byBwcm9wZXJseSBmb3JtIGEgVmVyc2lvbiBOZWdvdGlhdGlvbiBwYWNrZXQsIHNlcnZlcnMgU0hPVUxEIGJlIGFibGUgdG8gcmVhZCBsb25nZXIgY29ubmVjdGlvbiBJRHMgZnJvbSBvdGhlciBRVUlDIHZlcnNpb25zLiBTb3VyY2UgQ29ubmVjdGlvbiBJRDogVGhlIFNvdXJjZSBDb25uZWN0aW9uIElEIGZpZWxkIGZvbGxvd3MgdGhlIFNvdXJjZSBDb25uZWN0aW9uIElEIExlbmd0aCBmaWVsZCwgd2hpY2ggaW5kaWNhdGVzIHRoZSBsZW5ndGggb2YgdGhpcyBmaWVsZC4gU2VjdGlvbiA3LjIgZGVzY3JpYmVzIHRoZSB1c2Ugb2YgdGhpcyBmaWVsZCBpbiBtb3JlIGRldGFpbC4gVHlwZS1TcGVjaWZpYyBQYXlsb2FkOiBUaGUgcmVtYWluZGVyIG9mIHRoZSBwYWNrZXQsIGlmIGFueSwgaXMgdHlwZSBzcGVjaWZpYy4gSW4gdGhpcyB2ZXJzaW9uIG9mIFFVSUMsIHRoZSBmb2xsb3dpbmcgcGFja2V0IHR5cGVzIHdpdGggdGhlIGxvbmcgaGVhZGVyIGFyZSBkZWZpbmVkOiArPT09PT09Kz09PT09PT09PT09Kz09PT09PT09PT09PT09PT0rIHwgVHlwZSB8IE5hbWUgfCBTZWN0aW9uIHwgKz09PT09PSs9PT09PT09PT09PSs9PT09PT09PT09PT09PT09KyB8IDB4MDAgfCBJbml0aWFsIHwgU2VjdGlvbiAxNy4yLjIgfCArLS0tLS0tKy0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0rIHwgMHgwMSB8IDAtUlRUIHwgU2VjdGlvbiAxNy4yLjMgfCArLS0tLS0tKy0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0rIHwgMHgwMiB8IEhhbmRzaGFrZSB8IFNlY3Rpb24gMTcuMi40IHwgKy0tLS0tLSstLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tKyB8IDB4MDMgfCBSZXRyeSB8IFNlY3Rpb24gMTcuMi41IHwgKy0tLS0tLSstLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tKyBUYWJsZSA1OiBMb25nIEhlYWRlciBQYWNrZXQgVHlwZXMgVGhlIGhlYWRlciBmb3JtIGJpdCwgRGVzdGluYXRpb24gYW5kIFNvdXJjZSBDb25uZWN0aW9uIElEIGxlbmd0aHMsIERlc3RpbmF0aW9uIGFuZCBTb3VyY2UgQ29ubmVjdGlvbiBJRCBmaWVsZHMsIGFuZCBWZXJzaW9uIGZpZWxkcyBvZiBhIGxvbmcgaGVhZGVyIHBhY2tldCBhcmUgdmVyc2lvbiBpbmRlcGVuZGVudC4gVGhlIG90aGVyIGZpZWxkcyBpbiB0aGUgZmlyc3QgYnl0ZSBhcmUgdmVyc2lvbiBzcGVjaWZpYy4gU2VlIFtRVUlDLUlOVkFSSUFOVFNdIGZvciBkZXRhaWxzIG9uIGhvdyBwYWNrZXRzIGZyb20gZGlmZmVyZW50IHZlcnNpb25zIG9mIFFVSUMgYXJlIGludGVycHJldGVkLiBUaGUgaW50ZXJwcmV0YXRpb24gb2YgdGhlIGZpZWxkcyBhbmQgdGhlIHBheWxvYWQgYXJlIHNwZWNpZmljIHRvIGEgdmVyc2lvbiBhbmQgcGFja2V0IHR5cGUuIFdoaWxlIHR5cGUtc3BlY2lmaWMgc2VtYW50aWNzIGZvciB0aGlzIHZlcnNpb24gYXJlIGRlc2NyaWJlZCBpbiB0aGUgZm9sbG93aW5nIHNlY3Rpb25zLCBzZXZlcmFsIGxvbmcgaGVhZGVyIHBhY2tldHMgaW4gdGhpcyB2ZXJzaW9uIG9mIFFVSUMgY29udGFpbiB0aGVzZSBhZGRpdGlvbmFsIGZpZWxkczogUmVzZXJ2ZWQgQml0czogVHdvIGJpdHMgKHRob3NlIHdpdGggYSBtYXNrIG9mIDB4MGMpIG9mIGJ5dGUgMCBhcmUgcmVzZXJ2ZWQgYWNyb3NzIG11bHRpcGxlIHBhY2tldCB0eXBlcy4gVGhlc2UgYml0cyBhcmUgcHJvdGVjdGVkIHVzaW5nIGhlYWRlciBwcm90ZWN0aW9uOyBzZWUgU2VjdGlvbiA1LjQgb2YgW1FVSUMtVExTXS4gVGhlIHZhbHVlIGluY2x1ZGVkIHByaW9yIHRvIHByb3RlY3Rpb24gTVVTVCBiZSBzZXQgdG8gMC4gQW4gZW5kcG9pbnQgTVVTVCB0cmVhdCByZWNlaXB0IG9mIGEgcGFja2V0IHRoYXQgaGFzIGEgbm9uLXplcm8gdmFsdWUgZm9yIHRoZXNlIGJpdHMgYWZ0ZXIgcmVtb3ZpbmcgYm90aCBwYWNrZXQgYW5kIGhlYWRlciBwcm90ZWN0aW9uIGFzIGEgY29ubmVjdGlvbiBlcnJvciBvZiB0eXBlIFBST1RPQ09MX1ZJT0xBVElPTi4gRGlzY2FyZGluZyBzdWNoIGEgcGFja2V0IGFmdGVyIG9ubHkgcmVtb3ZpbmcgaGVhZGVyIHByb3RlY3Rpb24gY2FuIGV4cG9zZSB0aGUgZW5kcG9pbnQgdG8gYXR0YWNrczsgc2VlIFNlY3Rpb24gOS41IG9mIFtRVUlDLVRMU10uIFBhY2tldCBOdW1iZXIgTGVuZ3RoOiBJbiBwYWNrZXQgdHlwZXMgdGhhdCBjb250YWluIGEgUGFja2V0IE51bWJlciBmaWVsZCwgdGhlIGxlYXN0IHNpZ25pZmljYW50IHR3byBiaXRzICh0aG9zZSB3aXRoIGEgbWFzayBvZiAweDAzKSBvZiBieXRlIDAgY29udGFpbiB0aGUgbGVuZ3RoIG9mIHRoZSBQYWNrZXQgTnVtYmVyIGZpZWxkLCBlbmNvZGVkIGFzIGFuIHVuc2lnbmVkIHR3by1iaXQgaW50ZWdlciB0aGF0IGlzIG9uZSBsZXNzIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgUGFja2V0IE51bWJlciBmaWVsZCBpbiBieXRlcy4gVGhhdCBpcywgdGhlIGxlbmd0aCBvZiB0aGUgUGFja2V0IE51bWJlciBmaWVsZCBpcyB0aGUgdmFsdWUgb2YgdGhpcyBmaWVsZCBwbHVzIG9uZS4gVGhlc2UgYml0cyBhcmUgcHJvdGVjdGVkIHVzaW5nIGhlYWRlciBwcm90ZWN0aW9uOyBzZWUgU2VjdGlvbiA1LjQgb2YgW1FVSUMtVExTXS4gTGVuZ3RoOiBUaGlzIGlzIHRoZSBsZW5ndGggb2YgdGhlIHJlbWFpbmRlciBvZiB0aGUgcGFja2V0ICh0aGF0IGlzLCB0aGUgUGFja2V0IE51bWJlciBhbmQgUGF5bG9hZCBmaWVsZHMpIGluIGJ5dGVzLCBlbmNvZGVkIGFzIGEgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgKFNlY3Rpb24gMTYpLiBQYWNrZXQgTnVtYmVyOiBUaGlzIGZpZWxkIGlzIDEgdG8gNCBieXRlcyBsb25nLiBUaGUgcGFja2V0IG51bWJlciBpcyBwcm90ZWN0ZWQgdXNpbmcgaGVhZGVyIHByb3RlY3Rpb247IHNlZSBTZWN0aW9uIDUuNCBvZiBbUVVJQy1UTFNdLiBUaGUgbGVuZ3RoIG9mIHRoZSBQYWNrZXQgTnVtYmVyIGZpZWxkIGlzIGVuY29kZWQgaW4gdGhlIFBhY2tldCBOdW1iZXIgTGVuZ3RoIGJpdHMgb2YgYnl0ZSAwOyBzZWUgYWJvdmUuIFBhY2tldCBQYXlsb2FkOiBUaGlzIGlzIHRoZSBwYXlsb2FkIG9mIHRoZSBwYWNrZXQgLS0gY29udGFpbmluZyBhIHNlcXVlbmNlIG9mIGZyYW1lcyAtLSB0aGF0IGlzIHByb3RlY3RlZCB1c2luZyBwYWNrZXQgcHJvdGVjdGlvbi4gMTcuMi4xLiBWZXJzaW9uIE5lZ290aWF0aW9uIFBhY2tldCBBIFZlcnNpb24gTmVnb3RpYXRpb24gcGFja2V0IGlzIGluaGVyZW50bHkgbm90IHZlcnNpb24gc3BlY2lmaWMuIFVwb24gcmVjZWlwdCBieSBhIGNsaWVudCwgaXQgd2lsbCBiZSBpZGVudGlmaWVkIGFzIGEgVmVyc2lvbiBOZWdvdGlhdGlvbiBwYWNrZXQgYmFzZWQgb24gdGhlIFZlcnNpb24gZmllbGQgaGF2aW5nIGEgdmFsdWUgb2YgMC4gVGhlIFZlcnNpb24gTmVnb3RpYXRpb24gcGFja2V0IGlzIGEgcmVzcG9uc2UgdG8gYSBjbGllbnQgcGFja2V0IHRoYXQgY29udGFpbnMgYSB2ZXJzaW9uIHRoYXQgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgc2VydmVyLiBJdCBpcyBvbmx5IHNlbnQgYnkgc2VydmVycy4gVGhlIGxheW91dCBvZiBhIFZlcnNpb24gTmVnb3RpYXRpb24gcGFja2V0IGlzOiBWZXJzaW9uIE5lZ290aWF0aW9uIFBhY2tldCB7IEhlYWRlciBGb3JtICgxKSA9IDEsIFVudXNlZCAoNyksIFZlcnNpb24gKDMyKSA9IDAsIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgTGVuZ3RoICg4KSwgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCAoMC4uMjA0MCksIFNvdXJjZSBDb25uZWN0aW9uIElEIExlbmd0aCAoOCksIFNvdXJjZSBDb25uZWN0aW9uIElEICgwLi4yMDQwKSwgU3VwcG9ydGVkIFZlcnNpb24gKDMyKSAuLi4sIH0gRmlndXJlIDE0OiBWZXJzaW9uIE5lZ290aWF0aW9uIFBhY2tldCBUaGUgdmFsdWUgaW4gdGhlIFVudXNlZCBmaWVsZCBpcyBzZXQgdG8gYW4gYXJiaXRyYXJ5IHZhbHVlIGJ5IHRoZSBzZXJ2ZXIuIENsaWVudHMgTVVTVCBpZ25vcmUgdGhlIHZhbHVlIG9mIHRoaXMgZmllbGQuIFdoZXJlIFFVSUMgbWlnaHQgYmUgbXVsdGlwbGV4ZWQgd2l0aCBvdGhlciBwcm90b2NvbHMgKHNlZSBbUkZDNzk4M10pLCBzZXJ2ZXJzIFNIT1VMRCBzZXQgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoaXMgZmllbGQgKDB4NDApIHRvIDEgc28gdGhhdCBWZXJzaW9uIE5lZ290aWF0aW9uIHBhY2tldHMgYXBwZWFyIHRvIGhhdmUgdGhlIEZpeGVkIEJpdCBmaWVsZC4gTm90ZSB0aGF0IG90aGVyIHZlcnNpb25zIG9mIFFVSUMgbWlnaHQgbm90IG1ha2UgYSBzaW1pbGFyIHJlY29tbWVuZGF0aW9uLiBUaGUgVmVyc2lvbiBmaWVsZCBvZiBhIFZlcnNpb24gTmVnb3RpYXRpb24gcGFja2V0IE1VU1QgYmUgc2V0IHRvIDB4MDAwMDAwMDAuIFRoZSBzZXJ2ZXIgTVVTVCBpbmNsdWRlIHRoZSB2YWx1ZSBmcm9tIHRoZSBTb3VyY2UgQ29ubmVjdGlvbiBJRCBmaWVsZCBvZiB0aGUgcGFja2V0IGl0IHJlY2VpdmVzIGluIHRoZSBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEIGZpZWxkLiBUaGUgdmFsdWUgZm9yIFNvdXJjZSBDb25uZWN0aW9uIElEIE1VU1QgYmUgY29waWVkIGZyb20gdGhlIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgb2YgdGhlIHJlY2VpdmVkIHBhY2tldCwgd2hpY2ggaXMgaW5pdGlhbGx5IHJhbmRvbWx5IHNlbGVjdGVkIGJ5IGEgY2xpZW50LiBFY2hvaW5nIGJvdGggY29ubmVjdGlvbiBJRHMgZ2l2ZXMgY2xpZW50cyBzb21lIGFzc3VyYW5jZSB0aGF0IHRoZSBzZXJ2ZXIgcmVjZWl2ZWQgdGhlIHBhY2tldCBhbmQgdGhhdCB0aGUgVmVyc2lvbiBOZWdvdGlhdGlvbiBwYWNrZXQgd2FzIG5vdCBnZW5lcmF0ZWQgYnkgYW4gZW50aXR5IHRoYXQgZGlkIG5vdCBvYnNlcnZlIHRoZSBJbml0aWFsIHBhY2tldC4gRnV0dXJlIHZlcnNpb25zIG9mIFFVSUMgY291bGQgaGF2ZSBkaWZmZXJlbnQgcmVxdWlyZW1lbnRzIGZvciB0aGUgbGVuZ3RocyBvZiBjb25uZWN0aW9uIElEcy4gSW4gcGFydGljdWxhciwgY29ubmVjdGlvbiBJRHMgbWlnaHQgaGF2ZSBhIHNtYWxsZXIgbWluaW11bSBsZW5ndGggb3IgYSBncmVhdGVyIG1heGltdW0gbGVuZ3RoLiBWZXJzaW9uLSBzcGVjaWZpYyBydWxlcyBmb3IgdGhlIGNvbm5lY3Rpb24gSUQgdGhlcmVmb3JlIE1VU1QgTk9UIGluZmx1ZW5jZSBhIGRlY2lzaW9uIGFib3V0IHdoZXRoZXIgdG8gc2VuZCBhIFZlcnNpb24gTmVnb3RpYXRpb24gcGFja2V0LiBUaGUgcmVtYWluZGVyIG9mIHRoZSBWZXJzaW9uIE5lZ290aWF0aW9uIHBhY2tldCBpcyBhIGxpc3Qgb2YgMzItYml0IHZlcnNpb25zIHRoYXQgdGhlIHNlcnZlciBzdXBwb3J0cy4gQSBWZXJzaW9uIE5lZ290aWF0aW9uIHBhY2tldCBpcyBub3QgYWNrbm93bGVkZ2VkLiBJdCBpcyBvbmx5IHNlbnQgaW4gcmVzcG9uc2UgdG8gYSBwYWNrZXQgdGhhdCBpbmRpY2F0ZXMgYW4gdW5zdXBwb3J0ZWQgdmVyc2lvbjsgc2VlIFNlY3Rpb24gNS4yLjIuIFRoZSBWZXJzaW9uIE5lZ290aWF0aW9uIHBhY2tldCBkb2VzIG5vdCBpbmNsdWRlIHRoZSBQYWNrZXQgTnVtYmVyIGFuZCBMZW5ndGggZmllbGRzIHByZXNlbnQgaW4gb3RoZXIgcGFja2V0cyB0aGF0IHVzZSB0aGUgbG9uZyBoZWFkZXIgZm9ybS4gQ29uc2VxdWVudGx5LCBhIFZlcnNpb24gTmVnb3RpYXRpb24gcGFja2V0IGNvbnN1bWVzIGFuIGVudGlyZSBVRFAgZGF0YWdyYW0uIEEgc2VydmVyIE1VU1QgTk9UIHNlbmQgbW9yZSB0aGFuIG9uZSBWZXJzaW9uIE5lZ290aWF0aW9uIHBhY2tldCBpbiByZXNwb25zZSB0byBhIHNpbmdsZSBVRFAgZGF0YWdyYW0uIFNlZSBTZWN0aW9uIDYgZm9yIGEgZGVzY3JpcHRpb24gb2YgdGhlIHZlcnNpb24gbmVnb3RpYXRpb24gcHJvY2Vzcy4gMTcuMi4yLiBJbml0aWFsIFBhY2tldCBBbiBJbml0aWFsIHBhY2tldCB1c2VzIGxvbmcgaGVhZGVycyB3aXRoIGEgdHlwZSB2YWx1ZSBvZiAweDAwLiBJdCBjYXJyaWVzIHRoZSBmaXJzdCBDUllQVE8gZnJhbWVzIHNlbnQgYnkgdGhlIGNsaWVudCBhbmQgc2VydmVyIHRvIHBlcmZvcm0ga2V5IGV4Y2hhbmdlLCBhbmQgaXQgY2FycmllcyBBQ0sgZnJhbWVzIGluIGVpdGhlciBkaXJlY3Rpb24uIEluaXRpYWwgUGFja2V0IHsgSGVhZGVyIEZvcm0gKDEpID0gMSwgRml4ZWQgQml0ICgxKSA9IDEsIExvbmcgUGFja2V0IFR5cGUgKDIpID0gMCwgUmVzZXJ2ZWQgQml0cyAoMiksIFBhY2tldCBOdW1iZXIgTGVuZ3RoICgyKSwgVmVyc2lvbiAoMzIpLCBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEIExlbmd0aCAoOCksIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgKDAuLjE2MCksIFNvdXJjZSBDb25uZWN0aW9uIElEIExlbmd0aCAoOCksIFNvdXJjZSBDb25uZWN0aW9uIElEICgwLi4xNjApLCBUb2tlbiBMZW5ndGggKGkpLCBUb2tlbiAoLi4pLCBMZW5ndGggKGkpLCBQYWNrZXQgTnVtYmVyICg4Li4zMiksIFBhY2tldCBQYXlsb2FkICg4Li4pLCB9IEZpZ3VyZSAxNTogSW5pdGlhbCBQYWNrZXQgVGhlIEluaXRpYWwgcGFja2V0IGNvbnRhaW5zIGEgbG9uZyBoZWFkZXIgYXMgd2VsbCBhcyB0aGUgTGVuZ3RoIGFuZCBQYWNrZXQgTnVtYmVyIGZpZWxkczsgc2VlIFNlY3Rpb24gMTcuMi4gVGhlIGZpcnN0IGJ5dGUgY29udGFpbnMgdGhlIFJlc2VydmVkIGFuZCBQYWNrZXQgTnVtYmVyIExlbmd0aCBiaXRzOyBzZWUgYWxzbyBTZWN0aW9uIDE3LjIuIEJldHdlZW4gdGhlIFNvdXJjZSBDb25uZWN0aW9uIElEIGFuZCBMZW5ndGggZmllbGRzLCB0aGVyZSBhcmUgdHdvIGFkZGl0aW9uYWwgZmllbGRzIHNwZWNpZmljIHRvIHRoZSBJbml0aWFsIHBhY2tldC4gVG9rZW4gTGVuZ3RoOiBBIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIHNwZWNpZnlpbmcgdGhlIGxlbmd0aCBvZiB0aGUgVG9rZW4gZmllbGQsIGluIGJ5dGVzLiBUaGlzIHZhbHVlIGlzIDAgaWYgbm8gdG9rZW4gaXMgcHJlc2VudC4gSW5pdGlhbCBwYWNrZXRzIHNlbnQgYnkgdGhlIHNlcnZlciBNVVNUIHNldCB0aGUgVG9rZW4gTGVuZ3RoIGZpZWxkIHRvIDA7IGNsaWVudHMgdGhhdCByZWNlaXZlIGFuIEluaXRpYWwgcGFja2V0IHdpdGggYSBub24temVybyBUb2tlbiBMZW5ndGggZmllbGQgTVVTVCBlaXRoZXIgZGlzY2FyZCB0aGUgcGFja2V0IG9yIGdlbmVyYXRlIGEgY29ubmVjdGlvbiBlcnJvciBvZiB0eXBlIFBST1RPQ09MX1ZJT0xBVElPTi4gVG9rZW46IFRoZSB2YWx1ZSBvZiB0aGUgdG9rZW4gdGhhdCB3YXMgcHJldmlvdXNseSBwcm92aWRlZCBpbiBhIFJldHJ5IHBhY2tldCBvciBORVdfVE9LRU4gZnJhbWU7IHNlZSBTZWN0aW9uIDguMS4gSW4gb3JkZXIgdG8gcHJldmVudCB0YW1wZXJpbmcgYnkgdmVyc2lvbi11bmF3YXJlIG1pZGRsZWJveGVzLCBJbml0aWFsIHBhY2tldHMgYXJlIHByb3RlY3RlZCB3aXRoIGNvbm5lY3Rpb24tIGFuZCB2ZXJzaW9uLXNwZWNpZmljIGtleXMgKEluaXRpYWwga2V5cykgYXMgZGVzY3JpYmVkIGluIFtRVUlDLVRMU10uIFRoaXMgcHJvdGVjdGlvbiBkb2VzIG5vdCBwcm92aWRlIGNvbmZpZGVudGlhbGl0eSBvciBpbnRlZ3JpdHkgYWdhaW5zdCBhdHRhY2tlcnMgdGhhdCBjYW4gb2JzZXJ2ZSBwYWNrZXRzLCBidXQgaXQgZG9lcyBwcmV2ZW50IGF0dGFja2VycyB0aGF0IGNhbm5vdCBvYnNlcnZlIHBhY2tldHMgZnJvbSBzcG9vZmluZyBJbml0aWFsIHBhY2tldHMuIFRoZSBjbGllbnQgYW5kIHNlcnZlciB1c2UgdGhlIEluaXRpYWwgcGFja2V0IHR5cGUgZm9yIGFueSBwYWNrZXQgdGhhdCBjb250YWlucyBhbiBpbml0aWFsIGNyeXB0b2dyYXBoaWMgaGFuZHNoYWtlIG1lc3NhZ2UuIFRoaXMgaW5jbHVkZXMgYWxsIGNhc2VzIHdoZXJlIGEgbmV3IHBhY2tldCBjb250YWluaW5nIHRoZSBpbml0aWFsIGNyeXB0b2dyYXBoaWMgbWVzc2FnZSBuZWVkcyB0byBiZSBjcmVhdGVkLCBzdWNoIGFzIHRoZSBwYWNrZXRzIHNlbnQgYWZ0ZXIgcmVjZWl2aW5nIGEgUmV0cnkgcGFja2V0OyBzZWUgU2VjdGlvbiAxNy4yLjUuIEEgc2VydmVyIHNlbmRzIGl0cyBmaXJzdCBJbml0aWFsIHBhY2tldCBpbiByZXNwb25zZSB0byBhIGNsaWVudCBJbml0aWFsLiBBIHNlcnZlciBNQVkgc2VuZCBtdWx0aXBsZSBJbml0aWFsIHBhY2tldHMuIFRoZSBjcnlwdG9ncmFwaGljIGtleSBleGNoYW5nZSBjb3VsZCByZXF1aXJlIG11bHRpcGxlIHJvdW5kIHRyaXBzIG9yIHJldHJhbnNtaXNzaW9ucyBvZiB0aGlzIGRhdGEuIFRoZSBwYXlsb2FkIG9mIGFuIEluaXRpYWwgcGFja2V0IGluY2x1ZGVzIGEgQ1JZUFRPIGZyYW1lIChvciBmcmFtZXMpIGNvbnRhaW5pbmcgYSBjcnlwdG9ncmFwaGljIGhhbmRzaGFrZSBtZXNzYWdlLCBBQ0sgZnJhbWVzLCBvciBib3RoLiBQSU5HLCBQQURESU5HLCBhbmQgQ09OTkVDVElPTl9DTE9TRSBmcmFtZXMgb2YgdHlwZSAweDFjIGFyZSBhbHNvIHBlcm1pdHRlZC4gQW4gZW5kcG9pbnQgdGhhdCByZWNlaXZlcyBhbiBJbml0aWFsIHBhY2tldCBjb250YWluaW5nIG90aGVyIGZyYW1lcyBjYW4gZWl0aGVyIGRpc2NhcmQgdGhlIHBhY2tldCBhcyBzcHVyaW91cyBvciB0cmVhdCBpdCBhcyBhIGNvbm5lY3Rpb24gZXJyb3IuIFRoZSBmaXJzdCBwYWNrZXQgc2VudCBieSBhIGNsaWVudCBhbHdheXMgaW5jbHVkZXMgYSBDUllQVE8gZnJhbWUgdGhhdCBjb250YWlucyB0aGUgc3RhcnQgb3IgYWxsIG9mIHRoZSBmaXJzdCBjcnlwdG9ncmFwaGljIGhhbmRzaGFrZSBtZXNzYWdlLiBUaGUgZmlyc3QgQ1JZUFRPIGZyYW1lIHNlbnQgYWx3YXlzIGJlZ2lucyBhdCBhbiBvZmZzZXQgb2YgMDsgc2VlIFNlY3Rpb24gNy4gTm90ZSB0aGF0IGlmIHRoZSBzZXJ2ZXIgc2VuZHMgYSBUTFMgSGVsbG9SZXRyeVJlcXVlc3QgKHNlZSBTZWN0aW9uIDQuNyBvZiBbUVVJQy1UTFNdKSwgdGhlIGNsaWVudCB3aWxsIHNlbmQgYW5vdGhlciBzZXJpZXMgb2YgSW5pdGlhbCBwYWNrZXRzLiBUaGVzZSBJbml0aWFsIHBhY2tldHMgd2lsbCBjb250aW51ZSB0aGUgY3J5cHRvZ3JhcGhpYyBoYW5kc2hha2UgYW5kIHdpbGwgY29udGFpbiBDUllQVE8gZnJhbWVzIHN0YXJ0aW5nIGF0IGFuIG9mZnNldCBtYXRjaGluZyB0aGUgc2l6ZSBvZiB0aGUgQ1JZUFRPIGZyYW1lcyBzZW50IGluIHRoZSBmaXJzdCBmbGlnaHQgb2YgSW5pdGlhbCBwYWNrZXRzLiAxNy4yLjIuMS4gQWJhbmRvbmluZyBJbml0aWFsIFBhY2tldHMgQSBjbGllbnQgc3RvcHMgYm90aCBzZW5kaW5nIGFuZCBwcm9jZXNzaW5nIEluaXRpYWwgcGFja2V0cyB3aGVuIGl0IHNlbmRzIGl0cyBmaXJzdCBIYW5kc2hha2UgcGFja2V0LiBBIHNlcnZlciBzdG9wcyBzZW5kaW5nIGFuZCBwcm9jZXNzaW5nIEluaXRpYWwgcGFja2V0cyB3aGVuIGl0IHJlY2VpdmVzIGl0cyBmaXJzdCBIYW5kc2hha2UgcGFja2V0LiBUaG91Z2ggcGFja2V0cyBtaWdodCBzdGlsbCBiZSBpbiBmbGlnaHQgb3IgYXdhaXRpbmcgYWNrbm93bGVkZ21lbnQsIG5vIGZ1cnRoZXIgSW5pdGlhbCBwYWNrZXRzIG5lZWQgdG8gYmUgZXhjaGFuZ2VkIGJleW9uZCB0aGlzIHBvaW50LiBJbml0aWFsIHBhY2tldCBwcm90ZWN0aW9uIGtleXMgYXJlIGRpc2NhcmRlZCAoc2VlIFNlY3Rpb24gNC45LjEgb2YgW1FVSUMtVExTXSkgYWxvbmcgd2l0aCBhbnkgbG9zcyByZWNvdmVyeSBhbmQgY29uZ2VzdGlvbiBjb250cm9sIHN0YXRlOyBzZWUgU2VjdGlvbiA2LjQgb2YgW1FVSUMtUkVDT1ZFUlldLiBBbnkgZGF0YSBpbiBDUllQVE8gZnJhbWVzIGlzIGRpc2NhcmRlZCAtLSBhbmQgbm8gbG9uZ2VyIHJldHJhbnNtaXR0ZWQgLS0gd2hlbiBJbml0aWFsIGtleXMgYXJlIGRpc2NhcmRlZC4gMTcuMi4zLiAwLVJUVCBBIDAtUlRUIHBhY2tldCB1c2VzIGxvbmcgaGVhZGVycyB3aXRoIGEgdHlwZSB2YWx1ZSBvZiAweDAxLCBmb2xsb3dlZCBieSB0aGUgTGVuZ3RoIGFuZCBQYWNrZXQgTnVtYmVyIGZpZWxkczsgc2VlIFNlY3Rpb24gMTcuMi4gVGhlIGZpcnN0IGJ5dGUgY29udGFpbnMgdGhlIFJlc2VydmVkIGFuZCBQYWNrZXQgTnVtYmVyIExlbmd0aCBiaXRzOyBzZWUgU2VjdGlvbiAxNy4yLiBBIDAtUlRUIHBhY2tldCBpcyB1c2VkIHRvIGNhcnJ5ICJlYXJseSIgZGF0YSBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciBhcyBwYXJ0IG9mIHRoZSBmaXJzdCBmbGlnaHQsIHByaW9yIHRvIGhhbmRzaGFrZSBjb21wbGV0aW9uLiBBcyBwYXJ0IG9mIHRoZSBUTFMgaGFuZHNoYWtlLCB0aGUgc2VydmVyIGNhbiBhY2NlcHQgb3IgcmVqZWN0IHRoaXMgZWFybHkgZGF0YS4gU2VlIFNlY3Rpb24gMi4zIG9mIFtUTFMxM10gZm9yIGEgZGlzY3Vzc2lvbiBvZiAwLVJUVCBkYXRhIGFuZCBpdHMgbGltaXRhdGlvbnMuIDAtUlRUIFBhY2tldCB7IEhlYWRlciBGb3JtICgxKSA9IDEsIEZpeGVkIEJpdCAoMSkgPSAxLCBMb25nIFBhY2tldCBUeXBlICgyKSA9IDEsIFJlc2VydmVkIEJpdHMgKDIpLCBQYWNrZXQgTnVtYmVyIExlbmd0aCAoMiksIFZlcnNpb24gKDMyKSwgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBMZW5ndGggKDgpLCBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEICgwLi4xNjApLCBTb3VyY2UgQ29ubmVjdGlvbiBJRCBMZW5ndGggKDgpLCBTb3VyY2UgQ29ubmVjdGlvbiBJRCAoMC4uMTYwKSwgTGVuZ3RoIChpKSwgUGFja2V0IE51bWJlciAoOC4uMzIpLCBQYWNrZXQgUGF5bG9hZCAoOC4uKSwgfSBGaWd1cmUgMTY6IDAtUlRUIFBhY2tldCBQYWNrZXQgbnVtYmVycyBmb3IgMC1SVFQgcHJvdGVjdGVkIHBhY2tldHMgdXNlIHRoZSBzYW1lIHNwYWNlIGFzIDEtUlRUIHByb3RlY3RlZCBwYWNrZXRzLiBBZnRlciBhIGNsaWVudCByZWNlaXZlcyBhIFJldHJ5IHBhY2tldCwgMC1SVFQgcGFja2V0cyBhcmUgbGlrZWx5IHRvIGhhdmUgYmVlbiBsb3N0IG9yIGRpc2NhcmRlZCBieSB0aGUgc2VydmVyLiBBIGNsaWVudCBTSE9VTEQgYXR0ZW1wdCB0byByZXNlbmQgZGF0YSBpbiAwLVJUVCBwYWNrZXRzIGFmdGVyIGl0IHNlbmRzIGEgbmV3IEluaXRpYWwgcGFja2V0LiBOZXcgcGFja2V0IG51bWJlcnMgTVVTVCBiZSB1c2VkIGZvciBhbnkgbmV3IHBhY2tldHMgdGhhdCBhcmUgc2VudDsgYXMgZGVzY3JpYmVkIGluIFNlY3Rpb24gMTcuMi41LjMsIHJldXNpbmcgcGFja2V0IG51bWJlcnMgY291bGQgY29tcHJvbWlzZSBwYWNrZXQgcHJvdGVjdGlvbi4gQSBjbGllbnQgb25seSByZWNlaXZlcyBhY2tub3dsZWRnbWVudHMgZm9yIGl0cyAwLVJUVCBwYWNrZXRzIG9uY2UgdGhlIGhhbmRzaGFrZSBpcyBjb21wbGV0ZSwgYXMgZGVmaW5lZCBpbiBTZWN0aW9uIDQuMS4xIG9mIFtRVUlDLVRMU10uIEEgY2xpZW50IE1VU1QgTk9UIHNlbmQgMC1SVFQgcGFja2V0cyBvbmNlIGl0IHN0YXJ0cyBwcm9jZXNzaW5nIDEtUlRUIHBhY2tldHMgZnJvbSB0aGUgc2VydmVyLiBUaGlzIG1lYW5zIHRoYXQgMC1SVFQgcGFja2V0cyBjYW5ub3QgY29udGFpbiBhbnkgcmVzcG9uc2UgdG8gZnJhbWVzIGZyb20gMS1SVFQgcGFja2V0cy4gRm9yIGluc3RhbmNlLCBhIGNsaWVudCBjYW5ub3Qgc2VuZCBhbiBBQ0sgZnJhbWUgaW4gYSAwLVJUVCBwYWNrZXQsIGJlY2F1c2UgdGhhdCBjYW4gb25seSBhY2tub3dsZWRnZSBhIDEtUlRUIHBhY2tldC4gQW4gYWNrbm93bGVkZ21lbnQgZm9yIGEgMS1SVFQgcGFja2V0IE1VU1QgYmUgY2FycmllZCBpbiBhIDEtUlRUIHBhY2tldC4gQSBzZXJ2ZXIgU0hPVUxEIHRyZWF0IGEgdmlvbGF0aW9uIG9mIHJlbWVtYmVyZWQgbGltaXRzIChTZWN0aW9uIDcuNC4xKSBhcyBhIGNvbm5lY3Rpb24gZXJyb3Igb2YgYW4gYXBwcm9wcmlhdGUgdHlwZSAoZm9yIGluc3RhbmNlLCBhIEZMT1dfQ09OVFJPTF9FUlJPUiBmb3IgZXhjZWVkaW5nIHN0cmVhbSBkYXRhIGxpbWl0cykuIDE3LjIuNC4gSGFuZHNoYWtlIFBhY2tldCBBIEhhbmRzaGFrZSBwYWNrZXQgdXNlcyBsb25nIGhlYWRlcnMgd2l0aCBhIHR5cGUgdmFsdWUgb2YgMHgwMiwgZm9sbG93ZWQgYnkgdGhlIExlbmd0aCBhbmQgUGFja2V0IE51bWJlciBmaWVsZHM7IHNlZSBTZWN0aW9uIDE3LjIuIFRoZSBmaXJzdCBieXRlIGNvbnRhaW5zIHRoZSBSZXNlcnZlZCBhbmQgUGFja2V0IE51bWJlciBMZW5ndGggYml0czsgc2VlIFNlY3Rpb24gMTcuMi4gSXQgaXMgdXNlZCB0byBjYXJyeSBjcnlwdG9ncmFwaGljIGhhbmRzaGFrZSBtZXNzYWdlcyBhbmQgYWNrbm93bGVkZ21lbnRzIGZyb20gdGhlIHNlcnZlciBhbmQgY2xpZW50LiBIYW5kc2hha2UgUGFja2V0IHsgSGVhZGVyIEZvcm0gKDEpID0gMSwgRml4ZWQgQml0ICgxKSA9IDEsIExvbmcgUGFja2V0IFR5cGUgKDIpID0gMiwgUmVzZXJ2ZWQgQml0cyAoMiksIFBhY2tldCBOdW1iZXIgTGVuZ3RoICgyKSwgVmVyc2lvbiAoMzIpLCBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEIExlbmd0aCAoOCksIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgKDAuLjE2MCksIFNvdXJjZSBDb25uZWN0aW9uIElEIExlbmd0aCAoOCksIFNvdXJjZSBDb25uZWN0aW9uIElEICgwLi4xNjApLCBMZW5ndGggKGkpLCBQYWNrZXQgTnVtYmVyICg4Li4zMiksIFBhY2tldCBQYXlsb2FkICg4Li4pLCB9IEZpZ3VyZSAxNzogSGFuZHNoYWtlIFByb3RlY3RlZCBQYWNrZXQgT25jZSBhIGNsaWVudCBoYXMgcmVjZWl2ZWQgYSBIYW5kc2hha2UgcGFja2V0IGZyb20gYSBzZXJ2ZXIsIGl0IHVzZXMgSGFuZHNoYWtlIHBhY2tldHMgdG8gc2VuZCBzdWJzZXF1ZW50IGNyeXB0b2dyYXBoaWMgaGFuZHNoYWtlIG1lc3NhZ2VzIGFuZCBhY2tub3dsZWRnbWVudHMgdG8gdGhlIHNlcnZlci4gVGhlIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgZmllbGQgaW4gYSBIYW5kc2hha2UgcGFja2V0IGNvbnRhaW5zIGEgY29ubmVjdGlvbiBJRCB0aGF0IGlzIGNob3NlbiBieSB0aGUgcmVjaXBpZW50IG9mIHRoZSBwYWNrZXQ7IHRoZSBTb3VyY2UgQ29ubmVjdGlvbiBJRCBpbmNsdWRlcyB0aGUgY29ubmVjdGlvbiBJRCB0aGF0IHRoZSBzZW5kZXIgb2YgdGhlIHBhY2tldCB3aXNoZXMgdG8gdXNlOyBzZWUgU2VjdGlvbiA3LjIuIEhhbmRzaGFrZSBwYWNrZXRzIGhhdmUgdGhlaXIgb3duIHBhY2tldCBudW1iZXIgc3BhY2UsIGFuZCB0aHVzIHRoZSBmaXJzdCBIYW5kc2hha2UgcGFja2V0IHNlbnQgYnkgYSBzZXJ2ZXIgY29udGFpbnMgYSBwYWNrZXQgbnVtYmVyIG9mIDAuIFRoZSBwYXlsb2FkIG9mIHRoaXMgcGFja2V0IGNvbnRhaW5zIENSWVBUTyBmcmFtZXMgYW5kIGNvdWxkIGNvbnRhaW4gUElORywgUEFERElORywgb3IgQUNLIGZyYW1lcy4gSGFuZHNoYWtlIHBhY2tldHMgTUFZIGNvbnRhaW4gQ09OTkVDVElPTl9DTE9TRSBmcmFtZXMgb2YgdHlwZSAweDFjLiBFbmRwb2ludHMgTVVTVCB0cmVhdCByZWNlaXB0IG9mIEhhbmRzaGFrZSBwYWNrZXRzIHdpdGggb3RoZXIgZnJhbWVzIGFzIGEgY29ubmVjdGlvbiBlcnJvciBvZiB0eXBlIFBST1RPQ09MX1ZJT0xBVElPTi4gTGlrZSBJbml0aWFsIHBhY2tldHMgKHNlZSBTZWN0aW9uIDE3LjIuMi4xKSwgZGF0YSBpbiBDUllQVE8gZnJhbWVzIGZvciBIYW5kc2hha2UgcGFja2V0cyBpcyBkaXNjYXJkZWQgLS0gYW5kIG5vIGxvbmdlciByZXRyYW5zbWl0dGVkIC0tIHdoZW4gSGFuZHNoYWtlIHByb3RlY3Rpb24ga2V5cyBhcmUgZGlzY2FyZGVkLiAxNy4yLjUuIFJldHJ5IFBhY2tldCBBcyBzaG93biBpbiBGaWd1cmUgMTgsIGEgUmV0cnkgcGFja2V0IHVzZXMgYSBsb25nIHBhY2tldCBoZWFkZXIgd2l0aCBhIHR5cGUgdmFsdWUgb2YgMHgwMy4gSXQgY2FycmllcyBhbiBhZGRyZXNzIHZhbGlkYXRpb24gdG9rZW4gY3JlYXRlZCBieSB0aGUgc2VydmVyLiBJdCBpcyB1c2VkIGJ5IGEgc2VydmVyIHRoYXQgd2lzaGVzIHRvIHBlcmZvcm0gYSByZXRyeTsgc2VlIFNlY3Rpb24gOC4xLiBSZXRyeSBQYWNrZXQgeyBIZWFkZXIgRm9ybSAoMSkgPSAxLCBGaXhlZCBCaXQgKDEpID0gMSwgTG9uZyBQYWNrZXQgVHlwZSAoMikgPSAzLCBVbnVzZWQgKDQpLCBWZXJzaW9uICgzMiksIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgTGVuZ3RoICg4KSwgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCAoMC4uMTYwKSwgU291cmNlIENvbm5lY3Rpb24gSUQgTGVuZ3RoICg4KSwgU291cmNlIENvbm5lY3Rpb24gSUQgKDAuLjE2MCksIFJldHJ5IFRva2VuICguLiksIFJldHJ5IEludGVncml0eSBUYWcgKDEyOCksIH0gRmlndXJlIDE4OiBSZXRyeSBQYWNrZXQgQSBSZXRyeSBwYWNrZXQgZG9lcyBub3QgY29udGFpbiBhbnkgcHJvdGVjdGVkIGZpZWxkcy4gVGhlIHZhbHVlIGluIHRoZSBVbnVzZWQgZmllbGQgaXMgc2V0IHRvIGFuIGFyYml0cmFyeSB2YWx1ZSBieSB0aGUgc2VydmVyOyBhIGNsaWVudCBNVVNUIGlnbm9yZSB0aGVzZSBiaXRzLiBJbiBhZGRpdGlvbiB0byB0aGUgZmllbGRzIGZyb20gdGhlIGxvbmcgaGVhZGVyLCBpdCBjb250YWlucyB0aGVzZSBhZGRpdGlvbmFsIGZpZWxkczogUmV0cnkgVG9rZW46IEFuIG9wYXF1ZSB0b2tlbiB0aGF0IHRoZSBzZXJ2ZXIgY2FuIHVzZSB0byB2YWxpZGF0ZSB0aGUgY2xpZW50J3MgYWRkcmVzcy4gUmV0cnkgSW50ZWdyaXR5IFRhZzogRGVmaW5lZCBpbiBTZWN0aW9uIDUuOCAoIlJldHJ5IFBhY2tldCBJbnRlZ3JpdHkiKSBvZiBbUVVJQy1UTFNdLiAxNy4yLjUuMS4gU2VuZGluZyBhIFJldHJ5IFBhY2tldCBUaGUgc2VydmVyIHBvcHVsYXRlcyB0aGUgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCB3aXRoIHRoZSBjb25uZWN0aW9uIElEIHRoYXQgdGhlIGNsaWVudCBpbmNsdWRlZCBpbiB0aGUgU291cmNlIENvbm5lY3Rpb24gSUQgb2YgdGhlIEluaXRpYWwgcGFja2V0LiBUaGUgc2VydmVyIGluY2x1ZGVzIGEgY29ubmVjdGlvbiBJRCBvZiBpdHMgY2hvaWNlIGluIHRoZSBTb3VyY2UgQ29ubmVjdGlvbiBJRCBmaWVsZC4gVGhpcyB2YWx1ZSBNVVNUIE5PVCBiZSBlcXVhbCB0byB0aGUgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBmaWVsZCBvZiB0aGUgcGFja2V0IHNlbnQgYnkgdGhlIGNsaWVudC4gQSBjbGllbnQgTVVTVCBkaXNjYXJkIGEgUmV0cnkgcGFja2V0IHRoYXQgY29udGFpbnMgYSBTb3VyY2UgQ29ubmVjdGlvbiBJRCBmaWVsZCB0aGF0IGlzIGlkZW50aWNhbCB0byB0aGUgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBmaWVsZCBvZiBpdHMgSW5pdGlhbCBwYWNrZXQuIFRoZSBjbGllbnQgTVVTVCB1c2UgdGhlIHZhbHVlIGZyb20gdGhlIFNvdXJjZSBDb25uZWN0aW9uIElEIGZpZWxkIG9mIHRoZSBSZXRyeSBwYWNrZXQgaW4gdGhlIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgZmllbGQgb2Ygc3Vic2VxdWVudCBwYWNrZXRzIHRoYXQgaXQgc2VuZHMuIEEgc2VydmVyIE1BWSBzZW5kIFJldHJ5IHBhY2tldHMgaW4gcmVzcG9uc2UgdG8gSW5pdGlhbCBhbmQgMC1SVFQgcGFja2V0cy4gQSBzZXJ2ZXIgY2FuIGVpdGhlciBkaXNjYXJkIG9yIGJ1ZmZlciAwLVJUVCBwYWNrZXRzIHRoYXQgaXQgcmVjZWl2ZXMuIEEgc2VydmVyIGNhbiBzZW5kIG11bHRpcGxlIFJldHJ5IHBhY2tldHMgYXMgaXQgcmVjZWl2ZXMgSW5pdGlhbCBvciAwLVJUVCBwYWNrZXRzLiBBIHNlcnZlciBNVVNUIE5PVCBzZW5kIG1vcmUgdGhhbiBvbmUgUmV0cnkgcGFja2V0IGluIHJlc3BvbnNlIHRvIGEgc2luZ2xlIFVEUCBkYXRhZ3JhbS4gMTcuMi41LjIuIEhhbmRsaW5nIGEgUmV0cnkgUGFja2V0IEEgY2xpZW50IE1VU1QgYWNjZXB0IGFuZCBwcm9jZXNzIGF0IG1vc3Qgb25lIFJldHJ5IHBhY2tldCBmb3IgZWFjaCBjb25uZWN0aW9uIGF0dGVtcHQuIEFmdGVyIHRoZSBjbGllbnQgaGFzIHJlY2VpdmVkIGFuZCBwcm9jZXNzZWQgYW4gSW5pdGlhbCBvciBSZXRyeSBwYWNrZXQgZnJvbSB0aGUgc2VydmVyLCBpdCBNVVNUIGRpc2NhcmQgYW55IHN1YnNlcXVlbnQgUmV0cnkgcGFja2V0cyB0aGF0IGl0IHJlY2VpdmVzLiBDbGllbnRzIE1VU1QgZGlzY2FyZCBSZXRyeSBwYWNrZXRzIHRoYXQgaGF2ZSBhIFJldHJ5IEludGVncml0eSBUYWcgdGhhdCBjYW5ub3QgYmUgdmFsaWRhdGVkOyBzZWUgU2VjdGlvbiA1Ljggb2YgW1FVSUMtVExTXS4gVGhpcyBkaW1pbmlzaGVzIGFuIGF0dGFja2VyJ3MgYWJpbGl0eSB0byBpbmplY3QgYSBSZXRyeSBwYWNrZXQgYW5kIHByb3RlY3RzIGFnYWluc3QgYWNjaWRlbnRhbCBjb3JydXB0aW9uIG9mIFJldHJ5IHBhY2tldHMuIEEgY2xpZW50IE1VU1QgZGlzY2FyZCBhIFJldHJ5IHBhY2tldCB3aXRoIGEgemVyby1sZW5ndGggUmV0cnkgVG9rZW4gZmllbGQuIFRoZSBjbGllbnQgcmVzcG9uZHMgdG8gYSBSZXRyeSBwYWNrZXQgd2l0aCBhbiBJbml0aWFsIHBhY2tldCB0aGF0IGluY2x1ZGVzIHRoZSBwcm92aWRlZCBSZXRyeSB0b2tlbiB0byBjb250aW51ZSBjb25uZWN0aW9uIGVzdGFibGlzaG1lbnQuIEEgY2xpZW50IHNldHMgdGhlIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgZmllbGQgb2YgdGhpcyBJbml0aWFsIHBhY2tldCB0byB0aGUgdmFsdWUgZnJvbSB0aGUgU291cmNlIENvbm5lY3Rpb24gSUQgZmllbGQgaW4gdGhlIFJldHJ5IHBhY2tldC4gQ2hhbmdpbmcgdGhlIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgZmllbGQgYWxzbyByZXN1bHRzIGluIGEgY2hhbmdlIHRvIHRoZSBrZXlzIHVzZWQgdG8gcHJvdGVjdCB0aGUgSW5pdGlhbCBwYWNrZXQuIEl0IGFsc28gc2V0cyB0aGUgVG9rZW4gZmllbGQgdG8gdGhlIHRva2VuIHByb3ZpZGVkIGluIHRoZSBSZXRyeSBwYWNrZXQuIFRoZSBjbGllbnQgTVVTVCBOT1QgY2hhbmdlIHRoZSBTb3VyY2UgQ29ubmVjdGlvbiBJRCBiZWNhdXNlIHRoZSBzZXJ2ZXIgY291bGQgaW5jbHVkZSB0aGUgY29ubmVjdGlvbiBJRCBhcyBwYXJ0IG9mIGl0cyB0b2tlbiB2YWxpZGF0aW9uIGxvZ2ljOyBzZWUgU2VjdGlvbiA4LjEuNC4gQSBSZXRyeSBwYWNrZXQgZG9lcyBub3QgaW5jbHVkZSBhIHBhY2tldCBudW1iZXIgYW5kIGNhbm5vdCBiZSBleHBsaWNpdGx5IGFja25vd2xlZGdlZCBieSBhIGNsaWVudC4gMTcuMi41LjMuIENvbnRpbnVpbmcgYSBIYW5kc2hha2UgYWZ0ZXIgUmV0cnkgU3Vic2VxdWVudCBJbml0aWFsIHBhY2tldHMgZnJvbSB0aGUgY2xpZW50IGluY2x1ZGUgdGhlIGNvbm5lY3Rpb24gSUQgYW5kIHRva2VuIHZhbHVlcyBmcm9tIHRoZSBSZXRyeSBwYWNrZXQuIFRoZSBjbGllbnQgY29waWVzIHRoZSBTb3VyY2UgQ29ubmVjdGlvbiBJRCBmaWVsZCBmcm9tIHRoZSBSZXRyeSBwYWNrZXQgdG8gdGhlIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgZmllbGQgYW5kIHVzZXMgdGhpcyB2YWx1ZSB1bnRpbCBhbiBJbml0aWFsIHBhY2tldCB3aXRoIGFuIHVwZGF0ZWQgdmFsdWUgaXMgcmVjZWl2ZWQ7IHNlZSBTZWN0aW9uIDcuMi4gVGhlIHZhbHVlIG9mIHRoZSBUb2tlbiBmaWVsZCBpcyBjb3BpZWQgdG8gYWxsIHN1YnNlcXVlbnQgSW5pdGlhbCBwYWNrZXRzOyBzZWUgU2VjdGlvbiA4LjEuMi4gT3RoZXIgdGhhbiB1cGRhdGluZyB0aGUgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBhbmQgVG9rZW4gZmllbGRzLCB0aGUgSW5pdGlhbCBwYWNrZXQgc2VudCBieSB0aGUgY2xpZW50IGlzIHN1YmplY3QgdG8gdGhlIHNhbWUgcmVzdHJpY3Rpb25zIGFzIHRoZSBmaXJzdCBJbml0aWFsIHBhY2tldC4gQSBjbGllbnQgTVVTVCB1c2UgdGhlIHNhbWUgY3J5cHRvZ3JhcGhpYyBoYW5kc2hha2UgbWVzc2FnZSBpdCBpbmNsdWRlZCBpbiB0aGlzIHBhY2tldC4gQSBzZXJ2ZXIgTUFZIHRyZWF0IGEgcGFja2V0IHRoYXQgY29udGFpbnMgYSBkaWZmZXJlbnQgY3J5cHRvZ3JhcGhpYyBoYW5kc2hha2UgbWVzc2FnZSBhcyBhIGNvbm5lY3Rpb24gZXJyb3Igb3IgZGlzY2FyZCBpdC4gTm90ZSB0aGF0IGluY2x1ZGluZyBhIFRva2VuIGZpZWxkIHJlZHVjZXMgdGhlIGF2YWlsYWJsZSBzcGFjZSBmb3IgdGhlIGNyeXB0b2dyYXBoaWMgaGFuZHNoYWtlIG1lc3NhZ2UsIHdoaWNoIG1pZ2h0IHJlc3VsdCBpbiB0aGUgY2xpZW50IG5lZWRpbmcgdG8gc2VuZCBtdWx0aXBsZSBJbml0aWFsIHBhY2tldHMuIEEgY2xpZW50IE1BWSBhdHRlbXB0IDAtUlRUIGFmdGVyIHJlY2VpdmluZyBhIFJldHJ5IHBhY2tldCBieSBzZW5kaW5nIDAtUlRUIHBhY2tldHMgdG8gdGhlIGNvbm5lY3Rpb24gSUQgcHJvdmlkZWQgYnkgdGhlIHNlcnZlci4gQSBjbGllbnQgTVVTVCBOT1QgcmVzZXQgdGhlIHBhY2tldCBudW1iZXIgZm9yIGFueSBwYWNrZXQgbnVtYmVyIHNwYWNlIGFmdGVyIHByb2Nlc3NpbmcgYSBSZXRyeSBwYWNrZXQuIEluIHBhcnRpY3VsYXIsIDAtUlRUIHBhY2tldHMgY29udGFpbiBjb25maWRlbnRpYWwgaW5mb3JtYXRpb24gdGhhdCB3aWxsIG1vc3QgbGlrZWx5IGJlIHJldHJhbnNtaXR0ZWQgb24gcmVjZWl2aW5nIGEgUmV0cnkgcGFja2V0LiBUaGUga2V5cyB1c2VkIHRvIHByb3RlY3QgdGhlc2UgbmV3IDAtUlRUIHBhY2tldHMgd2lsbCBub3QgY2hhbmdlIGFzIGEgcmVzdWx0IG9mIHJlc3BvbmRpbmcgdG8gYSBSZXRyeSBwYWNrZXQuIEhvd2V2ZXIsIHRoZSBkYXRhIHNlbnQgaW4gdGhlc2UgcGFja2V0cyBjb3VsZCBiZSBkaWZmZXJlbnQgdGhhbiB3aGF0IHdhcyBzZW50IGVhcmxpZXIuIFNlbmRpbmcgdGhlc2UgbmV3IHBhY2tldHMgd2l0aCB0aGUgc2FtZSBwYWNrZXQgbnVtYmVyIGlzIGxpa2VseSB0byBjb21wcm9taXNlIHRoZSBwYWNrZXQgcHJvdGVjdGlvbiBmb3IgdGhvc2UgcGFja2V0cyBiZWNhdXNlIHRoZSBzYW1lIGtleSBhbmQgbm9uY2UgY291bGQgYmUgdXNlZCB0byBwcm90ZWN0IGRpZmZlcmVudCBjb250ZW50LiBBIHNlcnZlciBNQVkgYWJvcnQgdGhlIGNvbm5lY3Rpb24gaWYgaXQgZGV0ZWN0cyB0aGF0IHRoZSBjbGllbnQgcmVzZXQgdGhlIHBhY2tldCBudW1iZXIuIFRoZSBjb25uZWN0aW9uIElEcyB1c2VkIGluIEluaXRpYWwgYW5kIFJldHJ5IHBhY2tldHMgZXhjaGFuZ2VkIGJldHdlZW4gY2xpZW50IGFuZCBzZXJ2ZXIgYXJlIGNvcGllZCB0byB0aGUgdHJhbnNwb3J0IHBhcmFtZXRlcnMgYW5kIHZhbGlkYXRlZCBhcyBkZXNjcmliZWQgaW4gU2VjdGlvbiA3LjMuIDE3LjMuIFNob3J0IEhlYWRlciBQYWNrZXRzIFRoaXMgdmVyc2lvbiBvZiBRVUlDIGRlZmluZXMgYSBzaW5nbGUgcGFja2V0IHR5cGUgdGhhdCB1c2VzIHRoZSBzaG9ydCBwYWNrZXQgaGVhZGVyLiAxNy4zLjEuIDEtUlRUIFBhY2tldCBBIDEtUlRUIHBhY2tldCB1c2VzIGEgc2hvcnQgcGFja2V0IGhlYWRlci4gSXQgaXMgdXNlZCBhZnRlciB0aGUgdmVyc2lvbiBhbmQgMS1SVFQga2V5cyBhcmUgbmVnb3RpYXRlZC4gMS1SVFQgUGFja2V0IHsgSGVhZGVyIEZvcm0gKDEpID0gMCwgRml4ZWQgQml0ICgxKSA9IDEsIFNwaW4gQml0ICgxKSwgUmVzZXJ2ZWQgQml0cyAoMiksIEtleSBQaGFzZSAoMSksIFBhY2tldCBOdW1iZXIgTGVuZ3RoICgyKSwgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCAoMC4uMTYwKSwgUGFja2V0IE51bWJlciAoOC4uMzIpLCBQYWNrZXQgUGF5bG9hZCAoOC4uKSwgfSBGaWd1cmUgMTk6IDEtUlRUIFBhY2tldCAxLVJUVCBwYWNrZXRzIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBmaWVsZHM6IEhlYWRlciBGb3JtOiBUaGUgbW9zdCBzaWduaWZpY2FudCBiaXQgKDB4ODApIG9mIGJ5dGUgMCBpcyBzZXQgdG8gMCBmb3IgdGhlIHNob3J0IGhlYWRlci4gRml4ZWQgQml0OiBUaGUgbmV4dCBiaXQgKDB4NDApIG9mIGJ5dGUgMCBpcyBzZXQgdG8gMS4gUGFja2V0cyBjb250YWluaW5nIGEgemVybyB2YWx1ZSBmb3IgdGhpcyBiaXQgYXJlIG5vdCB2YWxpZCBwYWNrZXRzIGluIHRoaXMgdmVyc2lvbiBhbmQgTVVTVCBiZSBkaXNjYXJkZWQuIEEgdmFsdWUgb2YgMSBmb3IgdGhpcyBiaXQgYWxsb3dzIFFVSUMgdG8gY29leGlzdCB3aXRoIG90aGVyIHByb3RvY29sczsgc2VlIFtSRkM3OTgzXS4gU3BpbiBCaXQ6IFRoZSB0aGlyZCBtb3N0IHNpZ25pZmljYW50IGJpdCAoMHgyMCkgb2YgYnl0ZSAwIGlzIHRoZSBsYXRlbmN5IHNwaW4gYml0LCBzZXQgYXMgZGVzY3JpYmVkIGluIFNlY3Rpb24gMTcuNC4gUmVzZXJ2ZWQgQml0czogVGhlIG5leHQgdHdvIGJpdHMgKHRob3NlIHdpdGggYSBtYXNrIG9mIDB4MTgpIG9mIGJ5dGUgMCBhcmUgcmVzZXJ2ZWQuIFRoZXNlIGJpdHMgYXJlIHByb3RlY3RlZCB1c2luZyBoZWFkZXIgcHJvdGVjdGlvbjsgc2VlIFNlY3Rpb24gNS40IG9mIFtRVUlDLVRMU10uIFRoZSB2YWx1ZSBpbmNsdWRlZCBwcmlvciB0byBwcm90ZWN0aW9uIE1VU1QgYmUgc2V0IHRvIDAuIEFuIGVuZHBvaW50IE1VU1QgdHJlYXQgcmVjZWlwdCBvZiBhIHBhY2tldCB0aGF0IGhhcyBhIG5vbi16ZXJvIHZhbHVlIGZvciB0aGVzZSBiaXRzLCBhZnRlciByZW1vdmluZyBib3RoIHBhY2tldCBhbmQgaGVhZGVyIHByb3RlY3Rpb24sIGFzIGEgY29ubmVjdGlvbiBlcnJvciBvZiB0eXBlIFBST1RPQ09MX1ZJT0xBVElPTi4gRGlzY2FyZGluZyBzdWNoIGEgcGFja2V0IGFmdGVyIG9ubHkgcmVtb3ZpbmcgaGVhZGVyIHByb3RlY3Rpb24gY2FuIGV4cG9zZSB0aGUgZW5kcG9pbnQgdG8gYXR0YWNrczsgc2VlIFNlY3Rpb24gOS41IG9mIFtRVUlDLVRMU10uIEtleSBQaGFzZTogVGhlIG5leHQgYml0ICgweDA0KSBvZiBieXRlIDAgaW5kaWNhdGVzIHRoZSBrZXkgcGhhc2UsIHdoaWNoIGFsbG93cyBhIHJlY2lwaWVudCBvZiBhIHBhY2tldCB0byBpZGVudGlmeSB0aGUgcGFja2V0IHByb3RlY3Rpb24ga2V5cyB0aGF0IGFyZSB1c2VkIHRvIHByb3RlY3QgdGhlIHBhY2tldC4gU2VlIFtRVUlDLVRMU10gZm9yIGRldGFpbHMuIFRoaXMgYml0IGlzIHByb3RlY3RlZCB1c2luZyBoZWFkZXIgcHJvdGVjdGlvbjsgc2VlIFNlY3Rpb24gNS40IG9mIFtRVUlDLVRMU10uIFBhY2tldCBOdW1iZXIgTGVuZ3RoOiBUaGUgbGVhc3Qgc2lnbmlmaWNhbnQgdHdvIGJpdHMgKHRob3NlIHdpdGggYSBtYXNrIG9mIDB4MDMpIG9mIGJ5dGUgMCBjb250YWluIHRoZSBsZW5ndGggb2YgdGhlIFBhY2tldCBOdW1iZXIgZmllbGQsIGVuY29kZWQgYXMgYW4gdW5zaWduZWQgdHdvLWJpdCBpbnRlZ2VyIHRoYXQgaXMgb25lIGxlc3MgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBQYWNrZXQgTnVtYmVyIGZpZWxkIGluIGJ5dGVzLiBUaGF0IGlzLCB0aGUgbGVuZ3RoIG9mIHRoZSBQYWNrZXQgTnVtYmVyIGZpZWxkIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIHBsdXMgb25lLiBUaGVzZSBiaXRzIGFyZSBwcm90ZWN0ZWQgdXNpbmcgaGVhZGVyIHByb3RlY3Rpb247IHNlZSBTZWN0aW9uIDUuNCBvZiBbUVVJQy1UTFNdLiBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEOiBUaGUgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBpcyBhIGNvbm5lY3Rpb24gSUQgdGhhdCBpcyBjaG9zZW4gYnkgdGhlIGludGVuZGVkIHJlY2lwaWVudCBvZiB0aGUgcGFja2V0LiBTZWUgU2VjdGlvbiA1LjEgZm9yIG1vcmUgZGV0YWlscy4gUGFja2V0IE51bWJlcjogVGhlIFBhY2tldCBOdW1iZXIgZmllbGQgaXMgMSB0byA0IGJ5dGVzIGxvbmcuIFRoZSBwYWNrZXQgbnVtYmVyIGlzIHByb3RlY3RlZCB1c2luZyBoZWFkZXIgcHJvdGVjdGlvbjsgc2VlIFNlY3Rpb24gNS40IG9mIFtRVUlDLVRMU10uIFRoZSBsZW5ndGggb2YgdGhlIFBhY2tldCBOdW1iZXIgZmllbGQgaXMgZW5jb2RlZCBpbiBQYWNrZXQgTnVtYmVyIExlbmd0aCBmaWVsZC4gU2VlIFNlY3Rpb24gMTcuMSBmb3IgZGV0YWlscy4gUGFja2V0IFBheWxvYWQ6IDEtUlRUIHBhY2tldHMgYWx3YXlzIGluY2x1ZGUgYSAxLVJUVCBwcm90ZWN0ZWQgcGF5bG9hZC4gVGhlIGhlYWRlciBmb3JtIGJpdCBhbmQgdGhlIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgZmllbGQgb2YgYSBzaG9ydCBoZWFkZXIgcGFja2V0IGFyZSB2ZXJzaW9uIGluZGVwZW5kZW50LiBUaGUgcmVtYWluaW5nIGZpZWxkcyBhcmUgc3BlY2lmaWMgdG8gdGhlIHNlbGVjdGVkIFFVSUMgdmVyc2lvbi4gU2VlIFtRVUlDLUlOVkFSSUFOVFNdIGZvciBkZXRhaWxzIG9uIGhvdyBwYWNrZXRzIGZyb20gZGlmZmVyZW50IHZlcnNpb25zIG9mIFFVSUMgYXJlIGludGVycHJldGVkLiAxNy40LiBMYXRlbmN5IFNwaW4gQml0IFRoZSBsYXRlbmN5IHNwaW4gYml0LCB3aGljaCBpcyBkZWZpbmVkIGZvciAxLVJUVCBwYWNrZXRzIChTZWN0aW9uIDE3LjMuMSksIGVuYWJsZXMgcGFzc2l2ZSBsYXRlbmN5IG1vbml0b3JpbmcgZnJvbSBvYnNlcnZhdGlvbiBwb2ludHMgb24gdGhlIG5ldHdvcmsgcGF0aCB0aHJvdWdob3V0IHRoZSBkdXJhdGlvbiBvZiBhIGNvbm5lY3Rpb24uIFRoZSBzZXJ2ZXIgcmVmbGVjdHMgdGhlIHNwaW4gdmFsdWUgcmVjZWl2ZWQsIHdoaWxlIHRoZSBjbGllbnQgInNwaW5zIiBpdCBhZnRlciBvbmUgUlRULiBPbi1wYXRoIG9ic2VydmVycyBjYW4gbWVhc3VyZSB0aGUgdGltZSBiZXR3ZWVuIHR3byBzcGluIGJpdCB0b2dnbGUgZXZlbnRzIHRvIGVzdGltYXRlIHRoZSBlbmQtdG8tZW5kIFJUVCBvZiBhIGNvbm5lY3Rpb24uIFRoZSBzcGluIGJpdCBpcyBvbmx5IHByZXNlbnQgaW4gMS1SVFQgcGFja2V0cywgc2luY2UgaXQgaXMgcG9zc2libGUgdG8gbWVhc3VyZSB0aGUgaW5pdGlhbCBSVFQgb2YgYSBjb25uZWN0aW9uIGJ5IG9ic2VydmluZyB0aGUgaGFuZHNoYWtlLiBUaGVyZWZvcmUsIHRoZSBzcGluIGJpdCBpcyBhdmFpbGFibGUgYWZ0ZXIgdmVyc2lvbiBuZWdvdGlhdGlvbiBhbmQgY29ubmVjdGlvbiBlc3RhYmxpc2htZW50IGFyZSBjb21wbGV0ZWQuIE9uLXBhdGggbWVhc3VyZW1lbnQgYW5kIHVzZSBvZiB0aGUgbGF0ZW5jeSBzcGluIGJpdCBhcmUgZnVydGhlciBkaXNjdXNzZWQgaW4gW1FVSUMtTUFOQUdFQUJJTElUWV0uIFRoZSBzcGluIGJpdCBpcyBhbiBPUFRJT05BTCBmZWF0dXJlIG9mIHRoaXMgdmVyc2lvbiBvZiBRVUlDLiBBbiBlbmRwb2ludCB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhpcyBmZWF0dXJlIE1VU1QgZGlzYWJsZSBpdCwgYXMgZGVmaW5lZCBiZWxvdy4gRWFjaCBlbmRwb2ludCB1bmlsYXRlcmFsbHkgZGVjaWRlcyBpZiB0aGUgc3BpbiBiaXQgaXMgZW5hYmxlZCBvciBkaXNhYmxlZCBmb3IgYSBjb25uZWN0aW9uLiBJbXBsZW1lbnRhdGlvbnMgTVVTVCBhbGxvdyBhZG1pbmlzdHJhdG9ycyBvZiBjbGllbnRzIGFuZCBzZXJ2ZXJzIHRvIGRpc2FibGUgdGhlIHNwaW4gYml0IGVpdGhlciBnbG9iYWxseSBvciBvbiBhIHBlci1jb25uZWN0aW9uIGJhc2lzLiBFdmVuIHdoZW4gdGhlIHNwaW4gYml0IGlzIG5vdCBkaXNhYmxlZCBieSB0aGUgYWRtaW5pc3RyYXRvciwgZW5kcG9pbnRzIE1VU1QgZGlzYWJsZSB0aGVpciB1c2Ugb2YgdGhlIHNwaW4gYml0IGZvciBhIHJhbmRvbSBzZWxlY3Rpb24gb2YgYXQgbGVhc3Qgb25lIGluIGV2ZXJ5IDE2IG5ldHdvcmsgcGF0aHMsIG9yIGZvciBvbmUgaW4gZXZlcnkgMTYgY29ubmVjdGlvbiBJRHMsIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IFFVSUMgY29ubmVjdGlvbnMgdGhhdCBkaXNhYmxlIHRoZSBzcGluIGJpdCBhcmUgY29tbW9ubHkgb2JzZXJ2ZWQgb24gdGhlIG5ldHdvcmsuIEFzIGVhY2ggZW5kcG9pbnQgZGlzYWJsZXMgdGhlIHNwaW4gYml0IGluZGVwZW5kZW50bHksIHRoaXMgZW5zdXJlcyB0aGF0IHRoZSBzcGluIGJpdCBzaWduYWwgaXMgZGlzYWJsZWQgb24gYXBwcm94aW1hdGVseSBvbmUgaW4gZWlnaHQgbmV0d29yayBwYXRocy4gV2hlbiB0aGUgc3BpbiBiaXQgaXMgZGlzYWJsZWQsIGVuZHBvaW50cyBNQVkgc2V0IHRoZSBzcGluIGJpdCB0byBhbnkgdmFsdWUgYW5kIE1VU1QgaWdub3JlIGFueSBpbmNvbWluZyB2YWx1ZS4gSXQgaXMgUkVDT01NRU5ERUQgdGhhdCBlbmRwb2ludHMgc2V0IHRoZSBzcGluIGJpdCB0byBhIHJhbmRvbSB2YWx1ZSBlaXRoZXIgY2hvc2VuIGluZGVwZW5kZW50bHkgZm9yIGVhY2ggcGFja2V0IG9yIGNob3NlbiBpbmRlcGVuZGVudGx5IGZvciBlYWNoIGNvbm5lY3Rpb24gSUQuIElmIHRoZSBzcGluIGJpdCBpcyBlbmFibGVkIGZvciB0aGUgY29ubmVjdGlvbiwgdGhlIGVuZHBvaW50IG1haW50YWlucyBhIHNwaW4gdmFsdWUgZm9yIGVhY2ggbmV0d29yayBwYXRoIGFuZCBzZXRzIHRoZSBzcGluIGJpdCBpbiB0aGUgcGFja2V0IGhlYWRlciB0byB0aGUgY3VycmVudGx5IHN0b3JlZCB2YWx1ZSB3aGVuIGEgMS1SVFQgcGFja2V0IGlzIHNlbnQgb24gdGhhdCBwYXRoLiBUaGUgc3BpbiB2YWx1ZSBpcyBpbml0aWFsaXplZCB0byAwIGluIHRoZSBlbmRwb2ludCBmb3IgZWFjaCBuZXR3b3JrIHBhdGguIEVhY2ggZW5kcG9pbnQgYWxzbyByZW1lbWJlcnMgdGhlIGhpZ2hlc3QgcGFja2V0IG51bWJlciBzZWVuIGZyb20gaXRzIHBlZXIgb24gZWFjaCBwYXRoLiBXaGVuIGEgc2VydmVyIHJlY2VpdmVzIGEgMS1SVFQgcGFja2V0IHRoYXQgaW5jcmVhc2VzIHRoZSBoaWdoZXN0IHBhY2tldCBudW1iZXIgc2VlbiBieSB0aGUgc2VydmVyIGZyb20gdGhlIGNsaWVudCBvbiBhIGdpdmVuIG5ldHdvcmsgcGF0aCwgaXQgc2V0cyB0aGUgc3BpbiB2YWx1ZSBmb3IgdGhhdCBwYXRoIHRvIGJlIGVxdWFsIHRvIHRoZSBzcGluIGJpdCBpbiB0aGUgcmVjZWl2ZWQgcGFja2V0LiBXaGVuIGEgY2xpZW50IHJlY2VpdmVzIGEgMS1SVFQgcGFja2V0IHRoYXQgaW5jcmVhc2VzIHRoZSBoaWdoZXN0IHBhY2tldCBudW1iZXIgc2VlbiBieSB0aGUgY2xpZW50IGZyb20gdGhlIHNlcnZlciBvbiBhIGdpdmVuIG5ldHdvcmsgcGF0aCwgaXQgc2V0cyB0aGUgc3BpbiB2YWx1ZSBmb3IgdGhhdCBwYXRoIHRvIHRoZSBpbnZlcnNlIG9mIHRoZSBzcGluIGJpdCBpbiB0aGUgcmVjZWl2ZWQgcGFja2V0LiBBbiBlbmRwb2ludCByZXNldHMgdGhlIHNwaW4gdmFsdWUgZm9yIGEgbmV0d29yayBwYXRoIHRvIDAgd2hlbiBjaGFuZ2luZyB0aGUgY29ubmVjdGlvbiBJRCBiZWluZyB1c2VkIG9uIHRoYXQgbmV0d29yayBwYXRoLiAxOC4gVHJhbnNwb3J0IFBhcmFtZXRlciBFbmNvZGluZyBUaGUgZXh0ZW5zaW9uX2RhdGEgZmllbGQgb2YgdGhlIHF1aWNfdHJhbnNwb3J0X3BhcmFtZXRlcnMgZXh0ZW5zaW9uIGRlZmluZWQgaW4gW1FVSUMtVExTXSBjb250YWlucyB0aGUgUVVJQyB0cmFuc3BvcnQgcGFyYW1ldGVycy4gVGhleSBhcmUgZW5jb2RlZCBhcyBhIHNlcXVlbmNlIG9mIHRyYW5zcG9ydCBwYXJhbWV0ZXJzLCBhcyBzaG93biBpbiBGaWd1cmUgMjA6IFRyYW5zcG9ydCBQYXJhbWV0ZXJzIHsgVHJhbnNwb3J0IFBhcmFtZXRlciAoLi4pIC4uLiwgfSBGaWd1cmUgMjA6IFNlcXVlbmNlIG9mIFRyYW5zcG9ydCBQYXJhbWV0ZXJzIEVhY2ggdHJhbnNwb3J0IHBhcmFtZXRlciBpcyBlbmNvZGVkIGFzIGFuIChpZGVudGlmaWVyLCBsZW5ndGgsIHZhbHVlKSB0dXBsZSwgYXMgc2hvd24gaW4gRmlndXJlIDIxOiBUcmFuc3BvcnQgUGFyYW1ldGVyIHsgVHJhbnNwb3J0IFBhcmFtZXRlciBJRCAoaSksIFRyYW5zcG9ydCBQYXJhbWV0ZXIgTGVuZ3RoIChpKSwgVHJhbnNwb3J0IFBhcmFtZXRlciBWYWx1ZSAoLi4pLCB9IEZpZ3VyZSAyMTogVHJhbnNwb3J0IFBhcmFtZXRlciBFbmNvZGluZyBUaGUgVHJhbnNwb3J0IFBhcmFtZXRlciBMZW5ndGggZmllbGQgY29udGFpbnMgdGhlIGxlbmd0aCBvZiB0aGUgVHJhbnNwb3J0IFBhcmFtZXRlciBWYWx1ZSBmaWVsZCBpbiBieXRlcy4gUVVJQyBlbmNvZGVzIHRyYW5zcG9ydCBwYXJhbWV0ZXJzIGludG8gYSBzZXF1ZW5jZSBvZiBieXRlcywgd2hpY2ggaXMgdGhlbiBpbmNsdWRlZCBpbiB0aGUgY3J5cHRvZ3JhcGhpYyBoYW5kc2hha2UuIDE4LjEuIFJlc2VydmVkIFRyYW5zcG9ydCBQYXJhbWV0ZXJzIFRyYW5zcG9ydCBwYXJhbWV0ZXJzIHdpdGggYW4gaWRlbnRpZmllciBvZiB0aGUgZm9ybSAiMzEgKiBOICsgMjciIGZvciBpbnRlZ2VyIHZhbHVlcyBvZiBOIGFyZSByZXNlcnZlZCB0byBleGVyY2lzZSB0aGUgcmVxdWlyZW1lbnQgdGhhdCB1bmtub3duIHRyYW5zcG9ydCBwYXJhbWV0ZXJzIGJlIGlnbm9yZWQuIFRoZXNlIHRyYW5zcG9ydCBwYXJhbWV0ZXJzIGhhdmUgbm8gc2VtYW50aWNzIGFuZCBjYW4gY2FycnkgYXJiaXRyYXJ5IHZhbHVlcy4gMTguMi4gVHJhbnNwb3J0IFBhcmFtZXRlciBEZWZpbml0aW9ucyBUaGlzIHNlY3Rpb24gZGV0YWlscyB0aGUgdHJhbnNwb3J0IHBhcmFtZXRlcnMgZGVmaW5lZCBpbiB0aGlzIGRvY3VtZW50LiBNYW55IHRyYW5zcG9ydCBwYXJhbWV0ZXJzIGxpc3RlZCBoZXJlIGhhdmUgaW50ZWdlciB2YWx1ZXMuIFRob3NlIHRyYW5zcG9ydCBwYXJhbWV0ZXJzIHRoYXQgYXJlIGlkZW50aWZpZWQgYXMgaW50ZWdlcnMgdXNlIGEgdmFyaWFibGUtIGxlbmd0aCBpbnRlZ2VyIGVuY29kaW5nOyBzZWUgU2VjdGlvbiAxNi4gVHJhbnNwb3J0IHBhcmFtZXRlcnMgaGF2ZSBhIGRlZmF1bHQgdmFsdWUgb2YgMCBpZiB0aGUgdHJhbnNwb3J0IHBhcmFtZXRlciBpcyBhYnNlbnQsIHVubGVzcyBvdGhlcndpc2Ugc3RhdGVkLiBUaGUgZm9sbG93aW5nIHRyYW5zcG9ydCBwYXJhbWV0ZXJzIGFyZSBkZWZpbmVkOiBvcmlnaW5hbF9kZXN0aW5hdGlvbl9jb25uZWN0aW9uX2lkICgweDAwKTogVGhpcyBwYXJhbWV0ZXIgaXMgdGhlIHZhbHVlIG9mIHRoZSBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEIGZpZWxkIGZyb20gdGhlIGZpcnN0IEluaXRpYWwgcGFja2V0IHNlbnQgYnkgdGhlIGNsaWVudDsgc2VlIFNlY3Rpb24gNy4zLiBUaGlzIHRyYW5zcG9ydCBwYXJhbWV0ZXIgaXMgb25seSBzZW50IGJ5IGEgc2VydmVyLiBtYXhfaWRsZV90aW1lb3V0ICgweDAxKTogVGhlIG1heGltdW0gaWRsZSB0aW1lb3V0IGlzIGEgdmFsdWUgaW4gbWlsbGlzZWNvbmRzIHRoYXQgaXMgZW5jb2RlZCBhcyBhbiBpbnRlZ2VyOyBzZWUgKFNlY3Rpb24gMTAuMSkuIElkbGUgdGltZW91dCBpcyBkaXNhYmxlZCB3aGVuIGJvdGggZW5kcG9pbnRzIG9taXQgdGhpcyB0cmFuc3BvcnQgcGFyYW1ldGVyIG9yIHNwZWNpZnkgYSB2YWx1ZSBvZiAwLiBzdGF0ZWxlc3NfcmVzZXRfdG9rZW4gKDB4MDIpOiBBIHN0YXRlbGVzcyByZXNldCB0b2tlbiBpcyB1c2VkIGluIHZlcmlmeWluZyBhIHN0YXRlbGVzcyByZXNldDsgc2VlIFNlY3Rpb24gMTAuMy4gVGhpcyBwYXJhbWV0ZXIgaXMgYSBzZXF1ZW5jZSBvZiAxNiBieXRlcy4gVGhpcyB0cmFuc3BvcnQgcGFyYW1ldGVyIE1VU1QgTk9UIGJlIHNlbnQgYnkgYSBjbGllbnQgYnV0IE1BWSBiZSBzZW50IGJ5IGEgc2VydmVyLiBBIHNlcnZlciB0aGF0IGRvZXMgbm90IHNlbmQgdGhpcyB0cmFuc3BvcnQgcGFyYW1ldGVyIGNhbm5vdCB1c2Ugc3RhdGVsZXNzIHJlc2V0IChTZWN0aW9uIDEwLjMpIGZvciB0aGUgY29ubmVjdGlvbiBJRCBuZWdvdGlhdGVkIGR1cmluZyB0aGUgaGFuZHNoYWtlLiBtYXhfdWRwX3BheWxvYWRfc2l6ZSAoMHgwMyk6IFRoZSBtYXhpbXVtIFVEUCBwYXlsb2FkIHNpemUgcGFyYW1ldGVyIGlzIGFuIGludGVnZXIgdmFsdWUgdGhhdCBsaW1pdHMgdGhlIHNpemUgb2YgVURQIHBheWxvYWRzIHRoYXQgdGhlIGVuZHBvaW50IGlzIHdpbGxpbmcgdG8gcmVjZWl2ZS4gVURQIGRhdGFncmFtcyB3aXRoIHBheWxvYWRzIGxhcmdlciB0aGFuIHRoaXMgbGltaXQgYXJlIG5vdCBsaWtlbHkgdG8gYmUgcHJvY2Vzc2VkIGJ5IHRoZSByZWNlaXZlci4gVGhlIGRlZmF1bHQgZm9yIHRoaXMgcGFyYW1ldGVyIGlzIHRoZSBtYXhpbXVtIHBlcm1pdHRlZCBVRFAgcGF5bG9hZCBvZiA2NTUyNy4gVmFsdWVzIGJlbG93IDEyMDAgYXJlIGludmFsaWQuIFRoaXMgbGltaXQgZG9lcyBhY3QgYXMgYW4gYWRkaXRpb25hbCBjb25zdHJhaW50IG9uIGRhdGFncmFtIHNpemUgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZSBwYXRoIE1UVSwgYnV0IGl0IGlzIGEgcHJvcGVydHkgb2YgdGhlIGVuZHBvaW50IGFuZCBub3QgdGhlIHBhdGg7IHNlZSBTZWN0aW9uIDE0LiBJdCBpcyBleHBlY3RlZCB0aGF0IHRoaXMgaXMgdGhlIHNwYWNlIGFuIGVuZHBvaW50IGRlZGljYXRlcyB0byBob2xkaW5nIGluY29taW5nIHBhY2tldHMuIGluaXRpYWxfbWF4X2RhdGEgKDB4MDQpOiBUaGUgaW5pdGlhbCBtYXhpbXVtIGRhdGEgcGFyYW1ldGVyIGlzIGFuIGludGVnZXIgdmFsdWUgdGhhdCBjb250YWlucyB0aGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhlIG1heGltdW0gYW1vdW50IG9mIGRhdGEgdGhhdCBjYW4gYmUgc2VudCBvbiB0aGUgY29ubmVjdGlvbi4gVGhpcyBpcyBlcXVpdmFsZW50IHRvIHNlbmRpbmcgYSBNQVhfREFUQSAoU2VjdGlvbiAxOS45KSBmb3IgdGhlIGNvbm5lY3Rpb24gaW1tZWRpYXRlbHkgYWZ0ZXIgY29tcGxldGluZyB0aGUgaGFuZHNoYWtlLiBpbml0aWFsX21heF9zdHJlYW1fZGF0YV9iaWRpX2xvY2FsICgweDA1KTogVGhpcyBwYXJhbWV0ZXIgaXMgYW4gaW50ZWdlciB2YWx1ZSBzcGVjaWZ5aW5nIHRoZSBpbml0aWFsIGZsb3cgY29udHJvbCBsaW1pdCBmb3IgbG9jYWxseSBpbml0aWF0ZWQgYmlkaXJlY3Rpb25hbCBzdHJlYW1zLiBUaGlzIGxpbWl0IGFwcGxpZXMgdG8gbmV3bHkgY3JlYXRlZCBiaWRpcmVjdGlvbmFsIHN0cmVhbXMgb3BlbmVkIGJ5IHRoZSBlbmRwb2ludCB0aGF0IHNlbmRzIHRoZSB0cmFuc3BvcnQgcGFyYW1ldGVyLiBJbiBjbGllbnQgdHJhbnNwb3J0IHBhcmFtZXRlcnMsIHRoaXMgYXBwbGllcyB0byBzdHJlYW1zIHdpdGggYW4gaWRlbnRpZmllciB3aXRoIHRoZSBsZWFzdCBzaWduaWZpY2FudCB0d28gYml0cyBzZXQgdG8gMHgwMDsgaW4gc2VydmVyIHRyYW5zcG9ydCBwYXJhbWV0ZXJzLCB0aGlzIGFwcGxpZXMgdG8gc3RyZWFtcyB3aXRoIHRoZSBsZWFzdCBzaWduaWZpY2FudCB0d28gYml0cyBzZXQgdG8gMHgwMS4gaW5pdGlhbF9tYXhfc3RyZWFtX2RhdGFfYmlkaV9yZW1vdGUgKDB4MDYpOiBUaGlzIHBhcmFtZXRlciBpcyBhbiBpbnRlZ2VyIHZhbHVlIHNwZWNpZnlpbmcgdGhlIGluaXRpYWwgZmxvdyBjb250cm9sIGxpbWl0IGZvciBwZWVyLSBpbml0aWF0ZWQgYmlkaXJlY3Rpb25hbCBzdHJlYW1zLiBUaGlzIGxpbWl0IGFwcGxpZXMgdG8gbmV3bHkgY3JlYXRlZCBiaWRpcmVjdGlvbmFsIHN0cmVhbXMgb3BlbmVkIGJ5IHRoZSBlbmRwb2ludCB0aGF0IHJlY2VpdmVzIHRoZSB0cmFuc3BvcnQgcGFyYW1ldGVyLiBJbiBjbGllbnQgdHJhbnNwb3J0IHBhcmFtZXRlcnMsIHRoaXMgYXBwbGllcyB0byBzdHJlYW1zIHdpdGggYW4gaWRlbnRpZmllciB3aXRoIHRoZSBsZWFzdCBzaWduaWZpY2FudCB0d28gYml0cyBzZXQgdG8gMHgwMTsgaW4gc2VydmVyIHRyYW5zcG9ydCBwYXJhbWV0ZXJzLCB0aGlzIGFwcGxpZXMgdG8gc3RyZWFtcyB3aXRoIHRoZSBsZWFzdCBzaWduaWZpY2FudCB0d28gYml0cyBzZXQgdG8gMHgwMC4gaW5pdGlhbF9tYXhfc3RyZWFtX2RhdGFfdW5pICgweDA3KTogVGhpcyBwYXJhbWV0ZXIgaXMgYW4gaW50ZWdlciB2YWx1ZSBzcGVjaWZ5aW5nIHRoZSBpbml0aWFsIGZsb3cgY29udHJvbCBsaW1pdCBmb3IgdW5pZGlyZWN0aW9uYWwgc3RyZWFtcy4gVGhpcyBsaW1pdCBhcHBsaWVzIHRvIG5ld2x5IGNyZWF0ZWQgdW5pZGlyZWN0aW9uYWwgc3RyZWFtcyBvcGVuZWQgYnkgdGhlIGVuZHBvaW50IHRoYXQgcmVjZWl2ZXMgdGhlIHRyYW5zcG9ydCBwYXJhbWV0ZXIuIEluIGNsaWVudCB0cmFuc3BvcnQgcGFyYW1ldGVycywgdGhpcyBhcHBsaWVzIHRvIHN0cmVhbXMgd2l0aCBhbiBpZGVudGlmaWVyIHdpdGggdGhlIGxlYXN0IHNpZ25pZmljYW50IHR3byBiaXRzIHNldCB0byAweDAzOyBpbiBzZXJ2ZXIgdHJhbnNwb3J0IHBhcmFtZXRlcnMsIHRoaXMgYXBwbGllcyB0byBzdHJlYW1zIHdpdGggdGhlIGxlYXN0IHNpZ25pZmljYW50IHR3byBiaXRzIHNldCB0byAweDAyLiBpbml0aWFsX21heF9zdHJlYW1zX2JpZGkgKDB4MDgpOiBUaGUgaW5pdGlhbCBtYXhpbXVtIGJpZGlyZWN0aW9uYWwgc3RyZWFtcyBwYXJhbWV0ZXIgaXMgYW4gaW50ZWdlciB2YWx1ZSB0aGF0IGNvbnRhaW5zIHRoZSBpbml0aWFsIG1heGltdW0gbnVtYmVyIG9mIGJpZGlyZWN0aW9uYWwgc3RyZWFtcyB0aGUgZW5kcG9pbnQgdGhhdCByZWNlaXZlcyB0aGlzIHRyYW5zcG9ydCBwYXJhbWV0ZXIgaXMgcGVybWl0dGVkIHRvIGluaXRpYXRlLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBhYnNlbnQgb3IgemVybywgdGhlIHBlZXIgY2Fubm90IG9wZW4gYmlkaXJlY3Rpb25hbCBzdHJlYW1zIHVudGlsIGEgTUFYX1NUUkVBTVMgZnJhbWUgaXMgc2VudC4gU2V0dGluZyB0aGlzIHBhcmFtZXRlciBpcyBlcXVpdmFsZW50IHRvIHNlbmRpbmcgYSBNQVhfU1RSRUFNUyAoU2VjdGlvbiAxOS4xMSkgb2YgdGhlIGNvcnJlc3BvbmRpbmcgdHlwZSB3aXRoIHRoZSBzYW1lIHZhbHVlLiBpbml0aWFsX21heF9zdHJlYW1zX3VuaSAoMHgwOSk6IFRoZSBpbml0aWFsIG1heGltdW0gdW5pZGlyZWN0aW9uYWwgc3RyZWFtcyBwYXJhbWV0ZXIgaXMgYW4gaW50ZWdlciB2YWx1ZSB0aGF0IGNvbnRhaW5zIHRoZSBpbml0aWFsIG1heGltdW0gbnVtYmVyIG9mIHVuaWRpcmVjdGlvbmFsIHN0cmVhbXMgdGhlIGVuZHBvaW50IHRoYXQgcmVjZWl2ZXMgdGhpcyB0cmFuc3BvcnQgcGFyYW1ldGVyIGlzIHBlcm1pdHRlZCB0byBpbml0aWF0ZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgYWJzZW50IG9yIHplcm8sIHRoZSBwZWVyIGNhbm5vdCBvcGVuIHVuaWRpcmVjdGlvbmFsIHN0cmVhbXMgdW50aWwgYSBNQVhfU1RSRUFNUyBmcmFtZSBpcyBzZW50LiBTZXR0aW5nIHRoaXMgcGFyYW1ldGVyIGlzIGVxdWl2YWxlbnQgdG8gc2VuZGluZyBhIE1BWF9TVFJFQU1TIChTZWN0aW9uIDE5LjExKSBvZiB0aGUgY29ycmVzcG9uZGluZyB0eXBlIHdpdGggdGhlIHNhbWUgdmFsdWUuIGFja19kZWxheV9leHBvbmVudCAoMHgwYSk6IFRoZSBhY2tub3dsZWRnbWVudCBkZWxheSBleHBvbmVudCBpcyBhbiBpbnRlZ2VyIHZhbHVlIGluZGljYXRpbmcgYW4gZXhwb25lbnQgdXNlZCB0byBkZWNvZGUgdGhlIEFDSyBEZWxheSBmaWVsZCBpbiB0aGUgQUNLIGZyYW1lIChTZWN0aW9uIDE5LjMpLiBJZiB0aGlzIHZhbHVlIGlzIGFic2VudCwgYSBkZWZhdWx0IHZhbHVlIG9mIDMgaXMgYXNzdW1lZCAoaW5kaWNhdGluZyBhIG11bHRpcGxpZXIgb2YgOCkuIFZhbHVlcyBhYm92ZSAyMCBhcmUgaW52YWxpZC4gbWF4X2Fja19kZWxheSAoMHgwYik6IFRoZSBtYXhpbXVtIGFja25vd2xlZGdtZW50IGRlbGF5IGlzIGFuIGludGVnZXIgdmFsdWUgaW5kaWNhdGluZyB0aGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSBpbiBtaWxsaXNlY29uZHMgYnkgd2hpY2ggdGhlIGVuZHBvaW50IHdpbGwgZGVsYXkgc2VuZGluZyBhY2tub3dsZWRnbWVudHMuIFRoaXMgdmFsdWUgU0hPVUxEIGluY2x1ZGUgdGhlIHJlY2VpdmVyJ3MgZXhwZWN0ZWQgZGVsYXlzIGluIGFsYXJtcyBmaXJpbmcuIEZvciBleGFtcGxlLCBpZiBhIHJlY2VpdmVyIHNldHMgYSB0aW1lciBmb3IgNW1zIGFuZCBhbGFybXMgY29tbW9ubHkgZmlyZSB1cCB0byAxbXMgbGF0ZSwgdGhlbiBpdCBzaG91bGQgc2VuZCBhIG1heF9hY2tfZGVsYXkgb2YgNm1zLiBJZiB0aGlzIHZhbHVlIGlzIGFic2VudCwgYSBkZWZhdWx0IG9mIDI1IG1pbGxpc2Vjb25kcyBpcyBhc3N1bWVkLiBWYWx1ZXMgb2YgMl4xNCBvciBncmVhdGVyIGFyZSBpbnZhbGlkLiBkaXNhYmxlX2FjdGl2ZV9taWdyYXRpb24gKDB4MGMpOiBUaGUgZGlzYWJsZSBhY3RpdmUgbWlncmF0aW9uIHRyYW5zcG9ydCBwYXJhbWV0ZXIgaXMgaW5jbHVkZWQgaWYgdGhlIGVuZHBvaW50IGRvZXMgbm90IHN1cHBvcnQgYWN0aXZlIGNvbm5lY3Rpb24gbWlncmF0aW9uIChTZWN0aW9uIDkpIG9uIHRoZSBhZGRyZXNzIGJlaW5nIHVzZWQgZHVyaW5nIHRoZSBoYW5kc2hha2UuIEFuIGVuZHBvaW50IHRoYXQgcmVjZWl2ZXMgdGhpcyB0cmFuc3BvcnQgcGFyYW1ldGVyIE1VU1QgTk9UIHVzZSBhIG5ldyBsb2NhbCBhZGRyZXNzIHdoZW4gc2VuZGluZyB0byB0aGUgYWRkcmVzcyB0aGF0IHRoZSBwZWVyIHVzZWQgZHVyaW5nIHRoZSBoYW5kc2hha2UuIFRoaXMgdHJhbnNwb3J0IHBhcmFtZXRlciBkb2VzIG5vdCBwcm9oaWJpdCBjb25uZWN0aW9uIG1pZ3JhdGlvbiBhZnRlciBhIGNsaWVudCBoYXMgYWN0ZWQgb24gYSBwcmVmZXJyZWRfYWRkcmVzcyB0cmFuc3BvcnQgcGFyYW1ldGVyLiBUaGlzIHBhcmFtZXRlciBpcyBhIHplcm8tbGVuZ3RoIHZhbHVlLiBwcmVmZXJyZWRfYWRkcmVzcyAoMHgwZCk6IFRoZSBzZXJ2ZXIncyBwcmVmZXJyZWQgYWRkcmVzcyBpcyB1c2VkIHRvIGVmZmVjdCBhIGNoYW5nZSBpbiBzZXJ2ZXIgYWRkcmVzcyBhdCB0aGUgZW5kIG9mIHRoZSBoYW5kc2hha2UsIGFzIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDkuNi4gVGhpcyB0cmFuc3BvcnQgcGFyYW1ldGVyIGlzIG9ubHkgc2VudCBieSBhIHNlcnZlci4gU2VydmVycyBNQVkgY2hvb3NlIHRvIG9ubHkgc2VuZCBhIHByZWZlcnJlZCBhZGRyZXNzIG9mIG9uZSBhZGRyZXNzIGZhbWlseSBieSBzZW5kaW5nIGFuIGFsbC16ZXJvIGFkZHJlc3MgYW5kIHBvcnQgKDAuMC4wLjA6MCBvciBbOjpdOjApIGZvciB0aGUgb3RoZXIgZmFtaWx5LiBJUCBhZGRyZXNzZXMgYXJlIGVuY29kZWQgaW4gbmV0d29yayBieXRlIG9yZGVyLiBUaGUgcHJlZmVycmVkX2FkZHJlc3MgdHJhbnNwb3J0IHBhcmFtZXRlciBjb250YWlucyBhbiBhZGRyZXNzIGFuZCBwb3J0IGZvciBib3RoIElQdjQgYW5kIElQdjYuIFRoZSBmb3VyLWJ5dGUgSVB2NCBBZGRyZXNzIGZpZWxkIGlzIGZvbGxvd2VkIGJ5IHRoZSBhc3NvY2lhdGVkIHR3by1ieXRlIElQdjQgUG9ydCBmaWVsZC4gVGhpcyBpcyBmb2xsb3dlZCBieSBhIDE2LWJ5dGUgSVB2NiBBZGRyZXNzIGZpZWxkIGFuZCB0d28tYnl0ZSBJUHY2IFBvcnQgZmllbGQuIEFmdGVyIGFkZHJlc3MgYW5kIHBvcnQgcGFpcnMsIGEgQ29ubmVjdGlvbiBJRCBMZW5ndGggZmllbGQgZGVzY3JpYmVzIHRoZSBsZW5ndGggb2YgdGhlIGZvbGxvd2luZyBDb25uZWN0aW9uIElEIGZpZWxkLiBGaW5hbGx5LCBhIDE2LWJ5dGUgU3RhdGVsZXNzIFJlc2V0IFRva2VuIGZpZWxkIGluY2x1ZGVzIHRoZSBzdGF0ZWxlc3MgcmVzZXQgdG9rZW4gYXNzb2NpYXRlZCB3aXRoIHRoZSBjb25uZWN0aW9uIElELiBUaGUgZm9ybWF0IG9mIHRoaXMgdHJhbnNwb3J0IHBhcmFtZXRlciBpcyBzaG93biBpbiBGaWd1cmUgMjIgYmVsb3cuIFRoZSBDb25uZWN0aW9uIElEIGZpZWxkIGFuZCB0aGUgU3RhdGVsZXNzIFJlc2V0IFRva2VuIGZpZWxkIGNvbnRhaW4gYW4gYWx0ZXJuYXRpdmUgY29ubmVjdGlvbiBJRCB0aGF0IGhhcyBhIHNlcXVlbmNlIG51bWJlciBvZiAxOyBzZWUgU2VjdGlvbiA1LjEuMS4gSGF2aW5nIHRoZXNlIHZhbHVlcyBzZW50IGFsb25nc2lkZSB0aGUgcHJlZmVycmVkIGFkZHJlc3MgZW5zdXJlcyB0aGF0IHRoZXJlIHdpbGwgYmUgYXQgbGVhc3Qgb25lIHVudXNlZCBhY3RpdmUgY29ubmVjdGlvbiBJRCB3aGVuIHRoZSBjbGllbnQgaW5pdGlhdGVzIG1pZ3JhdGlvbiB0byB0aGUgcHJlZmVycmVkIGFkZHJlc3MuIFRoZSBDb25uZWN0aW9uIElEIGFuZCBTdGF0ZWxlc3MgUmVzZXQgVG9rZW4gZmllbGRzIG9mIGEgcHJlZmVycmVkIGFkZHJlc3MgYXJlIGlkZW50aWNhbCBpbiBzeW50YXggYW5kIHNlbWFudGljcyB0byB0aGUgY29ycmVzcG9uZGluZyBmaWVsZHMgb2YgYSBORVdfQ09OTkVDVElPTl9JRCBmcmFtZSAoU2VjdGlvbiAxOS4xNSkuIEEgc2VydmVyIHRoYXQgY2hvb3NlcyBhIHplcm8tbGVuZ3RoIGNvbm5lY3Rpb24gSUQgTVVTVCBOT1QgcHJvdmlkZSBhIHByZWZlcnJlZCBhZGRyZXNzLiBTaW1pbGFybHksIGEgc2VydmVyIE1VU1QgTk9UIGluY2x1ZGUgYSB6ZXJvLSBsZW5ndGggY29ubmVjdGlvbiBJRCBpbiB0aGlzIHRyYW5zcG9ydCBwYXJhbWV0ZXIuIEEgY2xpZW50IE1VU1QgdHJlYXQgYSB2aW9sYXRpb24gb2YgdGhlc2UgcmVxdWlyZW1lbnRzIGFzIGEgY29ubmVjdGlvbiBlcnJvciBvZiB0eXBlIFRSQU5TUE9SVF9QQVJBTUVURVJfRVJST1IuIFByZWZlcnJlZCBBZGRyZXNzIHsgSVB2NCBBZGRyZXNzICgzMiksIElQdjQgUG9ydCAoMTYpLCBJUHY2IEFkZHJlc3MgKDEyOCksIElQdjYgUG9ydCAoMTYpLCBDb25uZWN0aW9uIElEIExlbmd0aCAoOCksIENvbm5lY3Rpb24gSUQgKC4uKSwgU3RhdGVsZXNzIFJlc2V0IFRva2VuICgxMjgpLCB9IEZpZ3VyZSAyMjogUHJlZmVycmVkIEFkZHJlc3MgRm9ybWF0IGFjdGl2ZV9jb25uZWN0aW9uX2lkX2xpbWl0ICgweDBlKTogVGhpcyBpcyBhbiBpbnRlZ2VyIHZhbHVlIHNwZWNpZnlpbmcgdGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbm5lY3Rpb24gSURzIGZyb20gdGhlIHBlZXIgdGhhdCBhbiBlbmRwb2ludCBpcyB3aWxsaW5nIHRvIHN0b3JlLiBUaGlzIHZhbHVlIGluY2x1ZGVzIHRoZSBjb25uZWN0aW9uIElEIHJlY2VpdmVkIGR1cmluZyB0aGUgaGFuZHNoYWtlLCB0aGF0IHJlY2VpdmVkIGluIHRoZSBwcmVmZXJyZWRfYWRkcmVzcyB0cmFuc3BvcnQgcGFyYW1ldGVyLCBhbmQgdGhvc2UgcmVjZWl2ZWQgaW4gTkVXX0NPTk5FQ1RJT05fSUQgZnJhbWVzLiBUaGUgdmFsdWUgb2YgdGhlIGFjdGl2ZV9jb25uZWN0aW9uX2lkX2xpbWl0IHBhcmFtZXRlciBNVVNUIGJlIGF0IGxlYXN0IDIuIEFuIGVuZHBvaW50IHRoYXQgcmVjZWl2ZXMgYSB2YWx1ZSBsZXNzIHRoYW4gMiBNVVNUIGNsb3NlIHRoZSBjb25uZWN0aW9uIHdpdGggYW4gZXJyb3Igb2YgdHlwZSBUUkFOU1BPUlRfUEFSQU1FVEVSX0VSUk9SLiBJZiB0aGlzIHRyYW5zcG9ydCBwYXJhbWV0ZXIgaXMgYWJzZW50LCBhIGRlZmF1bHQgb2YgMiBpcyBhc3N1bWVkLiBJZiBhbiBlbmRwb2ludCBpc3N1ZXMgYSB6ZXJvLWxlbmd0aCBjb25uZWN0aW9uIElELCBpdCB3aWxsIG5ldmVyIHNlbmQgYSBORVdfQ09OTkVDVElPTl9JRCBmcmFtZSBhbmQgdGhlcmVmb3JlIGlnbm9yZXMgdGhlIGFjdGl2ZV9jb25uZWN0aW9uX2lkX2xpbWl0IHZhbHVlIHJlY2VpdmVkIGZyb20gaXRzIHBlZXIuIGluaXRpYWxfc291cmNlX2Nvbm5lY3Rpb25faWQgKDB4MGYpOiBUaGlzIGlzIHRoZSB2YWx1ZSB0aGF0IHRoZSBlbmRwb2ludCBpbmNsdWRlZCBpbiB0aGUgU291cmNlIENvbm5lY3Rpb24gSUQgZmllbGQgb2YgdGhlIGZpcnN0IEluaXRpYWwgcGFja2V0IGl0IHNlbmRzIGZvciB0aGUgY29ubmVjdGlvbjsgc2VlIFNlY3Rpb24gNy4zLiByZXRyeV9zb3VyY2VfY29ubmVjdGlvbl9pZCAoMHgxMCk6IFRoaXMgaXMgdGhlIHZhbHVlIHRoYXQgdGhlIHNlcnZlciBpbmNsdWRlZCBpbiB0aGUgU291cmNlIENvbm5lY3Rpb24gSUQgZmllbGQgb2YgYSBSZXRyeSBwYWNrZXQ7IHNlZSBTZWN0aW9uIDcuMy4gVGhpcyB0cmFuc3BvcnQgcGFyYW1ldGVyIGlzIG9ubHkgc2VudCBieSBhIHNlcnZlci4gSWYgcHJlc2VudCwgdHJhbnNwb3J0IHBhcmFtZXRlcnMgdGhhdCBzZXQgaW5pdGlhbCBwZXItc3RyZWFtIGZsb3cgY29udHJvbCBsaW1pdHMgKGluaXRpYWxfbWF4X3N0cmVhbV9kYXRhX2JpZGlfbG9jYWwsIGluaXRpYWxfbWF4X3N0cmVhbV9kYXRhX2JpZGlfcmVtb3RlLCBhbmQgaW5pdGlhbF9tYXhfc3RyZWFtX2RhdGFfdW5pKSBhcmUgZXF1aXZhbGVudCB0byBzZW5kaW5nIGEgTUFYX1NUUkVBTV9EQVRBIGZyYW1lIChTZWN0aW9uIDE5LjEwKSBvbiBldmVyeSBzdHJlYW0gb2YgdGhlIGNvcnJlc3BvbmRpbmcgdHlwZSBpbW1lZGlhdGVseSBhZnRlciBvcGVuaW5nLiBJZiB0aGUgdHJhbnNwb3J0IHBhcmFtZXRlciBpcyBhYnNlbnQsIHN0cmVhbXMgb2YgdGhhdCB0eXBlIHN0YXJ0IHdpdGggYSBmbG93IGNvbnRyb2wgbGltaXQgb2YgMC4gQSBjbGllbnQgTVVTVCBOT1QgaW5jbHVkZSBhbnkgc2VydmVyLW9ubHkgdHJhbnNwb3J0IHBhcmFtZXRlcjogb3JpZ2luYWxfZGVzdGluYXRpb25fY29ubmVjdGlvbl9pZCwgcHJlZmVycmVkX2FkZHJlc3MsIHJldHJ5X3NvdXJjZV9jb25uZWN0aW9uX2lkLCBvciBzdGF0ZWxlc3NfcmVzZXRfdG9rZW4uIEEgc2VydmVyIE1VU1QgdHJlYXQgcmVjZWlwdCBvZiBhbnkgb2YgdGhlc2UgdHJhbnNwb3J0IHBhcmFtZXRlcnMgYXMgYSBjb25uZWN0aW9uIGVycm9yIG9mIHR5cGUgVFJBTlNQT1JUX1BBUkFNRVRFUl9FUlJPUi4gMTkuIEZyYW1lIFR5cGVzIGFuZCBGb3JtYXRzIEFzIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDEyLjQsIHBhY2tldHMgY29udGFpbiBvbmUgb3IgbW9yZSBmcmFtZXMuIFRoaXMgc2VjdGlvbiBkZXNjcmliZXMgdGhlIGZvcm1hdCBhbmQgc2VtYW50aWNzIG9mIHRoZSBjb3JlIFFVSUMgZnJhbWUgdHlwZXMuIDE5LjEuIFBBRERJTkcgRnJhbWVzIEEgUEFERElORyBmcmFtZSAodHlwZT0weDAwKSBoYXMgbm8gc2VtYW50aWMgdmFsdWUuIFBBRERJTkcgZnJhbWVzIGNhbiBiZSB1c2VkIHRvIGluY3JlYXNlIHRoZSBzaXplIG9mIGEgcGFja2V0LiBQYWRkaW5nIGNhbiBiZSB1c2VkIHRvIGluY3JlYXNlIGFuIEluaXRpYWwgcGFja2V0IHRvIHRoZSBtaW5pbXVtIHJlcXVpcmVkIHNpemUgb3IgdG8gcHJvdmlkZSBwcm90ZWN0aW9uIGFnYWluc3QgdHJhZmZpYyBhbmFseXNpcyBmb3IgcHJvdGVjdGVkIHBhY2tldHMuIFBBRERJTkcgZnJhbWVzIGFyZSBmb3JtYXR0ZWQgYXMgc2hvd24gaW4gRmlndXJlIDIzLCB3aGljaCBzaG93cyB0aGF0IFBBRERJTkcgZnJhbWVzIGhhdmUgbm8gY29udGVudC4gVGhhdCBpcywgYSBQQURESU5HIGZyYW1lIGNvbnNpc3RzIG9mIHRoZSBzaW5nbGUgYnl0ZSB0aGF0IGlkZW50aWZpZXMgdGhlIGZyYW1lIGFzIGEgUEFERElORyBmcmFtZS4gUEFERElORyBGcmFtZSB7IFR5cGUgKGkpID0gMHgwMCwgfSBGaWd1cmUgMjM6IFBBRERJTkcgRnJhbWUgRm9ybWF0IDE5LjIuIFBJTkcgRnJhbWVzIEVuZHBvaW50cyBjYW4gdXNlIFBJTkcgZnJhbWVzICh0eXBlPTB4MDEpIHRvIHZlcmlmeSB0aGF0IHRoZWlyIHBlZXJzIGFyZSBzdGlsbCBhbGl2ZSBvciB0byBjaGVjayByZWFjaGFiaWxpdHkgdG8gdGhlIHBlZXIuIFBJTkcgZnJhbWVzIGFyZSBmb3JtYXR0ZWQgYXMgc2hvd24gaW4gRmlndXJlIDI0LCB3aGljaCBzaG93cyB0aGF0IFBJTkcgZnJhbWVzIGhhdmUgbm8gY29udGVudC4gUElORyBGcmFtZSB7IFR5cGUgKGkpID0gMHgwMSwgfSBGaWd1cmUgMjQ6IFBJTkcgRnJhbWUgRm9ybWF0IFRoZSByZWNlaXZlciBvZiBhIFBJTkcgZnJhbWUgc2ltcGx5IG5lZWRzIHRvIGFja25vd2xlZGdlIHRoZSBwYWNrZXQgY29udGFpbmluZyB0aGlzIGZyYW1lLiBUaGUgUElORyBmcmFtZSBjYW4gYmUgdXNlZCB0byBrZWVwIGEgY29ubmVjdGlvbiBhbGl2ZSB3aGVuIGFuIGFwcGxpY2F0aW9uIG9yIGFwcGxpY2F0aW9uIHByb3RvY29sIHdpc2hlcyB0byBwcmV2ZW50IHRoZSBjb25uZWN0aW9uIGZyb20gdGltaW5nIG91dDsgc2VlIFNlY3Rpb24gMTAuMS4yLiAxOS4zLiBBQ0sgRnJhbWVzIFJlY2VpdmVycyBzZW5kIEFDSyBmcmFtZXMgKHR5cGVzIDB4MDIgYW5kIDB4MDMpIHRvIGluZm9ybSBzZW5kZXJzIG9mIHBhY2tldHMgdGhleSBoYXZlIHJlY2VpdmVkIGFuZCBwcm9jZXNzZWQuIFRoZSBBQ0sgZnJhbWUgY29udGFpbnMgb25lIG9yIG1vcmUgQUNLIFJhbmdlcy4gQUNLIFJhbmdlcyBpZGVudGlmeSBhY2tub3dsZWRnZWQgcGFja2V0cy4gSWYgdGhlIGZyYW1lIHR5cGUgaXMgMHgwMywgQUNLIGZyYW1lcyBhbHNvIGNvbnRhaW4gdGhlIGN1bXVsYXRpdmUgY291bnQgb2YgUVVJQyBwYWNrZXRzIHdpdGggYXNzb2NpYXRlZCBFQ04gbWFya3MgcmVjZWl2ZWQgb24gdGhlIGNvbm5lY3Rpb24gdXAgdW50aWwgdGhpcyBwb2ludC4gUVVJQyBpbXBsZW1lbnRhdGlvbnMgTVVTVCBwcm9wZXJseSBoYW5kbGUgYm90aCB0eXBlcywgYW5kLCBpZiB0aGV5IGhhdmUgZW5hYmxlZCBFQ04gZm9yIHBhY2tldHMgdGhleSBzZW5kLCB0aGV5IFNIT1VMRCB1c2UgdGhlIGluZm9ybWF0aW9uIGluIHRoZSBFQ04gc2VjdGlvbiB0byBtYW5hZ2UgdGhlaXIgY29uZ2VzdGlvbiBzdGF0ZS4gUVVJQyBhY2tub3dsZWRnbWVudHMgYXJlIGlycmV2b2NhYmxlLiBPbmNlIGFja25vd2xlZGdlZCwgYSBwYWNrZXQgcmVtYWlucyBhY2tub3dsZWRnZWQsIGV2ZW4gaWYgaXQgZG9lcyBub3QgYXBwZWFyIGluIGEgZnV0dXJlIEFDSyBmcmFtZS4gVGhpcyBpcyB1bmxpa2UgcmVuZWdpbmcgZm9yIFRDUCBTZWxlY3RpdmUgQWNrbm93bGVkZ21lbnRzIChTQUNLcykgW1JGQzIwMThdLiBQYWNrZXRzIGZyb20gZGlmZmVyZW50IHBhY2tldCBudW1iZXIgc3BhY2VzIGNhbiBiZSBpZGVudGlmaWVkIHVzaW5nIHRoZSBzYW1lIG51bWVyaWMgdmFsdWUuIEFuIGFja25vd2xlZGdtZW50IGZvciBhIHBhY2tldCBuZWVkcyB0byBpbmRpY2F0ZSBib3RoIGEgcGFja2V0IG51bWJlciBhbmQgYSBwYWNrZXQgbnVtYmVyIHNwYWNlLiBUaGlzIGlzIGFjY29tcGxpc2hlZCBieSBoYXZpbmcgZWFjaCBBQ0sgZnJhbWUgb25seSBhY2tub3dsZWRnZSBwYWNrZXQgbnVtYmVycyBpbiB0aGUgc2FtZSBzcGFjZSBhcyB0aGUgcGFja2V0IGluIHdoaWNoIHRoZSBBQ0sgZnJhbWUgaXMgY29udGFpbmVkLiBWZXJzaW9uIE5lZ290aWF0aW9uIGFuZCBSZXRyeSBwYWNrZXRzIGNhbm5vdCBiZSBhY2tub3dsZWRnZWQgYmVjYXVzZSB0aGV5IGRvIG5vdCBjb250YWluIGEgcGFja2V0IG51bWJlci4gUmF0aGVyIHRoYW4gcmVseWluZyBvbiBBQ0sgZnJhbWVzLCB0aGVzZSBwYWNrZXRzIGFyZSBpbXBsaWNpdGx5IGFja25vd2xlZGdlZCBieSB0aGUgbmV4dCBJbml0aWFsIHBhY2tldCBzZW50IGJ5IHRoZSBjbGllbnQuIEFDSyBmcmFtZXMgYXJlIGZvcm1hdHRlZCBhcyBzaG93biBpbiBGaWd1cmUgMjUuIEFDSyBGcmFtZSB7IFR5cGUgKGkpID0gMHgwMi4uMHgwMywgTGFyZ2VzdCBBY2tub3dsZWRnZWQgKGkpLCBBQ0sgRGVsYXkgKGkpLCBBQ0sgUmFuZ2UgQ291bnQgKGkpLCBGaXJzdCBBQ0sgUmFuZ2UgKGkpLCBBQ0sgUmFuZ2UgKC4uKSAuLi4sIFtFQ04gQ291bnRzICguLildLCB9IEZpZ3VyZSAyNTogQUNLIEZyYW1lIEZvcm1hdCBBQ0sgZnJhbWVzIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBmaWVsZHM6IExhcmdlc3QgQWNrbm93bGVkZ2VkOiBBIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgbGFyZ2VzdCBwYWNrZXQgbnVtYmVyIHRoZSBwZWVyIGlzIGFja25vd2xlZGdpbmc7IHRoaXMgaXMgdXN1YWxseSB0aGUgbGFyZ2VzdCBwYWNrZXQgbnVtYmVyIHRoYXQgdGhlIHBlZXIgaGFzIHJlY2VpdmVkIHByaW9yIHRvIGdlbmVyYXRpbmcgdGhlIEFDSyBmcmFtZS4gVW5saWtlIHRoZSBwYWNrZXQgbnVtYmVyIGluIHRoZSBRVUlDIGxvbmcgb3Igc2hvcnQgaGVhZGVyLCB0aGUgdmFsdWUgaW4gYW4gQUNLIGZyYW1lIGlzIG5vdCB0cnVuY2F0ZWQuIEFDSyBEZWxheTogQSB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBlbmNvZGluZyB0aGUgYWNrbm93bGVkZ21lbnQgZGVsYXkgaW4gbWljcm9zZWNvbmRzOyBzZWUgU2VjdGlvbiAxMy4yLjUuIEl0IGlzIGRlY29kZWQgYnkgbXVsdGlwbHlpbmcgdGhlIHZhbHVlIGluIHRoZSBmaWVsZCBieSAyIHRvIHRoZSBwb3dlciBvZiB0aGUgYWNrX2RlbGF5X2V4cG9uZW50IHRyYW5zcG9ydCBwYXJhbWV0ZXIgc2VudCBieSB0aGUgc2VuZGVyIG9mIHRoZSBBQ0sgZnJhbWU7IHNlZSBTZWN0aW9uIDE4LjIuIENvbXBhcmVkIHRvIHNpbXBseSBleHByZXNzaW5nIHRoZSBkZWxheSBhcyBhbiBpbnRlZ2VyLCB0aGlzIGVuY29kaW5nIGFsbG93cyBmb3IgYSBsYXJnZXIgcmFuZ2Ugb2YgdmFsdWVzIHdpdGhpbiB0aGUgc2FtZSBudW1iZXIgb2YgYnl0ZXMsIGF0IHRoZSBjb3N0IG9mIGxvd2VyIHJlc29sdXRpb24uIEFDSyBSYW5nZSBDb3VudDogQSB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBzcGVjaWZ5aW5nIHRoZSBudW1iZXIgb2YgQUNLIFJhbmdlIGZpZWxkcyBpbiB0aGUgZnJhbWUuIEZpcnN0IEFDSyBSYW5nZTogQSB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBudW1iZXIgb2YgY29udGlndW91cyBwYWNrZXRzIHByZWNlZGluZyB0aGUgTGFyZ2VzdCBBY2tub3dsZWRnZWQgdGhhdCBhcmUgYmVpbmcgYWNrbm93bGVkZ2VkLiBUaGF0IGlzLCB0aGUgc21hbGxlc3QgcGFja2V0IGFja25vd2xlZGdlZCBpbiB0aGUgcmFuZ2UgaXMgZGV0ZXJtaW5lZCBieSBzdWJ0cmFjdGluZyB0aGUgRmlyc3QgQUNLIFJhbmdlIHZhbHVlIGZyb20gdGhlIExhcmdlc3QgQWNrbm93bGVkZ2VkIGZpZWxkLiBBQ0sgUmFuZ2VzOiBDb250YWlucyBhZGRpdGlvbmFsIHJhbmdlcyBvZiBwYWNrZXRzIHRoYXQgYXJlIGFsdGVybmF0ZWx5IG5vdCBhY2tub3dsZWRnZWQgKEdhcCkgYW5kIGFja25vd2xlZGdlZCAoQUNLIFJhbmdlKTsgc2VlIFNlY3Rpb24gMTkuMy4xLiBFQ04gQ291bnRzOiBUaGUgdGhyZWUgRUNOIGNvdW50czsgc2VlIFNlY3Rpb24gMTkuMy4yLiAxOS4zLjEuIEFDSyBSYW5nZXMgRWFjaCBBQ0sgUmFuZ2UgY29uc2lzdHMgb2YgYWx0ZXJuYXRpbmcgR2FwIGFuZCBBQ0sgUmFuZ2UgTGVuZ3RoIHZhbHVlcyBpbiBkZXNjZW5kaW5nIHBhY2tldCBudW1iZXIgb3JkZXIuIEFDSyBSYW5nZXMgY2FuIGJlIHJlcGVhdGVkLiBUaGUgbnVtYmVyIG9mIEdhcCBhbmQgQUNLIFJhbmdlIExlbmd0aCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgQUNLIFJhbmdlIENvdW50IGZpZWxkOyBvbmUgb2YgZWFjaCB2YWx1ZSBpcyBwcmVzZW50IGZvciBlYWNoIHZhbHVlIGluIHRoZSBBQ0sgUmFuZ2UgQ291bnQgZmllbGQuIEFDSyBSYW5nZXMgYXJlIHN0cnVjdHVyZWQgYXMgc2hvd24gaW4gRmlndXJlIDI2LiBBQ0sgUmFuZ2UgeyBHYXAgKGkpLCBBQ0sgUmFuZ2UgTGVuZ3RoIChpKSwgfSBGaWd1cmUgMjY6IEFDSyBSYW5nZXMgVGhlIGZpZWxkcyB0aGF0IGZvcm0gZWFjaCBBQ0sgUmFuZ2UgYXJlOiBHYXA6IEEgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW5kaWNhdGluZyB0aGUgbnVtYmVyIG9mIGNvbnRpZ3VvdXMgdW5hY2tub3dsZWRnZWQgcGFja2V0cyBwcmVjZWRpbmcgdGhlIHBhY2tldCBudW1iZXIgb25lIGxvd2VyIHRoYW4gdGhlIHNtYWxsZXN0IGluIHRoZSBwcmVjZWRpbmcgQUNLIFJhbmdlLiBBQ0sgUmFuZ2UgTGVuZ3RoOiBBIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIG51bWJlciBvZiBjb250aWd1b3VzIGFja25vd2xlZGdlZCBwYWNrZXRzIHByZWNlZGluZyB0aGUgbGFyZ2VzdCBwYWNrZXQgbnVtYmVyLCBhcyBkZXRlcm1pbmVkIGJ5IHRoZSBwcmVjZWRpbmcgR2FwLiBHYXAgYW5kIEFDSyBSYW5nZSBMZW5ndGggdmFsdWVzIHVzZSBhIHJlbGF0aXZlIGludGVnZXIgZW5jb2RpbmcgZm9yIGVmZmljaWVuY3kuIFRob3VnaCBlYWNoIGVuY29kZWQgdmFsdWUgaXMgcG9zaXRpdmUsIHRoZSB2YWx1ZXMgYXJlIHN1YnRyYWN0ZWQsIHNvIHRoYXQgZWFjaCBBQ0sgUmFuZ2UgZGVzY3JpYmVzIHByb2dyZXNzaXZlbHkgbG93ZXItIG51bWJlcmVkIHBhY2tldHMuIEVhY2ggQUNLIFJhbmdlIGFja25vd2xlZGdlcyBhIGNvbnRpZ3VvdXMgcmFuZ2Ugb2YgcGFja2V0cyBieSBpbmRpY2F0aW5nIHRoZSBudW1iZXIgb2YgYWNrbm93bGVkZ2VkIHBhY2tldHMgdGhhdCBwcmVjZWRlIHRoZSBsYXJnZXN0IHBhY2tldCBudW1iZXIgaW4gdGhhdCByYW5nZS4gQSB2YWx1ZSBvZiAwIGluZGljYXRlcyB0aGF0IG9ubHkgdGhlIGxhcmdlc3QgcGFja2V0IG51bWJlciBpcyBhY2tub3dsZWRnZWQuIExhcmdlciBBQ0sgUmFuZ2UgdmFsdWVzIGluZGljYXRlIGEgbGFyZ2VyIHJhbmdlLCB3aXRoIGNvcnJlc3BvbmRpbmcgbG93ZXIgdmFsdWVzIGZvciB0aGUgc21hbGxlc3QgcGFja2V0IG51bWJlciBpbiB0aGUgcmFuZ2UuIFRodXMsIGdpdmVuIGEgbGFyZ2VzdCBwYWNrZXQgbnVtYmVyIGZvciB0aGUgcmFuZ2UsIHRoZSBzbWFsbGVzdCB2YWx1ZSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBmb2xsb3dpbmcgZm9ybXVsYTogc21hbGxlc3QgPSBsYXJnZXN0IC0gYWNrX3JhbmdlIEFuIEFDSyBSYW5nZSBhY2tub3dsZWRnZXMgYWxsIHBhY2tldHMgYmV0d2VlbiB0aGUgc21hbGxlc3QgcGFja2V0IG51bWJlciBhbmQgdGhlIGxhcmdlc3QsIGluY2x1c2l2ZS4gVGhlIGxhcmdlc3QgdmFsdWUgZm9yIGFuIEFDSyBSYW5nZSBpcyBkZXRlcm1pbmVkIGJ5IGN1bXVsYXRpdmVseSBzdWJ0cmFjdGluZyB0aGUgc2l6ZSBvZiBhbGwgcHJlY2VkaW5nIEFDSyBSYW5nZSBMZW5ndGhzIGFuZCBHYXBzLiBFYWNoIEdhcCBpbmRpY2F0ZXMgYSByYW5nZSBvZiBwYWNrZXRzIHRoYXQgYXJlIG5vdCBiZWluZyBhY2tub3dsZWRnZWQuIFRoZSBudW1iZXIgb2YgcGFja2V0cyBpbiB0aGUgZ2FwIGlzIG9uZSBoaWdoZXIgdGhhbiB0aGUgZW5jb2RlZCB2YWx1ZSBvZiB0aGUgR2FwIGZpZWxkLiBUaGUgdmFsdWUgb2YgdGhlIEdhcCBmaWVsZCBlc3RhYmxpc2hlcyB0aGUgbGFyZ2VzdCBwYWNrZXQgbnVtYmVyIHZhbHVlIGZvciB0aGUgc3Vic2VxdWVudCBBQ0sgUmFuZ2UgdXNpbmcgdGhlIGZvbGxvd2luZyBmb3JtdWxhOiBsYXJnZXN0ID0gcHJldmlvdXNfc21hbGxlc3QgLSBnYXAgLSAyIElmIGFueSBjb21wdXRlZCBwYWNrZXQgbnVtYmVyIGlzIG5lZ2F0aXZlLCBhbiBlbmRwb2ludCBNVVNUIGdlbmVyYXRlIGEgY29ubmVjdGlvbiBlcnJvciBvZiB0eXBlIEZSQU1FX0VOQ09ESU5HX0VSUk9SLiAxOS4zLjIuIEVDTiBDb3VudHMgVGhlIEFDSyBmcmFtZSB1c2VzIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIHR5cGUgdmFsdWUgKHRoYXQgaXMsIHR5cGUgMHgwMykgdG8gaW5kaWNhdGUgRUNOIGZlZWRiYWNrIGFuZCByZXBvcnQgcmVjZWlwdCBvZiBRVUlDIHBhY2tldHMgd2l0aCBhc3NvY2lhdGVkIEVDTiBjb2RlcG9pbnRzIG9mIEVDVCgwKSwgRUNUKDEpLCBvciBFQ04tQ0UgaW4gdGhlIHBhY2tldCdzIElQIGhlYWRlci4gRUNOIGNvdW50cyBhcmUgb25seSBwcmVzZW50IHdoZW4gdGhlIEFDSyBmcmFtZSB0eXBlIGlzIDB4MDMuIFdoZW4gcHJlc2VudCwgdGhlcmUgYXJlIHRocmVlIEVDTiBjb3VudHMsIGFzIHNob3duIGluIEZpZ3VyZSAyNy4gRUNOIENvdW50cyB7IEVDVDAgQ291bnQgKGkpLCBFQ1QxIENvdW50IChpKSwgRUNOLUNFIENvdW50IChpKSwgfSBGaWd1cmUgMjc6IEVDTiBDb3VudCBGb3JtYXQgVGhlIEVDTiBjb3VudCBmaWVsZHMgYXJlOiBFQ1QwIENvdW50OiBBIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgdG90YWwgbnVtYmVyIG9mIHBhY2tldHMgcmVjZWl2ZWQgd2l0aCB0aGUgRUNUKDApIGNvZGVwb2ludCBpbiB0aGUgcGFja2V0IG51bWJlciBzcGFjZSBvZiB0aGUgQUNLIGZyYW1lLiBFQ1QxIENvdW50OiBBIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgdG90YWwgbnVtYmVyIG9mIHBhY2tldHMgcmVjZWl2ZWQgd2l0aCB0aGUgRUNUKDEpIGNvZGVwb2ludCBpbiB0aGUgcGFja2V0IG51bWJlciBzcGFjZSBvZiB0aGUgQUNLIGZyYW1lLiBFQ04tQ0UgQ291bnQ6IEEgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgcmVwcmVzZW50aW5nIHRoZSB0b3RhbCBudW1iZXIgb2YgcGFja2V0cyByZWNlaXZlZCB3aXRoIHRoZSBFQ04tQ0UgY29kZXBvaW50IGluIHRoZSBwYWNrZXQgbnVtYmVyIHNwYWNlIG9mIHRoZSBBQ0sgZnJhbWUuIEVDTiBjb3VudHMgYXJlIG1haW50YWluZWQgc2VwYXJhdGVseSBmb3IgZWFjaCBwYWNrZXQgbnVtYmVyIHNwYWNlLiAxOS40LiBSRVNFVF9TVFJFQU0gRnJhbWVzIEFuIGVuZHBvaW50IHVzZXMgYSBSRVNFVF9TVFJFQU0gZnJhbWUgKHR5cGU9MHgwNCkgdG8gYWJydXB0bHkgdGVybWluYXRlIHRoZSBzZW5kaW5nIHBhcnQgb2YgYSBzdHJlYW0uIEFmdGVyIHNlbmRpbmcgYSBSRVNFVF9TVFJFQU0sIGFuIGVuZHBvaW50IGNlYXNlcyB0cmFuc21pc3Npb24gYW5kIHJldHJhbnNtaXNzaW9uIG9mIFNUUkVBTSBmcmFtZXMgb24gdGhlIGlkZW50aWZpZWQgc3RyZWFtLiBBIHJlY2VpdmVyIG9mIFJFU0VUX1NUUkVBTSBjYW4gZGlzY2FyZCBhbnkgZGF0YSB0aGF0IGl0IGFscmVhZHkgcmVjZWl2ZWQgb24gdGhhdCBzdHJlYW0uIEFuIGVuZHBvaW50IHRoYXQgcmVjZWl2ZXMgYSBSRVNFVF9TVFJFQU0gZnJhbWUgZm9yIGEgc2VuZC1vbmx5IHN0cmVhbSBNVVNUIHRlcm1pbmF0ZSB0aGUgY29ubmVjdGlvbiB3aXRoIGVycm9yIFNUUkVBTV9TVEFURV9FUlJPUi4gUkVTRVRfU1RSRUFNIGZyYW1lcyBhcmUgZm9ybWF0dGVkIGFzIHNob3duIGluIEZpZ3VyZSAyOC4gUkVTRVRfU1RSRUFNIEZyYW1lIHsgVHlwZSAoaSkgPSAweDA0LCBTdHJlYW0gSUQgKGkpLCBBcHBsaWNhdGlvbiBQcm90b2NvbCBFcnJvciBDb2RlIChpKSwgRmluYWwgU2l6ZSAoaSksIH0gRmlndXJlIDI4OiBSRVNFVF9TVFJFQU0gRnJhbWUgRm9ybWF0IFJFU0VUX1NUUkVBTSBmcmFtZXMgY29udGFpbiB0aGUgZm9sbG93aW5nIGZpZWxkczogU3RyZWFtIElEOiBBIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGVuY29kaW5nIG9mIHRoZSBzdHJlYW0gSUQgb2YgdGhlIHN0cmVhbSBiZWluZyB0ZXJtaW5hdGVkLiBBcHBsaWNhdGlvbiBQcm90b2NvbCBFcnJvciBDb2RlOiBBIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGNvbnRhaW5pbmcgdGhlIGFwcGxpY2F0aW9uIHByb3RvY29sIGVycm9yIGNvZGUgKHNlZSBTZWN0aW9uIDIwLjIpIHRoYXQgaW5kaWNhdGVzIHdoeSB0aGUgc3RyZWFtIGlzIGJlaW5nIGNsb3NlZC4gRmluYWwgU2l6ZTogQSB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBmaW5hbCBzaXplIG9mIHRoZSBzdHJlYW0gYnkgdGhlIFJFU0VUX1NUUkVBTSBzZW5kZXIsIGluIHVuaXRzIG9mIGJ5dGVzOyBzZWUgU2VjdGlvbiA0LjUuIDE5LjUuIFNUT1BfU0VORElORyBGcmFtZXMgQW4gZW5kcG9pbnQgdXNlcyBhIFNUT1BfU0VORElORyBmcmFtZSAodHlwZT0weDA1KSB0byBjb21tdW5pY2F0ZSB0aGF0IGluY29taW5nIGRhdGEgaXMgYmVpbmcgZGlzY2FyZGVkIG9uIHJlY2VpcHQgcGVyIGFwcGxpY2F0aW9uIHJlcXVlc3QuIFNUT1BfU0VORElORyByZXF1ZXN0cyB0aGF0IGEgcGVlciBjZWFzZSB0cmFuc21pc3Npb24gb24gYSBzdHJlYW0uIEEgU1RPUF9TRU5ESU5HIGZyYW1lIGNhbiBiZSBzZW50IGZvciBzdHJlYW1zIGluIHRoZSAiUmVjdiIgb3IgIlNpemUgS25vd24iIHN0YXRlczsgc2VlIFNlY3Rpb24gMy4yLiBSZWNlaXZpbmcgYSBTVE9QX1NFTkRJTkcgZnJhbWUgZm9yIGEgbG9jYWxseSBpbml0aWF0ZWQgc3RyZWFtIHRoYXQgaGFzIG5vdCB5ZXQgYmVlbiBjcmVhdGVkIE1VU1QgYmUgdHJlYXRlZCBhcyBhIGNvbm5lY3Rpb24gZXJyb3Igb2YgdHlwZSBTVFJFQU1fU1RBVEVfRVJST1IuIEFuIGVuZHBvaW50IHRoYXQgcmVjZWl2ZXMgYSBTVE9QX1NFTkRJTkcgZnJhbWUgZm9yIGEgcmVjZWl2ZS1vbmx5IHN0cmVhbSBNVVNUIHRlcm1pbmF0ZSB0aGUgY29ubmVjdGlvbiB3aXRoIGVycm9yIFNUUkVBTV9TVEFURV9FUlJPUi4gU1RPUF9TRU5ESU5HIGZyYW1lcyBhcmUgZm9ybWF0dGVkIGFzIHNob3duIGluIEZpZ3VyZSAyOS4gU1RPUF9TRU5ESU5HIEZyYW1lIHsgVHlwZSAoaSkgPSAweDA1LCBTdHJlYW0gSUQgKGkpLCBBcHBsaWNhdGlvbiBQcm90b2NvbCBFcnJvciBDb2RlIChpKSwgfSBGaWd1cmUgMjk6IFNUT1BfU0VORElORyBGcmFtZSBGb3JtYXQgU1RPUF9TRU5ESU5HIGZyYW1lcyBjb250YWluIHRoZSBmb2xsb3dpbmcgZmllbGRzOiBTdHJlYW0gSUQ6IEEgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgY2FycnlpbmcgdGhlIHN0cmVhbSBJRCBvZiB0aGUgc3RyZWFtIGJlaW5nIGlnbm9yZWQuIEFwcGxpY2F0aW9uIFByb3RvY29sIEVycm9yIENvZGU6IEEgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgY29udGFpbmluZyB0aGUgYXBwbGljYXRpb24tc3BlY2lmaWVkIHJlYXNvbiB0aGUgc2VuZGVyIGlzIGlnbm9yaW5nIHRoZSBzdHJlYW07IHNlZSBTZWN0aW9uIDIwLjIuIDE5LjYuIENSWVBUTyBGcmFtZXMgQSBDUllQVE8gZnJhbWUgKHR5cGU9MHgwNikgaXMgdXNlZCB0byB0cmFuc21pdCBjcnlwdG9ncmFwaGljIGhhbmRzaGFrZSBtZXNzYWdlcy4gSXQgY2FuIGJlIHNlbnQgaW4gYWxsIHBhY2tldCB0eXBlcyBleGNlcHQgMC1SVFQuIFRoZSBDUllQVE8gZnJhbWUgb2ZmZXJzIHRoZSBjcnlwdG9ncmFwaGljIHByb3RvY29sIGFuIGluLW9yZGVyIHN0cmVhbSBvZiBieXRlcy4gQ1JZUFRPIGZyYW1lcyBhcmUgZnVuY3Rpb25hbGx5IGlkZW50aWNhbCB0byBTVFJFQU0gZnJhbWVzLCBleGNlcHQgdGhhdCB0aGV5IGRvIG5vdCBiZWFyIGEgc3RyZWFtIGlkZW50aWZpZXI7IHRoZXkgYXJlIG5vdCBmbG93IGNvbnRyb2xsZWQ7IGFuZCB0aGV5IGRvIG5vdCBjYXJyeSBtYXJrZXJzIGZvciBvcHRpb25hbCBvZmZzZXQsIG9wdGlvbmFsIGxlbmd0aCwgYW5kIHRoZSBlbmQgb2YgdGhlIHN0cmVhbS4gQ1JZUFRPIGZyYW1lcyBhcmUgZm9ybWF0dGVkIGFzIHNob3duIGluIEZpZ3VyZSAzMC4gQ1JZUFRPIEZyYW1lIHsgVHlwZSAoaSkgPSAweDA2LCBPZmZzZXQgKGkpLCBMZW5ndGggKGkpLCBDcnlwdG8gRGF0YSAoLi4pLCB9IEZpZ3VyZSAzMDogQ1JZUFRPIEZyYW1lIEZvcm1hdCBDUllQVE8gZnJhbWVzIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBmaWVsZHM6IE9mZnNldDogQSB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBzcGVjaWZ5aW5nIHRoZSBieXRlIG9mZnNldCBpbiB0aGUgc3RyZWFtIGZvciB0aGUgZGF0YSBpbiB0aGlzIENSWVBUTyBmcmFtZS4gTGVuZ3RoOiBBIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIHNwZWNpZnlpbmcgdGhlIGxlbmd0aCBvZiB0aGUgQ3J5cHRvIERhdGEgZmllbGQgaW4gdGhpcyBDUllQVE8gZnJhbWUuIENyeXB0byBEYXRhOiBUaGUgY3J5cHRvZ3JhcGhpYyBtZXNzYWdlIGRhdGEuIFRoZXJlIGlzIGEgc2VwYXJhdGUgZmxvdyBvZiBjcnlwdG9ncmFwaGljIGhhbmRzaGFrZSBkYXRhIGluIGVhY2ggZW5jcnlwdGlvbiBsZXZlbCwgZWFjaCBvZiB3aGljaCBzdGFydHMgYXQgYW4gb2Zmc2V0IG9mIDAuIFRoaXMgaW1wbGllcyB0aGF0IGVhY2ggZW5jcnlwdGlvbiBsZXZlbCBpcyB0cmVhdGVkIGFzIGEgc2VwYXJhdGUgQ1JZUFRPIHN0cmVhbSBvZiBkYXRhLiBUaGUgbGFyZ2VzdCBvZmZzZXQgZGVsaXZlcmVkIG9uIGEgc3RyZWFtIC0tIHRoZSBzdW0gb2YgdGhlIG9mZnNldCBhbmQgZGF0YSBsZW5ndGggLS0gY2Fubm90IGV4Y2VlZCAyXjYyLTEuIFJlY2VpcHQgb2YgYSBmcmFtZSB0aGF0IGV4Y2VlZHMgdGhpcyBsaW1pdCBNVVNUIGJlIHRyZWF0ZWQgYXMgYSBjb25uZWN0aW9uIGVycm9yIG9mIHR5cGUgRlJBTUVfRU5DT0RJTkdfRVJST1Igb3IgQ1JZUFRPX0JVRkZFUl9FWENFRURFRC4gVW5saWtlIFNUUkVBTSBmcmFtZXMsIHdoaWNoIGluY2x1ZGUgYSBzdHJlYW0gSUQgaW5kaWNhdGluZyB0byB3aGljaCBzdHJlYW0gdGhlIGRhdGEgYmVsb25ncywgdGhlIENSWVBUTyBmcmFtZSBjYXJyaWVzIGRhdGEgZm9yIGEgc2luZ2xlIHN0cmVhbSBwZXIgZW5jcnlwdGlvbiBsZXZlbC4gVGhlIHN0cmVhbSBkb2VzIG5vdCBoYXZlIGFuIGV4cGxpY2l0IGVuZCwgc28gQ1JZUFRPIGZyYW1lcyBkbyBub3QgaGF2ZSBhIEZJTiBiaXQuIDE5LjcuIE5FV19UT0tFTiBGcmFtZXMgQSBzZXJ2ZXIgc2VuZHMgYSBORVdfVE9LRU4gZnJhbWUgKHR5cGU9MHgwNykgdG8gcHJvdmlkZSB0aGUgY2xpZW50IHdpdGggYSB0b2tlbiB0byBzZW5kIGluIHRoZSBoZWFkZXIgb2YgYW4gSW5pdGlhbCBwYWNrZXQgZm9yIGEgZnV0dXJlIGNvbm5lY3Rpb24uIE5FV19UT0tFTiBmcmFtZXMgYXJlIGZvcm1hdHRlZCBhcyBzaG93biBpbiBGaWd1cmUgMzEuIE5FV19UT0tFTiBGcmFtZSB7IFR5cGUgKGkpID0gMHgwNywgVG9rZW4gTGVuZ3RoIChpKSwgVG9rZW4gKC4uKSwgfSBGaWd1cmUgMzE6IE5FV19UT0tFTiBGcmFtZSBGb3JtYXQgTkVXX1RPS0VOIGZyYW1lcyBjb250YWluIHRoZSBmb2xsb3dpbmcgZmllbGRzOiBUb2tlbiBMZW5ndGg6IEEgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgc3BlY2lmeWluZyB0aGUgbGVuZ3RoIG9mIHRoZSB0b2tlbiBpbiBieXRlcy4gVG9rZW46IEFuIG9wYXF1ZSBibG9iIHRoYXQgdGhlIGNsaWVudCBjYW4gdXNlIHdpdGggYSBmdXR1cmUgSW5pdGlhbCBwYWNrZXQuIFRoZSB0b2tlbiBNVVNUIE5PVCBiZSBlbXB0eS4gQSBjbGllbnQgTVVTVCB0cmVhdCByZWNlaXB0IG9mIGEgTkVXX1RPS0VOIGZyYW1lIHdpdGggYW4gZW1wdHkgVG9rZW4gZmllbGQgYXMgYSBjb25uZWN0aW9uIGVycm9yIG9mIHR5cGUgRlJBTUVfRU5DT0RJTkdfRVJST1IuIEEgY2xpZW50IG1pZ2h0IHJlY2VpdmUgbXVsdGlwbGUgTkVXX1RPS0VOIGZyYW1lcyB0aGF0IGNvbnRhaW4gdGhlIHNhbWUgdG9rZW4gdmFsdWUgaWYgcGFja2V0cyBjb250YWluaW5nIHRoZSBmcmFtZSBhcmUgaW5jb3JyZWN0bHkgZGV0ZXJtaW5lZCB0byBiZSBsb3N0LiBDbGllbnRzIGFyZSByZXNwb25zaWJsZSBmb3IgZGlzY2FyZGluZyBkdXBsaWNhdGUgdmFsdWVzLCB3aGljaCBtaWdodCBiZSB1c2VkIHRvIGxpbmsgY29ubmVjdGlvbiBhdHRlbXB0czsgc2VlIFNlY3Rpb24gOC4xLjMuIENsaWVudHMgTVVTVCBOT1Qgc2VuZCBORVdfVE9LRU4gZnJhbWVzLiBBIHNlcnZlciBNVVNUIHRyZWF0IHJlY2VpcHQgb2YgYSBORVdfVE9LRU4gZnJhbWUgYXMgYSBjb25uZWN0aW9uIGVycm9yIG9mIHR5cGUgUFJPVE9DT0xfVklPTEFUSU9OLiAxOS44LiBTVFJFQU0gRnJhbWVzIFNUUkVBTSBmcmFtZXMgaW1wbGljaXRseSBjcmVhdGUgYSBzdHJlYW0gYW5kIGNhcnJ5IHN0cmVhbSBkYXRhLiBUaGUgVHlwZSBmaWVsZCBpbiB0aGUgU1RSRUFNIGZyYW1lIHRha2VzIHRoZSBmb3JtIDBiMDAwMDFYWFggKG9yIHRoZSBzZXQgb2YgdmFsdWVzIGZyb20gMHgwOCB0byAweDBmKS4gVGhlIHRocmVlIGxvdy1vcmRlciBiaXRzIG9mIHRoZSBmcmFtZSB0eXBlIGRldGVybWluZSB0aGUgZmllbGRzIHRoYXQgYXJlIHByZXNlbnQgaW4gdGhlIGZyYW1lOiAqIFRoZSBPRkYgYml0ICgweDA0KSBpbiB0aGUgZnJhbWUgdHlwZSBpcyBzZXQgdG8gaW5kaWNhdGUgdGhhdCB0aGVyZSBpcyBhbiBPZmZzZXQgZmllbGQgcHJlc2VudC4gV2hlbiBzZXQgdG8gMSwgdGhlIE9mZnNldCBmaWVsZCBpcyBwcmVzZW50LiBXaGVuIHNldCB0byAwLCB0aGUgT2Zmc2V0IGZpZWxkIGlzIGFic2VudCBhbmQgdGhlIFN0cmVhbSBEYXRhIHN0YXJ0cyBhdCBhbiBvZmZzZXQgb2YgMCAodGhhdCBpcywgdGhlIGZyYW1lIGNvbnRhaW5zIHRoZSBmaXJzdCBieXRlcyBvZiB0aGUgc3RyZWFtLCBvciB0aGUgZW5kIG9mIGEgc3RyZWFtIHRoYXQgaW5jbHVkZXMgbm8gZGF0YSkuICogVGhlIExFTiBiaXQgKDB4MDIpIGluIHRoZSBmcmFtZSB0eXBlIGlzIHNldCB0byBpbmRpY2F0ZSB0aGF0IHRoZXJlIGlzIGEgTGVuZ3RoIGZpZWxkIHByZXNlbnQuIElmIHRoaXMgYml0IGlzIHNldCB0byAwLCB0aGUgTGVuZ3RoIGZpZWxkIGlzIGFic2VudCBhbmQgdGhlIFN0cmVhbSBEYXRhIGZpZWxkIGV4dGVuZHMgdG8gdGhlIGVuZCBvZiB0aGUgcGFja2V0LiBJZiB0aGlzIGJpdCBpcyBzZXQgdG8gMSwgdGhlIExlbmd0aCBmaWVsZCBpcyBwcmVzZW50LiAqIFRoZSBGSU4gYml0ICgweDAxKSBpbmRpY2F0ZXMgdGhhdCB0aGUgZnJhbWUgbWFya3MgdGhlIGVuZCBvZiB0aGUgc3RyZWFtLiBUaGUgZmluYWwgc2l6ZSBvZiB0aGUgc3RyZWFtIGlzIHRoZSBzdW0gb2YgdGhlIG9mZnNldCBhbmQgdGhlIGxlbmd0aCBvZiB0aGlzIGZyYW1lLiBBbiBlbmRwb2ludCBNVVNUIHRlcm1pbmF0ZSB0aGUgY29ubmVjdGlvbiB3aXRoIGVycm9yIFNUUkVBTV9TVEFURV9FUlJPUiBpZiBpdCByZWNlaXZlcyBhIFNUUkVBTSBmcmFtZSBmb3IgYSBsb2NhbGx5IGluaXRpYXRlZCBzdHJlYW0gdGhhdCBoYXMgbm90IHlldCBiZWVuIGNyZWF0ZWQsIG9yIGZvciBhIHNlbmQtb25seSBzdHJlYW0uIFNUUkVBTSBmcmFtZXMgYXJlIGZvcm1hdHRlZCBhcyBzaG93biBpbiBGaWd1cmUgMzIuIFNUUkVBTSBGcmFtZSB7IFR5cGUgKGkpID0gMHgwOC4uMHgwZiwgU3RyZWFtIElEIChpKSwgW09mZnNldCAoaSldLCBbTGVuZ3RoIChpKV0sIFN0cmVhbSBEYXRhICguLiksIH0gRmlndXJlIDMyOiBTVFJFQU0gRnJhbWUgRm9ybWF0IFNUUkVBTSBmcmFtZXMgY29udGFpbiB0aGUgZm9sbG93aW5nIGZpZWxkczogU3RyZWFtIElEOiBBIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIHN0cmVhbSBJRCBvZiB0aGUgc3RyZWFtOyBzZWUgU2VjdGlvbiAyLjEuIE9mZnNldDogQSB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBzcGVjaWZ5aW5nIHRoZSBieXRlIG9mZnNldCBpbiB0aGUgc3RyZWFtIGZvciB0aGUgZGF0YSBpbiB0aGlzIFNUUkVBTSBmcmFtZS4gVGhpcyBmaWVsZCBpcyBwcmVzZW50IHdoZW4gdGhlIE9GRiBiaXQgaXMgc2V0IHRvIDEuIFdoZW4gdGhlIE9mZnNldCBmaWVsZCBpcyBhYnNlbnQsIHRoZSBvZmZzZXQgaXMgMC4gTGVuZ3RoOiBBIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIHNwZWNpZnlpbmcgdGhlIGxlbmd0aCBvZiB0aGUgU3RyZWFtIERhdGEgZmllbGQgaW4gdGhpcyBTVFJFQU0gZnJhbWUuIFRoaXMgZmllbGQgaXMgcHJlc2VudCB3aGVuIHRoZSBMRU4gYml0IGlzIHNldCB0byAxLiBXaGVuIHRoZSBMRU4gYml0IGlzIHNldCB0byAwLCB0aGUgU3RyZWFtIERhdGEgZmllbGQgY29uc3VtZXMgYWxsIHRoZSByZW1haW5pbmcgYnl0ZXMgaW4gdGhlIHBhY2tldC4gU3RyZWFtIERhdGE6IFRoZSBieXRlcyBmcm9tIHRoZSBkZXNpZ25hdGVkIHN0cmVhbSB0byBiZSBkZWxpdmVyZWQuIFdoZW4gYSBTdHJlYW0gRGF0YSBmaWVsZCBoYXMgYSBsZW5ndGggb2YgMCwgdGhlIG9mZnNldCBpbiB0aGUgU1RSRUFNIGZyYW1lIGlzIHRoZSBvZmZzZXQgb2YgdGhlIG5leHQgYnl0ZSB0aGF0IHdvdWxkIGJlIHNlbnQuIFRoZSBmaXJzdCBieXRlIGluIHRoZSBzdHJlYW0gaGFzIGFuIG9mZnNldCBvZiAwLiBUaGUgbGFyZ2VzdCBvZmZzZXQgZGVsaXZlcmVkIG9uIGEgc3RyZWFtIC0tIHRoZSBzdW0gb2YgdGhlIG9mZnNldCBhbmQgZGF0YSBsZW5ndGggLS0gY2Fubm90IGV4Y2VlZCAyXjYyLTEsIGFzIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBwcm92aWRlIGZsb3cgY29udHJvbCBjcmVkaXQgZm9yIHRoYXQgZGF0YS4gUmVjZWlwdCBvZiBhIGZyYW1lIHRoYXQgZXhjZWVkcyB0aGlzIGxpbWl0IE1VU1QgYmUgdHJlYXRlZCBhcyBhIGNvbm5lY3Rpb24gZXJyb3Igb2YgdHlwZSBGUkFNRV9FTkNPRElOR19FUlJPUiBvciBGTE9XX0NPTlRST0xfRVJST1IuIDE5LjkuIE1BWF9EQVRBIEZyYW1lcyBBIE1BWF9EQVRBIGZyYW1lICh0eXBlPTB4MTApIGlzIHVzZWQgaW4gZmxvdyBjb250cm9sIHRvIGluZm9ybSB0aGUgcGVlciBvZiB0aGUgbWF4aW11bSBhbW91bnQgb2YgZGF0YSB0aGF0IGNhbiBiZSBzZW50IG9uIHRoZSBjb25uZWN0aW9uIGFzIGEgd2hvbGUuIE1BWF9EQVRBIGZyYW1lcyBhcmUgZm9ybWF0dGVkIGFzIHNob3duIGluIEZpZ3VyZSAzMy4gTUFYX0RBVEEgRnJhbWUgeyBUeXBlIChpKSA9IDB4MTAsIE1heGltdW0gRGF0YSAoaSksIH0gRmlndXJlIDMzOiBNQVhfREFUQSBGcmFtZSBGb3JtYXQgTUFYX0RBVEEgZnJhbWVzIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBmaWVsZDogTWF4aW11bSBEYXRhOiBBIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIG1heGltdW0gYW1vdW50IG9mIGRhdGEgdGhhdCBjYW4gYmUgc2VudCBvbiB0aGUgZW50aXJlIGNvbm5lY3Rpb24sIGluIHVuaXRzIG9mIGJ5dGVzLiBBbGwgZGF0YSBzZW50IGluIFNUUkVBTSBmcmFtZXMgY291bnRzIHRvd2FyZCB0aGlzIGxpbWl0LiBUaGUgc3VtIG9mIHRoZSBmaW5hbCBzaXplcyBvbiBhbGwgc3RyZWFtcyAtLSBpbmNsdWRpbmcgc3RyZWFtcyBpbiB0ZXJtaW5hbCBzdGF0ZXMgLS0gTVVTVCBOT1QgZXhjZWVkIHRoZSB2YWx1ZSBhZHZlcnRpc2VkIGJ5IGEgcmVjZWl2ZXIuIEFuIGVuZHBvaW50IE1VU1QgdGVybWluYXRlIGEgY29ubmVjdGlvbiB3aXRoIGFuIGVycm9yIG9mIHR5cGUgRkxPV19DT05UUk9MX0VSUk9SIGlmIGl0IHJlY2VpdmVzIG1vcmUgZGF0YSB0aGFuIHRoZSBtYXhpbXVtIGRhdGEgdmFsdWUgdGhhdCBpdCBoYXMgc2VudC4gVGhpcyBpbmNsdWRlcyB2aW9sYXRpb25zIG9mIHJlbWVtYmVyZWQgbGltaXRzIGluIEVhcmx5IERhdGE7IHNlZSBTZWN0aW9uIDcuNC4xLiAxOS4xMC4gTUFYX1NUUkVBTV9EQVRBIEZyYW1lcyBBIE1BWF9TVFJFQU1fREFUQSBmcmFtZSAodHlwZT0weDExKSBpcyB1c2VkIGluIGZsb3cgY29udHJvbCB0byBpbmZvcm0gYSBwZWVyIG9mIHRoZSBtYXhpbXVtIGFtb3VudCBvZiBkYXRhIHRoYXQgY2FuIGJlIHNlbnQgb24gYSBzdHJlYW0uIEEgTUFYX1NUUkVBTV9EQVRBIGZyYW1lIGNhbiBiZSBzZW50IGZvciBzdHJlYW1zIGluIHRoZSAiUmVjdiIgc3RhdGU7IHNlZSBTZWN0aW9uIDMuMi4gUmVjZWl2aW5nIGEgTUFYX1NUUkVBTV9EQVRBIGZyYW1lIGZvciBhIGxvY2FsbHkgaW5pdGlhdGVkIHN0cmVhbSB0aGF0IGhhcyBub3QgeWV0IGJlZW4gY3JlYXRlZCBNVVNUIGJlIHRyZWF0ZWQgYXMgYSBjb25uZWN0aW9uIGVycm9yIG9mIHR5cGUgU1RSRUFNX1NUQVRFX0VSUk9SLiBBbiBlbmRwb2ludCB0aGF0IHJlY2VpdmVzIGEgTUFYX1NUUkVBTV9EQVRBIGZyYW1lIGZvciBhIHJlY2VpdmUtb25seSBzdHJlYW0gTVVTVCB0ZXJtaW5hdGUgdGhlIGNvbm5lY3Rpb24gd2l0aCBlcnJvciBTVFJFQU1fU1RBVEVfRVJST1IuIE1BWF9TVFJFQU1fREFUQSBmcmFtZXMgYXJlIGZvcm1hdHRlZCBhcyBzaG93biBpbiBGaWd1cmUgMzQuIE1BWF9TVFJFQU1fREFUQSBGcmFtZSB7IFR5cGUgKGkpID0gMHgxMSwgU3RyZWFtIElEIChpKSwgTWF4aW11bSBTdHJlYW0gRGF0YSAoaSksIH0gRmlndXJlIDM0OiBNQVhfU1RSRUFNX0RBVEEgRnJhbWUgRm9ybWF0IE1BWF9TVFJFQU1fREFUQSBmcmFtZXMgY29udGFpbiB0aGUgZm9sbG93aW5nIGZpZWxkczogU3RyZWFtIElEOiBUaGUgc3RyZWFtIElEIG9mIHRoZSBhZmZlY3RlZCBzdHJlYW0sIGVuY29kZWQgYXMgYSB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci4gTWF4aW11bSBTdHJlYW0gRGF0YTogQSB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBtYXhpbXVtIGFtb3VudCBvZiBkYXRhIHRoYXQgY2FuIGJlIHNlbnQgb24gdGhlIGlkZW50aWZpZWQgc3RyZWFtLCBpbiB1bml0cyBvZiBieXRlcy4gV2hlbiBjb3VudGluZyBkYXRhIHRvd2FyZCB0aGlzIGxpbWl0LCBhbiBlbmRwb2ludCBhY2NvdW50cyBmb3IgdGhlIGxhcmdlc3QgcmVjZWl2ZWQgb2Zmc2V0IG9mIGRhdGEgdGhhdCBpcyBzZW50IG9yIHJlY2VpdmVkIG9uIHRoZSBzdHJlYW0uIExvc3Mgb3IgcmVvcmRlcmluZyBjYW4gbWVhbiB0aGF0IHRoZSBsYXJnZXN0IHJlY2VpdmVkIG9mZnNldCBvbiBhIHN0cmVhbSBjYW4gYmUgZ3JlYXRlciB0aGFuIHRoZSB0b3RhbCBzaXplIG9mIGRhdGEgcmVjZWl2ZWQgb24gdGhhdCBzdHJlYW0uIFJlY2VpdmluZyBTVFJFQU0gZnJhbWVzIG1pZ2h0IG5vdCBpbmNyZWFzZSB0aGUgbGFyZ2VzdCByZWNlaXZlZCBvZmZzZXQuIFRoZSBkYXRhIHNlbnQgb24gYSBzdHJlYW0gTVVTVCBOT1QgZXhjZWVkIHRoZSBsYXJnZXN0IG1heGltdW0gc3RyZWFtIGRhdGEgdmFsdWUgYWR2ZXJ0aXNlZCBieSB0aGUgcmVjZWl2ZXIuIEFuIGVuZHBvaW50IE1VU1QgdGVybWluYXRlIGEgY29ubmVjdGlvbiB3aXRoIGFuIGVycm9yIG9mIHR5cGUgRkxPV19DT05UUk9MX0VSUk9SIGlmIGl0IHJlY2VpdmVzIG1vcmUgZGF0YSB0aGFuIHRoZSBsYXJnZXN0IG1heGltdW0gc3RyZWFtIGRhdGEgdGhhdCBpdCBoYXMgc2VudCBmb3IgdGhlIGFmZmVjdGVkIHN0cmVhbS4gVGhpcyBpbmNsdWRlcyB2aW9sYXRpb25zIG9mIHJlbWVtYmVyZWQgbGltaXRzIGluIEVhcmx5IERhdGE7IHNlZSBTZWN0aW9uIDcuNC4xLiAxOS4xMS4gTUFYX1NUUkVBTVMgRnJhbWVzIEEgTUFYX1NUUkVBTVMgZnJhbWUgKHR5cGU9MHgxMiBvciAweDEzKSBpbmZvcm1zIHRoZSBwZWVyIG9mIHRoZSBjdW11bGF0aXZlIG51bWJlciBvZiBzdHJlYW1zIG9mIGEgZ2l2ZW4gdHlwZSBpdCBpcyBwZXJtaXR0ZWQgdG8gb3Blbi4gQSBNQVhfU1RSRUFNUyBmcmFtZSB3aXRoIGEgdHlwZSBvZiAweDEyIGFwcGxpZXMgdG8gYmlkaXJlY3Rpb25hbCBzdHJlYW1zLCBhbmQgYSBNQVhfU1RSRUFNUyBmcmFtZSB3aXRoIGEgdHlwZSBvZiAweDEzIGFwcGxpZXMgdG8gdW5pZGlyZWN0aW9uYWwgc3RyZWFtcy4gTUFYX1NUUkVBTVMgZnJhbWVzIGFyZSBmb3JtYXR0ZWQgYXMgc2hvd24gaW4gRmlndXJlIDM1LiBNQVhfU1RSRUFNUyBGcmFtZSB7IFR5cGUgKGkpID0gMHgxMi4uMHgxMywgTWF4aW11bSBTdHJlYW1zIChpKSwgfSBGaWd1cmUgMzU6IE1BWF9TVFJFQU1TIEZyYW1lIEZvcm1hdCBNQVhfU1RSRUFNUyBmcmFtZXMgY29udGFpbiB0aGUgZm9sbG93aW5nIGZpZWxkOiBNYXhpbXVtIFN0cmVhbXM6IEEgY291bnQgb2YgdGhlIGN1bXVsYXRpdmUgbnVtYmVyIG9mIHN0cmVhbXMgb2YgdGhlIGNvcnJlc3BvbmRpbmcgdHlwZSB0aGF0IGNhbiBiZSBvcGVuZWQgb3ZlciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbm5lY3Rpb24uIFRoaXMgdmFsdWUgY2Fubm90IGV4Y2VlZCAyXjYwLCBhcyBpdCBpcyBub3QgcG9zc2libGUgdG8gZW5jb2RlIHN0cmVhbSBJRHMgbGFyZ2VyIHRoYW4gMl42Mi0xLiBSZWNlaXB0IG9mIGEgZnJhbWUgdGhhdCBwZXJtaXRzIG9wZW5pbmcgb2YgYSBzdHJlYW0gbGFyZ2VyIHRoYW4gdGhpcyBsaW1pdCBNVVNUIGJlIHRyZWF0ZWQgYXMgYSBjb25uZWN0aW9uIGVycm9yIG9mIHR5cGUgRlJBTUVfRU5DT0RJTkdfRVJST1IuIExvc3Mgb3IgcmVvcmRlcmluZyBjYW4gY2F1c2UgYW4gZW5kcG9pbnQgdG8gcmVjZWl2ZSBhIE1BWF9TVFJFQU1TIGZyYW1lIHdpdGggYSBsb3dlciBzdHJlYW0gbGltaXQgdGhhbiB3YXMgcHJldmlvdXNseSByZWNlaXZlZC4gTUFYX1NUUkVBTVMgZnJhbWVzIHRoYXQgZG8gbm90IGluY3JlYXNlIHRoZSBzdHJlYW0gbGltaXQgTVVTVCBiZSBpZ25vcmVkLiBBbiBlbmRwb2ludCBNVVNUIE5PVCBvcGVuIG1vcmUgc3RyZWFtcyB0aGFuIHBlcm1pdHRlZCBieSB0aGUgY3VycmVudCBzdHJlYW0gbGltaXQgc2V0IGJ5IGl0cyBwZWVyLiBGb3IgaW5zdGFuY2UsIGEgc2VydmVyIHRoYXQgcmVjZWl2ZXMgYSB1bmlkaXJlY3Rpb25hbCBzdHJlYW0gbGltaXQgb2YgMyBpcyBwZXJtaXR0ZWQgdG8gb3BlbiBzdHJlYW1zIDMsIDcsIGFuZCAxMSwgYnV0IG5vdCBzdHJlYW0gMTUuIEFuIGVuZHBvaW50IE1VU1QgdGVybWluYXRlIGEgY29ubmVjdGlvbiB3aXRoIGFuIGVycm9yIG9mIHR5cGUgU1RSRUFNX0xJTUlUX0VSUk9SIGlmIGEgcGVlciBvcGVucyBtb3JlIHN0cmVhbXMgdGhhbiB3YXMgcGVybWl0dGVkLiBUaGlzIGluY2x1ZGVzIHZpb2xhdGlvbnMgb2YgcmVtZW1iZXJlZCBsaW1pdHMgaW4gRWFybHkgRGF0YTsgc2VlIFNlY3Rpb24gNy40LjEuIE5vdGUgdGhhdCB0aGVzZSBmcmFtZXMgKGFuZCB0aGUgY29ycmVzcG9uZGluZyB0cmFuc3BvcnQgcGFyYW1ldGVycykgZG8gbm90IGRlc2NyaWJlIHRoZSBudW1iZXIgb2Ygc3RyZWFtcyB0aGF0IGNhbiBiZSBvcGVuZWQgY29uY3VycmVudGx5LiBUaGUgbGltaXQgaW5jbHVkZXMgc3RyZWFtcyB0aGF0IGhhdmUgYmVlbiBjbG9zZWQgYXMgd2VsbCBhcyB0aG9zZSB0aGF0IGFyZSBvcGVuLiAxOS4xMi4gREFUQV9CTE9DS0VEIEZyYW1lcyBBIHNlbmRlciBTSE9VTEQgc2VuZCBhIERBVEFfQkxPQ0tFRCBmcmFtZSAodHlwZT0weDE0KSB3aGVuIGl0IHdpc2hlcyB0byBzZW5kIGRhdGEgYnV0IGlzIHVuYWJsZSB0byBkbyBzbyBkdWUgdG8gY29ubmVjdGlvbi1sZXZlbCBmbG93IGNvbnRyb2w7IHNlZSBTZWN0aW9uIDQuIERBVEFfQkxPQ0tFRCBmcmFtZXMgY2FuIGJlIHVzZWQgYXMgaW5wdXQgdG8gdHVuaW5nIG9mIGZsb3cgY29udHJvbCBhbGdvcml0aG1zOyBzZWUgU2VjdGlvbiA0LjIuIERBVEFfQkxPQ0tFRCBmcmFtZXMgYXJlIGZvcm1hdHRlZCBhcyBzaG93biBpbiBGaWd1cmUgMzYuIERBVEFfQkxPQ0tFRCBGcmFtZSB7IFR5cGUgKGkpID0gMHgxNCwgTWF4aW11bSBEYXRhIChpKSwgfSBGaWd1cmUgMzY6IERBVEFfQkxPQ0tFRCBGcmFtZSBGb3JtYXQgREFUQV9CTE9DS0VEIGZyYW1lcyBjb250YWluIHRoZSBmb2xsb3dpbmcgZmllbGQ6IE1heGltdW0gRGF0YTogQSB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBjb25uZWN0aW9uLSBsZXZlbCBsaW1pdCBhdCB3aGljaCBibG9ja2luZyBvY2N1cnJlZC4gMTkuMTMuIFNUUkVBTV9EQVRBX0JMT0NLRUQgRnJhbWVzIEEgc2VuZGVyIFNIT1VMRCBzZW5kIGEgU1RSRUFNX0RBVEFfQkxPQ0tFRCBmcmFtZSAodHlwZT0weDE1KSB3aGVuIGl0IHdpc2hlcyB0byBzZW5kIGRhdGEgYnV0IGlzIHVuYWJsZSB0byBkbyBzbyBkdWUgdG8gc3RyZWFtLWxldmVsIGZsb3cgY29udHJvbC4gVGhpcyBmcmFtZSBpcyBhbmFsb2dvdXMgdG8gREFUQV9CTE9DS0VEIChTZWN0aW9uIDE5LjEyKS4gQW4gZW5kcG9pbnQgdGhhdCByZWNlaXZlcyBhIFNUUkVBTV9EQVRBX0JMT0NLRUQgZnJhbWUgZm9yIGEgc2VuZC1vbmx5IHN0cmVhbSBNVVNUIHRlcm1pbmF0ZSB0aGUgY29ubmVjdGlvbiB3aXRoIGVycm9yIFNUUkVBTV9TVEFURV9FUlJPUi4gU1RSRUFNX0RBVEFfQkxPQ0tFRCBmcmFtZXMgYXJlIGZvcm1hdHRlZCBhcyBzaG93biBpbiBGaWd1cmUgMzcuIFNUUkVBTV9EQVRBX0JMT0NLRUQgRnJhbWUgeyBUeXBlIChpKSA9IDB4MTUsIFN0cmVhbSBJRCAoaSksIE1heGltdW0gU3RyZWFtIERhdGEgKGkpLCB9IEZpZ3VyZSAzNzogU1RSRUFNX0RBVEFfQkxPQ0tFRCBGcmFtZSBGb3JtYXQgU1RSRUFNX0RBVEFfQkxPQ0tFRCBmcmFtZXMgY29udGFpbiB0aGUgZm9sbG93aW5nIGZpZWxkczogU3RyZWFtIElEOiBBIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIHN0cmVhbSB0aGF0IGlzIGJsb2NrZWQgZHVlIHRvIGZsb3cgY29udHJvbC4gTWF4aW11bSBTdHJlYW0gRGF0YTogQSB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBvZmZzZXQgb2YgdGhlIHN0cmVhbSBhdCB3aGljaCB0aGUgYmxvY2tpbmcgb2NjdXJyZWQuIDE5LjE0LiBTVFJFQU1TX0JMT0NLRUQgRnJhbWVzIEEgc2VuZGVyIFNIT1VMRCBzZW5kIGEgU1RSRUFNU19CTE9DS0VEIGZyYW1lICh0eXBlPTB4MTYgb3IgMHgxNykgd2hlbiBpdCB3aXNoZXMgdG8gb3BlbiBhIHN0cmVhbSBidXQgaXMgdW5hYmxlIHRvIGRvIHNvIGR1ZSB0byB0aGUgbWF4aW11bSBzdHJlYW0gbGltaXQgc2V0IGJ5IGl0cyBwZWVyOyBzZWUgU2VjdGlvbiAxOS4xMS4gQSBTVFJFQU1TX0JMT0NLRUQgZnJhbWUgb2YgdHlwZSAweDE2IGlzIHVzZWQgdG8gaW5kaWNhdGUgcmVhY2hpbmcgdGhlIGJpZGlyZWN0aW9uYWwgc3RyZWFtIGxpbWl0LCBhbmQgYSBTVFJFQU1TX0JMT0NLRUQgZnJhbWUgb2YgdHlwZSAweDE3IGlzIHVzZWQgdG8gaW5kaWNhdGUgcmVhY2hpbmcgdGhlIHVuaWRpcmVjdGlvbmFsIHN0cmVhbSBsaW1pdC4gQSBTVFJFQU1TX0JMT0NLRUQgZnJhbWUgZG9lcyBub3Qgb3BlbiB0aGUgc3RyZWFtLCBidXQgaW5mb3JtcyB0aGUgcGVlciB0aGF0IGEgbmV3IHN0cmVhbSB3YXMgbmVlZGVkIGFuZCB0aGUgc3RyZWFtIGxpbWl0IHByZXZlbnRlZCB0aGUgY3JlYXRpb24gb2YgdGhlIHN0cmVhbS4gU1RSRUFNU19CTE9DS0VEIGZyYW1lcyBhcmUgZm9ybWF0dGVkIGFzIHNob3duIGluIEZpZ3VyZSAzOC4gU1RSRUFNU19CTE9DS0VEIEZyYW1lIHsgVHlwZSAoaSkgPSAweDE2Li4weDE3LCBNYXhpbXVtIFN0cmVhbXMgKGkpLCB9IEZpZ3VyZSAzODogU1RSRUFNU19CTE9DS0VEIEZyYW1lIEZvcm1hdCBTVFJFQU1TX0JMT0NLRUQgZnJhbWVzIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBmaWVsZDogTWF4aW11bSBTdHJlYW1zOiBBIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIG1heGltdW0gbnVtYmVyIG9mIHN0cmVhbXMgYWxsb3dlZCBhdCB0aGUgdGltZSB0aGUgZnJhbWUgd2FzIHNlbnQuIFRoaXMgdmFsdWUgY2Fubm90IGV4Y2VlZCAyXjYwLCBhcyBpdCBpcyBub3QgcG9zc2libGUgdG8gZW5jb2RlIHN0cmVhbSBJRHMgbGFyZ2VyIHRoYW4gMl42Mi0xLiBSZWNlaXB0IG9mIGEgZnJhbWUgdGhhdCBlbmNvZGVzIGEgbGFyZ2VyIHN0cmVhbSBJRCBNVVNUIGJlIHRyZWF0ZWQgYXMgYSBjb25uZWN0aW9uIGVycm9yIG9mIHR5cGUgU1RSRUFNX0xJTUlUX0VSUk9SIG9yIEZSQU1FX0VOQ09ESU5HX0VSUk9SLiAxOS4xNS4gTkVXX0NPTk5FQ1RJT05fSUQgRnJhbWVzIEFuIGVuZHBvaW50IHNlbmRzIGEgTkVXX0NPTk5FQ1RJT05fSUQgZnJhbWUgKHR5cGU9MHgxOCkgdG8gcHJvdmlkZSBpdHMgcGVlciB3aXRoIGFsdGVybmF0aXZlIGNvbm5lY3Rpb24gSURzIHRoYXQgY2FuIGJlIHVzZWQgdG8gYnJlYWsgbGlua2FiaWxpdHkgd2hlbiBtaWdyYXRpbmcgY29ubmVjdGlvbnM7IHNlZSBTZWN0aW9uIDkuNS4gTkVXX0NPTk5FQ1RJT05fSUQgZnJhbWVzIGFyZSBmb3JtYXR0ZWQgYXMgc2hvd24gaW4gRmlndXJlIDM5LiBORVdfQ09OTkVDVElPTl9JRCBGcmFtZSB7IFR5cGUgKGkpID0gMHgxOCwgU2VxdWVuY2UgTnVtYmVyIChpKSwgUmV0aXJlIFByaW9yIFRvIChpKSwgTGVuZ3RoICg4KSwgQ29ubmVjdGlvbiBJRCAoOC4uMTYwKSwgU3RhdGVsZXNzIFJlc2V0IFRva2VuICgxMjgpLCB9IEZpZ3VyZSAzOTogTkVXX0NPTk5FQ1RJT05fSUQgRnJhbWUgRm9ybWF0IE5FV19DT05ORUNUSU9OX0lEIGZyYW1lcyBjb250YWluIHRoZSBmb2xsb3dpbmcgZmllbGRzOiBTZXF1ZW5jZSBOdW1iZXI6IFRoZSBzZXF1ZW5jZSBudW1iZXIgYXNzaWduZWQgdG8gdGhlIGNvbm5lY3Rpb24gSUQgYnkgdGhlIHNlbmRlciwgZW5jb2RlZCBhcyBhIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyOyBzZWUgU2VjdGlvbiA1LjEuMS4gUmV0aXJlIFByaW9yIFRvOiBBIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGluZGljYXRpbmcgd2hpY2ggY29ubmVjdGlvbiBJRHMgc2hvdWxkIGJlIHJldGlyZWQ7IHNlZSBTZWN0aW9uIDUuMS4yLiBMZW5ndGg6IEFuIDgtYml0IHVuc2lnbmVkIGludGVnZXIgY29udGFpbmluZyB0aGUgbGVuZ3RoIG9mIHRoZSBjb25uZWN0aW9uIElELiBWYWx1ZXMgbGVzcyB0aGFuIDEgYW5kIGdyZWF0ZXIgdGhhbiAyMCBhcmUgaW52YWxpZCBhbmQgTVVTVCBiZSB0cmVhdGVkIGFzIGEgY29ubmVjdGlvbiBlcnJvciBvZiB0eXBlIEZSQU1FX0VOQ09ESU5HX0VSUk9SLiBDb25uZWN0aW9uIElEOiBBIGNvbm5lY3Rpb24gSUQgb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguIFN0YXRlbGVzcyBSZXNldCBUb2tlbjogQSAxMjgtYml0IHZhbHVlIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBhIHN0YXRlbGVzcyByZXNldCB3aGVuIHRoZSBhc3NvY2lhdGVkIGNvbm5lY3Rpb24gSUQgaXMgdXNlZDsgc2VlIFNlY3Rpb24gMTAuMy4gQW4gZW5kcG9pbnQgTVVTVCBOT1Qgc2VuZCB0aGlzIGZyYW1lIGlmIGl0IGN1cnJlbnRseSByZXF1aXJlcyB0aGF0IGl0cyBwZWVyIHNlbmQgcGFja2V0cyB3aXRoIGEgemVyby1sZW5ndGggRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRC4gQ2hhbmdpbmcgdGhlIGxlbmd0aCBvZiBhIGNvbm5lY3Rpb24gSUQgdG8gb3IgZnJvbSB6ZXJvIGxlbmd0aCBtYWtlcyBpdCBkaWZmaWN1bHQgdG8gaWRlbnRpZnkgd2hlbiB0aGUgdmFsdWUgb2YgdGhlIGNvbm5lY3Rpb24gSUQgY2hhbmdlZC4gQW4gZW5kcG9pbnQgdGhhdCBpcyBzZW5kaW5nIHBhY2tldHMgd2l0aCBhIHplcm8tbGVuZ3RoIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgTVVTVCB0cmVhdCByZWNlaXB0IG9mIGEgTkVXX0NPTk5FQ1RJT05fSUQgZnJhbWUgYXMgYSBjb25uZWN0aW9uIGVycm9yIG9mIHR5cGUgUFJPVE9DT0xfVklPTEFUSU9OLiBUcmFuc21pc3Npb24gZXJyb3JzLCB0aW1lb3V0cywgYW5kIHJldHJhbnNtaXNzaW9ucyBtaWdodCBjYXVzZSB0aGUgc2FtZSBORVdfQ09OTkVDVElPTl9JRCBmcmFtZSB0byBiZSByZWNlaXZlZCBtdWx0aXBsZSB0aW1lcy4gUmVjZWlwdCBvZiB0aGUgc2FtZSBmcmFtZSBtdWx0aXBsZSB0aW1lcyBNVVNUIE5PVCBiZSB0cmVhdGVkIGFzIGEgY29ubmVjdGlvbiBlcnJvci4gQSByZWNlaXZlciBjYW4gdXNlIHRoZSBzZXF1ZW5jZSBudW1iZXIgc3VwcGxpZWQgaW4gdGhlIE5FV19DT05ORUNUSU9OX0lEIGZyYW1lIHRvIGhhbmRsZSByZWNlaXZpbmcgdGhlIHNhbWUgTkVXX0NPTk5FQ1RJT05fSUQgZnJhbWUgbXVsdGlwbGUgdGltZXMuIElmIGFuIGVuZHBvaW50IHJlY2VpdmVzIGEgTkVXX0NPTk5FQ1RJT05fSUQgZnJhbWUgdGhhdCByZXBlYXRzIGEgcHJldmlvdXNseSBpc3N1ZWQgY29ubmVjdGlvbiBJRCB3aXRoIGEgZGlmZmVyZW50IFN0YXRlbGVzcyBSZXNldCBUb2tlbiBmaWVsZCB2YWx1ZSBvciBhIGRpZmZlcmVudCBTZXF1ZW5jZSBOdW1iZXIgZmllbGQgdmFsdWUsIG9yIGlmIGEgc2VxdWVuY2UgbnVtYmVyIGlzIHVzZWQgZm9yIGRpZmZlcmVudCBjb25uZWN0aW9uIElEcywgdGhlIGVuZHBvaW50IE1BWSB0cmVhdCB0aGF0IHJlY2VpcHQgYXMgYSBjb25uZWN0aW9uIGVycm9yIG9mIHR5cGUgUFJPVE9DT0xfVklPTEFUSU9OLiBUaGUgUmV0aXJlIFByaW9yIFRvIGZpZWxkIGFwcGxpZXMgdG8gY29ubmVjdGlvbiBJRHMgZXN0YWJsaXNoZWQgZHVyaW5nIGNvbm5lY3Rpb24gc2V0dXAgYW5kIHRoZSBwcmVmZXJyZWRfYWRkcmVzcyB0cmFuc3BvcnQgcGFyYW1ldGVyOyBzZWUgU2VjdGlvbiA1LjEuMi4gVGhlIHZhbHVlIGluIHRoZSBSZXRpcmUgUHJpb3IgVG8gZmllbGQgTVVTVCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIGluIHRoZSBTZXF1ZW5jZSBOdW1iZXIgZmllbGQuIFJlY2VpdmluZyBhIHZhbHVlIGluIHRoZSBSZXRpcmUgUHJpb3IgVG8gZmllbGQgdGhhdCBpcyBncmVhdGVyIHRoYW4gdGhhdCBpbiB0aGUgU2VxdWVuY2UgTnVtYmVyIGZpZWxkIE1VU1QgYmUgdHJlYXRlZCBhcyBhIGNvbm5lY3Rpb24gZXJyb3Igb2YgdHlwZSBGUkFNRV9FTkNPRElOR19FUlJPUi4gT25jZSBhIHNlbmRlciBpbmRpY2F0ZXMgYSBSZXRpcmUgUHJpb3IgVG8gdmFsdWUsIHNtYWxsZXIgdmFsdWVzIHNlbnQgaW4gc3Vic2VxdWVudCBORVdfQ09OTkVDVElPTl9JRCBmcmFtZXMgaGF2ZSBubyBlZmZlY3QuIEEgcmVjZWl2ZXIgTVVTVCBpZ25vcmUgYW55IFJldGlyZSBQcmlvciBUbyBmaWVsZHMgdGhhdCBkbyBub3QgaW5jcmVhc2UgdGhlIGxhcmdlc3QgcmVjZWl2ZWQgUmV0aXJlIFByaW9yIFRvIHZhbHVlLiBBbiBlbmRwb2ludCB0aGF0IHJlY2VpdmVzIGEgTkVXX0NPTk5FQ1RJT05fSUQgZnJhbWUgd2l0aCBhIHNlcXVlbmNlIG51bWJlciBzbWFsbGVyIHRoYW4gdGhlIFJldGlyZSBQcmlvciBUbyBmaWVsZCBvZiBhIHByZXZpb3VzbHkgcmVjZWl2ZWQgTkVXX0NPTk5FQ1RJT05fSUQgZnJhbWUgTVVTVCBzZW5kIGEgY29ycmVzcG9uZGluZyBSRVRJUkVfQ09OTkVDVElPTl9JRCBmcmFtZSB0aGF0IHJldGlyZXMgdGhlIG5ld2x5IHJlY2VpdmVkIGNvbm5lY3Rpb24gSUQsIHVubGVzcyBpdCBoYXMgYWxyZWFkeSBkb25lIHNvIGZvciB0aGF0IHNlcXVlbmNlIG51bWJlci4gMTkuMTYuIFJFVElSRV9DT05ORUNUSU9OX0lEIEZyYW1lcyBBbiBlbmRwb2ludCBzZW5kcyBhIFJFVElSRV9DT05ORUNUSU9OX0lEIGZyYW1lICh0eXBlPTB4MTkpIHRvIGluZGljYXRlIHRoYXQgaXQgd2lsbCBubyBsb25nZXIgdXNlIGEgY29ubmVjdGlvbiBJRCB0aGF0IHdhcyBpc3N1ZWQgYnkgaXRzIHBlZXIuIFRoaXMgaW5jbHVkZXMgdGhlIGNvbm5lY3Rpb24gSUQgcHJvdmlkZWQgZHVyaW5nIHRoZSBoYW5kc2hha2UuIFNlbmRpbmcgYSBSRVRJUkVfQ09OTkVDVElPTl9JRCBmcmFtZSBhbHNvIHNlcnZlcyBhcyBhIHJlcXVlc3QgdG8gdGhlIHBlZXIgdG8gc2VuZCBhZGRpdGlvbmFsIGNvbm5lY3Rpb24gSURzIGZvciBmdXR1cmUgdXNlOyBzZWUgU2VjdGlvbiA1LjEuIE5ldyBjb25uZWN0aW9uIElEcyBjYW4gYmUgZGVsaXZlcmVkIHRvIGEgcGVlciB1c2luZyB0aGUgTkVXX0NPTk5FQ1RJT05fSUQgZnJhbWUgKFNlY3Rpb24gMTkuMTUpLiBSZXRpcmluZyBhIGNvbm5lY3Rpb24gSUQgaW52YWxpZGF0ZXMgdGhlIHN0YXRlbGVzcyByZXNldCB0b2tlbiBhc3NvY2lhdGVkIHdpdGggdGhhdCBjb25uZWN0aW9uIElELiBSRVRJUkVfQ09OTkVDVElPTl9JRCBmcmFtZXMgYXJlIGZvcm1hdHRlZCBhcyBzaG93biBpbiBGaWd1cmUgNDAuIFJFVElSRV9DT05ORUNUSU9OX0lEIEZyYW1lIHsgVHlwZSAoaSkgPSAweDE5LCBTZXF1ZW5jZSBOdW1iZXIgKGkpLCB9IEZpZ3VyZSA0MDogUkVUSVJFX0NPTk5FQ1RJT05fSUQgRnJhbWUgRm9ybWF0IFJFVElSRV9DT05ORUNUSU9OX0lEIGZyYW1lcyBjb250YWluIHRoZSBmb2xsb3dpbmcgZmllbGQ6IFNlcXVlbmNlIE51bWJlcjogVGhlIHNlcXVlbmNlIG51bWJlciBvZiB0aGUgY29ubmVjdGlvbiBJRCBiZWluZyByZXRpcmVkOyBzZWUgU2VjdGlvbiA1LjEuMi4gUmVjZWlwdCBvZiBhIFJFVElSRV9DT05ORUNUSU9OX0lEIGZyYW1lIGNvbnRhaW5pbmcgYSBzZXF1ZW5jZSBudW1iZXIgZ3JlYXRlciB0aGFuIGFueSBwcmV2aW91c2x5IHNlbnQgdG8gdGhlIHBlZXIgTVVTVCBiZSB0cmVhdGVkIGFzIGEgY29ubmVjdGlvbiBlcnJvciBvZiB0eXBlIFBST1RPQ09MX1ZJT0xBVElPTi4gVGhlIHNlcXVlbmNlIG51bWJlciBzcGVjaWZpZWQgaW4gYSBSRVRJUkVfQ09OTkVDVElPTl9JRCBmcmFtZSBNVVNUIE5PVCByZWZlciB0byB0aGUgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBmaWVsZCBvZiB0aGUgcGFja2V0IGluIHdoaWNoIHRoZSBmcmFtZSBpcyBjb250YWluZWQuIFRoZSBwZWVyIE1BWSB0cmVhdCB0aGlzIGFzIGEgY29ubmVjdGlvbiBlcnJvciBvZiB0eXBlIFBST1RPQ09MX1ZJT0xBVElPTi4gQW4gZW5kcG9pbnQgY2Fubm90IHNlbmQgdGhpcyBmcmFtZSBpZiBpdCB3YXMgcHJvdmlkZWQgd2l0aCBhIHplcm8tIGxlbmd0aCBjb25uZWN0aW9uIElEIGJ5IGl0cyBwZWVyLiBBbiBlbmRwb2ludCB0aGF0IHByb3ZpZGVzIGEgemVyby0gbGVuZ3RoIGNvbm5lY3Rpb24gSUQgTVVTVCB0cmVhdCByZWNlaXB0IG9mIGEgUkVUSVJFX0NPTk5FQ1RJT05fSUQgZnJhbWUgYXMgYSBjb25uZWN0aW9uIGVycm9yIG9mIHR5cGUgUFJPVE9DT0xfVklPTEFUSU9OLiAxOS4xNy4gUEFUSF9DSEFMTEVOR0UgRnJhbWVzIEVuZHBvaW50cyBjYW4gdXNlIFBBVEhfQ0hBTExFTkdFIGZyYW1lcyAodHlwZT0weDFhKSB0byBjaGVjayByZWFjaGFiaWxpdHkgdG8gdGhlIHBlZXIgYW5kIGZvciBwYXRoIHZhbGlkYXRpb24gZHVyaW5nIGNvbm5lY3Rpb24gbWlncmF0aW9uLiBQQVRIX0NIQUxMRU5HRSBmcmFtZXMgYXJlIGZvcm1hdHRlZCBhcyBzaG93biBpbiBGaWd1cmUgNDEuIFBBVEhfQ0hBTExFTkdFIEZyYW1lIHsgVHlwZSAoaSkgPSAweDFhLCBEYXRhICg2NCksIH0gRmlndXJlIDQxOiBQQVRIX0NIQUxMRU5HRSBGcmFtZSBGb3JtYXQgUEFUSF9DSEFMTEVOR0UgZnJhbWVzIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBmaWVsZDogRGF0YTogVGhpcyA4LWJ5dGUgZmllbGQgY29udGFpbnMgYXJiaXRyYXJ5IGRhdGEuIEluY2x1ZGluZyA2NCBiaXRzIG9mIGVudHJvcHkgaW4gYSBQQVRIX0NIQUxMRU5HRSBmcmFtZSBlbnN1cmVzIHRoYXQgaXQgaXMgZWFzaWVyIHRvIHJlY2VpdmUgdGhlIHBhY2tldCB0aGFuIGl0IGlzIHRvIGd1ZXNzIHRoZSB2YWx1ZSBjb3JyZWN0bHkuIFRoZSByZWNpcGllbnQgb2YgdGhpcyBmcmFtZSBNVVNUIGdlbmVyYXRlIGEgUEFUSF9SRVNQT05TRSBmcmFtZSAoU2VjdGlvbiAxOS4xOCkgY29udGFpbmluZyB0aGUgc2FtZSBEYXRhIHZhbHVlLiAxOS4xOC4gUEFUSF9SRVNQT05TRSBGcmFtZXMgQSBQQVRIX1JFU1BPTlNFIGZyYW1lICh0eXBlPTB4MWIpIGlzIHNlbnQgaW4gcmVzcG9uc2UgdG8gYSBQQVRIX0NIQUxMRU5HRSBmcmFtZS4gUEFUSF9SRVNQT05TRSBmcmFtZXMgYXJlIGZvcm1hdHRlZCBhcyBzaG93biBpbiBGaWd1cmUgNDIuIFRoZSBmb3JtYXQgb2YgYSBQQVRIX1JFU1BPTlNFIGZyYW1lIGlzIGlkZW50aWNhbCB0byB0aGF0IG9mIHRoZSBQQVRIX0NIQUxMRU5HRSBmcmFtZTsgc2VlIFNlY3Rpb24gMTkuMTcuIFBBVEhfUkVTUE9OU0UgRnJhbWUgeyBUeXBlIChpKSA9IDB4MWIsIERhdGEgKDY0KSwgfSBGaWd1cmUgNDI6IFBBVEhfUkVTUE9OU0UgRnJhbWUgRm9ybWF0IElmIHRoZSBjb250ZW50IG9mIGEgUEFUSF9SRVNQT05TRSBmcmFtZSBkb2VzIG5vdCBtYXRjaCB0aGUgY29udGVudCBvZiBhIFBBVEhfQ0hBTExFTkdFIGZyYW1lIHByZXZpb3VzbHkgc2VudCBieSB0aGUgZW5kcG9pbnQsIHRoZSBlbmRwb2ludCBNQVkgZ2VuZXJhdGUgYSBjb25uZWN0aW9uIGVycm9yIG9mIHR5cGUgUFJPVE9DT0xfVklPTEFUSU9OLiAxOS4xOS4gQ09OTkVDVElPTl9DTE9TRSBGcmFtZXMgQW4gZW5kcG9pbnQgc2VuZHMgYSBDT05ORUNUSU9OX0NMT1NFIGZyYW1lICh0eXBlPTB4MWMgb3IgMHgxZCkgdG8gbm90aWZ5IGl0cyBwZWVyIHRoYXQgdGhlIGNvbm5lY3Rpb24gaXMgYmVpbmcgY2xvc2VkLiBUaGUgQ09OTkVDVElPTl9DTE9TRSBmcmFtZSB3aXRoIGEgdHlwZSBvZiAweDFjIGlzIHVzZWQgdG8gc2lnbmFsIGVycm9ycyBhdCBvbmx5IHRoZSBRVUlDIGxheWVyLCBvciB0aGUgYWJzZW5jZSBvZiBlcnJvcnMgKHdpdGggdGhlIE5PX0VSUk9SIGNvZGUpLiBUaGUgQ09OTkVDVElPTl9DTE9TRSBmcmFtZSB3aXRoIGEgdHlwZSBvZiAweDFkIGlzIHVzZWQgdG8gc2lnbmFsIGFuIGVycm9yIHdpdGggdGhlIGFwcGxpY2F0aW9uIHRoYXQgdXNlcyBRVUlDLiBJZiB0aGVyZSBhcmUgb3BlbiBzdHJlYW1zIHRoYXQgaGF2ZSBub3QgYmVlbiBleHBsaWNpdGx5IGNsb3NlZCwgdGhleSBhcmUgaW1wbGljaXRseSBjbG9zZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBjbG9zZWQuIENPTk5FQ1RJT05fQ0xPU0UgZnJhbWVzIGFyZSBmb3JtYXR0ZWQgYXMgc2hvd24gaW4gRmlndXJlIDQzLiBDT05ORUNUSU9OX0NMT1NFIEZyYW1lIHsgVHlwZSAoaSkgPSAweDFjLi4weDFkLCBFcnJvciBDb2RlIChpKSwgW0ZyYW1lIFR5cGUgKGkpXSwgUmVhc29uIFBocmFzZSBMZW5ndGggKGkpLCBSZWFzb24gUGhyYXNlICguLiksIH0gRmlndXJlIDQzOiBDT05ORUNUSU9OX0NMT1NFIEZyYW1lIEZvcm1hdCBDT05ORUNUSU9OX0NMT1NFIGZyYW1lcyBjb250YWluIHRoZSBmb2xsb3dpbmcgZmllbGRzOiBFcnJvciBDb2RlOiBBIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIHRoYXQgaW5kaWNhdGVzIHRoZSByZWFzb24gZm9yIGNsb3NpbmcgdGhpcyBjb25uZWN0aW9uLiBBIENPTk5FQ1RJT05fQ0xPU0UgZnJhbWUgb2YgdHlwZSAweDFjIHVzZXMgY29kZXMgZnJvbSB0aGUgc3BhY2UgZGVmaW5lZCBpbiBTZWN0aW9uIDIwLjEuIEEgQ09OTkVDVElPTl9DTE9TRSBmcmFtZSBvZiB0eXBlIDB4MWQgdXNlcyBjb2RlcyBkZWZpbmVkIGJ5IHRoZSBhcHBsaWNhdGlvbiBwcm90b2NvbDsgc2VlIFNlY3Rpb24gMjAuMi4gRnJhbWUgVHlwZTogQSB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBlbmNvZGluZyB0aGUgdHlwZSBvZiBmcmFtZSB0aGF0IHRyaWdnZXJlZCB0aGUgZXJyb3IuIEEgdmFsdWUgb2YgMCAoZXF1aXZhbGVudCB0byB0aGUgbWVudGlvbiBvZiB0aGUgUEFERElORyBmcmFtZSkgaXMgdXNlZCB3aGVuIHRoZSBmcmFtZSB0eXBlIGlzIHVua25vd24uIFRoZSBhcHBsaWNhdGlvbi1zcGVjaWZpYyB2YXJpYW50IG9mIENPTk5FQ1RJT05fQ0xPU0UgKHR5cGUgMHgxZCkgZG9lcyBub3QgaW5jbHVkZSB0aGlzIGZpZWxkLiBSZWFzb24gUGhyYXNlIExlbmd0aDogQSB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBzcGVjaWZ5aW5nIHRoZSBsZW5ndGggb2YgdGhlIHJlYXNvbiBwaHJhc2UgaW4gYnl0ZXMuIEJlY2F1c2UgYSBDT05ORUNUSU9OX0NMT1NFIGZyYW1lIGNhbm5vdCBiZSBzcGxpdCBiZXR3ZWVuIHBhY2tldHMsIGFueSBsaW1pdHMgb24gcGFja2V0IHNpemUgd2lsbCBhbHNvIGxpbWl0IHRoZSBzcGFjZSBhdmFpbGFibGUgZm9yIGEgcmVhc29uIHBocmFzZS4gUmVhc29uIFBocmFzZTogQWRkaXRpb25hbCBkaWFnbm9zdGljIGluZm9ybWF0aW9uIGZvciB0aGUgY2xvc3VyZS4gVGhpcyBjYW4gYmUgemVybyBsZW5ndGggaWYgdGhlIHNlbmRlciBjaG9vc2VzIG5vdCB0byBnaXZlIGRldGFpbHMgYmV5b25kIHRoZSBFcnJvciBDb2RlIHZhbHVlLiBUaGlzIFNIT1VMRCBiZSBhIFVURi04IGVuY29kZWQgc3RyaW5nIFtSRkMzNjI5XSwgdGhvdWdoIHRoZSBmcmFtZSBkb2VzIG5vdCBjYXJyeSBpbmZvcm1hdGlvbiwgc3VjaCBhcyBsYW5ndWFnZSB0YWdzLCB0aGF0IHdvdWxkIGFpZCBjb21wcmVoZW5zaW9uIGJ5IGFueSBlbnRpdHkgb3RoZXIgdGhhbiB0aGUgb25lIHRoYXQgY3JlYXRlZCB0aGUgdGV4dC4gVGhlIGFwcGxpY2F0aW9uLXNwZWNpZmljIHZhcmlhbnQgb2YgQ09OTkVDVElPTl9DTE9TRSAodHlwZSAweDFkKSBjYW4gb25seSBiZSBzZW50IHVzaW5nIDAtUlRUIG9yIDEtUlRUIHBhY2tldHM7IHNlZSBTZWN0aW9uIDEyLjUuIFdoZW4gYW4gYXBwbGljYXRpb24gd2lzaGVzIHRvIGFiYW5kb24gYSBjb25uZWN0aW9uIGR1cmluZyB0aGUgaGFuZHNoYWtlLCBhbiBlbmRwb2ludCBjYW4gc2VuZCBhIENPTk5FQ1RJT05fQ0xPU0UgZnJhbWUgKHR5cGUgMHgxYykgd2l0aCBhbiBlcnJvciBjb2RlIG9mIEFQUExJQ0FUSU9OX0VSUk9SIGluIGFuIEluaXRpYWwgb3IgSGFuZHNoYWtlIHBhY2tldC4gMTkuMjAuIEhBTkRTSEFLRV9ET05FIEZyYW1lcyBUaGUgc2VydmVyIHVzZXMgYSBIQU5EU0hBS0VfRE9ORSBmcmFtZSAodHlwZT0weDFlKSB0byBzaWduYWwgY29uZmlybWF0aW9uIG9mIHRoZSBoYW5kc2hha2UgdG8gdGhlIGNsaWVudC4gSEFORFNIQUtFX0RPTkUgZnJhbWVzIGFyZSBmb3JtYXR0ZWQgYXMgc2hvd24gaW4gRmlndXJlIDQ0LCB3aGljaCBzaG93cyB0aGF0IEhBTkRTSEFLRV9ET05FIGZyYW1lcyBoYXZlIG5vIGNvbnRlbnQuIEhBTkRTSEFLRV9ET05FIEZyYW1lIHsgVHlwZSAoaSkgPSAweDFlLCB9IEZpZ3VyZSA0NDogSEFORFNIQUtFX0RPTkUgRnJhbWUgRm9ybWF0IEEgSEFORFNIQUtFX0RPTkUgZnJhbWUgY2FuIG9ubHkgYmUgc2VudCBieSB0aGUgc2VydmVyLiBTZXJ2ZXJzIE1VU1QgTk9UIHNlbmQgYSBIQU5EU0hBS0VfRE9ORSBmcmFtZSBiZWZvcmUgY29tcGxldGluZyB0aGUgaGFuZHNoYWtlLiBBIHNlcnZlciBNVVNUIHRyZWF0IHJlY2VpcHQgb2YgYSBIQU5EU0hBS0VfRE9ORSBmcmFtZSBhcyBhIGNvbm5lY3Rpb24gZXJyb3Igb2YgdHlwZSBQUk9UT0NPTF9WSU9MQVRJT04uIDE5LjIxLiBFeHRlbnNpb24gRnJhbWVzIFFVSUMgZnJhbWVzIGRvIG5vdCB1c2UgYSBzZWxmLWRlc2NyaWJpbmcgZW5jb2RpbmcuIEFuIGVuZHBvaW50IHRoZXJlZm9yZSBuZWVkcyB0byB1bmRlcnN0YW5kIHRoZSBzeW50YXggb2YgYWxsIGZyYW1lcyBiZWZvcmUgaXQgY2FuIHN1Y2Nlc3NmdWxseSBwcm9jZXNzIGEgcGFja2V0LiBUaGlzIGFsbG93cyBmb3IgZWZmaWNpZW50IGVuY29kaW5nIG9mIGZyYW1lcywgYnV0IGl0IG1lYW5zIHRoYXQgYW4gZW5kcG9pbnQgY2Fubm90IHNlbmQgYSBmcmFtZSBvZiBhIHR5cGUgdGhhdCBpcyB1bmtub3duIHRvIGl0cyBwZWVyLiBBbiBleHRlbnNpb24gdG8gUVVJQyB0aGF0IHdpc2hlcyB0byB1c2UgYSBuZXcgdHlwZSBvZiBmcmFtZSBNVVNUIGZpcnN0IGVuc3VyZSB0aGF0IGEgcGVlciBpcyBhYmxlIHRvIHVuZGVyc3RhbmQgdGhlIGZyYW1lLiBBbiBlbmRwb2ludCBjYW4gdXNlIGEgdHJhbnNwb3J0IHBhcmFtZXRlciB0byBzaWduYWwgaXRzIHdpbGxpbmduZXNzIHRvIHJlY2VpdmUgZXh0ZW5zaW9uIGZyYW1lIHR5cGVzLiBPbmUgdHJhbnNwb3J0IHBhcmFtZXRlciBjYW4gaW5kaWNhdGUgc3VwcG9ydCBmb3Igb25lIG9yIG1vcmUgZXh0ZW5zaW9uIGZyYW1lIHR5cGVzLiBFeHRlbnNpb25zIHRoYXQgbW9kaWZ5IG9yIHJlcGxhY2UgY29yZSBwcm90b2NvbCBmdW5jdGlvbmFsaXR5IChpbmNsdWRpbmcgZnJhbWUgdHlwZXMpIHdpbGwgYmUgZGlmZmljdWx0IHRvIGNvbWJpbmUgd2l0aCBvdGhlciBleHRlbnNpb25zIHRoYXQgbW9kaWZ5IG9yIHJlcGxhY2UgdGhlIHNhbWUgZnVuY3Rpb25hbGl0eSB1bmxlc3MgdGhlIGJlaGF2aW9yIG9mIHRoZSBjb21iaW5hdGlvbiBpcyBleHBsaWNpdGx5IGRlZmluZWQuIFN1Y2ggZXh0ZW5zaW9ucyBTSE9VTEQgZGVmaW5lIHRoZWlyIGludGVyYWN0aW9uIHdpdGggcHJldmlvdXNseSBkZWZpbmVkIGV4dGVuc2lvbnMgbW9kaWZ5aW5nIHRoZSBzYW1lIHByb3RvY29sIGNvbXBvbmVudHMuIEV4dGVuc2lvbiBmcmFtZXMgTVVTVCBiZSBjb25nZXN0aW9uIGNvbnRyb2xsZWQgYW5kIE1VU1QgY2F1c2UgYW4gQUNLIGZyYW1lIHRvIGJlIHNlbnQuIFRoZSBleGNlcHRpb24gaXMgZXh0ZW5zaW9uIGZyYW1lcyB0aGF0IHJlcGxhY2Ugb3Igc3VwcGxlbWVudCB0aGUgQUNLIGZyYW1lLiBFeHRlbnNpb24gZnJhbWVzIGFyZSBub3QgaW5jbHVkZWQgaW4gZmxvdyBjb250cm9sIHVubGVzcyBzcGVjaWZpZWQgaW4gdGhlIGV4dGVuc2lvbi4gQW4gSUFOQSByZWdpc3RyeSBpcyB1c2VkIHRvIG1hbmFnZSB0aGUgYXNzaWdubWVudCBvZiBmcmFtZSB0eXBlczsgc2VlIFNlY3Rpb24gMjIuNC4gMjAuIEVycm9yIENvZGVzIFFVSUMgdHJhbnNwb3J0IGVycm9yIGNvZGVzIGFuZCBhcHBsaWNhdGlvbiBlcnJvciBjb2RlcyBhcmUgNjItYml0IHVuc2lnbmVkIGludGVnZXJzLiAyMC4xLiBUcmFuc3BvcnQgRXJyb3IgQ29kZXMgVGhpcyBzZWN0aW9uIGxpc3RzIHRoZSBkZWZpbmVkIFFVSUMgdHJhbnNwb3J0IGVycm9yIGNvZGVzIHRoYXQgY2FuIGJlIHVzZWQgaW4gYSBDT05ORUNUSU9OX0NMT1NFIGZyYW1lIHdpdGggYSB0eXBlIG9mIDB4MWMuIFRoZXNlIGVycm9ycyBhcHBseSB0byB0aGUgZW50aXJlIGNvbm5lY3Rpb24uIE5PX0VSUk9SICgweDAwKTogQW4gZW5kcG9pbnQgdXNlcyB0aGlzIHdpdGggQ09OTkVDVElPTl9DTE9TRSB0byBzaWduYWwgdGhhdCB0aGUgY29ubmVjdGlvbiBpcyBiZWluZyBjbG9zZWQgYWJydXB0bHkgaW4gdGhlIGFic2VuY2Ugb2YgYW55IGVycm9yLiBJTlRFUk5BTF9FUlJPUiAoMHgwMSk6IFRoZSBlbmRwb2ludCBlbmNvdW50ZXJlZCBhbiBpbnRlcm5hbCBlcnJvciBhbmQgY2Fubm90IGNvbnRpbnVlIHdpdGggdGhlIGNvbm5lY3Rpb24uIENPTk5FQ1RJT05fUkVGVVNFRCAoMHgwMik6IFRoZSBzZXJ2ZXIgcmVmdXNlZCB0byBhY2NlcHQgYSBuZXcgY29ubmVjdGlvbi4gRkxPV19DT05UUk9MX0VSUk9SICgweDAzKTogQW4gZW5kcG9pbnQgcmVjZWl2ZWQgbW9yZSBkYXRhIHRoYW4gaXQgcGVybWl0dGVkIGluIGl0cyBhZHZlcnRpc2VkIGRhdGEgbGltaXRzOyBzZWUgU2VjdGlvbiA0LiBTVFJFQU1fTElNSVRfRVJST1IgKDB4MDQpOiBBbiBlbmRwb2ludCByZWNlaXZlZCBhIGZyYW1lIGZvciBhIHN0cmVhbSBpZGVudGlmaWVyIHRoYXQgZXhjZWVkZWQgaXRzIGFkdmVydGlzZWQgc3RyZWFtIGxpbWl0IGZvciB0aGUgY29ycmVzcG9uZGluZyBzdHJlYW0gdHlwZS4gU1RSRUFNX1NUQVRFX0VSUk9SICgweDA1KTogQW4gZW5kcG9pbnQgcmVjZWl2ZWQgYSBmcmFtZSBmb3IgYSBzdHJlYW0gdGhhdCB3YXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXR0ZWQgdGhhdCBmcmFtZTsgc2VlIFNlY3Rpb24gMy4gRklOQUxfU0laRV9FUlJPUiAoMHgwNik6ICgxKSBBbiBlbmRwb2ludCByZWNlaXZlZCBhIFNUUkVBTSBmcmFtZSBjb250YWluaW5nIGRhdGEgdGhhdCBleGNlZWRlZCB0aGUgcHJldmlvdXNseSBlc3RhYmxpc2hlZCBmaW5hbCBzaXplLCAoMikgYW4gZW5kcG9pbnQgcmVjZWl2ZWQgYSBTVFJFQU0gZnJhbWUgb3IgYSBSRVNFVF9TVFJFQU0gZnJhbWUgY29udGFpbmluZyBhIGZpbmFsIHNpemUgdGhhdCB3YXMgbG93ZXIgdGhhbiB0aGUgc2l6ZSBvZiBzdHJlYW0gZGF0YSB0aGF0IHdhcyBhbHJlYWR5IHJlY2VpdmVkLCBvciAoMykgYW4gZW5kcG9pbnQgcmVjZWl2ZWQgYSBTVFJFQU0gZnJhbWUgb3IgYSBSRVNFVF9TVFJFQU0gZnJhbWUgY29udGFpbmluZyBhIGRpZmZlcmVudCBmaW5hbCBzaXplIHRvIHRoZSBvbmUgYWxyZWFkeSBlc3RhYmxpc2hlZC4gRlJBTUVfRU5DT0RJTkdfRVJST1IgKDB4MDcpOiBBbiBlbmRwb2ludCByZWNlaXZlZCBhIGZyYW1lIHRoYXQgd2FzIGJhZGx5IGZvcm1hdHRlZCAtLSBmb3IgaW5zdGFuY2UsIGEgZnJhbWUgb2YgYW4gdW5rbm93biB0eXBlIG9yIGFuIEFDSyBmcmFtZSB0aGF0IGhhcyBtb3JlIGFja25vd2xlZGdtZW50IHJhbmdlcyB0aGFuIHRoZSByZW1haW5kZXIgb2YgdGhlIHBhY2tldCBjb3VsZCBjYXJyeS4gVFJBTlNQT1JUX1BBUkFNRVRFUl9FUlJPUiAoMHgwOCk6IEFuIGVuZHBvaW50IHJlY2VpdmVkIHRyYW5zcG9ydCBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBiYWRseSBmb3JtYXR0ZWQsIGluY2x1ZGVkIGFuIGludmFsaWQgdmFsdWUsIG9taXR0ZWQgYSBtYW5kYXRvcnkgdHJhbnNwb3J0IHBhcmFtZXRlciwgaW5jbHVkZWQgYSBmb3JiaWRkZW4gdHJhbnNwb3J0IHBhcmFtZXRlciwgb3Igd2VyZSBvdGhlcndpc2UgaW4gZXJyb3IuIENPTk5FQ1RJT05fSURfTElNSVRfRVJST1IgKDB4MDkpOiBUaGUgbnVtYmVyIG9mIGNvbm5lY3Rpb24gSURzIHByb3ZpZGVkIGJ5IHRoZSBwZWVyIGV4Y2VlZHMgdGhlIGFkdmVydGlzZWQgYWN0aXZlX2Nvbm5lY3Rpb25faWRfbGltaXQuIFBST1RPQ09MX1ZJT0xBVElPTiAoMHgwYSk6IEFuIGVuZHBvaW50IGRldGVjdGVkIGFuIGVycm9yIHdpdGggcHJvdG9jb2wgY29tcGxpYW5jZSB0aGF0IHdhcyBub3QgY292ZXJlZCBieSBtb3JlIHNwZWNpZmljIGVycm9yIGNvZGVzLiBJTlZBTElEX1RPS0VOICgweDBiKTogQSBzZXJ2ZXIgcmVjZWl2ZWQgYSBjbGllbnQgSW5pdGlhbCB0aGF0IGNvbnRhaW5lZCBhbiBpbnZhbGlkIFRva2VuIGZpZWxkLiBBUFBMSUNBVElPTl9FUlJPUiAoMHgwYyk6IFRoZSBhcHBsaWNhdGlvbiBvciBhcHBsaWNhdGlvbiBwcm90b2NvbCBjYXVzZWQgdGhlIGNvbm5lY3Rpb24gdG8gYmUgY2xvc2VkLiBDUllQVE9fQlVGRkVSX0VYQ0VFREVEICgweDBkKTogQW4gZW5kcG9pbnQgaGFzIHJlY2VpdmVkIG1vcmUgZGF0YSBpbiBDUllQVE8gZnJhbWVzIHRoYW4gaXQgY2FuIGJ1ZmZlci4gS0VZX1VQREFURV9FUlJPUiAoMHgwZSk6IEFuIGVuZHBvaW50IGRldGVjdGVkIGVycm9ycyBpbiBwZXJmb3JtaW5nIGtleSB1cGRhdGVzOyBzZWUgU2VjdGlvbiA2IG9mIFtRVUlDLVRMU10uIEFFQURfTElNSVRfUkVBQ0hFRCAoMHgwZik6IEFuIGVuZHBvaW50IGhhcyByZWFjaGVkIHRoZSBjb25maWRlbnRpYWxpdHkgb3IgaW50ZWdyaXR5IGxpbWl0IGZvciB0aGUgQUVBRCBhbGdvcml0aG0gdXNlZCBieSB0aGUgZ2l2ZW4gY29ubmVjdGlvbi4gTk9fVklBQkxFX1BBVEggKDB4MTApOiBBbiBlbmRwb2ludCBoYXMgZGV0ZXJtaW5lZCB0aGF0IHRoZSBuZXR3b3JrIHBhdGggaXMgaW5jYXBhYmxlIG9mIHN1cHBvcnRpbmcgUVVJQy4gQW4gZW5kcG9pbnQgaXMgdW5saWtlbHkgdG8gcmVjZWl2ZSBhIENPTk5FQ1RJT05fQ0xPU0UgZnJhbWUgY2FycnlpbmcgdGhpcyBjb2RlIGV4Y2VwdCB3aGVuIHRoZSBwYXRoIGRvZXMgbm90IHN1cHBvcnQgYSBsYXJnZSBlbm91Z2ggTVRVLiBDUllQVE9fRVJST1IgKDB4MDEwMC0weDAxZmYpOiBUaGUgY3J5cHRvZ3JhcGhpYyBoYW5kc2hha2UgZmFpbGVkLiBBIHJhbmdlIG9mIDI1NiB2YWx1ZXMgaXMgcmVzZXJ2ZWQgZm9yIGNhcnJ5aW5nIGVycm9yIGNvZGVzIHNwZWNpZmljIHRvIHRoZSBjcnlwdG9ncmFwaGljIGhhbmRzaGFrZSB0aGF0IGlzIHVzZWQuIENvZGVzIGZvciBlcnJvcnMgb2NjdXJyaW5nIHdoZW4gVExTIGlzIHVzZWQgZm9yIHRoZSBjcnlwdG9ncmFwaGljIGhhbmRzaGFrZSBhcmUgZGVzY3JpYmVkIGluIFNlY3Rpb24gNC44IG9mIFtRVUlDLVRMU10uIFNlZSBTZWN0aW9uIDIyLjUgZm9yIGRldGFpbHMgb24gcmVnaXN0ZXJpbmcgbmV3IGVycm9yIGNvZGVzLiBJbiBkZWZpbmluZyB0aGVzZSBlcnJvciBjb2Rlcywgc2V2ZXJhbCBwcmluY2lwbGVzIGFyZSBhcHBsaWVkLiBFcnJvciBjb25kaXRpb25zIHRoYXQgbWlnaHQgcmVxdWlyZSBzcGVjaWZpYyBhY3Rpb24gb24gdGhlIHBhcnQgb2YgYSByZWNpcGllbnQgYXJlIGdpdmVuIHVuaXF1ZSBjb2Rlcy4gRXJyb3JzIHRoYXQgcmVwcmVzZW50IGNvbW1vbiBjb25kaXRpb25zIGFyZSBnaXZlbiBzcGVjaWZpYyBjb2Rlcy4gQWJzZW50IGVpdGhlciBvZiB0aGVzZSBjb25kaXRpb25zLCBlcnJvciBjb2RlcyBhcmUgdXNlZCB0byBpZGVudGlmeSBhIGdlbmVyYWwgZnVuY3Rpb24gb2YgdGhlIHN0YWNrLCBsaWtlIGZsb3cgY29udHJvbCBvciB0cmFuc3BvcnQgcGFyYW1ldGVyIGhhbmRsaW5nLiBGaW5hbGx5LCBnZW5lcmljIGVycm9ycyBhcmUgcHJvdmlkZWQgZm9yIGNvbmRpdGlvbnMgd2hlcmUgaW1wbGVtZW50YXRpb25zIGFyZSB1bmFibGUgb3IgdW53aWxsaW5nIHRvIHVzZSBtb3JlIHNwZWNpZmljIGNvZGVzLiAyMC4yLiBBcHBsaWNhdGlvbiBQcm90b2NvbCBFcnJvciBDb2RlcyBUaGUgbWFuYWdlbWVudCBvZiBhcHBsaWNhdGlvbiBlcnJvciBjb2RlcyBpcyBsZWZ0IHRvIGFwcGxpY2F0aW9uIHByb3RvY29scy4gQXBwbGljYXRpb24gcHJvdG9jb2wgZXJyb3IgY29kZXMgYXJlIHVzZWQgZm9yIHRoZSBSRVNFVF9TVFJFQU0gZnJhbWUgKFNlY3Rpb24gMTkuNCksIHRoZSBTVE9QX1NFTkRJTkcgZnJhbWUgKFNlY3Rpb24gMTkuNSksIGFuZCB0aGUgQ09OTkVDVElPTl9DTE9TRSBmcmFtZSB3aXRoIGEgdHlwZSBvZiAweDFkIChTZWN0aW9uIDE5LjE5KS4gMjEuIFNlY3VyaXR5IENvbnNpZGVyYXRpb25zIFRoZSBnb2FsIG9mIFFVSUMgaXMgdG8gcHJvdmlkZSBhIHNlY3VyZSB0cmFuc3BvcnQgY29ubmVjdGlvbi4gU2VjdGlvbiAyMS4xIHByb3ZpZGVzIGFuIG92ZXJ2aWV3IG9mIHRob3NlIHByb3BlcnRpZXM7IHN1YnNlcXVlbnQgc2VjdGlvbnMgZGlzY3VzcyBjb25zdHJhaW50cyBhbmQgY2F2ZWF0cyByZWdhcmRpbmcgdGhlc2UgcHJvcGVydGllcywgaW5jbHVkaW5nIGRlc2NyaXB0aW9ucyBvZiBrbm93biBhdHRhY2tzIGFuZCBjb3VudGVybWVhc3VyZXMuIDIxLjEuIE92ZXJ2aWV3IG9mIFNlY3VyaXR5IFByb3BlcnRpZXMgQSBjb21wbGV0ZSBzZWN1cml0eSBhbmFseXNpcyBvZiBRVUlDIGlzIG91dHNpZGUgdGhlIHNjb3BlIG9mIHRoaXMgZG9jdW1lbnQuIFRoaXMgc2VjdGlvbiBwcm92aWRlcyBhbiBpbmZvcm1hbCBkZXNjcmlwdGlvbiBvZiB0aGUgZGVzaXJlZCBzZWN1cml0eSBwcm9wZXJ0aWVzIGFzIGFuIGFpZCB0byBpbXBsZW1lbnRlcnMgYW5kIHRvIGhlbHAgZ3VpZGUgcHJvdG9jb2wgYW5hbHlzaXMuIFFVSUMgYXNzdW1lcyB0aGUgdGhyZWF0IG1vZGVsIGRlc2NyaWJlZCBpbiBbU0VDLUNPTlNdIGFuZCBwcm92aWRlcyBwcm90ZWN0aW9ucyBhZ2FpbnN0IG1hbnkgb2YgdGhlIGF0dGFja3MgdGhhdCBhcmlzZSBmcm9tIHRoYXQgbW9kZWwuIEZvciB0aGlzIHB1cnBvc2UsIGF0dGFja3MgYXJlIGRpdmlkZWQgaW50byBwYXNzaXZlIGFuZCBhY3RpdmUgYXR0YWNrcy4gUGFzc2l2ZSBhdHRhY2tlcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZWFkIHBhY2tldHMgZnJvbSB0aGUgbmV0d29yaywgd2hpbGUgYWN0aXZlIGF0dGFja2VycyBhbHNvIGhhdmUgdGhlIGFiaWxpdHkgdG8gd3JpdGUgcGFja2V0cyBpbnRvIHRoZSBuZXR3b3JrLiBIb3dldmVyLCBhIHBhc3NpdmUgYXR0YWNrIGNvdWxkIGludm9sdmUgYW4gYXR0YWNrZXIgd2l0aCB0aGUgYWJpbGl0eSB0byBjYXVzZSBhIHJvdXRpbmcgY2hhbmdlIG9yIG90aGVyIG1vZGlmaWNhdGlvbiBpbiB0aGUgcGF0aCB0YWtlbiBieSBwYWNrZXRzIHRoYXQgY29tcHJpc2UgYSBjb25uZWN0aW9uLiBBdHRhY2tlcnMgYXJlIGFkZGl0aW9uYWxseSBjYXRlZ29yaXplZCBhcyBlaXRoZXIgb24tcGF0aCBhdHRhY2tlcnMgb3Igb2ZmLXBhdGggYXR0YWNrZXJzLiBBbiBvbi1wYXRoIGF0dGFja2VyIGNhbiByZWFkLCBtb2RpZnksIG9yIHJlbW92ZSBhbnkgcGFja2V0IGl0IG9ic2VydmVzIHN1Y2ggdGhhdCB0aGUgcGFja2V0IG5vIGxvbmdlciByZWFjaGVzIGl0cyBkZXN0aW5hdGlvbiwgd2hpbGUgYW4gb2ZmLXBhdGggYXR0YWNrZXIgb2JzZXJ2ZXMgdGhlIHBhY2tldHMgYnV0IGNhbm5vdCBwcmV2ZW50IHRoZSBvcmlnaW5hbCBwYWNrZXQgZnJvbSByZWFjaGluZyBpdHMgaW50ZW5kZWQgZGVzdGluYXRpb24uIEJvdGggdHlwZXMgb2YgYXR0YWNrZXJzIGNhbiBhbHNvIHRyYW5zbWl0IGFyYml0cmFyeSBwYWNrZXRzLiBUaGlzIGRlZmluaXRpb24gZGlmZmVycyBmcm9tIHRoYXQgb2YgU2VjdGlvbiAzLjUgb2YgW1NFQy1DT05TXSBpbiB0aGF0IGFuIG9mZi1wYXRoIGF0dGFja2VyIGlzIGFibGUgdG8gb2JzZXJ2ZSBwYWNrZXRzLiBQcm9wZXJ0aWVzIG9mIHRoZSBoYW5kc2hha2UsIHByb3RlY3RlZCBwYWNrZXRzLCBhbmQgY29ubmVjdGlvbiBtaWdyYXRpb24gYXJlIGNvbnNpZGVyZWQgc2VwYXJhdGVseS4gMjEuMS4xLiBIYW5kc2hha2UgVGhlIFFVSUMgaGFuZHNoYWtlIGluY29ycG9yYXRlcyB0aGUgVExTIDEuMyBoYW5kc2hha2UgYW5kIGluaGVyaXRzIHRoZSBjcnlwdG9ncmFwaGljIHByb3BlcnRpZXMgZGVzY3JpYmVkIGluIEFwcGVuZGl4IEUuMSBvZiBbVExTMTNdLiBNYW55IG9mIHRoZSBzZWN1cml0eSBwcm9wZXJ0aWVzIG9mIFFVSUMgZGVwZW5kIG9uIHRoZSBUTFMgaGFuZHNoYWtlIHByb3ZpZGluZyB0aGVzZSBwcm9wZXJ0aWVzLiBBbnkgYXR0YWNrIG9uIHRoZSBUTFMgaGFuZHNoYWtlIGNvdWxkIGFmZmVjdCBRVUlDLiBBbnkgYXR0YWNrIG9uIHRoZSBUTFMgaGFuZHNoYWtlIHRoYXQgY29tcHJvbWlzZXMgdGhlIHNlY3JlY3kgb3IgdW5pcXVlbmVzcyBvZiBzZXNzaW9uIGtleXMsIG9yIHRoZSBhdXRoZW50aWNhdGlvbiBvZiB0aGUgcGFydGljaXBhdGluZyBwZWVycywgYWZmZWN0cyBvdGhlciBzZWN1cml0eSBndWFyYW50ZWVzIHByb3ZpZGVkIGJ5IFFVSUMgdGhhdCBkZXBlbmQgb24gdGhvc2Uga2V5cy4gRm9yIGluc3RhbmNlLCBtaWdyYXRpb24gKFNlY3Rpb24gOSkgZGVwZW5kcyBvbiB0aGUgZWZmaWNhY3kgb2YgY29uZmlkZW50aWFsaXR5IHByb3RlY3Rpb25zLCBib3RoIGZvciB0aGUgbmVnb3RpYXRpb24gb2Yga2V5cyB1c2luZyB0aGUgVExTIGhhbmRzaGFrZSBhbmQgZm9yIFFVSUMgcGFja2V0IHByb3RlY3Rpb24sIHRvIGF2b2lkIGxpbmthYmlsaXR5IGFjcm9zcyBuZXR3b3JrIHBhdGhzLiBBbiBhdHRhY2sgb24gdGhlIGludGVncml0eSBvZiB0aGUgVExTIGhhbmRzaGFrZSBtaWdodCBhbGxvdyBhbiBhdHRhY2tlciB0byBhZmZlY3QgdGhlIHNlbGVjdGlvbiBvZiBhcHBsaWNhdGlvbiBwcm90b2NvbCBvciBRVUlDIHZlcnNpb24uIEluIGFkZGl0aW9uIHRvIHRoZSBwcm9wZXJ0aWVzIHByb3ZpZGVkIGJ5IFRMUywgdGhlIFFVSUMgaGFuZHNoYWtlIHByb3ZpZGVzIHNvbWUgZGVmZW5zZSBhZ2FpbnN0IERvUyBhdHRhY2tzIG9uIHRoZSBoYW5kc2hha2UuIDIxLjEuMS4xLiBBbnRpLUFtcGxpZmljYXRpb24gQWRkcmVzcyB2YWxpZGF0aW9uIChTZWN0aW9uIDgpIGlzIHVzZWQgdG8gdmVyaWZ5IHRoYXQgYW4gZW50aXR5IHRoYXQgY2xhaW1zIGEgZ2l2ZW4gYWRkcmVzcyBpcyBhYmxlIHRvIHJlY2VpdmUgcGFja2V0cyBhdCB0aGF0IGFkZHJlc3MuIEFkZHJlc3MgdmFsaWRhdGlvbiBsaW1pdHMgYW1wbGlmaWNhdGlvbiBhdHRhY2sgdGFyZ2V0cyB0byBhZGRyZXNzZXMgZm9yIHdoaWNoIGFuIGF0dGFja2VyIGNhbiBvYnNlcnZlIHBhY2tldHMuIFByaW9yIHRvIGFkZHJlc3MgdmFsaWRhdGlvbiwgZW5kcG9pbnRzIGFyZSBsaW1pdGVkIGluIHdoYXQgdGhleSBhcmUgYWJsZSB0byBzZW5kLiBFbmRwb2ludHMgY2Fubm90IHNlbmQgZGF0YSB0b3dhcmQgYW4gdW52YWxpZGF0ZWQgYWRkcmVzcyBpbiBleGNlc3Mgb2YgdGhyZWUgdGltZXMgdGhlIGRhdGEgcmVjZWl2ZWQgZnJvbSB0aGF0IGFkZHJlc3MuIHwgTm90ZTogVGhlIGFudGktYW1wbGlmaWNhdGlvbiBsaW1pdCBvbmx5IGFwcGxpZXMgd2hlbiBhbiB8IGVuZHBvaW50IHJlc3BvbmRzIHRvIHBhY2tldHMgcmVjZWl2ZWQgZnJvbSBhbiB1bnZhbGlkYXRlZCB8IGFkZHJlc3MuIFRoZSBhbnRpLWFtcGxpZmljYXRpb24gbGltaXQgZG9lcyBub3QgYXBwbHkgdG8gfCBjbGllbnRzIHdoZW4gZXN0YWJsaXNoaW5nIGEgbmV3IGNvbm5lY3Rpb24gb3Igd2hlbiBpbml0aWF0aW5nIHwgY29ubmVjdGlvbiBtaWdyYXRpb24uIDIxLjEuMS4yLiBTZXJ2ZXItU2lkZSBEb1MgQ29tcHV0aW5nIHRoZSBzZXJ2ZXIncyBmaXJzdCBmbGlnaHQgZm9yIGEgZnVsbCBoYW5kc2hha2UgaXMgcG90ZW50aWFsbHkgZXhwZW5zaXZlLCByZXF1aXJpbmcgYm90aCBhIHNpZ25hdHVyZSBhbmQgYSBrZXkgZXhjaGFuZ2UgY29tcHV0YXRpb24uIEluIG9yZGVyIHRvIHByZXZlbnQgY29tcHV0YXRpb25hbCBEb1MgYXR0YWNrcywgdGhlIFJldHJ5IHBhY2tldCBwcm92aWRlcyBhIGNoZWFwIHRva2VuIGV4Y2hhbmdlIG1lY2hhbmlzbSB0aGF0IGFsbG93cyBzZXJ2ZXJzIHRvIHZhbGlkYXRlIGEgY2xpZW50J3MgSVAgYWRkcmVzcyBwcmlvciB0byBkb2luZyBhbnkgZXhwZW5zaXZlIGNvbXB1dGF0aW9ucyBhdCB0aGUgY29zdCBvZiBhIHNpbmdsZSByb3VuZCB0cmlwLiBBZnRlciBhIHN1Y2Nlc3NmdWwgaGFuZHNoYWtlLCBzZXJ2ZXJzIGNhbiBpc3N1ZSBuZXcgdG9rZW5zIHRvIGEgY2xpZW50LCB3aGljaCB3aWxsIGFsbG93IG5ldyBjb25uZWN0aW9uIGVzdGFibGlzaG1lbnQgd2l0aG91dCBpbmN1cnJpbmcgdGhpcyBjb3N0LiAyMS4xLjEuMy4gT24tUGF0aCBIYW5kc2hha2UgVGVybWluYXRpb24gQW4gb24tcGF0aCBvciBvZmYtcGF0aCBhdHRhY2tlciBjYW4gZm9yY2UgYSBoYW5kc2hha2UgdG8gZmFpbCBieSByZXBsYWNpbmcgb3IgcmFjaW5nIEluaXRpYWwgcGFja2V0cy4gT25jZSB2YWxpZCBJbml0aWFsIHBhY2tldHMgaGF2ZSBiZWVuIGV4Y2hhbmdlZCwgc3Vic2VxdWVudCBIYW5kc2hha2UgcGFja2V0cyBhcmUgcHJvdGVjdGVkIHdpdGggdGhlIEhhbmRzaGFrZSBrZXlzLCBhbmQgYW4gb24tcGF0aCBhdHRhY2tlciBjYW5ub3QgZm9yY2UgaGFuZHNoYWtlIGZhaWx1cmUgb3RoZXIgdGhhbiBieSBkcm9wcGluZyBwYWNrZXRzIHRvIGNhdXNlIGVuZHBvaW50cyB0byBhYmFuZG9uIHRoZSBhdHRlbXB0LiBBbiBvbi1wYXRoIGF0dGFja2VyIGNhbiBhbHNvIHJlcGxhY2UgdGhlIGFkZHJlc3NlcyBvZiBwYWNrZXRzIG9uIGVpdGhlciBzaWRlIGFuZCB0aGVyZWZvcmUgY2F1c2UgdGhlIGNsaWVudCBvciBzZXJ2ZXIgdG8gaGF2ZSBhbiBpbmNvcnJlY3QgdmlldyBvZiB0aGUgcmVtb3RlIGFkZHJlc3Nlcy4gU3VjaCBhbiBhdHRhY2sgaXMgaW5kaXN0aW5ndWlzaGFibGUgZnJvbSB0aGUgZnVuY3Rpb25zIHBlcmZvcm1lZCBieSBhIE5BVC4gMjEuMS4xLjQuIFBhcmFtZXRlciBOZWdvdGlhdGlvbiBUaGUgZW50aXJlIGhhbmRzaGFrZSBpcyBjcnlwdG9ncmFwaGljYWxseSBwcm90ZWN0ZWQsIHdpdGggdGhlIEluaXRpYWwgcGFja2V0cyBiZWluZyBlbmNyeXB0ZWQgd2l0aCBwZXItdmVyc2lvbiBrZXlzIGFuZCB0aGUgSGFuZHNoYWtlIGFuZCBsYXRlciBwYWNrZXRzIGJlaW5nIGVuY3J5cHRlZCB3aXRoIGtleXMgZGVyaXZlZCBmcm9tIHRoZSBUTFMga2V5IGV4Y2hhbmdlLiBGdXJ0aGVyLCBwYXJhbWV0ZXIgbmVnb3RpYXRpb24gaXMgZm9sZGVkIGludG8gdGhlIFRMUyB0cmFuc2NyaXB0IGFuZCB0aHVzIHByb3ZpZGVzIHRoZSBzYW1lIGludGVncml0eSBndWFyYW50ZWVzIGFzIG9yZGluYXJ5IFRMUyBuZWdvdGlhdGlvbi4gQW4gYXR0YWNrZXIgY2FuIG9ic2VydmUgdGhlIGNsaWVudCdzIHRyYW5zcG9ydCBwYXJhbWV0ZXJzIChhcyBsb25nIGFzIGl0IGtub3dzIHRoZSB2ZXJzaW9uLXNwZWNpZmljIHNhbHQpIGJ1dCBjYW5ub3Qgb2JzZXJ2ZSB0aGUgc2VydmVyJ3MgdHJhbnNwb3J0IHBhcmFtZXRlcnMgYW5kIGNhbm5vdCBpbmZsdWVuY2UgcGFyYW1ldGVyIG5lZ290aWF0aW9uLiBDb25uZWN0aW9uIElEcyBhcmUgdW5lbmNyeXB0ZWQgYnV0IGludGVncml0eSBwcm90ZWN0ZWQgaW4gYWxsIHBhY2tldHMuIFRoaXMgdmVyc2lvbiBvZiBRVUlDIGRvZXMgbm90IGluY29ycG9yYXRlIGEgdmVyc2lvbiBuZWdvdGlhdGlvbiBtZWNoYW5pc207IGltcGxlbWVudGF0aW9ucyBvZiBpbmNvbXBhdGlibGUgdmVyc2lvbnMgd2lsbCBzaW1wbHkgZmFpbCB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uLiAyMS4xLjIuIFByb3RlY3RlZCBQYWNrZXRzIFBhY2tldCBwcm90ZWN0aW9uIChTZWN0aW9uIDEyLjEpIGFwcGxpZXMgYXV0aGVudGljYXRlZCBlbmNyeXB0aW9uIHRvIGFsbCBwYWNrZXRzIGV4Y2VwdCBWZXJzaW9uIE5lZ290aWF0aW9uIHBhY2tldHMsIHRob3VnaCBJbml0aWFsIGFuZCBSZXRyeSBwYWNrZXRzIGhhdmUgbGltaXRlZCBwcm90ZWN0aW9uIGR1ZSB0byB0aGUgdXNlIG9mIHZlcnNpb24tIHNwZWNpZmljIGtleWluZyBtYXRlcmlhbDsgc2VlIFtRVUlDLVRMU10gZm9yIG1vcmUgZGV0YWlscy4gVGhpcyBzZWN0aW9uIGNvbnNpZGVycyBwYXNzaXZlIGFuZCBhY3RpdmUgYXR0YWNrcyBhZ2FpbnN0IHByb3RlY3RlZCBwYWNrZXRzLiBCb3RoIG9uLXBhdGggYW5kIG9mZi1wYXRoIGF0dGFja2VycyBjYW4gbW91bnQgYSBwYXNzaXZlIGF0dGFjayBpbiB3aGljaCB0aGV5IHNhdmUgb2JzZXJ2ZWQgcGFja2V0cyBmb3IgYW4gb2ZmbGluZSBhdHRhY2sgYWdhaW5zdCBwYWNrZXQgcHJvdGVjdGlvbiBhdCBhIGZ1dHVyZSB0aW1lOyB0aGlzIGlzIHRydWUgZm9yIGFueSBvYnNlcnZlciBvZiBhbnkgcGFja2V0IG9uIGFueSBuZXR3b3JrLiBBbiBhdHRhY2tlciB0aGF0IGluamVjdHMgcGFja2V0cyB3aXRob3V0IGJlaW5nIGFibGUgdG8gb2JzZXJ2ZSB2YWxpZCBwYWNrZXRzIGZvciBhIGNvbm5lY3Rpb24gaXMgdW5saWtlbHkgdG8gYmUgc3VjY2Vzc2Z1bCwgc2luY2UgcGFja2V0IHByb3RlY3Rpb24gZW5zdXJlcyB0aGF0IHZhbGlkIHBhY2tldHMgYXJlIG9ubHkgZ2VuZXJhdGVkIGJ5IGVuZHBvaW50cyB0aGF0IHBvc3Nlc3MgdGhlIGtleSBtYXRlcmlhbCBlc3RhYmxpc2hlZCBkdXJpbmcgdGhlIGhhbmRzaGFrZTsgc2VlIFNlY3Rpb25zIDcgYW5kIDIxLjEuMS4gU2ltaWxhcmx5LCBhbnkgYWN0aXZlIGF0dGFja2VyIHRoYXQgb2JzZXJ2ZXMgcGFja2V0cyBhbmQgYXR0ZW1wdHMgdG8gaW5zZXJ0IG5ldyBkYXRhIG9yIG1vZGlmeSBleGlzdGluZyBkYXRhIGluIHRob3NlIHBhY2tldHMgc2hvdWxkIG5vdCBiZSBhYmxlIHRvIGdlbmVyYXRlIHBhY2tldHMgZGVlbWVkIHZhbGlkIGJ5IHRoZSByZWNlaXZpbmcgZW5kcG9pbnQsIG90aGVyIHRoYW4gSW5pdGlhbCBwYWNrZXRzLiBBIHNwb29maW5nIGF0dGFjaywgaW4gd2hpY2ggYW4gYWN0aXZlIGF0dGFja2VyIHJld3JpdGVzIHVucHJvdGVjdGVkIHBhcnRzIG9mIGEgcGFja2V0IHRoYXQgaXQgZm9yd2FyZHMgb3IgaW5qZWN0cywgc3VjaCBhcyB0aGUgc291cmNlIG9yIGRlc3RpbmF0aW9uIGFkZHJlc3MsIGlzIG9ubHkgZWZmZWN0aXZlIGlmIHRoZSBhdHRhY2tlciBjYW4gZm9yd2FyZCBwYWNrZXRzIHRvIHRoZSBvcmlnaW5hbCBlbmRwb2ludC4gUGFja2V0IHByb3RlY3Rpb24gZW5zdXJlcyB0aGF0IHRoZSBwYWNrZXQgcGF5bG9hZHMgY2FuIG9ubHkgYmUgcHJvY2Vzc2VkIGJ5IHRoZSBlbmRwb2ludHMgdGhhdCBjb21wbGV0ZWQgdGhlIGhhbmRzaGFrZSwgYW5kIGludmFsaWQgcGFja2V0cyBhcmUgaWdub3JlZCBieSB0aG9zZSBlbmRwb2ludHMuIEFuIGF0dGFja2VyIGNhbiBhbHNvIG1vZGlmeSB0aGUgYm91bmRhcmllcyBiZXR3ZWVuIHBhY2tldHMgYW5kIFVEUCBkYXRhZ3JhbXMsIGNhdXNpbmcgbXVsdGlwbGUgcGFja2V0cyB0byBiZSBjb2FsZXNjZWQgaW50byBhIHNpbmdsZSBkYXRhZ3JhbSBvciBzcGxpdHRpbmcgY29hbGVzY2VkIHBhY2tldHMgaW50byBtdWx0aXBsZSBkYXRhZ3JhbXMuIEFzaWRlIGZyb20gZGF0YWdyYW1zIGNvbnRhaW5pbmcgSW5pdGlhbCBwYWNrZXRzLCB3aGljaCByZXF1aXJlIHBhZGRpbmcsIG1vZGlmaWNhdGlvbiBvZiBob3cgcGFja2V0cyBhcmUgYXJyYW5nZWQgaW4gZGF0YWdyYW1zIGhhcyBubyBmdW5jdGlvbmFsIGVmZmVjdCBvbiBhIGNvbm5lY3Rpb24sIGFsdGhvdWdoIGl0IG1pZ2h0IGNoYW5nZSBzb21lIHBlcmZvcm1hbmNlIGNoYXJhY3RlcmlzdGljcy4gMjEuMS4zLiBDb25uZWN0aW9uIE1pZ3JhdGlvbiBDb25uZWN0aW9uIG1pZ3JhdGlvbiAoU2VjdGlvbiA5KSBwcm92aWRlcyBlbmRwb2ludHMgd2l0aCB0aGUgYWJpbGl0eSB0byB0cmFuc2l0aW9uIGJldHdlZW4gSVAgYWRkcmVzc2VzIGFuZCBwb3J0cyBvbiBtdWx0aXBsZSBwYXRocywgdXNpbmcgb25lIHBhdGggYXQgYSB0aW1lIGZvciB0cmFuc21pc3Npb24gYW5kIHJlY2VpcHQgb2Ygbm9uLXByb2JpbmcgZnJhbWVzLiBQYXRoIHZhbGlkYXRpb24gKFNlY3Rpb24gOC4yKSBlc3RhYmxpc2hlcyB0aGF0IGEgcGVlciBpcyBib3RoIHdpbGxpbmcgYW5kIGFibGUgdG8gcmVjZWl2ZSBwYWNrZXRzIHNlbnQgb24gYSBwYXJ0aWN1bGFyIHBhdGguIFRoaXMgaGVscHMgcmVkdWNlIHRoZSBlZmZlY3RzIG9mIGFkZHJlc3Mgc3Bvb2ZpbmcgYnkgbGltaXRpbmcgdGhlIG51bWJlciBvZiBwYWNrZXRzIHNlbnQgdG8gYSBzcG9vZmVkIGFkZHJlc3MuIFRoaXMgc2VjdGlvbiBkZXNjcmliZXMgdGhlIGludGVuZGVkIHNlY3VyaXR5IHByb3BlcnRpZXMgb2YgY29ubmVjdGlvbiBtaWdyYXRpb24gdW5kZXIgdmFyaW91cyB0eXBlcyBvZiBEb1MgYXR0YWNrcy4gMjEuMS4zLjEuIE9uLVBhdGggQWN0aXZlIEF0dGFja3MgQW4gYXR0YWNrZXIgdGhhdCBjYW4gY2F1c2UgYSBwYWNrZXQgaXQgb2JzZXJ2ZXMgdG8gbm8gbG9uZ2VyIHJlYWNoIGl0cyBpbnRlbmRlZCBkZXN0aW5hdGlvbiBpcyBjb25zaWRlcmVkIGFuIG9uLXBhdGggYXR0YWNrZXIuIFdoZW4gYW4gYXR0YWNrZXIgaXMgcHJlc2VudCBiZXR3ZWVuIGEgY2xpZW50IGFuZCBzZXJ2ZXIsIGVuZHBvaW50cyBhcmUgcmVxdWlyZWQgdG8gc2VuZCBwYWNrZXRzIHRocm91Z2ggdGhlIGF0dGFja2VyIHRvIGVzdGFibGlzaCBjb25uZWN0aXZpdHkgb24gYSBnaXZlbiBwYXRoLiBBbiBvbi1wYXRoIGF0dGFja2VyIGNhbjogKiBJbnNwZWN0IHBhY2tldHMgKiBNb2RpZnkgSVAgYW5kIFVEUCBwYWNrZXQgaGVhZGVycyAqIEluamVjdCBuZXcgcGFja2V0cyAqIERlbGF5IHBhY2tldHMgKiBSZW9yZGVyIHBhY2tldHMgKiBEcm9wIHBhY2tldHMgKiBTcGxpdCBhbmQgbWVyZ2UgZGF0YWdyYW1zIGFsb25nIHBhY2tldCBib3VuZGFyaWVzIEFuIG9uLXBhdGggYXR0YWNrZXIgY2Fubm90OiAqIE1vZGlmeSBhbiBhdXRoZW50aWNhdGVkIHBvcnRpb24gb2YgYSBwYWNrZXQgYW5kIGNhdXNlIHRoZSByZWNpcGllbnQgdG8gYWNjZXB0IHRoYXQgcGFja2V0IEFuIG9uLXBhdGggYXR0YWNrZXIgaGFzIHRoZSBvcHBvcnR1bml0eSB0byBtb2RpZnkgdGhlIHBhY2tldHMgdGhhdCBpdCBvYnNlcnZlczsgaG93ZXZlciwgYW55IG1vZGlmaWNhdGlvbnMgdG8gYW4gYXV0aGVudGljYXRlZCBwb3J0aW9uIG9mIGEgcGFja2V0IHdpbGwgY2F1c2UgaXQgdG8gYmUgZHJvcHBlZCBieSB0aGUgcmVjZWl2aW5nIGVuZHBvaW50IGFzIGludmFsaWQsIGFzIHBhY2tldCBwYXlsb2FkcyBhcmUgYm90aCBhdXRoZW50aWNhdGVkIGFuZCBlbmNyeXB0ZWQuIFFVSUMgYWltcyB0byBjb25zdHJhaW4gdGhlIGNhcGFiaWxpdGllcyBvZiBhbiBvbi1wYXRoIGF0dGFja2VyIGFzIGZvbGxvd3M6IDEuIEFuIG9uLXBhdGggYXR0YWNrZXIgY2FuIHByZXZlbnQgdGhlIHVzZSBvZiBhIHBhdGggZm9yIGEgY29ubmVjdGlvbiwgY2F1c2luZyB0aGUgY29ubmVjdGlvbiB0byBmYWlsIGlmIGl0IGNhbm5vdCB1c2UgYSBkaWZmZXJlbnQgcGF0aCB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIGF0dGFja2VyLiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSBkcm9wcGluZyBhbGwgcGFja2V0cywgbW9kaWZ5aW5nIHRoZW0gc28gdGhhdCB0aGV5IGZhaWwgdG8gZGVjcnlwdCwgb3Igb3RoZXIgbWV0aG9kcy4gMi4gQW4gb24tcGF0aCBhdHRhY2tlciBjYW4gcHJldmVudCBtaWdyYXRpb24gdG8gYSBuZXcgcGF0aCBmb3Igd2hpY2ggdGhlIGF0dGFja2VyIGlzIGFsc28gb24tcGF0aCBieSBjYXVzaW5nIHBhdGggdmFsaWRhdGlvbiB0byBmYWlsIG9uIHRoZSBuZXcgcGF0aC4gMy4gQW4gb24tcGF0aCBhdHRhY2tlciBjYW5ub3QgcHJldmVudCBhIGNsaWVudCBmcm9tIG1pZ3JhdGluZyB0byBhIHBhdGggZm9yIHdoaWNoIHRoZSBhdHRhY2tlciBpcyBub3Qgb24tcGF0aC4gNC4gQW4gb24tcGF0aCBhdHRhY2tlciBjYW4gcmVkdWNlIHRoZSB0aHJvdWdocHV0IG9mIGEgY29ubmVjdGlvbiBieSBkZWxheWluZyBwYWNrZXRzIG9yIGRyb3BwaW5nIHRoZW0uIDUuIEFuIG9uLXBhdGggYXR0YWNrZXIgY2Fubm90IGNhdXNlIGFuIGVuZHBvaW50IHRvIGFjY2VwdCBhIHBhY2tldCBmb3Igd2hpY2ggaXQgaGFzIG1vZGlmaWVkIGFuIGF1dGhlbnRpY2F0ZWQgcG9ydGlvbiBvZiB0aGF0IHBhY2tldC4gMjEuMS4zLjIuIE9mZi1QYXRoIEFjdGl2ZSBBdHRhY2tzIEFuIG9mZi1wYXRoIGF0dGFja2VyIGlzIG5vdCBkaXJlY3RseSBvbiB0aGUgcGF0aCBiZXR3ZWVuIGEgY2xpZW50IGFuZCBzZXJ2ZXIgYnV0IGNvdWxkIGJlIGFibGUgdG8gb2J0YWluIGNvcGllcyBvZiBzb21lIG9yIGFsbCBwYWNrZXRzIHNlbnQgYmV0d2VlbiB0aGUgY2xpZW50IGFuZCB0aGUgc2VydmVyLiBJdCBpcyBhbHNvIGFibGUgdG8gc2VuZCBjb3BpZXMgb2YgdGhvc2UgcGFja2V0cyB0byBlaXRoZXIgZW5kcG9pbnQuIEFuIG9mZi1wYXRoIGF0dGFja2VyIGNhbjogKiBJbnNwZWN0IHBhY2tldHMgKiBJbmplY3QgbmV3IHBhY2tldHMgKiBSZW9yZGVyIGluamVjdGVkIHBhY2tldHMgQW4gb2ZmLXBhdGggYXR0YWNrZXIgY2Fubm90OiAqIE1vZGlmeSBwYWNrZXRzIHNlbnQgYnkgZW5kcG9pbnRzICogRGVsYXkgcGFja2V0cyAqIERyb3AgcGFja2V0cyAqIFJlb3JkZXIgb3JpZ2luYWwgcGFja2V0cyBBbiBvZmYtcGF0aCBhdHRhY2tlciBjYW4gY3JlYXRlIG1vZGlmaWVkIGNvcGllcyBvZiBwYWNrZXRzIHRoYXQgaXQgaGFzIG9ic2VydmVkIGFuZCBpbmplY3QgdGhvc2UgY29waWVzIGludG8gdGhlIG5ldHdvcmssIHBvdGVudGlhbGx5IHdpdGggc3Bvb2ZlZCBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGFkZHJlc3Nlcy4gRm9yIHRoZSBwdXJwb3NlcyBvZiB0aGlzIGRpc2N1c3Npb24sIGl0IGlzIGFzc3VtZWQgdGhhdCBhbiBvZmYtcGF0aCBhdHRhY2tlciBoYXMgdGhlIGFiaWxpdHkgdG8gaW5qZWN0IGEgbW9kaWZpZWQgY29weSBvZiBhIHBhY2tldCBpbnRvIHRoZSBuZXR3b3JrIHRoYXQgd2lsbCByZWFjaCB0aGUgZGVzdGluYXRpb24gZW5kcG9pbnQgcHJpb3IgdG8gdGhlIGFycml2YWwgb2YgdGhlIG9yaWdpbmFsIHBhY2tldCBvYnNlcnZlZCBieSB0aGUgYXR0YWNrZXIuIEluIG90aGVyIHdvcmRzLCBhbiBhdHRhY2tlciBoYXMgdGhlIGFiaWxpdHkgdG8gY29uc2lzdGVudGx5ICJ3aW4iIGEgcmFjZSB3aXRoIHRoZSBsZWdpdGltYXRlIHBhY2tldHMgYmV0d2VlbiB0aGUgZW5kcG9pbnRzLCBwb3RlbnRpYWxseSBjYXVzaW5nIHRoZSBvcmlnaW5hbCBwYWNrZXQgdG8gYmUgaWdub3JlZCBieSB0aGUgcmVjaXBpZW50LiBJdCBpcyBhbHNvIGFzc3VtZWQgdGhhdCBhbiBhdHRhY2tlciBoYXMgdGhlIHJlc291cmNlcyBuZWNlc3NhcnkgdG8gYWZmZWN0IE5BVCBzdGF0ZS4gSW4gcGFydGljdWxhciwgYW4gYXR0YWNrZXIgY2FuIGNhdXNlIGFuIGVuZHBvaW50IHRvIGxvc2UgaXRzIE5BVCBiaW5kaW5nIGFuZCB0aGVuIG9idGFpbiB0aGUgc2FtZSBwb3J0IGZvciB1c2Ugd2l0aCBpdHMgb3duIHRyYWZmaWMuIFFVSUMgYWltcyB0byBjb25zdHJhaW4gdGhlIGNhcGFiaWxpdGllcyBvZiBhbiBvZmYtcGF0aCBhdHRhY2tlciBhcyBmb2xsb3dzOiAxLiBBbiBvZmYtcGF0aCBhdHRhY2tlciBjYW4gcmFjZSBwYWNrZXRzIGFuZCBhdHRlbXB0IHRvIGJlY29tZSBhICJsaW1pdGVkIiBvbi1wYXRoIGF0dGFja2VyLiAyLiBBbiBvZmYtcGF0aCBhdHRhY2tlciBjYW4gY2F1c2UgcGF0aCB2YWxpZGF0aW9uIHRvIHN1Y2NlZWQgZm9yIGZvcndhcmRlZCBwYWNrZXRzIHdpdGggdGhlIHNvdXJjZSBhZGRyZXNzIGxpc3RlZCBhcyB0aGUgb2ZmLXBhdGggYXR0YWNrZXIgYXMgbG9uZyBhcyBpdCBjYW4gcHJvdmlkZSBpbXByb3ZlZCBjb25uZWN0aXZpdHkgYmV0d2VlbiB0aGUgY2xpZW50IGFuZCB0aGUgc2VydmVyLiAzLiBBbiBvZmYtcGF0aCBhdHRhY2tlciBjYW5ub3QgY2F1c2UgYSBjb25uZWN0aW9uIHRvIGNsb3NlIG9uY2UgdGhlIGhhbmRzaGFrZSBoYXMgY29tcGxldGVkLiA0LiBBbiBvZmYtcGF0aCBhdHRhY2tlciBjYW5ub3QgY2F1c2UgbWlncmF0aW9uIHRvIGEgbmV3IHBhdGggdG8gZmFpbCBpZiBpdCBjYW5ub3Qgb2JzZXJ2ZSB0aGUgbmV3IHBhdGguIDUuIEFuIG9mZi1wYXRoIGF0dGFja2VyIGNhbiBiZWNvbWUgYSBsaW1pdGVkIG9uLXBhdGggYXR0YWNrZXIgZHVyaW5nIG1pZ3JhdGlvbiB0byBhIG5ldyBwYXRoIGZvciB3aGljaCBpdCBpcyBhbHNvIGFuIG9mZi1wYXRoIGF0dGFja2VyLiA2LiBBbiBvZmYtcGF0aCBhdHRhY2tlciBjYW4gYmVjb21lIGEgbGltaXRlZCBvbi1wYXRoIGF0dGFja2VyIGJ5IGFmZmVjdGluZyBzaGFyZWQgTkFUIHN0YXRlIHN1Y2ggdGhhdCBpdCBzZW5kcyBwYWNrZXRzIHRvIHRoZSBzZXJ2ZXIgZnJvbSB0aGUgc2FtZSBJUCBhZGRyZXNzIGFuZCBwb3J0IHRoYXQgdGhlIGNsaWVudCBvcmlnaW5hbGx5IHVzZWQuIDIxLjEuMy4zLiBMaW1pdGVkIE9uLVBhdGggQWN0aXZlIEF0dGFja3MgQSBsaW1pdGVkIG9uLXBhdGggYXR0YWNrZXIgaXMgYW4gb2ZmLXBhdGggYXR0YWNrZXIgdGhhdCBoYXMgb2ZmZXJlZCBpbXByb3ZlZCByb3V0aW5nIG9mIHBhY2tldHMgYnkgZHVwbGljYXRpbmcgYW5kIGZvcndhcmRpbmcgb3JpZ2luYWwgcGFja2V0cyBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIHRoZSBjbGllbnQsIGNhdXNpbmcgdGhvc2UgcGFja2V0cyB0byBhcnJpdmUgYmVmb3JlIHRoZSBvcmlnaW5hbCBjb3BpZXMgc3VjaCB0aGF0IHRoZSBvcmlnaW5hbCBwYWNrZXRzIGFyZSBkcm9wcGVkIGJ5IHRoZSBkZXN0aW5hdGlvbiBlbmRwb2ludC4gQSBsaW1pdGVkIG9uLXBhdGggYXR0YWNrZXIgZGlmZmVycyBmcm9tIGFuIG9uLXBhdGggYXR0YWNrZXIgaW4gdGhhdCBpdCBpcyBub3Qgb24gdGhlIG9yaWdpbmFsIHBhdGggYmV0d2VlbiBlbmRwb2ludHMsIGFuZCB0aGVyZWZvcmUgdGhlIG9yaWdpbmFsIHBhY2tldHMgc2VudCBieSBhbiBlbmRwb2ludCBhcmUgc3RpbGwgcmVhY2hpbmcgdGhlaXIgZGVzdGluYXRpb24uIFRoaXMgbWVhbnMgdGhhdCBhIGZ1dHVyZSBmYWlsdXJlIHRvIHJvdXRlIGNvcGllZCBwYWNrZXRzIHRvIHRoZSBkZXN0aW5hdGlvbiBmYXN0ZXIgdGhhbiB0aGVpciBvcmlnaW5hbCBwYXRoIHdpbGwgbm90IHByZXZlbnQgdGhlIG9yaWdpbmFsIHBhY2tldHMgZnJvbSByZWFjaGluZyB0aGUgZGVzdGluYXRpb24uIEEgbGltaXRlZCBvbi1wYXRoIGF0dGFja2VyIGNhbjogKiBJbnNwZWN0IHBhY2tldHMgKiBJbmplY3QgbmV3IHBhY2tldHMgKiBNb2RpZnkgdW5lbmNyeXB0ZWQgcGFja2V0IGhlYWRlcnMgKiBSZW9yZGVyIHBhY2tldHMgQSBsaW1pdGVkIG9uLXBhdGggYXR0YWNrZXIgY2Fubm90OiAqIERlbGF5IHBhY2tldHMgc28gdGhhdCB0aGV5IGFycml2ZSBsYXRlciB0aGFuIHBhY2tldHMgc2VudCBvbiB0aGUgb3JpZ2luYWwgcGF0aCAqIERyb3AgcGFja2V0cyAqIE1vZGlmeSB0aGUgYXV0aGVudGljYXRlZCBhbmQgZW5jcnlwdGVkIHBvcnRpb24gb2YgYSBwYWNrZXQgYW5kIGNhdXNlIHRoZSByZWNpcGllbnQgdG8gYWNjZXB0IHRoYXQgcGFja2V0IEEgbGltaXRlZCBvbi1wYXRoIGF0dGFja2VyIGNhbiBvbmx5IGRlbGF5IHBhY2tldHMgdXAgdG8gdGhlIHBvaW50IHRoYXQgdGhlIG9yaWdpbmFsIHBhY2tldHMgYXJyaXZlIGJlZm9yZSB0aGUgZHVwbGljYXRlIHBhY2tldHMsIG1lYW5pbmcgdGhhdCBpdCBjYW5ub3Qgb2ZmZXIgcm91dGluZyB3aXRoIHdvcnNlIGxhdGVuY3kgdGhhbiB0aGUgb3JpZ2luYWwgcGF0aC4gSWYgYSBsaW1pdGVkIG9uLXBhdGggYXR0YWNrZXIgZHJvcHMgcGFja2V0cywgdGhlIG9yaWdpbmFsIGNvcHkgd2lsbCBzdGlsbCBhcnJpdmUgYXQgdGhlIGRlc3RpbmF0aW9uIGVuZHBvaW50LiBRVUlDIGFpbXMgdG8gY29uc3RyYWluIHRoZSBjYXBhYmlsaXRpZXMgb2YgYSBsaW1pdGVkIG9mZi1wYXRoIGF0dGFja2VyIGFzIGZvbGxvd3M6IDEuIEEgbGltaXRlZCBvbi1wYXRoIGF0dGFja2VyIGNhbm5vdCBjYXVzZSBhIGNvbm5lY3Rpb24gdG8gY2xvc2Ugb25jZSB0aGUgaGFuZHNoYWtlIGhhcyBjb21wbGV0ZWQuIDIuIEEgbGltaXRlZCBvbi1wYXRoIGF0dGFja2VyIGNhbm5vdCBjYXVzZSBhbiBpZGxlIGNvbm5lY3Rpb24gdG8gY2xvc2UgaWYgdGhlIGNsaWVudCBpcyBmaXJzdCB0byByZXN1bWUgYWN0aXZpdHkuIDMuIEEgbGltaXRlZCBvbi1wYXRoIGF0dGFja2VyIGNhbiBjYXVzZSBhbiBpZGxlIGNvbm5lY3Rpb24gdG8gYmUgZGVlbWVkIGxvc3QgaWYgdGhlIHNlcnZlciBpcyB0aGUgZmlyc3QgdG8gcmVzdW1lIGFjdGl2aXR5LiBOb3RlIHRoYXQgdGhlc2UgZ3VhcmFudGVlcyBhcmUgdGhlIHNhbWUgZ3VhcmFudGVlcyBwcm92aWRlZCBmb3IgYW55IE5BVCwgZm9yIHRoZSBzYW1lIHJlYXNvbnMuIDIxLjIuIEhhbmRzaGFrZSBEZW5pYWwgb2YgU2VydmljZSBBcyBhbiBlbmNyeXB0ZWQgYW5kIGF1dGhlbnRpY2F0ZWQgdHJhbnNwb3J0LCBRVUlDIHByb3ZpZGVzIGEgcmFuZ2Ugb2YgcHJvdGVjdGlvbnMgYWdhaW5zdCBkZW5pYWwgb2Ygc2VydmljZS4gT25jZSB0aGUgY3J5cHRvZ3JhcGhpYyBoYW5kc2hha2UgaXMgY29tcGxldGUsIFFVSUMgZW5kcG9pbnRzIGRpc2NhcmQgbW9zdCBwYWNrZXRzIHRoYXQgYXJlIG5vdCBhdXRoZW50aWNhdGVkLCBncmVhdGx5IGxpbWl0aW5nIHRoZSBhYmlsaXR5IG9mIGFuIGF0dGFja2VyIHRvIGludGVyZmVyZSB3aXRoIGV4aXN0aW5nIGNvbm5lY3Rpb25zLiBPbmNlIGEgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCwgUVVJQyBlbmRwb2ludHMgbWlnaHQgYWNjZXB0IHNvbWUgdW5hdXRoZW50aWNhdGVkIElDTVAgcGFja2V0cyAoc2VlIFNlY3Rpb24gMTQuMi4xKSwgYnV0IHRoZSB1c2Ugb2YgdGhlc2UgcGFja2V0cyBpcyBleHRyZW1lbHkgbGltaXRlZC4gVGhlIG9ubHkgb3RoZXIgdHlwZSBvZiBwYWNrZXQgdGhhdCBhbiBlbmRwb2ludCBtaWdodCBhY2NlcHQgaXMgYSBzdGF0ZWxlc3MgcmVzZXQgKFNlY3Rpb24gMTAuMyksIHdoaWNoIHJlbGllcyBvbiB0aGUgdG9rZW4gYmVpbmcga2VwdCBzZWNyZXQgdW50aWwgaXQgaXMgdXNlZC4gRHVyaW5nIHRoZSBjcmVhdGlvbiBvZiBhIGNvbm5lY3Rpb24sIFFVSUMgb25seSBwcm92aWRlcyBwcm90ZWN0aW9uIGFnYWluc3QgYXR0YWNrcyBmcm9tIG9mZiB0aGUgbmV0d29yayBwYXRoLiBBbGwgUVVJQyBwYWNrZXRzIGNvbnRhaW4gcHJvb2YgdGhhdCB0aGUgcmVjaXBpZW50IHNhdyBhIHByZWNlZGluZyBwYWNrZXQgZnJvbSBpdHMgcGVlci4gQWRkcmVzc2VzIGNhbm5vdCBjaGFuZ2UgZHVyaW5nIHRoZSBoYW5kc2hha2UsIHNvIGVuZHBvaW50cyBjYW4gZGlzY2FyZCBwYWNrZXRzIHRoYXQgYXJlIHJlY2VpdmVkIG9uIGEgZGlmZmVyZW50IG5ldHdvcmsgcGF0aC4gVGhlIFNvdXJjZSBhbmQgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBmaWVsZHMgYXJlIHRoZSBwcmltYXJ5IG1lYW5zIG9mIHByb3RlY3Rpb24gYWdhaW5zdCBhbiBvZmYtcGF0aCBhdHRhY2sgZHVyaW5nIHRoZSBoYW5kc2hha2U7IHNlZSBTZWN0aW9uIDguMS4gVGhlc2UgYXJlIHJlcXVpcmVkIHRvIG1hdGNoIHRob3NlIHNldCBieSBhIHBlZXIuIEV4Y2VwdCBmb3IgSW5pdGlhbCBhbmQgU3RhdGVsZXNzIFJlc2V0cywgYW4gZW5kcG9pbnQgb25seSBhY2NlcHRzIHBhY2tldHMgdGhhdCBpbmNsdWRlIGEgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBmaWVsZCB0aGF0IG1hdGNoZXMgYSB2YWx1ZSB0aGUgZW5kcG9pbnQgcHJldmlvdXNseSBjaG9zZS4gVGhpcyBpcyB0aGUgb25seSBwcm90ZWN0aW9uIG9mZmVyZWQgZm9yIFZlcnNpb24gTmVnb3RpYXRpb24gcGFja2V0cy4gVGhlIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgZmllbGQgaW4gYW4gSW5pdGlhbCBwYWNrZXQgaXMgc2VsZWN0ZWQgYnkgYSBjbGllbnQgdG8gYmUgdW5wcmVkaWN0YWJsZSwgd2hpY2ggc2VydmVzIGFuIGFkZGl0aW9uYWwgcHVycG9zZS4gVGhlIHBhY2tldHMgdGhhdCBjYXJyeSB0aGUgY3J5cHRvZ3JhcGhpYyBoYW5kc2hha2UgYXJlIHByb3RlY3RlZCB3aXRoIGEga2V5IHRoYXQgaXMgZGVyaXZlZCBmcm9tIHRoaXMgY29ubmVjdGlvbiBJRCBhbmQgYSBzYWx0IHNwZWNpZmljIHRvIHRoZSBRVUlDIHZlcnNpb24uIFRoaXMgYWxsb3dzIGVuZHBvaW50cyB0byB1c2UgdGhlIHNhbWUgcHJvY2VzcyBmb3IgYXV0aGVudGljYXRpbmcgcGFja2V0cyB0aGF0IHRoZXkgcmVjZWl2ZSBhcyB0aGV5IHVzZSBhZnRlciB0aGUgY3J5cHRvZ3JhcGhpYyBoYW5kc2hha2UgY29tcGxldGVzLiBQYWNrZXRzIHRoYXQgY2Fubm90IGJlIGF1dGhlbnRpY2F0ZWQgYXJlIGRpc2NhcmRlZC4gUHJvdGVjdGluZyBwYWNrZXRzIGluIHRoaXMgZmFzaGlvbiBwcm92aWRlcyBhIHN0cm9uZyBhc3N1cmFuY2UgdGhhdCB0aGUgc2VuZGVyIG9mIHRoZSBwYWNrZXQgc2F3IHRoZSBJbml0aWFsIHBhY2tldCBhbmQgdW5kZXJzdG9vZCBpdC4gVGhlc2UgcHJvdGVjdGlvbnMgYXJlIG5vdCBpbnRlbmRlZCB0byBiZSBlZmZlY3RpdmUgYWdhaW5zdCBhbiBhdHRhY2tlciB0aGF0IGlzIGFibGUgdG8gcmVjZWl2ZSBRVUlDIHBhY2tldHMgcHJpb3IgdG8gdGhlIGNvbm5lY3Rpb24gYmVpbmcgZXN0YWJsaXNoZWQuIFN1Y2ggYW4gYXR0YWNrZXIgY2FuIHBvdGVudGlhbGx5IHNlbmQgcGFja2V0cyB0aGF0IHdpbGwgYmUgYWNjZXB0ZWQgYnkgUVVJQyBlbmRwb2ludHMuIFRoaXMgdmVyc2lvbiBvZiBRVUlDIGF0dGVtcHRzIHRvIGRldGVjdCB0aGlzIHNvcnQgb2YgYXR0YWNrLCBidXQgaXQgZXhwZWN0cyB0aGF0IGVuZHBvaW50cyB3aWxsIGZhaWwgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiByYXRoZXIgdGhhbiByZWNvdmVyaW5nLiBGb3IgdGhlIG1vc3QgcGFydCwgdGhlIGNyeXB0b2dyYXBoaWMgaGFuZHNoYWtlIHByb3RvY29sIFtRVUlDLVRMU10gaXMgcmVzcG9uc2libGUgZm9yIGRldGVjdGluZyB0YW1wZXJpbmcgZHVyaW5nIHRoZSBoYW5kc2hha2UuIEVuZHBvaW50cyBhcmUgcGVybWl0dGVkIHRvIHVzZSBvdGhlciBtZXRob2RzIHRvIGRldGVjdCBhbmQgYXR0ZW1wdCB0byByZWNvdmVyIGZyb20gaW50ZXJmZXJlbmNlIHdpdGggdGhlIGhhbmRzaGFrZS4gSW52YWxpZCBwYWNrZXRzIGNhbiBiZSBpZGVudGlmaWVkIGFuZCBkaXNjYXJkZWQgdXNpbmcgb3RoZXIgbWV0aG9kcywgYnV0IG5vIHNwZWNpZmljIG1ldGhvZCBpcyBtYW5kYXRlZCBpbiB0aGlzIGRvY3VtZW50LiAyMS4zLiBBbXBsaWZpY2F0aW9uIEF0dGFjayBBbiBhdHRhY2tlciBtaWdodCBiZSBhYmxlIHRvIHJlY2VpdmUgYW4gYWRkcmVzcyB2YWxpZGF0aW9uIHRva2VuIChTZWN0aW9uIDgpIGZyb20gYSBzZXJ2ZXIgYW5kIHRoZW4gcmVsZWFzZSB0aGUgSVAgYWRkcmVzcyBpdCB1c2VkIHRvIGFjcXVpcmUgdGhhdCB0b2tlbi4gQXQgYSBsYXRlciB0aW1lLCB0aGUgYXR0YWNrZXIgY2FuIGluaXRpYXRlIGEgMC1SVFQgY29ubmVjdGlvbiB3aXRoIGEgc2VydmVyIGJ5IHNwb29maW5nIHRoaXMgc2FtZSBhZGRyZXNzLCB3aGljaCBtaWdodCBub3cgYWRkcmVzcyBhIGRpZmZlcmVudCAodmljdGltKSBlbmRwb2ludC4gVGhlIGF0dGFja2VyIGNhbiB0aHVzIHBvdGVudGlhbGx5IGNhdXNlIHRoZSBzZXJ2ZXIgdG8gc2VuZCBhbiBpbml0aWFsIGNvbmdlc3Rpb24gd2luZG93J3Mgd29ydGggb2YgZGF0YSB0b3dhcmRzIHRoZSB2aWN0aW0uIFNlcnZlcnMgU0hPVUxEIHByb3ZpZGUgbWl0aWdhdGlvbnMgZm9yIHRoaXMgYXR0YWNrIGJ5IGxpbWl0aW5nIHRoZSB1c2FnZSBhbmQgbGlmZXRpbWUgb2YgYWRkcmVzcyB2YWxpZGF0aW9uIHRva2Vuczsgc2VlIFNlY3Rpb24gOC4xLjMuIDIxLjQuIE9wdGltaXN0aWMgQUNLIEF0dGFjayBBbiBlbmRwb2ludCB0aGF0IGFja25vd2xlZGdlcyBwYWNrZXRzIGl0IGhhcyBub3QgcmVjZWl2ZWQgbWlnaHQgY2F1c2UgYSBjb25nZXN0aW9uIGNvbnRyb2xsZXIgdG8gcGVybWl0IHNlbmRpbmcgYXQgcmF0ZXMgYmV5b25kIHdoYXQgdGhlIG5ldHdvcmsgc3VwcG9ydHMuIEFuIGVuZHBvaW50IE1BWSBza2lwIHBhY2tldCBudW1iZXJzIHdoZW4gc2VuZGluZyBwYWNrZXRzIHRvIGRldGVjdCB0aGlzIGJlaGF2aW9yLiBBbiBlbmRwb2ludCBjYW4gdGhlbiBpbW1lZGlhdGVseSBjbG9zZSB0aGUgY29ubmVjdGlvbiB3aXRoIGEgY29ubmVjdGlvbiBlcnJvciBvZiB0eXBlIFBST1RPQ09MX1ZJT0xBVElPTjsgc2VlIFNlY3Rpb24gMTAuMi4gMjEuNS4gUmVxdWVzdCBGb3JnZXJ5IEF0dGFja3MgQSByZXF1ZXN0IGZvcmdlcnkgYXR0YWNrIG9jY3VycyB3aGVyZSBhbiBlbmRwb2ludCBjYXVzZXMgaXRzIHBlZXIgdG8gaXNzdWUgYSByZXF1ZXN0IHRvd2FyZHMgYSB2aWN0aW0sIHdpdGggdGhlIHJlcXVlc3QgY29udHJvbGxlZCBieSB0aGUgZW5kcG9pbnQuIFJlcXVlc3QgZm9yZ2VyeSBhdHRhY2tzIGFpbSB0byBwcm92aWRlIGFuIGF0dGFja2VyIHdpdGggYWNjZXNzIHRvIGNhcGFiaWxpdGllcyBvZiBpdHMgcGVlciB0aGF0IG1pZ2h0IG90aGVyd2lzZSBiZSB1bmF2YWlsYWJsZSB0byB0aGUgYXR0YWNrZXIuIEZvciBhIG5ldHdvcmtpbmcgcHJvdG9jb2wsIGEgcmVxdWVzdCBmb3JnZXJ5IGF0dGFjayBpcyBvZnRlbiB1c2VkIHRvIGV4cGxvaXQgYW55IGltcGxpY2l0IGF1dGhvcml6YXRpb24gY29uZmVycmVkIG9uIHRoZSBwZWVyIGJ5IHRoZSB2aWN0aW0gZHVlIHRvIHRoZSBwZWVyJ3MgbG9jYXRpb24gaW4gdGhlIG5ldHdvcmsuIEZvciByZXF1ZXN0IGZvcmdlcnkgdG8gYmUgZWZmZWN0aXZlLCBhbiBhdHRhY2tlciBuZWVkcyB0byBiZSBhYmxlIHRvIGluZmx1ZW5jZSB3aGF0IHBhY2tldHMgdGhlIHBlZXIgc2VuZHMgYW5kIHdoZXJlIHRoZXNlIHBhY2tldHMgYXJlIHNlbnQuIElmIGFuIGF0dGFja2VyIGNhbiB0YXJnZXQgYSB2dWxuZXJhYmxlIHNlcnZpY2Ugd2l0aCBhIGNvbnRyb2xsZWQgcGF5bG9hZCwgdGhhdCBzZXJ2aWNlIG1pZ2h0IHBlcmZvcm0gYWN0aW9ucyB0aGF0IGFyZSBhdHRyaWJ1dGVkIHRvIHRoZSBhdHRhY2tlcidzIHBlZXIgYnV0IGFyZSBkZWNpZGVkIGJ5IHRoZSBhdHRhY2tlci4gRm9yIGV4YW1wbGUsIGNyb3NzLXNpdGUgcmVxdWVzdCBmb3JnZXJ5IFtDU1JGXSBleHBsb2l0cyBvbiB0aGUgV2ViIGNhdXNlIGEgY2xpZW50IHRvIGlzc3VlIHJlcXVlc3RzIHRoYXQgaW5jbHVkZSBhdXRob3JpemF0aW9uIGNvb2tpZXMgW0NPT0tJRV0sIGFsbG93aW5nIG9uZSBzaXRlIGFjY2VzcyB0byBpbmZvcm1hdGlvbiBhbmQgYWN0aW9ucyB0aGF0IGFyZSBpbnRlbmRlZCB0byBiZSByZXN0cmljdGVkIHRvIGEgZGlmZmVyZW50IHNpdGUuIEFzIFFVSUMgcnVucyBvdmVyIFVEUCwgdGhlIHByaW1hcnkgYXR0YWNrIG1vZGFsaXR5IG9mIGNvbmNlcm4gaXMgb25lIHdoZXJlIGFuIGF0dGFja2VyIGNhbiBzZWxlY3QgdGhlIGFkZHJlc3MgdG8gd2hpY2ggaXRzIHBlZXIgc2VuZHMgVURQIGRhdGFncmFtcyBhbmQgY2FuIGNvbnRyb2wgc29tZSBvZiB0aGUgdW5wcm90ZWN0ZWQgY29udGVudCBvZiB0aG9zZSBwYWNrZXRzLiBBcyBtdWNoIG9mIHRoZSBkYXRhIHNlbnQgYnkgUVVJQyBlbmRwb2ludHMgaXMgcHJvdGVjdGVkLCB0aGlzIGluY2x1ZGVzIGNvbnRyb2wgb3ZlciBjaXBoZXJ0ZXh0LiBBbiBhdHRhY2sgaXMgc3VjY2Vzc2Z1bCBpZiBhbiBhdHRhY2tlciBjYW4gY2F1c2UgYSBwZWVyIHRvIHNlbmQgYSBVRFAgZGF0YWdyYW0gdG8gYSBob3N0IHRoYXQgd2lsbCBwZXJmb3JtIHNvbWUgYWN0aW9uIGJhc2VkIG9uIGNvbnRlbnQgaW4gdGhlIGRhdGFncmFtLiBUaGlzIHNlY3Rpb24gZGlzY3Vzc2VzIHdheXMgaW4gd2hpY2ggUVVJQyBtaWdodCBiZSB1c2VkIGZvciByZXF1ZXN0IGZvcmdlcnkgYXR0YWNrcy4gVGhpcyBzZWN0aW9uIGFsc28gZGVzY3JpYmVzIGxpbWl0ZWQgY291bnRlcm1lYXN1cmVzIHRoYXQgY2FuIGJlIGltcGxlbWVudGVkIGJ5IFFVSUMgZW5kcG9pbnRzLiBUaGVzZSBtaXRpZ2F0aW9ucyBjYW4gYmUgZW1wbG95ZWQgdW5pbGF0ZXJhbGx5IGJ5IGEgUVVJQyBpbXBsZW1lbnRhdGlvbiBvciBkZXBsb3ltZW50LCB3aXRob3V0IHBvdGVudGlhbCB0YXJnZXRzIGZvciByZXF1ZXN0IGZvcmdlcnkgYXR0YWNrcyB0YWtpbmcgYWN0aW9uLiBIb3dldmVyLCB0aGVzZSBjb3VudGVybWVhc3VyZXMgY291bGQgYmUgaW5zdWZmaWNpZW50IGlmIFVEUC1iYXNlZCBzZXJ2aWNlcyBkbyBub3QgcHJvcGVybHkgYXV0aG9yaXplIHJlcXVlc3RzLiBCZWNhdXNlIHRoZSBtaWdyYXRpb24gYXR0YWNrIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDIxLjUuNCBpcyBxdWl0ZSBwb3dlcmZ1bCBhbmQgZG9lcyBub3QgaGF2ZSBhZGVxdWF0ZSBjb3VudGVybWVhc3VyZXMsIFFVSUMgc2VydmVyIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYXNzdW1lIHRoYXQgYXR0YWNrZXJzIGNhbiBjYXVzZSB0aGVtIHRvIGdlbmVyYXRlIGFyYml0cmFyeSBVRFAgcGF5bG9hZHMgdG8gYXJiaXRyYXJ5IGRlc3RpbmF0aW9ucy4gUVVJQyBzZXJ2ZXJzIFNIT1VMRCBOT1QgYmUgZGVwbG95ZWQgaW4gbmV0d29ya3MgdGhhdCBkbyBub3QgZGVwbG95IGluZ3Jlc3MgZmlsdGVyaW5nIFtCQ1AzOF0gYW5kIGFsc28gaGF2ZSBpbmFkZXF1YXRlbHkgc2VjdXJlZCBVRFAgZW5kcG9pbnRzLiBBbHRob3VnaCBpdCBpcyBub3QgZ2VuZXJhbGx5IHBvc3NpYmxlIHRvIGVuc3VyZSB0aGF0IGNsaWVudHMgYXJlIG5vdCBjby1sb2NhdGVkIHdpdGggdnVsbmVyYWJsZSBlbmRwb2ludHMsIHRoaXMgdmVyc2lvbiBvZiBRVUlDIGRvZXMgbm90IGFsbG93IHNlcnZlcnMgdG8gbWlncmF0ZSwgdGh1cyBwcmV2ZW50aW5nIHNwb29mZWQgbWlncmF0aW9uIGF0dGFja3Mgb24gY2xpZW50cy4gQW55IGZ1dHVyZSBleHRlbnNpb24gdGhhdCBhbGxvd3Mgc2VydmVyIG1pZ3JhdGlvbiBNVVNUIGFsc28gZGVmaW5lIGNvdW50ZXJtZWFzdXJlcyBmb3IgZm9yZ2VyeSBhdHRhY2tzLiAyMS41LjEuIENvbnRyb2wgT3B0aW9ucyBmb3IgRW5kcG9pbnRzIFFVSUMgb2ZmZXJzIHNvbWUgb3Bwb3J0dW5pdGllcyBmb3IgYW4gYXR0YWNrZXIgdG8gaW5mbHVlbmNlIG9yIGNvbnRyb2wgd2hlcmUgaXRzIHBlZXIgc2VuZHMgVURQIGRhdGFncmFtczogKiBpbml0aWFsIGNvbm5lY3Rpb24gZXN0YWJsaXNobWVudCAoU2VjdGlvbiA3KSwgd2hlcmUgYSBzZXJ2ZXIgaXMgYWJsZSB0byBjaG9vc2Ugd2hlcmUgYSBjbGllbnQgc2VuZHMgZGF0YWdyYW1zIC0tIGZvciBleGFtcGxlLCBieSBwb3B1bGF0aW5nIEROUyByZWNvcmRzOyAqIHByZWZlcnJlZCBhZGRyZXNzZXMgKFNlY3Rpb24gOS42KSwgd2hlcmUgYSBzZXJ2ZXIgaXMgYWJsZSB0byBjaG9vc2Ugd2hlcmUgYSBjbGllbnQgc2VuZHMgZGF0YWdyYW1zOyAqIHNwb29mZWQgY29ubmVjdGlvbiBtaWdyYXRpb25zIChTZWN0aW9uIDkuMy4xKSwgd2hlcmUgYSBjbGllbnQgaXMgYWJsZSB0byB1c2Ugc291cmNlIGFkZHJlc3Mgc3Bvb2ZpbmcgdG8gc2VsZWN0IHdoZXJlIGEgc2VydmVyIHNlbmRzIHN1YnNlcXVlbnQgZGF0YWdyYW1zOyBhbmQgKiBzcG9vZmVkIHBhY2tldHMgdGhhdCBjYXVzZSBhIHNlcnZlciB0byBzZW5kIGEgVmVyc2lvbiBOZWdvdGlhdGlvbiBwYWNrZXQgKFNlY3Rpb24gMjEuNS41KS4gSW4gYWxsIGNhc2VzLCB0aGUgYXR0YWNrZXIgY2FuIGNhdXNlIGl0cyBwZWVyIHRvIHNlbmQgZGF0YWdyYW1zIHRvIGEgdmljdGltIHRoYXQgbWlnaHQgbm90IHVuZGVyc3RhbmQgUVVJQy4gVGhhdCBpcywgdGhlc2UgcGFja2V0cyBhcmUgc2VudCBieSB0aGUgcGVlciBwcmlvciB0byBhZGRyZXNzIHZhbGlkYXRpb247IHNlZSBTZWN0aW9uIDguIE91dHNpZGUgb2YgdGhlIGVuY3J5cHRlZCBwb3J0aW9uIG9mIHBhY2tldHMsIFFVSUMgb2ZmZXJzIGFuIGVuZHBvaW50IHNldmVyYWwgb3B0aW9ucyBmb3IgY29udHJvbGxpbmcgdGhlIGNvbnRlbnQgb2YgVURQIGRhdGFncmFtcyB0aGF0IGl0cyBwZWVyIHNlbmRzLiBUaGUgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBmaWVsZCBvZmZlcnMgZGlyZWN0IGNvbnRyb2wgb3ZlciBieXRlcyB0aGF0IGFwcGVhciBlYXJseSBpbiBwYWNrZXRzIHNlbnQgYnkgdGhlIHBlZXI7IHNlZSBTZWN0aW9uIDUuMS4gVGhlIFRva2VuIGZpZWxkIGluIEluaXRpYWwgcGFja2V0cyBvZmZlcnMgYSBzZXJ2ZXIgY29udHJvbCBvdmVyIG90aGVyIGJ5dGVzIG9mIEluaXRpYWwgcGFja2V0czsgc2VlIFNlY3Rpb24gMTcuMi4yLiBUaGVyZSBhcmUgbm8gbWVhc3VyZXMgaW4gdGhpcyB2ZXJzaW9uIG9mIFFVSUMgdG8gcHJldmVudCBpbmRpcmVjdCBjb250cm9sIG92ZXIgdGhlIGVuY3J5cHRlZCBwb3J0aW9ucyBvZiBwYWNrZXRzLiBJdCBpcyBuZWNlc3NhcnkgdG8gYXNzdW1lIHRoYXQgZW5kcG9pbnRzIGFyZSBhYmxlIHRvIGNvbnRyb2wgdGhlIGNvbnRlbnRzIG9mIGZyYW1lcyB0aGF0IGEgcGVlciBzZW5kcywgZXNwZWNpYWxseSB0aG9zZSBmcmFtZXMgdGhhdCBjb252ZXkgYXBwbGljYXRpb24gZGF0YSwgc3VjaCBhcyBTVFJFQU0gZnJhbWVzLiBUaG91Z2ggdGhpcyBkZXBlbmRzIHRvIHNvbWUgZGVncmVlIG9uIGRldGFpbHMgb2YgdGhlIGFwcGxpY2F0aW9uIHByb3RvY29sLCBzb21lIGNvbnRyb2wgaXMgcG9zc2libGUgaW4gbWFueSBwcm90b2NvbCB1c2FnZSBjb250ZXh0cy4gQXMgdGhlIGF0dGFja2VyIGhhcyBhY2Nlc3MgdG8gcGFja2V0IHByb3RlY3Rpb24ga2V5cywgdGhleSBhcmUgbGlrZWx5IHRvIGJlIGNhcGFibGUgb2YgcHJlZGljdGluZyBob3cgYSBwZWVyIHdpbGwgZW5jcnlwdCBmdXR1cmUgcGFja2V0cy4gU3VjY2Vzc2Z1bCBjb250cm9sIG92ZXIgZGF0YWdyYW0gY29udGVudCB0aGVuIG9ubHkgcmVxdWlyZXMgdGhhdCB0aGUgYXR0YWNrZXIgYmUgYWJsZSB0byBwcmVkaWN0IHRoZSBwYWNrZXQgbnVtYmVyIGFuZCBwbGFjZW1lbnQgb2YgZnJhbWVzIGluIHBhY2tldHMgd2l0aCBzb21lIGFtb3VudCBvZiByZWxpYWJpbGl0eS4gVGhpcyBzZWN0aW9uIGFzc3VtZXMgdGhhdCBsaW1pdGluZyBjb250cm9sIG92ZXIgZGF0YWdyYW0gY29udGVudCBpcyBub3QgZmVhc2libGUuIFRoZSBmb2N1cyBvZiB0aGUgbWl0aWdhdGlvbnMgaW4gc3Vic2VxdWVudCBzZWN0aW9ucyBpcyBvbiBsaW1pdGluZyB0aGUgd2F5cyBpbiB3aGljaCBkYXRhZ3JhbXMgdGhhdCBhcmUgc2VudCBwcmlvciB0byBhZGRyZXNzIHZhbGlkYXRpb24gY2FuIGJlIHVzZWQgZm9yIHJlcXVlc3QgZm9yZ2VyeS4gMjEuNS4yLiBSZXF1ZXN0IEZvcmdlcnkgd2l0aCBDbGllbnQgSW5pdGlhbCBQYWNrZXRzIEFuIGF0dGFja2VyIGFjdGluZyBhcyBhIHNlcnZlciBjYW4gY2hvb3NlIHRoZSBJUCBhZGRyZXNzIGFuZCBwb3J0IG9uIHdoaWNoIGl0IGFkdmVydGlzZXMgaXRzIGF2YWlsYWJpbGl0eSwgc28gSW5pdGlhbCBwYWNrZXRzIGZyb20gY2xpZW50cyBhcmUgYXNzdW1lZCB0byBiZSBhdmFpbGFibGUgZm9yIHVzZSBpbiB0aGlzIHNvcnQgb2YgYXR0YWNrLiBUaGUgYWRkcmVzcyB2YWxpZGF0aW9uIGltcGxpY2l0IGluIHRoZSBoYW5kc2hha2UgZW5zdXJlcyB0aGF0IC0tIGZvciBhIG5ldyBjb25uZWN0aW9uIC0tIGEgY2xpZW50IHdpbGwgbm90IHNlbmQgb3RoZXIgdHlwZXMgb2YgcGFja2V0cyB0byBhIGRlc3RpbmF0aW9uIHRoYXQgZG9lcyBub3QgdW5kZXJzdGFuZCBRVUlDIG9yIGlzIG5vdCB3aWxsaW5nIHRvIGFjY2VwdCBhIFFVSUMgY29ubmVjdGlvbi4gSW5pdGlhbCBwYWNrZXQgcHJvdGVjdGlvbiAoU2VjdGlvbiA1LjIgb2YgW1FVSUMtVExTXSkgbWFrZXMgaXQgZGlmZmljdWx0IGZvciBzZXJ2ZXJzIHRvIGNvbnRyb2wgdGhlIGNvbnRlbnQgb2YgSW5pdGlhbCBwYWNrZXRzIHNlbnQgYnkgY2xpZW50cy4gQSBjbGllbnQgY2hvb3NpbmcgYW4gdW5wcmVkaWN0YWJsZSBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEIGVuc3VyZXMgdGhhdCBzZXJ2ZXJzIGFyZSB1bmFibGUgdG8gY29udHJvbCBhbnkgb2YgdGhlIGVuY3J5cHRlZCBwb3J0aW9uIG9mIEluaXRpYWwgcGFja2V0cyBmcm9tIGNsaWVudHMuIEhvd2V2ZXIsIHRoZSBUb2tlbiBmaWVsZCBpcyBvcGVuIHRvIHNlcnZlciBjb250cm9sIGFuZCBkb2VzIGFsbG93IGEgc2VydmVyIHRvIHVzZSBjbGllbnRzIHRvIG1vdW50IHJlcXVlc3QgZm9yZ2VyeSBhdHRhY2tzLiBUaGUgdXNlIG9mIHRva2VucyBwcm92aWRlZCB3aXRoIHRoZSBORVdfVE9LRU4gZnJhbWUgKFNlY3Rpb24gOC4xLjMpIG9mZmVycyB0aGUgb25seSBvcHRpb24gZm9yIHJlcXVlc3QgZm9yZ2VyeSBkdXJpbmcgY29ubmVjdGlvbiBlc3RhYmxpc2htZW50LiBDbGllbnRzLCBob3dldmVyLCBhcmUgbm90IG9ibGlnYXRlZCB0byB1c2UgdGhlIE5FV19UT0tFTiBmcmFtZS4gUmVxdWVzdCBmb3JnZXJ5IGF0dGFja3MgdGhhdCByZWx5IG9uIHRoZSBUb2tlbiBmaWVsZCBjYW4gYmUgYXZvaWRlZCBpZiBjbGllbnRzIHNlbmQgYW4gZW1wdHkgVG9rZW4gZmllbGQgd2hlbiB0aGUgc2VydmVyIGFkZHJlc3MgaGFzIGNoYW5nZWQgZnJvbSB3aGVuIHRoZSBORVdfVE9LRU4gZnJhbWUgd2FzIHJlY2VpdmVkLiBDbGllbnRzIGNvdWxkIGF2b2lkIHVzaW5nIE5FV19UT0tFTiBpZiB0aGUgc2VydmVyIGFkZHJlc3MgY2hhbmdlcy4gSG93ZXZlciwgbm90IGluY2x1ZGluZyBhIFRva2VuIGZpZWxkIGNvdWxkIGFkdmVyc2VseSBhZmZlY3QgcGVyZm9ybWFuY2UuIFNlcnZlcnMgY291bGQgcmVseSBvbiBORVdfVE9LRU4gdG8gZW5hYmxlIHRoZSBzZW5kaW5nIG9mIGRhdGEgaW4gZXhjZXNzIG9mIHRoZSB0aHJlZS10aW1lcyBsaW1pdCBvbiBzZW5kaW5nIGRhdGE7IHNlZSBTZWN0aW9uIDguMS4gSW4gcGFydGljdWxhciwgdGhpcyBhZmZlY3RzIGNhc2VzIHdoZXJlIGNsaWVudHMgdXNlIDAtUlRUIHRvIHJlcXVlc3QgZGF0YSBmcm9tIHNlcnZlcnMuIFNlbmRpbmcgYSBSZXRyeSBwYWNrZXQgKFNlY3Rpb24gMTcuMi41KSBvZmZlcnMgYSBzZXJ2ZXIgdGhlIG9wdGlvbiB0byBjaGFuZ2UgdGhlIFRva2VuIGZpZWxkLiBBZnRlciBzZW5kaW5nIGEgUmV0cnksIHRoZSBzZXJ2ZXIgY2FuIGFsc28gY29udHJvbCB0aGUgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBmaWVsZCBvZiBzdWJzZXF1ZW50IEluaXRpYWwgcGFja2V0cyBmcm9tIHRoZSBjbGllbnQuIFRoaXMgYWxzbyBtaWdodCBhbGxvdyBpbmRpcmVjdCBjb250cm9sIG92ZXIgdGhlIGVuY3J5cHRlZCBjb250ZW50IG9mIEluaXRpYWwgcGFja2V0cy4gSG93ZXZlciwgdGhlIGV4Y2hhbmdlIG9mIGEgUmV0cnkgcGFja2V0IHZhbGlkYXRlcyB0aGUgc2VydmVyJ3MgYWRkcmVzcywgdGhlcmVieSBwcmV2ZW50aW5nIHRoZSB1c2Ugb2Ygc3Vic2VxdWVudCBJbml0aWFsIHBhY2tldHMgZm9yIHJlcXVlc3QgZm9yZ2VyeS4gMjEuNS4zLiBSZXF1ZXN0IEZvcmdlcnkgd2l0aCBQcmVmZXJyZWQgQWRkcmVzc2VzIFNlcnZlcnMgY2FuIHNwZWNpZnkgYSBwcmVmZXJyZWQgYWRkcmVzcywgd2hpY2ggY2xpZW50cyB0aGVuIG1pZ3JhdGUgdG8gYWZ0ZXIgY29uZmlybWluZyB0aGUgaGFuZHNoYWtlOyBzZWUgU2VjdGlvbiA5LjYuIFRoZSBEZXN0aW5hdGlvbiBDb25uZWN0aW9uIElEIGZpZWxkIG9mIHBhY2tldHMgdGhhdCB0aGUgY2xpZW50IHNlbmRzIHRvIGEgcHJlZmVycmVkIGFkZHJlc3MgY2FuIGJlIHVzZWQgZm9yIHJlcXVlc3QgZm9yZ2VyeS4gQSBjbGllbnQgTVVTVCBOT1Qgc2VuZCBub24tcHJvYmluZyBmcmFtZXMgdG8gYSBwcmVmZXJyZWQgYWRkcmVzcyBwcmlvciB0byB2YWxpZGF0aW5nIHRoYXQgYWRkcmVzczsgc2VlIFNlY3Rpb24gOC4gVGhpcyBncmVhdGx5IHJlZHVjZXMgdGhlIG9wdGlvbnMgdGhhdCBhIHNlcnZlciBoYXMgdG8gY29udHJvbCB0aGUgZW5jcnlwdGVkIHBvcnRpb24gb2YgZGF0YWdyYW1zLiBUaGlzIGRvY3VtZW50IGRvZXMgbm90IG9mZmVyIGFueSBhZGRpdGlvbmFsIGNvdW50ZXJtZWFzdXJlcyB0aGF0IGFyZSBzcGVjaWZpYyB0byB0aGUgdXNlIG9mIHByZWZlcnJlZCBhZGRyZXNzZXMgYW5kIGNhbiBiZSBpbXBsZW1lbnRlZCBieSBlbmRwb2ludHMuIFRoZSBnZW5lcmljIG1lYXN1cmVzIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDIxLjUuNiBjb3VsZCBiZSB1c2VkIGFzIGZ1cnRoZXIgbWl0aWdhdGlvbi4gMjEuNS40LiBSZXF1ZXN0IEZvcmdlcnkgd2l0aCBTcG9vZmVkIE1pZ3JhdGlvbiBDbGllbnRzIGFyZSBhYmxlIHRvIHByZXNlbnQgYSBzcG9vZmVkIHNvdXJjZSBhZGRyZXNzIGFzIHBhcnQgb2YgYW4gYXBwYXJlbnQgY29ubmVjdGlvbiBtaWdyYXRpb24gdG8gY2F1c2UgYSBzZXJ2ZXIgdG8gc2VuZCBkYXRhZ3JhbXMgdG8gdGhhdCBhZGRyZXNzLiBUaGUgRGVzdGluYXRpb24gQ29ubmVjdGlvbiBJRCBmaWVsZCBpbiBhbnkgcGFja2V0cyB0aGF0IGEgc2VydmVyIHN1YnNlcXVlbnRseSBzZW5kcyB0byB0aGlzIHNwb29mZWQgYWRkcmVzcyBjYW4gYmUgdXNlZCBmb3IgcmVxdWVzdCBmb3JnZXJ5LiBBIGNsaWVudCBtaWdodCBhbHNvIGJlIGFibGUgdG8gaW5mbHVlbmNlIHRoZSBjaXBoZXJ0ZXh0LiBBIHNlcnZlciB0aGF0IG9ubHkgc2VuZHMgcHJvYmluZyBwYWNrZXRzIChTZWN0aW9uIDkuMSkgdG8gYW4gYWRkcmVzcyBwcmlvciB0byBhZGRyZXNzIHZhbGlkYXRpb24gcHJvdmlkZXMgYW4gYXR0YWNrZXIgd2l0aCBvbmx5IGxpbWl0ZWQgY29udHJvbCBvdmVyIHRoZSBlbmNyeXB0ZWQgcG9ydGlvbiBvZiBkYXRhZ3JhbXMuIEhvd2V2ZXIsIHBhcnRpY3VsYXJseSBmb3IgTkFUIHJlYmluZGluZywgdGhpcyBjYW4gYWR2ZXJzZWx5IGFmZmVjdCBwZXJmb3JtYW5jZS4gSWYgdGhlIHNlcnZlciBzZW5kcyBmcmFtZXMgY2FycnlpbmcgYXBwbGljYXRpb24gZGF0YSwgYW4gYXR0YWNrZXIgbWlnaHQgYmUgYWJsZSB0byBjb250cm9sIG1vc3Qgb2YgdGhlIGNvbnRlbnQgb2YgZGF0YWdyYW1zLiBUaGlzIGRvY3VtZW50IGRvZXMgbm90IG9mZmVyIHNwZWNpZmljIGNvdW50ZXJtZWFzdXJlcyB0aGF0IGNhbiBiZSBpbXBsZW1lbnRlZCBieSBlbmRwb2ludHMsIGFzaWRlIGZyb20gdGhlIGdlbmVyaWMgbWVhc3VyZXMgZGVzY3JpYmVkIGluIFNlY3Rpb24gMjEuNS42LiBIb3dldmVyLCBjb3VudGVybWVhc3VyZXMgZm9yIGFkZHJlc3Mgc3Bvb2ZpbmcgYXQgdGhlIG5ldHdvcmsgbGV2ZWwgLS0gaW4gcGFydGljdWxhciwgaW5ncmVzcyBmaWx0ZXJpbmcgW0JDUDM4XSAtLSBhcmUgZXNwZWNpYWxseSBlZmZlY3RpdmUgYWdhaW5zdCBhdHRhY2tzIHRoYXQgdXNlIHNwb29maW5nIGFuZCBvcmlnaW5hdGUgZnJvbSBhbiBleHRlcm5hbCBuZXR3b3JrLiAyMS41LjUuIFJlcXVlc3QgRm9yZ2VyeSB3aXRoIFZlcnNpb24gTmVnb3RpYXRpb24gQ2xpZW50cyB0aGF0IGFyZSBhYmxlIHRvIHByZXNlbnQgYSBzcG9vZmVkIHNvdXJjZSBhZGRyZXNzIG9uIGEgcGFja2V0IGNhbiBjYXVzZSBhIHNlcnZlciB0byBzZW5kIGEgVmVyc2lvbiBOZWdvdGlhdGlvbiBwYWNrZXQgKFNlY3Rpb24gMTcuMi4xKSB0byB0aGF0IGFkZHJlc3MuIFRoZSBhYnNlbmNlIG9mIHNpemUgcmVzdHJpY3Rpb25zIG9uIHRoZSBjb25uZWN0aW9uIElEIGZpZWxkcyBmb3IgcGFja2V0cyBvZiBhbiB1bmtub3duIHZlcnNpb24gaW5jcmVhc2VzIHRoZSBhbW91bnQgb2YgZGF0YSB0aGF0IHRoZSBjbGllbnQgY29udHJvbHMgZnJvbSB0aGUgcmVzdWx0aW5nIGRhdGFncmFtLiBUaGUgZmlyc3QgYnl0ZSBvZiB0aGlzIHBhY2tldCBpcyBub3QgdW5kZXIgY2xpZW50IGNvbnRyb2wgYW5kIHRoZSBuZXh0IGZvdXIgYnl0ZXMgYXJlIHplcm8sIGJ1dCB0aGUgY2xpZW50IGlzIGFibGUgdG8gY29udHJvbCB1cCB0byA1MTIgYnl0ZXMgc3RhcnRpbmcgZnJvbSB0aGUgZmlmdGggYnl0ZS4gTm8gc3BlY2lmaWMgY291bnRlcm1lYXN1cmVzIGFyZSBwcm92aWRlZCBmb3IgdGhpcyBhdHRhY2ssIHRob3VnaCBnZW5lcmljIHByb3RlY3Rpb25zIChTZWN0aW9uIDIxLjUuNikgY291bGQgYXBwbHkuIEluIHRoaXMgY2FzZSwgaW5ncmVzcyBmaWx0ZXJpbmcgW0JDUDM4XSBpcyBhbHNvIGVmZmVjdGl2ZS4gMjEuNS42LiBHZW5lcmljIFJlcXVlc3QgRm9yZ2VyeSBDb3VudGVybWVhc3VyZXMgVGhlIG1vc3QgZWZmZWN0aXZlIGRlZmVuc2UgYWdhaW5zdCByZXF1ZXN0IGZvcmdlcnkgYXR0YWNrcyBpcyB0byBtb2RpZnkgdnVsbmVyYWJsZSBzZXJ2aWNlcyB0byB1c2Ugc3Ryb25nIGF1dGhlbnRpY2F0aW9uLiBIb3dldmVyLCB0aGlzIGlzIG5vdCBhbHdheXMgc29tZXRoaW5nIHRoYXQgaXMgd2l0aGluIHRoZSBjb250cm9sIG9mIGEgUVVJQyBkZXBsb3ltZW50LiBUaGlzIHNlY3Rpb24gb3V0bGluZXMgc29tZSBvdGhlciBzdGVwcyB0aGF0IFFVSUMgZW5kcG9pbnRzIGNvdWxkIHRha2UgdW5pbGF0ZXJhbGx5LiBUaGVzZSBhZGRpdGlvbmFsIHN0ZXBzIGFyZSBhbGwgZGlzY3JldGlvbmFyeSBiZWNhdXNlLCBkZXBlbmRpbmcgb24gY2lyY3Vtc3RhbmNlcywgdGhleSBjb3VsZCBpbnRlcmZlcmUgd2l0aCBvciBwcmV2ZW50IGxlZ2l0aW1hdGUgdXNlcy4gU2VydmljZXMgb2ZmZXJlZCBvdmVyIGxvb3BiYWNrIGludGVyZmFjZXMgb2Z0ZW4gbGFjayBwcm9wZXIgYXV0aGVudGljYXRpb24uIEVuZHBvaW50cyBNQVkgcHJldmVudCBjb25uZWN0aW9uIGF0dGVtcHRzIG9yIG1pZ3JhdGlvbiB0byBhIGxvb3BiYWNrIGFkZHJlc3MuIEVuZHBvaW50cyBTSE9VTEQgTk9UIGFsbG93IGNvbm5lY3Rpb25zIG9yIG1pZ3JhdGlvbiB0byBhIGxvb3BiYWNrIGFkZHJlc3MgaWYgdGhlIHNhbWUgc2VydmljZSB3YXMgcHJldmlvdXNseSBhdmFpbGFibGUgYXQgYSBkaWZmZXJlbnQgaW50ZXJmYWNlIG9yIGlmIHRoZSBhZGRyZXNzIHdhcyBwcm92aWRlZCBieSBhIHNlcnZpY2UgYXQgYSBub24tbG9vcGJhY2sgYWRkcmVzcy4gRW5kcG9pbnRzIHRoYXQgZGVwZW5kIG9uIHRoZXNlIGNhcGFiaWxpdGllcyBjb3VsZCBvZmZlciBhbiBvcHRpb24gdG8gZGlzYWJsZSB0aGVzZSBwcm90ZWN0aW9ucy4gU2ltaWxhcmx5LCBlbmRwb2ludHMgY291bGQgcmVnYXJkIGEgY2hhbmdlIGluIGFkZHJlc3MgdG8gYSBsaW5rLWxvY2FsIGFkZHJlc3MgW1JGQzQyOTFdIG9yIGFuIGFkZHJlc3MgaW4gYSBwcml2YXRlLXVzZSByYW5nZSBbUkZDMTkxOF0gZnJvbSBhIGdsb2JhbCwgdW5pcXVlLWxvY2FsIFtSRkM0MTkzXSwgb3Igbm9uLXByaXZhdGUgYWRkcmVzcyBhcyBhIHBvdGVudGlhbCBhdHRlbXB0IGF0IHJlcXVlc3QgZm9yZ2VyeS4gRW5kcG9pbnRzIGNvdWxkIHJlZnVzZSB0byB1c2UgdGhlc2UgYWRkcmVzc2VzIGVudGlyZWx5LCBidXQgdGhhdCBjYXJyaWVzIGEgc2lnbmlmaWNhbnQgcmlzayBvZiBpbnRlcmZlcmluZyB3aXRoIGxlZ2l0aW1hdGUgdXNlcy4gRW5kcG9pbnRzIFNIT1VMRCBOT1QgcmVmdXNlIHRvIHVzZSBhbiBhZGRyZXNzIHVubGVzcyB0aGV5IGhhdmUgc3BlY2lmaWMga25vd2xlZGdlIGFib3V0IHRoZSBuZXR3b3JrIGluZGljYXRpbmcgdGhhdCBzZW5kaW5nIGRhdGFncmFtcyB0byB1bnZhbGlkYXRlZCBhZGRyZXNzZXMgaW4gYSBnaXZlbiByYW5nZSBpcyBub3Qgc2FmZS4gRW5kcG9pbnRzIE1BWSBjaG9vc2UgdG8gcmVkdWNlIHRoZSByaXNrIG9mIHJlcXVlc3QgZm9yZ2VyeSBieSBub3QgaW5jbHVkaW5nIHZhbHVlcyBmcm9tIE5FV19UT0tFTiBmcmFtZXMgaW4gSW5pdGlhbCBwYWNrZXRzIG9yIGJ5IG9ubHkgc2VuZGluZyBwcm9iaW5nIGZyYW1lcyBpbiBwYWNrZXRzIHByaW9yIHRvIGNvbXBsZXRpbmcgYWRkcmVzcyB2YWxpZGF0aW9uLiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBwcmV2ZW50IGFuIGF0dGFja2VyIGZyb20gdXNpbmcgdGhlIERlc3RpbmF0aW9uIENvbm5lY3Rpb24gSUQgZmllbGQgZm9yIGFuIGF0dGFjay4gRW5kcG9pbnRzIGFyZSBub3QgZXhwZWN0ZWQgdG8gaGF2ZSBzcGVjaWZpYyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbG9jYXRpb24gb2Ygc2VydmVycyB0aGF0IGNvdWxkIGJlIHZ1bG5lcmFibGUgdGFyZ2V0cyBvZiBhIHJlcXVlc3QgZm9yZ2VyeSBhdHRhY2suIEhvd2V2ZXIsIGl0IG1pZ2h0IGJlIHBvc3NpYmxlIG92ZXIgdGltZSB0byBpZGVudGlmeSBzcGVjaWZpYyBVRFAgcG9ydHMgdGhhdCBhcmUgY29tbW9uIHRhcmdldHMgb2YgYXR0YWNrcyBvciBwYXJ0aWN1bGFyIHBhdHRlcm5zIGluIGRhdGFncmFtcyB0aGF0IGFyZSB1c2VkIGZvciBhdHRhY2tzLiBFbmRwb2ludHMgTUFZIGNob29zZSB0byBhdm9pZCBzZW5kaW5nIGRhdGFncmFtcyB0byB0aGVzZSBwb3J0cyBvciBub3Qgc2VuZCBkYXRhZ3JhbXMgdGhhdCBtYXRjaCB0aGVzZSBwYXR0ZXJucyBwcmlvciB0byB2YWxpZGF0aW5nIHRoZSBkZXN0aW5hdGlvbiBhZGRyZXNzLiBFbmRwb2ludHMgTUFZIHJldGlyZSBjb25uZWN0aW9uIElEcyBjb250YWluaW5nIHBhdHRlcm5zIGtub3duIHRvIGJlIHByb2JsZW1hdGljIHdpdGhvdXQgdXNpbmcgdGhlbS4gfCBOb3RlOiBNb2RpZnlpbmcgZW5kcG9pbnRzIHRvIGFwcGx5IHRoZXNlIHByb3RlY3Rpb25zIGlzIG1vcmUgfCBlZmZpY2llbnQgdGhhbiBkZXBsb3lpbmcgbmV0d29yay1iYXNlZCBwcm90ZWN0aW9ucywgYXMgfCBlbmRwb2ludHMgZG8gbm90IG5lZWQgdG8gcGVyZm9ybSBhbnkgYWRkaXRpb25hbCBwcm9jZXNzaW5nIHdoZW4gfCBzZW5kaW5nIHRvIGFuIGFkZHJlc3MgdGhhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuIDIxLjYuIFNsb3dsb3JpcyBBdHRhY2tzIFRoZSBhdHRhY2tzIGNvbW1vbmx5IGtub3duIGFzIFNsb3dsb3JpcyBbU0xPV0xPUklTXSB0cnkgdG8ga2VlcCBtYW55IGNvbm5lY3Rpb25zIHRvIHRoZSB0YXJnZXQgZW5kcG9pbnQgb3BlbiBhbmQgaG9sZCB0aGVtIG9wZW4gYXMgbG9uZyBhcyBwb3NzaWJsZS4gVGhlc2UgYXR0YWNrcyBjYW4gYmUgZXhlY3V0ZWQgYWdhaW5zdCBhIFFVSUMgZW5kcG9pbnQgYnkgZ2VuZXJhdGluZyB0aGUgbWluaW11bSBhbW91bnQgb2YgYWN0aXZpdHkgbmVjZXNzYXJ5IHRvIGF2b2lkIGJlaW5nIGNsb3NlZCBmb3IgaW5hY3Rpdml0eS4gVGhpcyBtaWdodCBpbnZvbHZlIHNlbmRpbmcgc21hbGwgYW1vdW50cyBvZiBkYXRhLCBncmFkdWFsbHkgb3BlbmluZyBmbG93IGNvbnRyb2wgd2luZG93cyBpbiBvcmRlciB0byBjb250cm9sIHRoZSBzZW5kZXIgcmF0ZSwgb3IgbWFudWZhY3R1cmluZyBBQ0sgZnJhbWVzIHRoYXQgc2ltdWxhdGUgYSBoaWdoIGxvc3MgcmF0ZS4gUVVJQyBkZXBsb3ltZW50cyBTSE9VTEQgcHJvdmlkZSBtaXRpZ2F0aW9ucyBmb3IgdGhlIFNsb3dsb3JpcyBhdHRhY2tzLCBzdWNoIGFzIGluY3JlYXNpbmcgdGhlIG1heGltdW0gbnVtYmVyIG9mIGNsaWVudHMgdGhlIHNlcnZlciB3aWxsIGFsbG93LCBsaW1pdGluZyB0aGUgbnVtYmVyIG9mIGNvbm5lY3Rpb25zIGEgc2luZ2xlIElQIGFkZHJlc3MgaXMgYWxsb3dlZCB0byBtYWtlLCBpbXBvc2luZyByZXN0cmljdGlvbnMgb24gdGhlIG1pbmltdW0gdHJhbnNmZXIgc3BlZWQgYSBjb25uZWN0aW9uIGlzIGFsbG93ZWQgdG8gaGF2ZSwgYW5kIHJlc3RyaWN0aW5nIHRoZSBsZW5ndGggb2YgdGltZSBhbiBlbmRwb2ludCBpcyBhbGxvd2VkIHRvIHN0YXkgY29ubmVjdGVkLiAyMS43LiBTdHJlYW0gRnJhZ21lbnRhdGlvbiBhbmQgUmVhc3NlbWJseSBBdHRhY2tzIEFuIGFkdmVyc2FyaWFsIHNlbmRlciBtaWdodCBpbnRlbnRpb25hbGx5IG5vdCBzZW5kIHBvcnRpb25zIG9mIHRoZSBzdHJlYW0gZGF0YSwgY2F1c2luZyB0aGUgcmVjZWl2ZXIgdG8gY29tbWl0IHJlc291cmNlcyBmb3IgdGhlIHVuc2VudCBkYXRhLiBUaGlzIGNvdWxkIGNhdXNlIGEgZGlzcHJvcG9ydGlvbmF0ZSByZWNlaXZlIGJ1ZmZlciBtZW1vcnkgY29tbWl0bWVudCBhbmQvb3IgdGhlIGNyZWF0aW9uIG9mIGEgbGFyZ2UgYW5kIGluZWZmaWNpZW50IGRhdGEgc3RydWN0dXJlIGF0IHRoZSByZWNlaXZlci4gQW4gYWR2ZXJzYXJpYWwgcmVjZWl2ZXIgbWlnaHQgaW50ZW50aW9uYWxseSBub3QgYWNrbm93bGVkZ2UgcGFja2V0cyBjb250YWluaW5nIHN0cmVhbSBkYXRhIGluIGFuIGF0dGVtcHQgdG8gZm9yY2UgdGhlIHNlbmRlciB0byBzdG9yZSB0aGUgdW5hY2tub3dsZWRnZWQgc3RyZWFtIGRhdGEgZm9yIHJldHJhbnNtaXNzaW9uLiBUaGUgYXR0YWNrIG9uIHJlY2VpdmVycyBpcyBtaXRpZ2F0ZWQgaWYgZmxvdyBjb250cm9sIHdpbmRvd3MgY29ycmVzcG9uZCB0byBhdmFpbGFibGUgbWVtb3J5LiBIb3dldmVyLCBzb21lIHJlY2VpdmVycyB3aWxsIG92ZXJjb21taXQgbWVtb3J5IGFuZCBhZHZlcnRpc2UgZmxvdyBjb250cm9sIG9mZnNldHMgaW4gdGhlIGFnZ3JlZ2F0ZSB0aGF0IGV4Y2VlZCBhY3R1YWwgYXZhaWxhYmxlIG1lbW9yeS4gVGhlIG92ZXJjb21taXRtZW50IHN0cmF0ZWd5IGNhbiBsZWFkIHRvIGJldHRlciBwZXJmb3JtYW5jZSB3aGVuIGVuZHBvaW50cyBhcmUgd2VsbCBiZWhhdmVkLCBidXQgcmVuZGVycyBlbmRwb2ludHMgdnVsbmVyYWJsZSB0byB0aGUgc3RyZWFtIGZyYWdtZW50YXRpb24gYXR0YWNrLiBRVUlDIGRlcGxveW1lbnRzIFNIT1VMRCBwcm92aWRlIG1pdGlnYXRpb25zIGZvciBzdHJlYW0gZnJhZ21lbnRhdGlvbiBhdHRhY2tzLiBNaXRpZ2F0aW9ucyBjb3VsZCBjb25zaXN0IG9mIGF2b2lkaW5nIG92ZXJjb21taXR0aW5nIG1lbW9yeSwgbGltaXRpbmcgdGhlIHNpemUgb2YgdHJhY2tpbmcgZGF0YSBzdHJ1Y3R1cmVzLCBkZWxheWluZyByZWFzc2VtYmx5IG9mIFNUUkVBTSBmcmFtZXMsIGltcGxlbWVudGluZyBoZXVyaXN0aWNzIGJhc2VkIG9uIHRoZSBhZ2UgYW5kIGR1cmF0aW9uIG9mIHJlYXNzZW1ibHkgaG9sZXMsIG9yIHNvbWUgY29tYmluYXRpb24gb2YgdGhlc2UuIDIxLjguIFN0cmVhbSBDb21taXRtZW50IEF0dGFjayBBbiBhZHZlcnNhcmlhbCBlbmRwb2ludCBjYW4gb3BlbiBhIGxhcmdlIG51bWJlciBvZiBzdHJlYW1zLCBleGhhdXN0aW5nIHN0YXRlIG9uIGFuIGVuZHBvaW50LiBUaGUgYWR2ZXJzYXJpYWwgZW5kcG9pbnQgY291bGQgcmVwZWF0IHRoZSBwcm9jZXNzIG9uIGEgbGFyZ2UgbnVtYmVyIG9mIGNvbm5lY3Rpb25zLCBpbiBhIG1hbm5lciBzaW1pbGFyIHRvIFNZTiBmbG9vZGluZyBhdHRhY2tzIGluIFRDUC4gTm9ybWFsbHksIGNsaWVudHMgd2lsbCBvcGVuIHN0cmVhbXMgc2VxdWVudGlhbGx5LCBhcyBleHBsYWluZWQgaW4gU2VjdGlvbiAyLjEuIEhvd2V2ZXIsIHdoZW4gc2V2ZXJhbCBzdHJlYW1zIGFyZSBpbml0aWF0ZWQgYXQgc2hvcnQgaW50ZXJ2YWxzLCBsb3NzIG9yIHJlb3JkZXJpbmcgY2FuIGNhdXNlIFNUUkVBTSBmcmFtZXMgdGhhdCBvcGVuIHN0cmVhbXMgdG8gYmUgcmVjZWl2ZWQgb3V0IG9mIHNlcXVlbmNlLiBPbiByZWNlaXZpbmcgYSBoaWdoZXItIG51bWJlcmVkIHN0cmVhbSBJRCwgYSByZWNlaXZlciBpcyByZXF1aXJlZCB0byBvcGVuIGFsbCBpbnRlcnZlbmluZyBzdHJlYW1zIG9mIHRoZSBzYW1lIHR5cGU7IHNlZSBTZWN0aW9uIDMuMi4gVGh1cywgb24gYSBuZXcgY29ubmVjdGlvbiwgb3BlbmluZyBzdHJlYW0gNDAwMDAwMCBvcGVucyAxIG1pbGxpb24gYW5kIDEgY2xpZW50LSBpbml0aWF0ZWQgYmlkaXJlY3Rpb25hbCBzdHJlYW1zLiBUaGUgbnVtYmVyIG9mIGFjdGl2ZSBzdHJlYW1zIGlzIGxpbWl0ZWQgYnkgdGhlIGluaXRpYWxfbWF4X3N0cmVhbXNfYmlkaSBhbmQgaW5pdGlhbF9tYXhfc3RyZWFtc191bmkgdHJhbnNwb3J0IHBhcmFtZXRlcnMgYXMgdXBkYXRlZCBieSBhbnkgcmVjZWl2ZWQgTUFYX1NUUkVBTVMgZnJhbWVzLCBhcyBleHBsYWluZWQgaW4gU2VjdGlvbiA0LjYuIElmIGNob3NlbiBqdWRpY2lvdXNseSwgdGhlc2UgbGltaXRzIG1pdGlnYXRlIHRoZSBlZmZlY3Qgb2YgdGhlIHN0cmVhbSBjb21taXRtZW50IGF0dGFjay4gSG93ZXZlciwgc2V0dGluZyB0aGUgbGltaXQgdG9vIGxvdyBjb3VsZCBhZmZlY3QgcGVyZm9ybWFuY2Ugd2hlbiBhcHBsaWNhdGlvbnMgZXhwZWN0IHRvIG9wZW4gYSBsYXJnZSBudW1iZXIgb2Ygc3RyZWFtcy4gMjEuOS4gUGVlciBEZW5pYWwgb2YgU2VydmljZSBRVUlDIGFuZCBUTFMgYm90aCBjb250YWluIGZyYW1lcyBvciBtZXNzYWdlcyB0aGF0IGhhdmUgbGVnaXRpbWF0ZSB1c2VzIGluIHNvbWUgY29udGV4dHMsIGJ1dCB0aGVzZSBmcmFtZXMgb3IgbWVzc2FnZXMgY2FuIGJlIGFidXNlZCB0byBjYXVzZSBhIHBlZXIgdG8gZXhwZW5kIHByb2Nlc3NpbmcgcmVzb3VyY2VzIHdpdGhvdXQgaGF2aW5nIGFueSBvYnNlcnZhYmxlIGltcGFjdCBvbiB0aGUgc3RhdGUgb2YgdGhlIGNvbm5lY3Rpb24uIE1lc3NhZ2VzIGNhbiBhbHNvIGJlIHVzZWQgdG8gY2hhbmdlIGFuZCByZXZlcnQgc3RhdGUgaW4gc21hbGwgb3IgaW5jb25zZXF1ZW50aWFsIHdheXMsIHN1Y2ggYXMgYnkgc2VuZGluZyBzbWFsbCBpbmNyZW1lbnRzIHRvIGZsb3cgY29udHJvbCBsaW1pdHMuIElmIHByb2Nlc3NpbmcgY29zdHMgYXJlIGRpc3Byb3BvcnRpb25hdGVseSBsYXJnZSBpbiBjb21wYXJpc29uIHRvIGJhbmR3aWR0aCBjb25zdW1wdGlvbiBvciBlZmZlY3Qgb24gc3RhdGUsIHRoZW4gdGhpcyBjb3VsZCBhbGxvdyBhIG1hbGljaW91cyBwZWVyIHRvIGV4aGF1c3QgcHJvY2Vzc2luZyBjYXBhY2l0eS4gV2hpbGUgdGhlcmUgYXJlIGxlZ2l0aW1hdGUgdXNlcyBmb3IgYWxsIG1lc3NhZ2VzLCBpbXBsZW1lbnRhdGlvbnMgU0hPVUxEIHRyYWNrIGNvc3Qgb2YgcHJvY2Vzc2luZyByZWxhdGl2ZSB0byBwcm9ncmVzcyBhbmQgdHJlYXQgZXhjZXNzaXZlIHF1YW50aXRpZXMgb2YgYW55IG5vbi1wcm9kdWN0aXZlIHBhY2tldHMgYXMgaW5kaWNhdGl2ZSBvZiBhbiBhdHRhY2suIEVuZHBvaW50cyBNQVkgcmVzcG9uZCB0byB0aGlzIGNvbmRpdGlvbiB3aXRoIGEgY29ubmVjdGlvbiBlcnJvciBvciBieSBkcm9wcGluZyBwYWNrZXRzLiAyMS4xMC4gRXhwbGljaXQgQ29uZ2VzdGlvbiBOb3RpZmljYXRpb24gQXR0YWNrcyBBbiBvbi1wYXRoIGF0dGFja2VyIGNvdWxkIG1hbmlwdWxhdGUgdGhlIHZhbHVlIG9mIEVDTiBmaWVsZHMgaW4gdGhlIElQIGhlYWRlciB0byBpbmZsdWVuY2UgdGhlIHNlbmRlcidzIHJhdGUuIFtSRkMzMTY4XSBkaXNjdXNzZXMgbWFuaXB1bGF0aW9ucyBhbmQgdGhlaXIgZWZmZWN0cyBpbiBtb3JlIGRldGFpbC4gQSBsaW1pdGVkIG9uLXBhdGggYXR0YWNrZXIgY2FuIGR1cGxpY2F0ZSBhbmQgc2VuZCBwYWNrZXRzIHdpdGggbW9kaWZpZWQgRUNOIGZpZWxkcyB0byBhZmZlY3QgdGhlIHNlbmRlcidzIHJhdGUuIElmIGR1cGxpY2F0ZSBwYWNrZXRzIGFyZSBkaXNjYXJkZWQgYnkgYSByZWNlaXZlciwgYW4gYXR0YWNrZXIgd2lsbCBuZWVkIHRvIHJhY2UgdGhlIGR1cGxpY2F0ZSBwYWNrZXQgYWdhaW5zdCB0aGUgb3JpZ2luYWwgdG8gYmUgc3VjY2Vzc2Z1bCBpbiB0aGlzIGF0dGFjay4gVGhlcmVmb3JlLCBRVUlDIGVuZHBvaW50cyBpZ25vcmUgdGhlIEVDTiBmaWVsZCBpbiBhbiBJUCBwYWNrZXQgdW5sZXNzIGF0IGxlYXN0IG9uZSBRVUlDIHBhY2tldCBpbiB0aGF0IElQIHBhY2tldCBpcyBzdWNjZXNzZnVsbHkgcHJvY2Vzc2VkOyBzZWUgU2VjdGlvbiAxMy40LiAyMS4xMS4gU3RhdGVsZXNzIFJlc2V0IE9yYWNsZSBTdGF0ZWxlc3MgcmVzZXRzIGNyZWF0ZSBhIHBvc3NpYmxlIGRlbmlhbC1vZi1zZXJ2aWNlIGF0dGFjayBhbmFsb2dvdXMgdG8gYSBUQ1AgcmVzZXQgaW5qZWN0aW9uLiBUaGlzIGF0dGFjayBpcyBwb3NzaWJsZSBpZiBhbiBhdHRhY2tlciBpcyBhYmxlIHRvIGNhdXNlIGEgc3RhdGVsZXNzIHJlc2V0IHRva2VuIHRvIGJlIGdlbmVyYXRlZCBmb3IgYSBjb25uZWN0aW9uIHdpdGggYSBzZWxlY3RlZCBjb25uZWN0aW9uIElELiBBbiBhdHRhY2tlciB0aGF0IGNhbiBjYXVzZSB0aGlzIHRva2VuIHRvIGJlIGdlbmVyYXRlZCBjYW4gcmVzZXQgYW4gYWN0aXZlIGNvbm5lY3Rpb24gd2l0aCB0aGUgc2FtZSBjb25uZWN0aW9uIElELiBJZiBhIHBhY2tldCBjYW4gYmUgcm91dGVkIHRvIGRpZmZlcmVudCBpbnN0YW5jZXMgdGhhdCBzaGFyZSBhIHN0YXRpYyBrZXkgLS0gZm9yIGV4YW1wbGUsIGJ5IGNoYW5naW5nIGFuIElQIGFkZHJlc3Mgb3IgcG9ydCAtLSB0aGVuIGFuIGF0dGFja2VyIGNhbiBjYXVzZSB0aGUgc2VydmVyIHRvIHNlbmQgYSBzdGF0ZWxlc3MgcmVzZXQuIFRvIGRlZmVuZCBhZ2FpbnN0IHRoaXMgc3R5bGUgb2YgZGVuaWFsIG9mIHNlcnZpY2UsIGVuZHBvaW50cyB0aGF0IHNoYXJlIGEgc3RhdGljIGtleSBmb3Igc3RhdGVsZXNzIHJlc2V0cyAoc2VlIFNlY3Rpb24gMTAuMy4yKSBNVVNUIGJlIGFycmFuZ2VkIHNvIHRoYXQgcGFja2V0cyB3aXRoIGEgZ2l2ZW4gY29ubmVjdGlvbiBJRCBhbHdheXMgYXJyaXZlIGF0IGFuIGluc3RhbmNlIHRoYXQgaGFzIGNvbm5lY3Rpb24gc3RhdGUsIHVubGVzcyB0aGF0IGNvbm5lY3Rpb24gaXMgbm8gbG9uZ2VyIGFjdGl2ZS4gTW9yZSBnZW5lcmFsbHksIHNlcnZlcnMgTVVTVCBOT1QgZ2VuZXJhdGUgYSBzdGF0ZWxlc3MgcmVzZXQgaWYgYSBjb25uZWN0aW9uIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgY29ubmVjdGlvbiBJRCBjb3VsZCBiZSBhY3RpdmUgb24gYW55IGVuZHBvaW50IHVzaW5nIHRoZSBzYW1lIHN0YXRpYyBrZXkuIEluIHRoZSBjYXNlIG9mIGEgY2x1c3RlciB0aGF0IHVzZXMgZHluYW1pYyBsb2FkIGJhbGFuY2luZywgaXQgaXMgcG9zc2libGUgdGhhdCBhIGNoYW5nZSBpbiBsb2FkLWJhbGFuY2VyIGNvbmZpZ3VyYXRpb24gY291bGQgb2NjdXIgd2hpbGUgYW4gYWN0aXZlIGluc3RhbmNlIHJldGFpbnMgY29ubmVjdGlvbiBzdGF0ZS4gRXZlbiBpZiBhbiBpbnN0YW5jZSByZXRhaW5zIGNvbm5lY3Rpb24gc3RhdGUsIHRoZSBjaGFuZ2UgaW4gcm91dGluZyBhbmQgcmVzdWx0aW5nIHN0YXRlbGVzcyByZXNldCB3aWxsIHJlc3VsdCBpbiB0aGUgY29ubmVjdGlvbiBiZWluZyB0ZXJtaW5hdGVkLiBJZiB0aGVyZSBpcyBubyBjaGFuY2Ugb2YgdGhlIHBhY2tldCBiZWluZyByb3V0ZWQgdG8gdGhlIGNvcnJlY3QgaW5zdGFuY2UsIGl0IGlzIGJldHRlciB0byBzZW5kIGEgc3RhdGVsZXNzIHJlc2V0IHRoYW4gd2FpdCBmb3IgdGhlIGNvbm5lY3Rpb24gdG8gdGltZSBvdXQuIEhvd2V2ZXIsIHRoaXMgaXMgYWNjZXB0YWJsZSBvbmx5IGlmIHRoZSByb3V0aW5nIGNhbm5vdCBiZSBpbmZsdWVuY2VkIGJ5IGFuIGF0dGFja2VyLiAyMS4xMi4gVmVyc2lvbiBEb3duZ3JhZGUgVGhpcyBkb2N1bWVudCBkZWZpbmVzIFFVSUMgVmVyc2lvbiBOZWdvdGlhdGlvbiBwYWNrZXRzIChTZWN0aW9uIDYpLCB3aGljaCBjYW4gYmUgdXNlZCB0byBuZWdvdGlhdGUgdGhlIFFVSUMgdmVyc2lvbiB1c2VkIGJldHdlZW4gdHdvIGVuZHBvaW50cy4gSG93ZXZlciwgdGhpcyBkb2N1bWVudCBkb2VzIG5vdCBzcGVjaWZ5IGhvdyB0aGlzIG5lZ290aWF0aW9uIHdpbGwgYmUgcGVyZm9ybWVkIGJldHdlZW4gdGhpcyB2ZXJzaW9uIGFuZCBzdWJzZXF1ZW50IGZ1dHVyZSB2ZXJzaW9ucy4gSW4gcGFydGljdWxhciwgVmVyc2lvbiBOZWdvdGlhdGlvbiBwYWNrZXRzIGRvIG5vdCBjb250YWluIGFueSBtZWNoYW5pc20gdG8gcHJldmVudCB2ZXJzaW9uIGRvd25ncmFkZSBhdHRhY2tzLiBGdXR1cmUgdmVyc2lvbnMgb2YgUVVJQyB0aGF0IHVzZSBWZXJzaW9uIE5lZ290aWF0aW9uIHBhY2tldHMgTVVTVCBkZWZpbmUgYSBtZWNoYW5pc20gdGhhdCBpcyByb2J1c3QgYWdhaW5zdCB2ZXJzaW9uIGRvd25ncmFkZSBhdHRhY2tzLiAyMS4xMy4gVGFyZ2V0ZWQgQXR0YWNrcyBieSBSb3V0aW5nIERlcGxveW1lbnRzIHNob3VsZCBsaW1pdCB0aGUgYWJpbGl0eSBvZiBhbiBhdHRhY2tlciB0byB0YXJnZXQgYSBuZXcgY29ubmVjdGlvbiB0byBhIHBhcnRpY3VsYXIgc2VydmVyIGluc3RhbmNlLiBJZGVhbGx5LCByb3V0aW5nIGRlY2lzaW9ucyBhcmUgbWFkZSBpbmRlcGVuZGVudGx5IG9mIGNsaWVudC1zZWxlY3RlZCB2YWx1ZXMsIGluY2x1ZGluZyBhZGRyZXNzZXMuIE9uY2UgYW4gaW5zdGFuY2UgaXMgc2VsZWN0ZWQsIGEgY29ubmVjdGlvbiBJRCBjYW4gYmUgc2VsZWN0ZWQgc28gdGhhdCBsYXRlciBwYWNrZXRzIGFyZSByb3V0ZWQgdG8gdGhlIHNhbWUgaW5zdGFuY2UuIDIxLjE0LiBUcmFmZmljIEFuYWx5c2lzIFRoZSBsZW5ndGggb2YgUVVJQyBwYWNrZXRzIGNhbiByZXZlYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxlbmd0aCBvZiB0aGUgY29udGVudCBvZiB0aG9zZSBwYWNrZXRzLiBUaGUgUEFERElORyBmcmFtZSBpcyBwcm92aWRlZCBzbyB0aGF0IGVuZHBvaW50cyBoYXZlIHNvbWUgYWJpbGl0eSB0byBvYnNjdXJlIHRoZSBsZW5ndGggb2YgcGFja2V0IGNvbnRlbnQ7IHNlZSBTZWN0aW9uIDE5LjEuIERlZmVhdGluZyB0cmFmZmljIGFuYWx5c2lzIGlzIGNoYWxsZW5naW5nIGFuZCB0aGUgc3ViamVjdCBvZiBhY3RpdmUgcmVzZWFyY2guIExlbmd0aCBpcyBub3QgdGhlIG9ubHkgd2F5IHRoYXQgaW5mb3JtYXRpb24gbWlnaHQgbGVhay4gRW5kcG9pbnRzIG1pZ2h0IGFsc28gcmV2ZWFsIHNlbnNpdGl2ZSBpbmZvcm1hdGlvbiB0aHJvdWdoIG90aGVyIHNpZGUgY2hhbm5lbHMsIHN1Y2ggYXMgdGhlIHRpbWluZyBvZiBwYWNrZXRzLiAyMi4gSUFOQSBDb25zaWRlcmF0aW9ucyBUaGlzIGRvY3VtZW50IGVzdGFibGlzaGVzIHNldmVyYWwgcmVnaXN0cmllcyBmb3IgdGhlIG1hbmFnZW1lbnQgb2YgY29kZXBvaW50cyBpbiBRVUlDLiBUaGVzZSByZWdpc3RyaWVzIG9wZXJhdGUgb24gYSBjb21tb24gc2V0IG9mIHBvbGljaWVzIGFzIGRlZmluZWQgaW4gU2VjdGlvbiAyMi4xLiAyMi4xLiBSZWdpc3RyYXRpb24gUG9saWNpZXMgZm9yIFFVSUMgUmVnaXN0cmllcyBBbGwgUVVJQyByZWdpc3RyaWVzIGFsbG93IGZvciBib3RoIHByb3Zpc2lvbmFsIGFuZCBwZXJtYW5lbnQgcmVnaXN0cmF0aW9uIG9mIGNvZGVwb2ludHMuIFRoaXMgc2VjdGlvbiBkb2N1bWVudHMgcG9saWNpZXMgdGhhdCBhcmUgY29tbW9uIHRvIHRoZXNlIHJlZ2lzdHJpZXMuIDIyLjEuMS4gUHJvdmlzaW9uYWwgUmVnaXN0cmF0aW9ucyBQcm92aXNpb25hbCByZWdpc3RyYXRpb25zIG9mIGNvZGVwb2ludHMgYXJlIGludGVuZGVkIHRvIGFsbG93IGZvciBwcml2YXRlIHVzZSBhbmQgZXhwZXJpbWVudGF0aW9uIHdpdGggZXh0ZW5zaW9ucyB0byBRVUlDLiBQcm92aXNpb25hbCByZWdpc3RyYXRpb25zIG9ubHkgcmVxdWlyZSB0aGUgaW5jbHVzaW9uIG9mIHRoZSBjb2RlcG9pbnQgdmFsdWUgYW5kIGNvbnRhY3QgaW5mb3JtYXRpb24uIEhvd2V2ZXIsIHByb3Zpc2lvbmFsIHJlZ2lzdHJhdGlvbnMgY291bGQgYmUgcmVjbGFpbWVkIGFuZCByZWFzc2lnbmVkIGZvciBhbm90aGVyIHB1cnBvc2UuIFByb3Zpc2lvbmFsIHJlZ2lzdHJhdGlvbnMgcmVxdWlyZSBFeHBlcnQgUmV2aWV3LCBhcyBkZWZpbmVkIGluIFNlY3Rpb24gNC41IG9mIFtSRkM4MTI2XS4gVGhlIGRlc2lnbmF0ZWQgZXhwZXJ0IG9yIGV4cGVydHMgYXJlIGFkdmlzZWQgdGhhdCBvbmx5IHJlZ2lzdHJhdGlvbnMgZm9yIGFuIGV4Y2Vzc2l2ZSBwcm9wb3J0aW9uIG9mIHJlbWFpbmluZyBjb2RlcG9pbnQgc3BhY2Ugb3IgdGhlIHZlcnkgZmlyc3QgdW5hc3NpZ25lZCB2YWx1ZSAoc2VlIFNlY3Rpb24gMjIuMS4yKSBjYW4gYmUgcmVqZWN0ZWQuIFByb3Zpc2lvbmFsIHJlZ2lzdHJhdGlvbnMgd2lsbCBpbmNsdWRlIGEgRGF0ZSBmaWVsZCB0aGF0IGluZGljYXRlcyB3aGVuIHRoZSByZWdpc3RyYXRpb24gd2FzIGxhc3QgdXBkYXRlZC4gQSByZXF1ZXN0IHRvIHVwZGF0ZSB0aGUgZGF0ZSBvbiBhbnkgcHJvdmlzaW9uYWwgcmVnaXN0cmF0aW9uIGNhbiBiZSBtYWRlIHdpdGhvdXQgcmV2aWV3IGZyb20gdGhlIGRlc2lnbmF0ZWQgZXhwZXJ0KHMpLiBBbGwgUVVJQyByZWdpc3RyaWVzIGluY2x1ZGUgdGhlIGZvbGxvd2luZyBmaWVsZHMgdG8gc3VwcG9ydCBwcm92aXNpb25hbCByZWdpc3RyYXRpb246IFZhbHVlOiBUaGUgYXNzaWduZWQgY29kZXBvaW50LiBTdGF0dXM6ICJwZXJtYW5lbnQiIG9yICJwcm92aXNpb25hbCIuIFNwZWNpZmljYXRpb246IEEgcmVmZXJlbmNlIHRvIGEgcHVibGljbHkgYXZhaWxhYmxlIHNwZWNpZmljYXRpb24gZm9yIHRoZSB2YWx1ZS4gRGF0ZTogVGhlIGRhdGUgb2YgdGhlIGxhc3QgdXBkYXRlIHRvIHRoZSByZWdpc3RyYXRpb24uIENoYW5nZSBDb250cm9sbGVyOiBUaGUgZW50aXR5IHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIHRoZSBkZWZpbml0aW9uIG9mIHRoZSByZWdpc3RyYXRpb24uIENvbnRhY3Q6IENvbnRhY3QgZGV0YWlscyBmb3IgdGhlIHJlZ2lzdHJhbnQuIE5vdGVzOiBTdXBwbGVtZW50YXJ5IG5vdGVzIGFib3V0IHRoZSByZWdpc3RyYXRpb24uIFByb3Zpc2lvbmFsIHJlZ2lzdHJhdGlvbnMgTUFZIG9taXQgdGhlIFNwZWNpZmljYXRpb24gYW5kIE5vdGVzIGZpZWxkcywgcGx1cyBhbnkgYWRkaXRpb25hbCBmaWVsZHMgdGhhdCBtaWdodCBiZSByZXF1aXJlZCBmb3IgYSBwZXJtYW5lbnQgcmVnaXN0cmF0aW9uLiBUaGUgRGF0ZSBmaWVsZCBpcyBub3QgcmVxdWlyZWQgYXMgcGFydCBvZiByZXF1ZXN0aW5nIGEgcmVnaXN0cmF0aW9uLCBhcyBpdCBpcyBzZXQgdG8gdGhlIGRhdGUgdGhlIHJlZ2lzdHJhdGlvbiBpcyBjcmVhdGVkIG9yIHVwZGF0ZWQuIDIyLjEuMi4gU2VsZWN0aW5nIENvZGVwb2ludHMgTmV3IHJlcXVlc3RzIGZvciBjb2RlcG9pbnRzIGZyb20gUVVJQyByZWdpc3RyaWVzIFNIT1VMRCB1c2UgYSByYW5kb21seSBzZWxlY3RlZCBjb2RlcG9pbnQgdGhhdCBleGNsdWRlcyBib3RoIGV4aXN0aW5nIGFsbG9jYXRpb25zIGFuZCB0aGUgZmlyc3QgdW5hbGxvY2F0ZWQgY29kZXBvaW50IGluIHRoZSBzZWxlY3RlZCBzcGFjZS4gUmVxdWVzdHMgZm9yIG11bHRpcGxlIGNvZGVwb2ludHMgTUFZIHVzZSBhIGNvbnRpZ3VvdXMgcmFuZ2UuIFRoaXMgbWluaW1pemVzIHRoZSByaXNrIHRoYXQgZGlmZmVyaW5nIHNlbWFudGljcyBhcmUgYXR0cmlidXRlZCB0byB0aGUgc2FtZSBjb2RlcG9pbnQgYnkgZGlmZmVyZW50IGltcGxlbWVudGF0aW9ucy4gVGhlIHVzZSBvZiB0aGUgZmlyc3QgdW5hc3NpZ25lZCBjb2RlcG9pbnQgaXMgcmVzZXJ2ZWQgZm9yIGFsbG9jYXRpb24gdXNpbmcgdGhlIFN0YW5kYXJkcyBBY3Rpb24gcG9saWN5OyBzZWUgU2VjdGlvbiA0Ljkgb2YgW1JGQzgxMjZdLiBUaGUgZWFybHkgY29kZXBvaW50IGFzc2lnbm1lbnQgcHJvY2VzcyBbRUFSTFktQVNTSUdOXSBjYW4gYmUgdXNlZCBmb3IgdGhlc2UgdmFsdWVzLiBGb3IgY29kZXBvaW50cyB0aGF0IGFyZSBlbmNvZGVkIGluIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VycyAoU2VjdGlvbiAxNiksIHN1Y2ggYXMgZnJhbWUgdHlwZXMsIGNvZGVwb2ludHMgdGhhdCBlbmNvZGUgdG8gZm91ciBvciBlaWdodCBieXRlcyAodGhhdCBpcywgdmFsdWVzIDJeMTQgYW5kIGFib3ZlKSBTSE9VTEQgYmUgdXNlZCB1bmxlc3MgdGhlIHVzYWdlIGlzIGVzcGVjaWFsbHkgc2Vuc2l0aXZlIHRvIGhhdmluZyBhIGxvbmdlciBlbmNvZGluZy4gQXBwbGljYXRpb25zIHRvIHJlZ2lzdGVyIGNvZGVwb2ludHMgaW4gUVVJQyByZWdpc3RyaWVzIE1BWSBpbmNsdWRlIGEgcmVxdWVzdGVkIGNvZGVwb2ludCBhcyBwYXJ0IG9mIHRoZSByZWdpc3RyYXRpb24uIElBTkEgTVVTVCBhbGxvY2F0ZSB0aGUgc2VsZWN0ZWQgY29kZXBvaW50IGlmIHRoZSBjb2RlcG9pbnQgaXMgdW5hc3NpZ25lZCBhbmQgdGhlIHJlcXVpcmVtZW50cyBvZiB0aGUgcmVnaXN0cmF0aW9uIHBvbGljeSBhcmUgbWV0LiAyMi4xLjMuIFJlY2xhaW1pbmcgUHJvdmlzaW9uYWwgQ29kZXBvaW50cyBBIHJlcXVlc3QgbWlnaHQgYmUgbWFkZSB0byByZW1vdmUgYW4gdW51c2VkIHByb3Zpc2lvbmFsIHJlZ2lzdHJhdGlvbiBmcm9tIHRoZSByZWdpc3RyeSB0byByZWNsYWltIHNwYWNlIGluIGEgcmVnaXN0cnksIG9yIGEgcG9ydGlvbiBvZiB0aGUgcmVnaXN0cnkgKHN1Y2ggYXMgdGhlIDY0LTE2MzgzIHJhbmdlIGZvciBjb2RlcG9pbnRzIHRoYXQgdXNlIHZhcmlhYmxlLWxlbmd0aCBlbmNvZGluZ3MpLiBUaGlzIFNIT1VMRCBiZSBkb25lIG9ubHkgZm9yIHRoZSBjb2RlcG9pbnRzIHdpdGggdGhlIGVhcmxpZXN0IHJlY29yZGVkIGRhdGUsIGFuZCBlbnRyaWVzIHRoYXQgaGF2ZSBiZWVuIHVwZGF0ZWQgbGVzcyB0aGFuIGEgeWVhciBwcmlvciBTSE9VTEQgTk9UIGJlIHJlY2xhaW1lZC4gQSByZXF1ZXN0IHRvIHJlbW92ZSBhIGNvZGVwb2ludCBNVVNUIGJlIHJldmlld2VkIGJ5IHRoZSBkZXNpZ25hdGVkIGV4cGVydHMuIFRoZSBleHBlcnRzIE1VU1QgYXR0ZW1wdCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgY29kZXBvaW50IGlzIHN0aWxsIGluIHVzZS4gRXhwZXJ0cyBhcmUgYWR2aXNlZCB0byBjb250YWN0IHRoZSBsaXN0ZWQgY29udGFjdHMgZm9yIHRoZSByZWdpc3RyYXRpb24sIHBsdXMgYXMgd2lkZSBhIHNldCBvZiBwcm90b2NvbCBpbXBsZW1lbnRlcnMgYXMgcG9zc2libGUgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYW55IHVzZSBvZiB0aGUgY29kZXBvaW50IGlzIGtub3duLiBUaGUgZXhwZXJ0cyBhcmUgYWxzbyBhZHZpc2VkIHRvIGFsbG93IGF0IGxlYXN0IGZvdXIgd2Vla3MgZm9yIHJlc3BvbnNlcy4gSWYgYW55IHVzZSBvZiB0aGUgY29kZXBvaW50cyBpcyBpZGVudGlmaWVkIGJ5IHRoaXMgc2VhcmNoIG9yIGEgcmVxdWVzdCB0byB1cGRhdGUgdGhlIHJlZ2lzdHJhdGlvbiBpcyBtYWRlLCB0aGUgY29kZXBvaW50IE1VU1QgTk9UIGJlIHJlY2xhaW1lZC4gSW5zdGVhZCwgdGhlIGRhdGUgb24gdGhlIHJlZ2lzdHJhdGlvbiBpcyB1cGRhdGVkLiBBIG5vdGUgbWlnaHQgYmUgYWRkZWQgZm9yIHRoZSByZWdpc3RyYXRpb24gcmVjb3JkaW5nIHJlbGV2YW50IGluZm9ybWF0aW9uIHRoYXQgd2FzIGxlYXJuZWQuIElmIG5vIHVzZSBvZiB0aGUgY29kZXBvaW50IHdhcyBpZGVudGlmaWVkIGFuZCBubyByZXF1ZXN0IHdhcyBtYWRlIHRvIHVwZGF0ZSB0aGUgcmVnaXN0cmF0aW9uLCB0aGUgY29kZXBvaW50IE1BWSBiZSByZW1vdmVkIGZyb20gdGhlIHJlZ2lzdHJ5LiBUaGlzIHJldmlldyBhbmQgY29uc3VsdGF0aW9uIHByb2Nlc3MgYWxzbyBhcHBsaWVzIHRvIHJlcXVlc3RzIHRvIGNoYW5nZSBhIHByb3Zpc2lvbmFsIHJlZ2lzdHJhdGlvbiBpbnRvIGEgcGVybWFuZW50IHJlZ2lzdHJhdGlvbiwgZXhjZXB0IHRoYXQgdGhlIGdvYWwgaXMgbm90IHRvIGRldGVybWluZSB3aGV0aGVyIHRoZXJlIGlzIG5vIHVzZSBvZiB0aGUgY29kZXBvaW50IGJ1dCB0byBkZXRlcm1pbmUgdGhhdCB0aGUgcmVnaXN0cmF0aW9uIGlzIGFuIGFjY3VyYXRlIHJlcHJlc2VudGF0aW9uIG9mIGFueSBkZXBsb3llZCB1c2FnZS4gMjIuMS40LiBQZXJtYW5lbnQgUmVnaXN0cmF0aW9ucyBQZXJtYW5lbnQgcmVnaXN0cmF0aW9ucyBpbiBRVUlDIHJlZ2lzdHJpZXMgdXNlIHRoZSBTcGVjaWZpY2F0aW9uIFJlcXVpcmVkIHBvbGljeSAoU2VjdGlvbiA0LjYgb2YgW1JGQzgxMjZdKSwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuIFRoZSBkZXNpZ25hdGVkIGV4cGVydCBvciBleHBlcnRzIHZlcmlmeSB0aGF0IGEgc3BlY2lmaWNhdGlvbiBleGlzdHMgYW5kIGlzIHJlYWRpbHkgYWNjZXNzaWJsZS4gRXhwZXJ0cyBhcmUgZW5jb3VyYWdlZCB0byBiZSBiaWFzZWQgdG93YXJkcyBhcHByb3ZpbmcgcmVnaXN0cmF0aW9ucyB1bmxlc3MgdGhleSBhcmUgYWJ1c2l2ZSwgZnJpdm9sb3VzLCBvciBhY3RpdmVseSBoYXJtZnVsIChub3QgbWVyZWx5IGFlc3RoZXRpY2FsbHkgZGlzcGxlYXNpbmcgb3IgYXJjaGl0ZWN0dXJhbGx5IGR1YmlvdXMpLiBUaGUgY3JlYXRpb24gb2YgYSByZWdpc3RyeSBNQVkgc3BlY2lmeSBhZGRpdGlvbmFsIGNvbnN0cmFpbnRzIG9uIHBlcm1hbmVudCByZWdpc3RyYXRpb25zLiBUaGUgY3JlYXRpb24gb2YgYSByZWdpc3RyeSBNQVkgaWRlbnRpZnkgYSByYW5nZSBvZiBjb2RlcG9pbnRzIHdoZXJlIHJlZ2lzdHJhdGlvbnMgYXJlIGdvdmVybmVkIGJ5IGEgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBwb2xpY3kuIEZvciBpbnN0YW5jZSwgdGhlICJRVUlDIEZyYW1lIFR5cGVzIiByZWdpc3RyeSAoU2VjdGlvbiAyMi40KSBoYXMgYSBzdHJpY3RlciBwb2xpY3kgZm9yIGNvZGVwb2ludHMgaW4gdGhlIHJhbmdlIGZyb20gMCB0byA2My4gQW55IHN0cmljdGVyIHJlcXVpcmVtZW50cyBmb3IgcGVybWFuZW50IHJlZ2lzdHJhdGlvbnMgZG8gbm90IHByZXZlbnQgcHJvdmlzaW9uYWwgcmVnaXN0cmF0aW9ucyBmb3IgYWZmZWN0ZWQgY29kZXBvaW50cy4gRm9yIGluc3RhbmNlLCBhIHByb3Zpc2lvbmFsIHJlZ2lzdHJhdGlvbiBmb3IgYSBmcmFtZSB0eXBlIG9mIDYxIGNvdWxkIGJlIHJlcXVlc3RlZC4gQWxsIHJlZ2lzdHJhdGlvbnMgbWFkZSBieSBTdGFuZGFyZHMgVHJhY2sgcHVibGljYXRpb25zIE1VU1QgYmUgcGVybWFuZW50LiBBbGwgcmVnaXN0cmF0aW9ucyBpbiB0aGlzIGRvY3VtZW50IGFyZSBhc3NpZ25lZCBhIHBlcm1hbmVudCBzdGF0dXMgYW5kIGxpc3QgYSBjaGFuZ2UgY29udHJvbGxlciBvZiB0aGUgSUVURiBhbmQgYSBjb250YWN0IG9mIHRoZSBRVUlDIFdvcmtpbmcgR3JvdXAgKHF1aWNAaWV0Zi5vcmcpLiAyMi4yLiBRVUlDIFZlcnNpb25zIFJlZ2lzdHJ5IElBTkEgaGFzIGFkZGVkIGEgcmVnaXN0cnkgZm9yICJRVUlDIFZlcnNpb25zIiB1bmRlciBhICJRVUlDIiBoZWFkaW5nLiBUaGUgIlFVSUMgVmVyc2lvbnMiIHJlZ2lzdHJ5IGdvdmVybnMgYSAzMi1iaXQgc3BhY2U7IHNlZSBTZWN0aW9uIDE1LiBUaGlzIHJlZ2lzdHJ5IGZvbGxvd3MgdGhlIHJlZ2lzdHJhdGlvbiBwb2xpY3kgZnJvbSBTZWN0aW9uIDIyLjEuIFBlcm1hbmVudCByZWdpc3RyYXRpb25zIGluIHRoaXMgcmVnaXN0cnkgYXJlIGFzc2lnbmVkIHVzaW5nIHRoZSBTcGVjaWZpY2F0aW9uIFJlcXVpcmVkIHBvbGljeSAoU2VjdGlvbiA0LjYgb2YgW1JGQzgxMjZdKS4gVGhlIGNvZGVwb2ludCBvZiAweDAwMDAwMDAxIGZvciB0aGUgcHJvdG9jb2wgaXMgYXNzaWduZWQgd2l0aCBwZXJtYW5lbnQgc3RhdHVzIHRvIHRoZSBwcm90b2NvbCBkZWZpbmVkIGluIHRoaXMgZG9jdW1lbnQuIFRoZSBjb2RlcG9pbnQgb2YgMHgwMDAwMDAwMCBpcyBwZXJtYW5lbnRseSByZXNlcnZlZDsgdGhlIG5vdGUgZm9yIHRoaXMgY29kZXBvaW50IGluZGljYXRlcyB0aGF0IHRoaXMgdmVyc2lvbiBpcyByZXNlcnZlZCBmb3IgdmVyc2lvbiBuZWdvdGlhdGlvbi4gQWxsIGNvZGVwb2ludHMgdGhhdCBmb2xsb3cgdGhlIHBhdHRlcm4gMHg/YT9hP2E/YSBhcmUgcmVzZXJ2ZWQsIE1VU1QgTk9UIGJlIGFzc2lnbmVkIGJ5IElBTkEsIGFuZCBNVVNUIE5PVCBhcHBlYXIgaW4gdGhlIGxpc3Rpbmcgb2YgYXNzaWduZWQgdmFsdWVzLiAyMi4zLiBRVUlDIFRyYW5zcG9ydCBQYXJhbWV0ZXJzIFJlZ2lzdHJ5IElBTkEgaGFzIGFkZGVkIGEgcmVnaXN0cnkgZm9yICJRVUlDIFRyYW5zcG9ydCBQYXJhbWV0ZXJzIiB1bmRlciBhICJRVUlDIiBoZWFkaW5nLiBUaGUgIlFVSUMgVHJhbnNwb3J0IFBhcmFtZXRlcnMiIHJlZ2lzdHJ5IGdvdmVybnMgYSA2Mi1iaXQgc3BhY2UuIFRoaXMgcmVnaXN0cnkgZm9sbG93cyB0aGUgcmVnaXN0cmF0aW9uIHBvbGljeSBmcm9tIFNlY3Rpb24gMjIuMS4gUGVybWFuZW50IHJlZ2lzdHJhdGlvbnMgaW4gdGhpcyByZWdpc3RyeSBhcmUgYXNzaWduZWQgdXNpbmcgdGhlIFNwZWNpZmljYXRpb24gUmVxdWlyZWQgcG9saWN5IChTZWN0aW9uIDQuNiBvZiBbUkZDODEyNl0pLCBleGNlcHQgZm9yIHZhbHVlcyBiZXR3ZWVuIDB4MDAgYW5kIDB4M2YgKGluIGhleGFkZWNpbWFsKSwgaW5jbHVzaXZlLCB3aGljaCBhcmUgYXNzaWduZWQgdXNpbmcgU3RhbmRhcmRzIEFjdGlvbiBvciBJRVNHIEFwcHJvdmFsIGFzIGRlZmluZWQgaW4gU2VjdGlvbnMgNC45IGFuZCA0LjEwIG9mIFtSRkM4MTI2XS4gSW4gYWRkaXRpb24gdG8gdGhlIGZpZWxkcyBsaXN0ZWQgaW4gU2VjdGlvbiAyMi4xLjEsIHBlcm1hbmVudCByZWdpc3RyYXRpb25zIGluIHRoaXMgcmVnaXN0cnkgTVVTVCBpbmNsdWRlIHRoZSBmb2xsb3dpbmcgZmllbGQ6IFBhcmFtZXRlciBOYW1lOiBBIHNob3J0IG1uZW1vbmljIGZvciB0aGUgcGFyYW1ldGVyLiBUaGUgaW5pdGlhbCBjb250ZW50cyBvZiB0aGlzIHJlZ2lzdHJ5IGFyZSBzaG93biBpbiBUYWJsZSA2LiArPT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PSsgfCBWYWx1ZSB8IFBhcmFtZXRlciBOYW1lIHwgU3BlY2lmaWNhdGlvbiB8ICs9PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09KyB8IDB4MDAgfCBvcmlnaW5hbF9kZXN0aW5hdGlvbl9jb25uZWN0aW9uX2lkIHwgU2VjdGlvbiAxOC4yIHwgKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rIHwgMHgwMSB8IG1heF9pZGxlX3RpbWVvdXQgfCBTZWN0aW9uIDE4LjIgfCArLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSsgfCAweDAyIHwgc3RhdGVsZXNzX3Jlc2V0X3Rva2VuIHwgU2VjdGlvbiAxOC4yIHwgKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rIHwgMHgwMyB8IG1heF91ZHBfcGF5bG9hZF9zaXplIHwgU2VjdGlvbiAxOC4yIHwgKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rIHwgMHgwNCB8IGluaXRpYWxfbWF4X2RhdGEgfCBTZWN0aW9uIDE4LjIgfCArLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSsgfCAweDA1IHwgaW5pdGlhbF9tYXhfc3RyZWFtX2RhdGFfYmlkaV9sb2NhbCB8IFNlY3Rpb24gMTguMiB8ICstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKyB8IDB4MDYgfCBpbml0aWFsX21heF9zdHJlYW1fZGF0YV9iaWRpX3JlbW90ZSB8IFNlY3Rpb24gMTguMiB8ICstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKyB8IDB4MDcgfCBpbml0aWFsX21heF9zdHJlYW1fZGF0YV91bmkgfCBTZWN0aW9uIDE4LjIgfCArLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSsgfCAweDA4IHwgaW5pdGlhbF9tYXhfc3RyZWFtc19iaWRpIHwgU2VjdGlvbiAxOC4yIHwgKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rIHwgMHgwOSB8IGluaXRpYWxfbWF4X3N0cmVhbXNfdW5pIHwgU2VjdGlvbiAxOC4yIHwgKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rIHwgMHgwYSB8IGFja19kZWxheV9leHBvbmVudCB8IFNlY3Rpb24gMTguMiB8ICstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKyB8IDB4MGIgfCBtYXhfYWNrX2RlbGF5IHwgU2VjdGlvbiAxOC4yIHwgKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rIHwgMHgwYyB8IGRpc2FibGVfYWN0aXZlX21pZ3JhdGlvbiB8IFNlY3Rpb24gMTguMiB8ICstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKyB8IDB4MGQgfCBwcmVmZXJyZWRfYWRkcmVzcyB8IFNlY3Rpb24gMTguMiB8ICstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKyB8IDB4MGUgfCBhY3RpdmVfY29ubmVjdGlvbl9pZF9saW1pdCB8IFNlY3Rpb24gMTguMiB8ICstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKyB8IDB4MGYgfCBpbml0aWFsX3NvdXJjZV9jb25uZWN0aW9uX2lkIHwgU2VjdGlvbiAxOC4yIHwgKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rIHwgMHgxMCB8IHJldHJ5X3NvdXJjZV9jb25uZWN0aW9uX2lkIHwgU2VjdGlvbiAxOC4yIHwgKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rIFRhYmxlIDY6IEluaXRpYWwgUVVJQyBUcmFuc3BvcnQgUGFyYW1ldGVycyBSZWdpc3RyeSBFbnRyaWVzIEVhY2ggdmFsdWUgb2YgdGhlIGZvcm0gIjMxICogTiArIDI3IiBmb3IgaW50ZWdlciB2YWx1ZXMgb2YgTiAodGhhdCBpcywgMjcsIDU4LCA4OSwgLi4uKSBhcmUgcmVzZXJ2ZWQ7IHRoZXNlIHZhbHVlcyBNVVNUIE5PVCBiZSBhc3NpZ25lZCBieSBJQU5BIGFuZCBNVVNUIE5PVCBhcHBlYXIgaW4gdGhlIGxpc3Rpbmcgb2YgYXNzaWduZWQgdmFsdWVzLiAyMi40LiBRVUlDIEZyYW1lIFR5cGVzIFJlZ2lzdHJ5IElBTkEgaGFzIGFkZGVkIGEgcmVnaXN0cnkgZm9yICJRVUlDIEZyYW1lIFR5cGVzIiB1bmRlciBhICJRVUlDIiBoZWFkaW5nLiBUaGUgIlFVSUMgRnJhbWUgVHlwZXMiIHJlZ2lzdHJ5IGdvdmVybnMgYSA2Mi1iaXQgc3BhY2UuIFRoaXMgcmVnaXN0cnkgZm9sbG93cyB0aGUgcmVnaXN0cmF0aW9uIHBvbGljeSBmcm9tIFNlY3Rpb24gMjIuMS4gUGVybWFuZW50IHJlZ2lzdHJhdGlvbnMgaW4gdGhpcyByZWdpc3RyeSBhcmUgYXNzaWduZWQgdXNpbmcgdGhlIFNwZWNpZmljYXRpb24gUmVxdWlyZWQgcG9saWN5IChTZWN0aW9uIDQuNiBvZiBbUkZDODEyNl0pLCBleGNlcHQgZm9yIHZhbHVlcyBiZXR3ZWVuIDB4MDAgYW5kIDB4M2YgKGluIGhleGFkZWNpbWFsKSwgaW5jbHVzaXZlLCB3aGljaCBhcmUgYXNzaWduZWQgdXNpbmcgU3RhbmRhcmRzIEFjdGlvbiBvciBJRVNHIEFwcHJvdmFsIGFzIGRlZmluZWQgaW4gU2VjdGlvbnMgNC45IGFuZCA0LjEwIG9mIFtSRkM4MTI2XS4gSW4gYWRkaXRpb24gdG8gdGhlIGZpZWxkcyBsaXN0ZWQgaW4gU2VjdGlvbiAyMi4xLjEsIHBlcm1hbmVudCByZWdpc3RyYXRpb25zIGluIHRoaXMgcmVnaXN0cnkgTVVTVCBpbmNsdWRlIHRoZSBmb2xsb3dpbmcgZmllbGQ6IEZyYW1lIFR5cGUgTmFtZTogQSBzaG9ydCBtbmVtb25pYyBmb3IgdGhlIGZyYW1lIHR5cGUuIEluIGFkZGl0aW9uIHRvIHRoZSBhZHZpY2UgaW4gU2VjdGlvbiAyMi4xLCBzcGVjaWZpY2F0aW9ucyBmb3IgbmV3IHBlcm1hbmVudCByZWdpc3RyYXRpb25zIFNIT1VMRCBkZXNjcmliZSB0aGUgbWVhbnMgYnkgd2hpY2ggYW4gZW5kcG9pbnQgbWlnaHQgZGV0ZXJtaW5lIHRoYXQgaXQgY2FuIHNlbmQgdGhlIGlkZW50aWZpZWQgdHlwZSBvZiBmcmFtZS4gQW4gYWNjb21wYW55aW5nIHRyYW5zcG9ydCBwYXJhbWV0ZXIgcmVnaXN0cmF0aW9uIGlzIGV4cGVjdGVkIGZvciBtb3N0IHJlZ2lzdHJhdGlvbnM7IHNlZSBTZWN0aW9uIDIyLjMuIFNwZWNpZmljYXRpb25zIGZvciBwZXJtYW5lbnQgcmVnaXN0cmF0aW9ucyBhbHNvIG5lZWQgdG8gZGVzY3JpYmUgdGhlIGZvcm1hdCBhbmQgYXNzaWduZWQgc2VtYW50aWNzIG9mIGFueSBmaWVsZHMgaW4gdGhlIGZyYW1lLiBUaGUgaW5pdGlhbCBjb250ZW50cyBvZiB0aGlzIHJlZ2lzdHJ5IGFyZSB0YWJ1bGF0ZWQgaW4gVGFibGUgMy4gTm90ZSB0aGF0IHRoZSByZWdpc3RyeSBkb2VzIG5vdCBpbmNsdWRlIHRoZSAiUGt0cyIgYW5kICJTcGVjIiBjb2x1bW5zIGZyb20gVGFibGUgMy4gMjIuNS4gUVVJQyBUcmFuc3BvcnQgRXJyb3IgQ29kZXMgUmVnaXN0cnkgSUFOQSBoYXMgYWRkZWQgYSByZWdpc3RyeSBmb3IgIlFVSUMgVHJhbnNwb3J0IEVycm9yIENvZGVzIiB1bmRlciBhICJRVUlDIiBoZWFkaW5nLiBUaGUgIlFVSUMgVHJhbnNwb3J0IEVycm9yIENvZGVzIiByZWdpc3RyeSBnb3Zlcm5zIGEgNjItYml0IHNwYWNlLiBUaGlzIHNwYWNlIGlzIHNwbGl0IGludG8gdGhyZWUgcmFuZ2VzIHRoYXQgYXJlIGdvdmVybmVkIGJ5IGRpZmZlcmVudCBwb2xpY2llcy4gUGVybWFuZW50IHJlZ2lzdHJhdGlvbnMgaW4gdGhpcyByZWdpc3RyeSBhcmUgYXNzaWduZWQgdXNpbmcgdGhlIFNwZWNpZmljYXRpb24gUmVxdWlyZWQgcG9saWN5IChTZWN0aW9uIDQuNiBvZiBbUkZDODEyNl0pLCBleGNlcHQgZm9yIHZhbHVlcyBiZXR3ZWVuIDB4MDAgYW5kIDB4M2YgKGluIGhleGFkZWNpbWFsKSwgaW5jbHVzaXZlLCB3aGljaCBhcmUgYXNzaWduZWQgdXNpbmcgU3RhbmRhcmRzIEFjdGlvbiBvciBJRVNHIEFwcHJvdmFsIGFzIGRlZmluZWQgaW4gU2VjdGlvbnMgNC45IGFuZCA0LjEwIG9mIFtSRkM4MTI2XS4gSW4gYWRkaXRpb24gdG8gdGhlIGZpZWxkcyBsaXN0ZWQgaW4gU2VjdGlvbiAyMi4xLjEsIHBlcm1hbmVudCByZWdpc3RyYXRpb25zIGluIHRoaXMgcmVnaXN0cnkgTVVTVCBpbmNsdWRlIHRoZSBmb2xsb3dpbmcgZmllbGRzOiBDb2RlOiBBIHNob3J0IG1uZW1vbmljIGZvciB0aGUgcGFyYW1ldGVyLiBEZXNjcmlwdGlvbjogQSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3IgY29kZSBzZW1hbnRpY3MsIHdoaWNoIE1BWSBiZSBhIHN1bW1hcnkgaWYgYSBzcGVjaWZpY2F0aW9uIHJlZmVyZW5jZSBpcyBwcm92aWRlZC4gVGhlIGluaXRpYWwgY29udGVudHMgb2YgdGhpcyByZWdpc3RyeSBhcmUgc2hvd24gaW4gVGFibGUgNy4gKz09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT0rIHxWYWx1ZSB8IENvZGUgfERlc2NyaXB0aW9uIHxTcGVjaWZpY2F0aW9uIHwgKz09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT0rIHwweDAwIHwgTk9fRVJST1IgfE5vIGVycm9yIHxTZWN0aW9uIDIwIHwgKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHwweDAxIHwgSU5URVJOQUxfRVJST1IgfEltcGxlbWVudGF0aW9uIHxTZWN0aW9uIDIwIHwgfCB8IHxlcnJvciB8IHwgKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHwweDAyIHwgQ09OTkVDVElPTl9SRUZVU0VEIHxTZXJ2ZXIgcmVmdXNlcyBhfFNlY3Rpb24gMjAgfCB8IHwgfGNvbm5lY3Rpb24gfCB8ICstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8MHgwMyB8IEZMT1dfQ09OVFJPTF9FUlJPUiB8RmxvdyBjb250cm9sIHxTZWN0aW9uIDIwIHwgfCB8IHxlcnJvciB8IHwgKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHwweDA0IHwgU1RSRUFNX0xJTUlUX0VSUk9SIHxUb28gbWFueSBzdHJlYW1zfFNlY3Rpb24gMjAgfCB8IHwgfG9wZW5lZCB8IHwgKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHwweDA1IHwgU1RSRUFNX1NUQVRFX0VSUk9SIHxGcmFtZSByZWNlaXZlZCB8U2VjdGlvbiAyMCB8IHwgfCB8aW4gaW52YWxpZCB8IHwgfCB8IHxzdHJlYW0gc3RhdGUgfCB8ICstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8MHgwNiB8IEZJTkFMX1NJWkVfRVJST1IgfENoYW5nZSB0byBmaW5hbCB8U2VjdGlvbiAyMCB8IHwgfCB8c2l6ZSB8IHwgKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHwweDA3IHwgRlJBTUVfRU5DT0RJTkdfRVJST1IgfEZyYW1lIGVuY29kaW5nIHxTZWN0aW9uIDIwIHwgfCB8IHxlcnJvciB8IHwgKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHwweDA4IHwgVFJBTlNQT1JUX1BBUkFNRVRFUl9FUlJPUiB8RXJyb3IgaW4gfFNlY3Rpb24gMjAgfCB8IHwgfHRyYW5zcG9ydCB8IHwgfCB8IHxwYXJhbWV0ZXJzIHwgfCArLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSsgfDB4MDkgfCBDT05ORUNUSU9OX0lEX0xJTUlUX0VSUk9SIHxUb28gbWFueSB8U2VjdGlvbiAyMCB8IHwgfCB8Y29ubmVjdGlvbiBJRHMgfCB8IHwgfCB8cmVjZWl2ZWQgfCB8ICstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8MHgwYSB8IFBST1RPQ09MX1ZJT0xBVElPTiB8R2VuZXJpYyBwcm90b2NvbHxTZWN0aW9uIDIwIHwgfCB8IHx2aW9sYXRpb24gfCB8ICstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8MHgwYiB8IElOVkFMSURfVE9LRU4gfEludmFsaWQgVG9rZW4gfFNlY3Rpb24gMjAgfCB8IHwgfHJlY2VpdmVkIHwgfCArLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSsgfDB4MGMgfCBBUFBMSUNBVElPTl9FUlJPUiB8QXBwbGljYXRpb24gfFNlY3Rpb24gMjAgfCB8IHwgfGVycm9yIHwgfCArLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSsgfDB4MGQgfCBDUllQVE9fQlVGRkVSX0VYQ0VFREVEIHxDUllQVE8gZGF0YSB8U2VjdGlvbiAyMCB8IHwgfCB8YnVmZmVyIHwgfCB8IHwgfG92ZXJmbG93ZWQgfCB8ICstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8MHgwZSB8IEtFWV9VUERBVEVfRVJST1IgfEludmFsaWQgcGFja2V0IHxTZWN0aW9uIDIwIHwgfCB8IHxwcm90ZWN0aW9uIHwgfCB8IHwgfHVwZGF0ZSB8IHwgKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHwweDBmIHwgQUVBRF9MSU1JVF9SRUFDSEVEIHxFeGNlc3NpdmUgdXNlIG9mfFNlY3Rpb24gMjAgfCB8IHwgfHBhY2tldCB8IHwgfCB8IHxwcm90ZWN0aW9uIGtleXMgfCB8ICstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8MHgxMCB8IE5PX1ZJQUJMRV9QQVRIIHxObyB2aWFibGUgfFNlY3Rpb24gMjAgfCB8IHwgfG5ldHdvcmsgcGF0aCB8IHwgfCB8IHxleGlzdHMgfCB8ICstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8MHgwMTAwLXwgQ1JZUFRPX0VSUk9SIHxUTFMgYWxlcnQgY29kZSB8U2VjdGlvbiAyMCB8IHwweDAxZmYgfCB8IHwgfCArLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSsgVGFibGUgNzogSW5pdGlhbCBRVUlDIFRyYW5zcG9ydCBFcnJvciBDb2RlcyBSZWdpc3RyeSBFbnRyaWVzIDIzLiBSZWZlcmVuY2VzIDIzLjEuIE5vcm1hdGl2ZSBSZWZlcmVuY2VzIFtCQ1AzOF0gRmVyZ3Vzb24sIFAuIGFuZCBELiBTZW5pZSwgIk5ldHdvcmsgSW5ncmVzcyBGaWx0ZXJpbmc6IERlZmVhdGluZyBEZW5pYWwgb2YgU2VydmljZSBBdHRhY2tzIHdoaWNoIGVtcGxveSBJUCBTb3VyY2UgQWRkcmVzcyBTcG9vZmluZyIsIEJDUCAzOCwgUkZDIDI4MjcsIE1heSAyMDAwLiAmbHQ7aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvaW5mby9iY3AzOCZndDsgW0RQTFBNVFVEXSBGYWlyaHVyc3QsIEcuLCBKb25lcywgVC4sIFTDvHhlbiwgTS4sIFLDvG5nZWxlciwgSS4sIGFuZCBULiBWw7Zsa2VyLCAiUGFja2V0aXphdGlvbiBMYXllciBQYXRoIE1UVSBEaXNjb3ZlcnkgZm9yIERhdGFncmFtIFRyYW5zcG9ydHMiLCBSRkMgODg5OSwgRE9JIDEwLjE3NDg3L1JGQzg4OTksIFNlcHRlbWJlciAyMDIwLCAmbHQ7aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvaW5mby9yZmM4ODk5Jmd0Oy4gW0VBUkxZLUFTU0lHTl0gQ290dG9uLCBNLiwgIkVhcmx5IElBTkEgQWxsb2NhdGlvbiBvZiBTdGFuZGFyZHMgVHJhY2sgQ29kZSBQb2ludHMiLCBCQ1AgMTAwLCBSRkMgNzEyMCwgRE9JIDEwLjE3NDg3L1JGQzcxMjAsIEphbnVhcnkgMjAxNCwgJmx0O2h0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL2luZm8vcmZjNzEyMCZndDsuIFtJUHY0XSBQb3N0ZWwsIEouLCAiSW50ZXJuZXQgUHJvdG9jb2wiLCBTVEQgNSwgUkZDIDc5MSwgRE9JIDEwLjE3NDg3L1JGQzA3OTEsIFNlcHRlbWJlciAxOTgxLCAmbHQ7aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvaW5mby9yZmM3OTEmZ3Q7LiBbUVVJQy1JTlZBUklBTlRTXSBUaG9tc29uLCBNLiwgIlZlcnNpb24tSW5kZXBlbmRlbnQgUHJvcGVydGllcyBvZiBRVUlDIiwgUkZDIDg5OTksIERPSSAxMC4xNzQ4Ny9SRkM4OTk5LCBNYXkgMjAyMSwgJmx0O2h0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL2luZm8vcmZjODk5OSZndDsuIFtRVUlDLVJFQ09WRVJZXSBJeWVuZ2FyLCBKLiwgRWQuIGFuZCBJLiBTd2V0dCwgRWQuLCAiUVVJQyBMb3NzIERldGVjdGlvbiBhbmQgQ29uZ2VzdGlvbiBDb250cm9sIiwgUkZDIDkwMDIsIERPSSAxMC4xNzQ4Ny9SRkM5MDAyLCBNYXkgMjAyMSwgJmx0O2h0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL2luZm8vcmZjOTAwMiZndDsuIFtRVUlDLVRMU10gVGhvbXNvbiwgTS4sIEVkLiBhbmQgUy4gVHVybmVyLCBFZC4sICJVc2luZyBUTFMgdG8gU2VjdXJlIFFVSUMiLCBSRkMgOTAwMSwgRE9JIDEwLjE3NDg3L1JGQzkwMDEsIE1heSAyMDIxLCAmbHQ7aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvaW5mby9yZmM5MDAxJmd0Oy4gW1JGQzExOTFdIE1vZ3VsLCBKLiBhbmQgUy4gRGVlcmluZywgIlBhdGggTVRVIGRpc2NvdmVyeSIsIFJGQyAxMTkxLCBET0kgMTAuMTc0ODcvUkZDMTE5MSwgTm92ZW1iZXIgMTk5MCwgJmx0O2h0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL2luZm8vcmZjMTE5MSZndDsuIFtSRkMyMTE5XSBCcmFkbmVyLCBTLiwgIktleSB3b3JkcyBmb3IgdXNlIGluIFJGQ3MgdG8gSW5kaWNhdGUgUmVxdWlyZW1lbnQgTGV2ZWxzIiwgQkNQIDE0LCBSRkMgMjExOSwgRE9JIDEwLjE3NDg3L1JGQzIxMTksIE1hcmNoIDE5OTcsICZsdDtodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9pbmZvL3JmYzIxMTkmZ3Q7LiBbUkZDMzE2OF0gUmFtYWtyaXNobmFuLCBLLiwgRmxveWQsIFMuLCBhbmQgRC4gQmxhY2ssICJUaGUgQWRkaXRpb24gb2YgRXhwbGljaXQgQ29uZ2VzdGlvbiBOb3RpZmljYXRpb24gKEVDTikgdG8gSVAiLCBSRkMgMzE2OCwgRE9JIDEwLjE3NDg3L1JGQzMxNjgsIFNlcHRlbWJlciAyMDAxLCAmbHQ7aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvaW5mby9yZmMzMTY4Jmd0Oy4gW1JGQzM2MjldIFllcmdlYXUsIEYuLCAiVVRGLTgsIGEgdHJhbnNmb3JtYXRpb24gZm9ybWF0IG9mIElTTyAxMDY0NiIsIFNURCA2MywgUkZDIDM2MjksIERPSSAxMC4xNzQ4Ny9SRkMzNjI5LCBOb3ZlbWJlciAyMDAzLCAmbHQ7aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvaW5mby9yZmMzNjI5Jmd0Oy4gW1JGQzY0MzddIEFtYW50ZSwgUy4sIENhcnBlbnRlciwgQi4sIEppYW5nLCBTLiwgYW5kIEouIFJhamFoYWxtZSwgIklQdjYgRmxvdyBMYWJlbCBTcGVjaWZpY2F0aW9uIiwgUkZDIDY0MzcsIERPSSAxMC4xNzQ4Ny9SRkM2NDM3LCBOb3ZlbWJlciAyMDExLCAmbHQ7aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvaW5mby9yZmM2NDM3Jmd0Oy4gW1JGQzgwODVdIEVnZ2VydCwgTC4sIEZhaXJodXJzdCwgRy4sIGFuZCBHLiBTaGVwaGVyZCwgIlVEUCBVc2FnZSBHdWlkZWxpbmVzIiwgQkNQIDE0NSwgUkZDIDgwODUsIERPSSAxMC4xNzQ4Ny9SRkM4MDg1LCBNYXJjaCAyMDE3LCAmbHQ7aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvaW5mby9yZmM4MDg1Jmd0Oy4gW1JGQzgxMjZdIENvdHRvbiwgTS4sIExlaWJhLCBCLiwgYW5kIFQuIE5hcnRlbiwgIkd1aWRlbGluZXMgZm9yIFdyaXRpbmcgYW4gSUFOQSBDb25zaWRlcmF0aW9ucyBTZWN0aW9uIGluIFJGQ3MiLCBCQ1AgMjYsIFJGQyA4MTI2LCBET0kgMTAuMTc0ODcvUkZDODEyNiwgSnVuZSAyMDE3LCAmbHQ7aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvaW5mby9yZmM4MTI2Jmd0Oy4gW1JGQzgxNzRdIExlaWJhLCBCLiwgIkFtYmlndWl0eSBvZiBVcHBlcmNhc2UgdnMgTG93ZXJjYXNlIGluIFJGQyAyMTE5IEtleSBXb3JkcyIsIEJDUCAxNCwgUkZDIDgxNzQsIERPSSAxMC4xNzQ4Ny9SRkM4MTc0LCBNYXkgMjAxNywgJmx0O2h0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL2luZm8vcmZjODE3NCZndDsuIFtSRkM4MjAxXSBNY0Nhbm4sIEouLCBEZWVyaW5nLCBTLiwgTW9ndWwsIEouLCBhbmQgUi4gSGluZGVuLCBFZC4sICJQYXRoIE1UVSBEaXNjb3ZlcnkgZm9yIElQIHZlcnNpb24gNiIsIFNURCA4NywgUkZDIDgyMDEsIERPSSAxMC4xNzQ4Ny9SRkM4MjAxLCBKdWx5IDIwMTcsICZsdDtodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9pbmZvL3JmYzgyMDEmZ3Q7LiBbUkZDODMxMV0gQmxhY2ssIEQuLCAiUmVsYXhpbmcgUmVzdHJpY3Rpb25zIG9uIEV4cGxpY2l0IENvbmdlc3Rpb24gTm90aWZpY2F0aW9uIChFQ04pIEV4cGVyaW1lbnRhdGlvbiIsIFJGQyA4MzExLCBET0kgMTAuMTc0ODcvUkZDODMxMSwgSmFudWFyeSAyMDE4LCAmbHQ7aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvaW5mby9yZmM4MzExJmd0Oy4gW1RMUzEzXSBSZXNjb3JsYSwgRS4sICJUaGUgVHJhbnNwb3J0IExheWVyIFNlY3VyaXR5IChUTFMpIFByb3RvY29sIFZlcnNpb24gMS4zIiwgUkZDIDg0NDYsIERPSSAxMC4xNzQ4Ny9SRkM4NDQ2LCBBdWd1c3QgMjAxOCwgJmx0O2h0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL2luZm8vcmZjODQ0NiZndDsuIFtVRFBdIFBvc3RlbCwgSi4sICJVc2VyIERhdGFncmFtIFByb3RvY29sIiwgU1REIDYsIFJGQyA3NjgsIERPSSAxMC4xNzQ4Ny9SRkMwNzY4LCBBdWd1c3QgMTk4MCwgJmx0O2h0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL2luZm8vcmZjNzY4Jmd0Oy4gMjMuMi4gSW5mb3JtYXRpdmUgUmVmZXJlbmNlcyBbQUVBRF0gTWNHcmV3LCBELiwgIkFuIEludGVyZmFjZSBhbmQgQWxnb3JpdGhtcyBmb3IgQXV0aGVudGljYXRlZCBFbmNyeXB0aW9uIiwgUkZDIDUxMTYsIERPSSAxMC4xNzQ4Ny9SRkM1MTE2LCBKYW51YXJ5IDIwMDgsICZsdDtodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9pbmZvL3JmYzUxMTYmZ3Q7LiBbQUxQTl0gRnJpZWRsLCBTLiwgUG9wb3YsIEEuLCBMYW5nbGV5LCBBLiwgYW5kIEUuIFN0ZXBoYW4sICJUcmFuc3BvcnQgTGF5ZXIgU2VjdXJpdHkgKFRMUykgQXBwbGljYXRpb24tTGF5ZXIgUHJvdG9jb2wgTmVnb3RpYXRpb24gRXh0ZW5zaW9uIiwgUkZDIDczMDEsIERPSSAxMC4xNzQ4Ny9SRkM3MzAxLCBKdWx5IDIwMTQsICZsdDtodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9pbmZvL3JmYzczMDEmZ3Q7LiBbQUxUU1ZDXSBOb3R0aW5naGFtLCBNLiwgTWNNYW51cywgUC4sIGFuZCBKLiBSZXNjaGtlLCAiSFRUUCBBbHRlcm5hdGl2ZSBTZXJ2aWNlcyIsIFJGQyA3ODM4LCBET0kgMTAuMTc0ODcvUkZDNzgzOCwgQXByaWwgMjAxNiwgJmx0O2h0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL2luZm8vcmZjNzgzOCZndDsuIFtDT09LSUVdIEJhcnRoLCBBLiwgIkhUVFAgU3RhdGUgTWFuYWdlbWVudCBNZWNoYW5pc20iLCBSRkMgNjI2NSwgRE9JIDEwLjE3NDg3L1JGQzYyNjUsIEFwcmlsIDIwMTEsICZsdDtodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9pbmZvL3JmYzYyNjUmZ3Q7LiBbQ1NSRl0gQmFydGgsIEEuLCBKYWNrc29uLCBDLiwgYW5kIEouIE1pdGNoZWxsLCAiUm9idXN0IGRlZmVuc2VzIGZvciBjcm9zcy1zaXRlIHJlcXVlc3QgZm9yZ2VyeSIsIFByb2NlZWRpbmdzIG9mIHRoZSAxNXRoIEFDTSBjb25mZXJlbmNlIG9uIENvbXB1dGVyIGFuZCBjb21tdW5pY2F0aW9ucyBzZWN1cml0eSAtIENDUyAnMDgsIERPSSAxMC4xMTQ1LzE0NTU3NzAuMTQ1NTc4MiwgMjAwOCwgJmx0O2h0dHBzOi8vZG9pLm9yZy8xMC4xMTQ1LzE0NTU3NzAuMTQ1NTc4MiZndDsuIFtFQVJMWS1ERVNJR05dIFJvc2tpbmQsIEouLCAiUVVJQzogTXVsdGlwbGV4ZWQgU3RyZWFtIFRyYW5zcG9ydCBPdmVyIFVEUCIsIDIgRGVjZW1iZXIgMjAxMywgJmx0O2h0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50LyBkLzFSTkhreF9WdktXeVdnNkxyOFNaLXNhcXNReDdyRlYtZXYyalJGVW9WRDM0LyBlZGl0P3VzcD1zaGFyaW5nJmd0Oy4gW0dBVEVXQVldIEjDpHTDtm5lbiwgUy4sIE55cmhpbmVuLCBBLiwgRWdnZXJ0LCBMLiwgU3Ryb3dlcywgUy4sIFNhcm9sYWh0aSwgUC4sIGFuZCBNLiBLb2pvLCAiQW4gZXhwZXJpbWVudGFsIHN0dWR5IG9mIGhvbWUgZ2F0ZXdheSBjaGFyYWN0ZXJpc3RpY3MiLCBQcm9jZWVkaW5ncyBvZiB0aGUgMTB0aCBBQ00gU0lHQ09NTSBjb25mZXJlbmNlIG9uIEludGVybmV0IG1lYXN1cmVtZW50IC0gSU1DICcxMCwgRE9JIDEwLjExNDUvMTg3OTE0MS4xODc5MTc0LCBOb3ZlbWJlciAyMDEwLCAmbHQ7aHR0cHM6Ly9kb2kub3JnLzEwLjExNDUvMTg3OTE0MS4xODc5MTc0Jmd0Oy4gW0hUVFAyXSBCZWxzaGUsIE0uLCBQZW9uLCBSLiwgYW5kIE0uIFRob21zb24sIEVkLiwgIkh5cGVydGV4dCBUcmFuc2ZlciBQcm90b2NvbCBWZXJzaW9uIDIgKEhUVFAvMikiLCBSRkMgNzU0MCwgRE9JIDEwLjE3NDg3L1JGQzc1NDAsIE1heSAyMDE1LCAmbHQ7aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvaW5mby9yZmM3NTQwJmd0Oy4gW0lQdjZdIERlZXJpbmcsIFMuIGFuZCBSLiBIaW5kZW4sICJJbnRlcm5ldCBQcm90b2NvbCwgVmVyc2lvbiA2IChJUHY2KSBTcGVjaWZpY2F0aW9uIiwgU1REIDg2LCBSRkMgODIwMCwgRE9JIDEwLjE3NDg3L1JGQzgyMDAsIEp1bHkgMjAxNywgJmx0O2h0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL2luZm8vcmZjODIwMCZndDsuIFtRVUlDLU1BTkFHRUFCSUxJVFldIEt1ZWhsZXdpbmQsIE0uIGFuZCBCLiBUcmFtbWVsbCwgIk1hbmFnZWFiaWxpdHkgb2YgdGhlIFFVSUMgVHJhbnNwb3J0IFByb3RvY29sIiwgV29yayBpbiBQcm9ncmVzcywgSW50ZXJuZXQtRHJhZnQsIGRyYWZ0LWlldGYtcXVpYy1tYW5hZ2VhYmlsaXR5LTExLCAyMSBBcHJpbCAyMDIxLCAmbHQ7aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtcXVpYy0gbWFuYWdlYWJpbGl0eS0xMSZndDsuIFtSQU5ET01dIEVhc3RsYWtlIDNyZCwgRC4sIFNjaGlsbGVyLCBKLiwgYW5kIFMuIENyb2NrZXIsICJSYW5kb21uZXNzIFJlcXVpcmVtZW50cyBmb3IgU2VjdXJpdHkiLCBCQ1AgMTA2LCBSRkMgNDA4NiwgRE9JIDEwLjE3NDg3L1JGQzQwODYsIEp1bmUgMjAwNSwgJmx0O2h0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL2luZm8vcmZjNDA4NiZndDsuIFtSRkMxODEyXSBCYWtlciwgRi4sIEVkLiwgIlJlcXVpcmVtZW50cyBmb3IgSVAgVmVyc2lvbiA0IFJvdXRlcnMiLCBSRkMgMTgxMiwgRE9JIDEwLjE3NDg3L1JGQzE4MTIsIEp1bmUgMTk5NSwgJmx0O2h0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL2luZm8vcmZjMTgxMiZndDsuIFtSRkMxOTE4XSBSZWtodGVyLCBZLiwgTW9za293aXR6LCBCLiwgS2FycmVuYmVyZywgRC4sIGRlIEdyb290LCBHLiBKLiwgYW5kIEUuIExlYXIsICJBZGRyZXNzIEFsbG9jYXRpb24gZm9yIFByaXZhdGUgSW50ZXJuZXRzIiwgQkNQIDUsIFJGQyAxOTE4LCBET0kgMTAuMTc0ODcvUkZDMTkxOCwgRmVicnVhcnkgMTk5NiwgJmx0O2h0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL2luZm8vcmZjMTkxOCZndDsuIFtSRkMyMDE4XSBNYXRoaXMsIE0uLCBNYWhkYXZpLCBKLiwgRmxveWQsIFMuLCBhbmQgQS4gUm9tYW5vdywgIlRDUCBTZWxlY3RpdmUgQWNrbm93bGVkZ21lbnQgT3B0aW9ucyIsIFJGQyAyMDE4LCBET0kgMTAuMTc0ODcvUkZDMjAxOCwgT2N0b2JlciAxOTk2LCAmbHQ7aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvaW5mby9yZmMyMDE4Jmd0Oy4gW1JGQzIxMDRdIEtyYXdjenlrLCBILiwgQmVsbGFyZSwgTS4sIGFuZCBSLiBDYW5ldHRpLCAiSE1BQzogS2V5ZWQtIEhhc2hpbmcgZm9yIE1lc3NhZ2UgQXV0aGVudGljYXRpb24iLCBSRkMgMjEwNCwgRE9JIDEwLjE3NDg3L1JGQzIxMDQsIEZlYnJ1YXJ5IDE5OTcsICZsdDtodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9pbmZvL3JmYzIxMDQmZ3Q7LiBbUkZDMzQ0OV0gQmFsYWtyaXNobmFuLCBILiwgUGFkbWFuYWJoYW4sIFYuLCBGYWlyaHVyc3QsIEcuLCBhbmQgTS4gU29vcml5YWJhbmRhcmEsICJUQ1AgUGVyZm9ybWFuY2UgSW1wbGljYXRpb25zIG9mIE5ldHdvcmsgUGF0aCBBc3ltbWV0cnkiLCBCQ1AgNjksIFJGQyAzNDQ5LCBET0kgMTAuMTc0ODcvUkZDMzQ0OSwgRGVjZW1iZXIgMjAwMiwgJmx0O2h0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL2luZm8vcmZjMzQ0OSZndDsuIFtSRkM0MTkzXSBIaW5kZW4sIFIuIGFuZCBCLiBIYWJlcm1hbiwgIlVuaXF1ZSBMb2NhbCBJUHY2IFVuaWNhc3QgQWRkcmVzc2VzIiwgUkZDIDQxOTMsIERPSSAxMC4xNzQ4Ny9SRkM0MTkzLCBPY3RvYmVyIDIwMDUsICZsdDtodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9pbmZvL3JmYzQxOTMmZ3Q7LiBbUkZDNDI5MV0gSGluZGVuLCBSLiBhbmQgUy4gRGVlcmluZywgIklQIFZlcnNpb24gNiBBZGRyZXNzaW5nIEFyY2hpdGVjdHVyZSIsIFJGQyA0MjkxLCBET0kgMTAuMTc0ODcvUkZDNDI5MSwgRmVicnVhcnkgMjAwNiwgJmx0O2h0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL2luZm8vcmZjNDI5MSZndDsuIFtSRkM0NDQzXSBDb250YSwgQS4sIERlZXJpbmcsIFMuLCBhbmQgTS4gR3VwdGEsIEVkLiwgIkludGVybmV0IENvbnRyb2wgTWVzc2FnZSBQcm90b2NvbCAoSUNNUHY2KSBmb3IgdGhlIEludGVybmV0IFByb3RvY29sIFZlcnNpb24gNiAoSVB2NikgU3BlY2lmaWNhdGlvbiIsIFNURCA4OSwgUkZDIDQ0NDMsIERPSSAxMC4xNzQ4Ny9SRkM0NDQzLCBNYXJjaCAyMDA2LCAmbHQ7aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvaW5mby9yZmM0NDQzJmd0Oy4gW1JGQzQ3ODddIEF1ZGV0LCBGLiwgRWQuIGFuZCBDLiBKZW5uaW5ncywgIk5ldHdvcmsgQWRkcmVzcyBUcmFuc2xhdGlvbiAoTkFUKSBCZWhhdmlvcmFsIFJlcXVpcmVtZW50cyBmb3IgVW5pY2FzdCBVRFAiLCBCQ1AgMTI3LCBSRkMgNDc4NywgRE9JIDEwLjE3NDg3L1JGQzQ3ODcsIEphbnVhcnkgMjAwNywgJmx0O2h0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL2luZm8vcmZjNDc4NyZndDsuIFtSRkM1NjgxXSBBbGxtYW4sIE0uLCBQYXhzb24sIFYuLCBhbmQgRS4gQmxhbnRvbiwgIlRDUCBDb25nZXN0aW9uIENvbnRyb2wiLCBSRkMgNTY4MSwgRE9JIDEwLjE3NDg3L1JGQzU2ODEsIFNlcHRlbWJlciAyMDA5LCAmbHQ7aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvaW5mby9yZmM1NjgxJmd0Oy4gW1JGQzU4NjldIEtyYXdjenlrLCBILiBhbmQgUC4gRXJvbmVuLCAiSE1BQy1iYXNlZCBFeHRyYWN0LWFuZC1FeHBhbmQgS2V5IERlcml2YXRpb24gRnVuY3Rpb24gKEhLREYpIiwgUkZDIDU4NjksIERPSSAxMC4xNzQ4Ny9SRkM1ODY5LCBNYXkgMjAxMCwgJmx0O2h0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL2luZm8vcmZjNTg2OSZndDsuIFtSRkM3OTgzXSBQZXRpdC1IdWd1ZW5pbiwgTS4gYW5kIEcuIFNhbGd1ZWlybywgIk11bHRpcGxleGluZyBTY2hlbWUgVXBkYXRlcyBmb3IgU2VjdXJlIFJlYWwtdGltZSBUcmFuc3BvcnQgUHJvdG9jb2wgKFNSVFApIEV4dGVuc2lvbiBmb3IgRGF0YWdyYW0gVHJhbnNwb3J0IExheWVyIFNlY3VyaXR5IChEVExTKSIsIFJGQyA3OTgzLCBET0kgMTAuMTc0ODcvUkZDNzk4MywgU2VwdGVtYmVyIDIwMTYsICZsdDtodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9pbmZvL3JmYzc5ODMmZ3Q7LiBbUkZDODA4N10gRmFpcmh1cnN0LCBHLiBhbmQgTS4gV2VsemwsICJUaGUgQmVuZWZpdHMgb2YgVXNpbmcgRXhwbGljaXQgQ29uZ2VzdGlvbiBOb3RpZmljYXRpb24gKEVDTikiLCBSRkMgODA4NywgRE9JIDEwLjE3NDg3L1JGQzgwODcsIE1hcmNoIDIwMTcsICZsdDtodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9pbmZvL3JmYzgwODcmZ3Q7LiBbUkZDODk4MV0gR29udCwgRi4sIEtyaXNobmFuLCBTLiwgTmFydGVuLCBULiwgYW5kIFIuIERyYXZlcywgIlRlbXBvcmFyeSBBZGRyZXNzIEV4dGVuc2lvbnMgZm9yIFN0YXRlbGVzcyBBZGRyZXNzIEF1dG9jb25maWd1cmF0aW9uIGluIElQdjYiLCBSRkMgODk4MSwgRE9JIDEwLjE3NDg3L1JGQzg5ODEsIEZlYnJ1YXJ5IDIwMjEsICZsdDtodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9pbmZvL3JmYzg5ODEmZ3Q7LiBbU0VDLUNPTlNdIFJlc2NvcmxhLCBFLiBhbmQgQi4gS29ydmVyLCAiR3VpZGVsaW5lcyBmb3IgV3JpdGluZyBSRkMgVGV4dCBvbiBTZWN1cml0eSBDb25zaWRlcmF0aW9ucyIsIEJDUCA3MiwgUkZDIDM1NTIsIERPSSAxMC4xNzQ4Ny9SRkMzNTUyLCBKdWx5IDIwMDMsICZsdDtodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9pbmZvL3JmYzM1NTImZ3Q7LiBbU0xPV0xPUklTXSAiUlNuYWtlIiBIYW5zZW4sIFIuLCAiV2VsY29tZSB0byBTbG93bG9yaXMgLSB0aGUgbG93IGJhbmR3aWR0aCwgeWV0IGdyZWVkeSBhbmQgcG9pc29ub3VzIEhUVFAgY2xpZW50ISIsIEp1bmUgMjAwOSwgJmx0O2h0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE1MDMxNTA1NDgzOC8gaHR0cDovL2hhLmNrZXJzLm9yZy9zbG93bG9yaXMvJmd0Oy4gQXBwZW5kaXggQS4gUHNldWRvY29kZSBUaGUgcHNldWRvY29kZSBpbiB0aGlzIHNlY3Rpb24gZGVzY3JpYmVzIHNhbXBsZSBhbGdvcml0aG1zLiBUaGVzZSBhbGdvcml0aG1zIGFyZSBpbnRlbmRlZCB0byBiZSBjb3JyZWN0IGFuZCBjbGVhciwgcmF0aGVyIHRoYW4gYmVpbmcgb3B0aW1hbGx5IHBlcmZvcm1hbnQuIFRoZSBwc2V1ZG9jb2RlIHNlZ21lbnRzIGluIHRoaXMgc2VjdGlvbiBhcmUgbGljZW5zZWQgYXMgQ29kZSBDb21wb25lbnRzOyBzZWUgdGhlIENvcHlyaWdodCBOb3RpY2UuIEEuMS4gU2FtcGxlIFZhcmlhYmxlLUxlbmd0aCBJbnRlZ2VyIERlY29kaW5nIFRoZSBwc2V1ZG9jb2RlIGluIEZpZ3VyZSA0NSBzaG93cyBob3cgYSB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBjYW4gYmUgcmVhZCBmcm9tIGEgc3RyZWFtIG9mIGJ5dGVzLiBUaGUgZnVuY3Rpb24gUmVhZFZhcmludCB0YWtlcyBhIHNpbmdsZSBhcmd1bWVudCAtLSBhIHNlcXVlbmNlIG9mIGJ5dGVzLCB3aGljaCBjYW4gYmUgcmVhZCBpbiBuZXR3b3JrIGJ5dGUgb3JkZXIuIFJlYWRWYXJpbnQoZGF0YSk6IC8vIFRoZSBsZW5ndGggb2YgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJzIGlzIGVuY29kZWQgaW4gdGhlIC8vIGZpcnN0IHR3byBiaXRzIG9mIHRoZSBmaXJzdCBieXRlLiB2ID0gZGF0YS5uZXh0X2J5dGUoKSBwcmVmaXggPSB2ICZndDsmZ3Q7IDYgbGVuZ3RoID0gMSAmbHQ7Jmx0OyBwcmVmaXggLy8gT25jZSB0aGUgbGVuZ3RoIGlzIGtub3duLCByZW1vdmUgdGhlc2UgYml0cyBhbmQgcmVhZCBhbnkgLy8gcmVtYWluaW5nIGJ5dGVzLiB2ID0gdiAweDNmIHJlcGVhdCBsZW5ndGgtMSB0aW1lczogdiA9ICh2ICZsdDsmbHQ7IDgpICsgZGF0YS5uZXh0X2J5dGUoKSByZXR1cm4gdiBGaWd1cmUgNDU6IFNhbXBsZSBWYXJpYWJsZS1MZW5ndGggSW50ZWdlciBEZWNvZGluZyBBbGdvcml0aG0gRm9yIGV4YW1wbGUsIHRoZSBlaWdodC1ieXRlIHNlcXVlbmNlIDB4YzIxOTdjNWVmZjE0ZTg4YyBkZWNvZGVzIHRvIHRoZSBkZWNpbWFsIHZhbHVlIDE1MSwyODgsODA5LDk0MSw5NTIsNjUyOyB0aGUgZm91ci1ieXRlIHNlcXVlbmNlIDB4OWQ3ZjNlN2QgZGVjb2RlcyB0byA0OTQsODc4LDMzMzsgdGhlIHR3by1ieXRlIHNlcXVlbmNlIDB4N2JiZCBkZWNvZGVzIHRvIDE1LDI5MzsgYW5kIHRoZSBzaW5nbGUgYnl0ZSAweDI1IGRlY29kZXMgdG8gMzcgKGFzIGRvZXMgdGhlIHR3by1ieXRlIHNlcXVlbmNlIDB4NDAyNSkuIEEuMi4gU2FtcGxlIFBhY2tldCBOdW1iZXIgRW5jb2RpbmcgQWxnb3JpdGhtIFRoZSBwc2V1ZG9jb2RlIGluIEZpZ3VyZSA0NiBzaG93cyBob3cgYW4gaW1wbGVtZW50YXRpb24gY2FuIHNlbGVjdCBhbiBhcHByb3ByaWF0ZSBzaXplIGZvciBwYWNrZXQgbnVtYmVyIGVuY29kaW5ncy4gVGhlIEVuY29kZVBhY2tldE51bWJlciBmdW5jdGlvbiB0YWtlcyB0d28gYXJndW1lbnRzOiAqIGZ1bGxfcG4gaXMgdGhlIGZ1bGwgcGFja2V0IG51bWJlciBvZiB0aGUgcGFja2V0IGJlaW5nIHNlbnQuICogbGFyZ2VzdF9hY2tlZCBpcyB0aGUgbGFyZ2VzdCBwYWNrZXQgbnVtYmVyIHRoYXQgaGFzIGJlZW4gYWNrbm93bGVkZ2VkIGJ5IHRoZSBwZWVyIGluIHRoZSBjdXJyZW50IHBhY2tldCBudW1iZXIgc3BhY2UsIGlmIGFueS4gRW5jb2RlUGFja2V0TnVtYmVyKGZ1bGxfcG4sIGxhcmdlc3RfYWNrZWQpOiAvLyBUaGUgbnVtYmVyIG9mIGJpdHMgbXVzdCBiZSBhdCBsZWFzdCBvbmUgbW9yZSAvLyB0aGFuIHRoZSBiYXNlLTIgbG9nYXJpdGhtIG9mIHRoZSBudW1iZXIgb2YgY29udGlndW91cyAvLyB1bmFja25vd2xlZGdlZCBwYWNrZXQgbnVtYmVycywgaW5jbHVkaW5nIHRoZSBuZXcgcGFja2V0LiBpZiBsYXJnZXN0X2Fja2VkIGlzIE5vbmU6IG51bV91bmFja2VkID0gZnVsbF9wbiArIDEgZWxzZTogbnVtX3VuYWNrZWQgPSBmdWxsX3BuIC0gbGFyZ2VzdF9hY2tlZCBtaW5fYml0cyA9IGxvZyhudW1fdW5hY2tlZCwgMikgKyAxIG51bV9ieXRlcyA9IGNlaWwobWluX2JpdHMgLyA4KSAvLyBFbmNvZGUgdGhlIGludGVnZXIgdmFsdWUgYW5kIHRydW5jYXRlIHRvIC8vIHRoZSBudW1fYnl0ZXMgbGVhc3Qgc2lnbmlmaWNhbnQgYnl0ZXMuIHJldHVybiBlbmNvZGUoZnVsbF9wbiwgbnVtX2J5dGVzKSBGaWd1cmUgNDY6IFNhbXBsZSBQYWNrZXQgTnVtYmVyIEVuY29kaW5nIEFsZ29yaXRobSBGb3IgZXhhbXBsZSwgaWYgYW4gZW5kcG9pbnQgaGFzIHJlY2VpdmVkIGFuIGFja25vd2xlZGdtZW50IGZvciBwYWNrZXQgMHhhYmU4YjMgYW5kIGlzIHNlbmRpbmcgYSBwYWNrZXQgd2l0aCBhIG51bWJlciBvZiAweGFjNWMwMiwgdGhlcmUgYXJlIDI5LDUxOSAoMHg3MzRmKSBvdXRzdGFuZGluZyBwYWNrZXQgbnVtYmVycy4gSW4gb3JkZXIgdG8gcmVwcmVzZW50IGF0IGxlYXN0IHR3aWNlIHRoaXMgcmFuZ2UgKDU5LDAzOCBwYWNrZXRzLCBvciAweGU2OWUpLCAxNiBiaXRzIGFyZSByZXF1aXJlZC4gSW4gdGhlIHNhbWUgc3RhdGUsIHNlbmRpbmcgYSBwYWNrZXQgd2l0aCBhIG51bWJlciBvZiAweGFjZThmZSB1c2VzIHRoZSAyNC1iaXQgZW5jb2RpbmcsIGJlY2F1c2UgYXQgbGVhc3QgMTggYml0cyBhcmUgcmVxdWlyZWQgdG8gcmVwcmVzZW50IHR3aWNlIHRoZSByYW5nZSAoMTMxLDIyMiBwYWNrZXRzLCBvciAweDAyMDA5NikuIEEuMy4gU2FtcGxlIFBhY2tldCBOdW1iZXIgRGVjb2RpbmcgQWxnb3JpdGhtIFRoZSBwc2V1ZG9jb2RlIGluIEZpZ3VyZSA0NyBpbmNsdWRlcyBhbiBleGFtcGxlIGFsZ29yaXRobSBmb3IgZGVjb2RpbmcgcGFja2V0IG51bWJlcnMgYWZ0ZXIgaGVhZGVyIHByb3RlY3Rpb24gaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIERlY29kZVBhY2tldE51bWJlciBmdW5jdGlvbiB0YWtlcyB0aHJlZSBhcmd1bWVudHM6ICogbGFyZ2VzdF9wbiBpcyB0aGUgbGFyZ2VzdCBwYWNrZXQgbnVtYmVyIHRoYXQgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IHByb2Nlc3NlZCBpbiB0aGUgY3VycmVudCBwYWNrZXQgbnVtYmVyIHNwYWNlLiAqIHRydW5jYXRlZF9wbiBpcyB0aGUgdmFsdWUgb2YgdGhlIFBhY2tldCBOdW1iZXIgZmllbGQuICogcG5fbmJpdHMgaXMgdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBQYWNrZXQgTnVtYmVyIGZpZWxkICg4LCAxNiwgMjQsIG9yIDMyKS4gRGVjb2RlUGFja2V0TnVtYmVyKGxhcmdlc3RfcG4sIHRydW5jYXRlZF9wbiwgcG5fbmJpdHMpOiBleHBlY3RlZF9wbiA9IGxhcmdlc3RfcG4gKyAxIHBuX3dpbiA9IDEgJmx0OyZsdDsgcG5fbmJpdHMgcG5faHdpbiA9IHBuX3dpbiAvIDIgcG5fbWFzayA9IHBuX3dpbiAtIDEgLy8gVGhlIGluY29taW5nIHBhY2tldCBudW1iZXIgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiAvLyBleHBlY3RlZF9wbiAtIHBuX2h3aW4gYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byAvLyBleHBlY3RlZF9wbiArIHBuX2h3aW4gLy8gLy8gVGhpcyBtZWFucyB3ZSBjYW5ub3QganVzdCBzdHJpcCB0aGUgdHJhaWxpbmcgYml0cyBmcm9tIC8vIGV4cGVjdGVkX3BuIGFuZCBhZGQgdGhlIHRydW5jYXRlZF9wbiBiZWNhdXNlIHRoYXQgbWlnaHQgLy8geWllbGQgYSB2YWx1ZSBvdXRzaWRlIHRoZSB3aW5kb3cuIC8vIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBjYWxjdWxhdGVzIGEgY2FuZGlkYXRlIHZhbHVlIGFuZCAvLyBtYWtlcyBzdXJlIGl0J3Mgd2l0aGluIHRoZSBwYWNrZXQgbnVtYmVyIHdpbmRvdy4gLy8gTm90ZSB0aGUgZXh0cmEgY2hlY2tzIHRvIHByZXZlbnQgb3ZlcmZsb3cgYW5kIHVuZGVyZmxvdy4gY2FuZGlkYXRlX3BuID0gKGV4cGVjdGVkX3BuIH5wbl9tYXNrKSB8IHRydW5jYXRlZF9wbiBpZiBjYW5kaWRhdGVfcG4gJmx0Oz0gZXhwZWN0ZWRfcG4gLSBwbl9od2luIGFuZCBjYW5kaWRhdGVfcG4gJmx0OyAoMSAmbHQ7Jmx0OyA2MikgLSBwbl93aW46IHJldHVybiBjYW5kaWRhdGVfcG4gKyBwbl93aW4gaWYgY2FuZGlkYXRlX3BuICZndDsgZXhwZWN0ZWRfcG4gKyBwbl9od2luIGFuZCBjYW5kaWRhdGVfcG4gJmd0Oz0gcG5fd2luOiByZXR1cm4gY2FuZGlkYXRlX3BuIC0gcG5fd2luIHJldHVybiBjYW5kaWRhdGVfcG4gRmlndXJlIDQ3OiBTYW1wbGUgUGFja2V0IE51bWJlciBEZWNvZGluZyBBbGdvcml0aG0gRm9yIGV4YW1wbGUsIGlmIHRoZSBoaWdoZXN0IHN1Y2Nlc3NmdWxseSBhdXRoZW50aWNhdGVkIHBhY2tldCBoYWQgYSBwYWNrZXQgbnVtYmVyIG9mIDB4YTgyZjMwZWEsIHRoZW4gYSBwYWNrZXQgY29udGFpbmluZyBhIDE2LWJpdCB2YWx1ZSBvZiAweDliMzIgd2lsbCBiZSBkZWNvZGVkIGFzIDB4YTgyZjliMzIuIEEuNC4gU2FtcGxlIEVDTiBWYWxpZGF0aW9uIEFsZ29yaXRobSBFYWNoIHRpbWUgYW4gZW5kcG9pbnQgY29tbWVuY2VzIHNlbmRpbmcgb24gYSBuZXcgbmV0d29yayBwYXRoLCBpdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBhdGggc3VwcG9ydHMgRUNOOyBzZWUgU2VjdGlvbiAxMy40LiBJZiB0aGUgcGF0aCBzdXBwb3J0cyBFQ04sIHRoZSBnb2FsIGlzIHRvIHVzZSBFQ04uIEVuZHBvaW50cyBtaWdodCBhbHNvIHBlcmlvZGljYWxseSByZWFzc2VzcyBhIHBhdGggdGhhdCB3YXMgZGV0ZXJtaW5lZCB0byBub3Qgc3VwcG9ydCBFQ04uIFRoaXMgc2VjdGlvbiBkZXNjcmliZXMgb25lIG1ldGhvZCBmb3IgdGVzdGluZyBuZXcgcGF0aHMuIFRoaXMgYWxnb3JpdGhtIGlzIGludGVuZGVkIHRvIHNob3cgaG93IGEgcGF0aCBtaWdodCBiZSB0ZXN0ZWQgZm9yIEVDTiBzdXBwb3J0LiBFbmRwb2ludHMgY2FuIGltcGxlbWVudCBkaWZmZXJlbnQgbWV0aG9kcy4gVGhlIHBhdGggaXMgYXNzaWduZWQgYW4gRUNOIHN0YXRlIHRoYXQgaXMgb25lIG9mICJ0ZXN0aW5nIiwgInVua25vd24iLCAiZmFpbGVkIiwgb3IgImNhcGFibGUiLiBPbiBwYXRocyB3aXRoIGEgInRlc3RpbmciIG9yICJjYXBhYmxlIiBzdGF0ZSwgdGhlIGVuZHBvaW50IHNlbmRzIHBhY2tldHMgd2l0aCBhbiBFQ1QgbWFya2luZyAtLSBFQ1QoMCkgYnkgZGVmYXVsdDsgb3RoZXJ3aXNlLCB0aGUgZW5kcG9pbnQgc2VuZHMgdW5tYXJrZWQgcGFja2V0cy4gVG8gc3RhcnQgdGVzdGluZyBhIHBhdGgsIHRoZSBFQ04gc3RhdGUgaXMgc2V0IHRvICJ0ZXN0aW5nIiwgYW5kIGV4aXN0aW5nIEVDTiBjb3VudHMgYXJlIHJlbWVtYmVyZWQgYXMgYSBiYXNlbGluZS4gVGhlIHRlc3RpbmcgcGVyaW9kIHJ1bnMgZm9yIGEgbnVtYmVyIG9mIHBhY2tldHMgb3IgYSBsaW1pdGVkIHRpbWUsIGFzIGRldGVybWluZWQgYnkgdGhlIGVuZHBvaW50LiBUaGUgZ29hbCBpcyBub3QgdG8gbGltaXQgdGhlIGR1cmF0aW9uIG9mIHRoZSB0ZXN0aW5nIHBlcmlvZCBidXQgdG8gZW5zdXJlIHRoYXQgZW5vdWdoIG1hcmtlZCBwYWNrZXRzIGFyZSBzZW50IGZvciByZWNlaXZlZCBFQ04gY291bnRzIHRvIHByb3ZpZGUgYSBjbGVhciBpbmRpY2F0aW9uIG9mIGhvdyB0aGUgcGF0aCB0cmVhdHMgbWFya2VkIHBhY2tldHMuIFNlY3Rpb24gMTMuNC4yIHN1Z2dlc3RzIGxpbWl0aW5nIHRoaXMgdG8gdGVuIHBhY2tldHMgb3IgdGhyZWUgdGltZXMgdGhlIFBUTy4gQWZ0ZXIgdGhlIHRlc3RpbmcgcGVyaW9kIGVuZHMsIHRoZSBFQ04gc3RhdGUgZm9yIHRoZSBwYXRoIGJlY29tZXMgInVua25vd24iLiBGcm9tIHRoZSAidW5rbm93biIgc3RhdGUsIHN1Y2Nlc3NmdWwgdmFsaWRhdGlvbiBvZiB0aGUgRUNOIGNvdW50cyBpbiBhbiBBQ0sgZnJhbWUgKHNlZSBTZWN0aW9uIDEzLjQuMi4xKSBjYXVzZXMgdGhlIEVDTiBzdGF0ZSBmb3IgdGhlIHBhdGggdG8gYmVjb21lICJjYXBhYmxlIiwgdW5sZXNzIG5vIG1hcmtlZCBwYWNrZXQgaGFzIGJlZW4gYWNrbm93bGVkZ2VkLiBJZiB2YWxpZGF0aW9uIG9mIEVDTiBjb3VudHMgZmFpbHMgYXQgYW55IHRpbWUsIHRoZSBFQ04gc3RhdGUgZm9yIHRoZSBhZmZlY3RlZCBwYXRoIGJlY29tZXMgImZhaWxlZCIuIEFuIGVuZHBvaW50IGNhbiBhbHNvIG1hcmsgdGhlIEVDTiBzdGF0ZSBmb3IgYSBwYXRoIGFzICJmYWlsZWQiIGlmIG1hcmtlZCBwYWNrZXRzIGFyZSBhbGwgZGVjbGFyZWQgbG9zdCBvciBpZiB0aGV5IGFyZSBhbGwgRUNOLUNFIG1hcmtlZC4gRm9sbG93aW5nIHRoaXMgYWxnb3JpdGhtIGVuc3VyZXMgdGhhdCBFQ04gaXMgcmFyZWx5IGRpc2FibGVkIGZvciBwYXRocyB0aGF0IHByb3Blcmx5IHN1cHBvcnQgRUNOLiBBbnkgcGF0aCB0aGF0IGluY29ycmVjdGx5IG1vZGlmaWVzIG1hcmtpbmdzIHdpbGwgY2F1c2UgRUNOIHRvIGJlIGRpc2FibGVkLiBGb3IgdGhvc2UgcmFyZSBjYXNlcyB3aGVyZSBtYXJrZWQgcGFja2V0cyBhcmUgZGlzY2FyZGVkIGJ5IHRoZSBwYXRoLCB0aGUgc2hvcnQgZHVyYXRpb24gb2YgdGhlIHRlc3RpbmcgcGVyaW9kIGxpbWl0cyB0aGUgbnVtYmVyIG9mIGxvc3NlcyBpbmN1cnJlZC4gQ29udHJpYnV0b3JzIFRoZSBvcmlnaW5hbCBkZXNpZ24gYW5kIHJhdGlvbmFsZSBiZWhpbmQgdGhpcyBwcm90b2NvbCBkcmF3IHNpZ25pZmljYW50bHkgZnJvbSB3b3JrIGJ5IEppbSBSb3NraW5kIFtFQVJMWS1ERVNJR05dLiBUaGUgSUVURiBRVUlDIFdvcmtpbmcgR3JvdXAgcmVjZWl2ZWQgYW4gZW5vcm1vdXMgYW1vdW50IG9mIHN1cHBvcnQgZnJvbSBtYW55IHBlb3BsZS4gVGhlIGZvbGxvd2luZyBwZW9wbGUgcHJvdmlkZWQgc3Vic3RhbnRpdmUgY29udHJpYnV0aW9ucyB0byB0aGlzIGRvY3VtZW50OiAqIEFsZXNzYW5kcm8gR2hlZGluaSAqIEFseXNzYSBXaWxrICogQW50b2luZSBEZWxpZ25hdC1MYXZhdWQgKiBCcmlhbiBUcmFtbWVsbCAqIENocmlzdGlhbiBIdWl0ZW1hICogQ29saW4gUGVya2lucyAqIERhdmlkIFNjaGluYXppICogRG1pdHJpIFRpa2hvbm92ICogRXJpYyBLaW5uZWFyICogRXJpYyBSZXNjb3JsYSAqIEdvcnJ5IEZhaXJodXJzdCAqIElhbiBTd2V0dCAqIElnb3IgTHViYXNoZXYgKiDlpaUg5LiA56mCIChLYXp1aG8gT2t1KSAqIExhcnMgRWdnZXJ0ICogTHVjYXMgUGFyZHVlICogTWFnbnVzIFdlc3Rlcmx1bmQgKiBNYXJ0ZW4gU2VlbWFubiAqIE1hcnRpbiBEdWtlICogTWlrZSBCaXNob3AgKiBNaWtrZWwgRmFobsO4ZSBKw7hyZ2Vuc2VuICogTWlyamEgS8O8aGxld2luZCAqIE5pY2sgQmFua3MgKiBOaWNrIEhhcnBlciAqIFBhdHJpY2sgTWNNYW51cyAqIFJvYmVydG8gUGVvbiAqIFJ5YW4gSGFtaWx0b24gKiBTdWJvZGggSXllbmdhciAqIFRhdHN1aGlybyBUc3VqaWthd2EgKiBUZWQgSGFyZGllICogVG9tIEpvbmVzICogVmljdG9yIFZhc2lsaWV2IEF1dGhvcnMnIEFkZHJlc3NlcyBKYW5hIEl5ZW5nYXIgKGVkaXRvcikgRmFzdGx5IEVtYWlsOiBqcmkuaWV0ZkBnbWFpbC5jb20gTWFydGluIFRob21zb24gKGVkaXRvcikgTW96aWxsYSBFbWFpbDogbXRAbG93ZW50cm9weS5uZXQgPC9wcmU+IDwvZGl2PiA8ZGl2ID4gPGRpdiA+IDxhID5SRkPCoEVkaXRvcjwvYT4gPGEgPklBU0EgSUVURsKgTExDPC9hPiA8YSA+SUVURsKgVHJ1c3Q8L2E+IDxhID5JUlRGPC9hPiA8YSA+SUVURjwvYT4gPGEgPklFU0c8L2E+IDxhID5JQUI8L2E+IDxhID5JQU5BPC9hPiA8YSA+UHJpdmFjecKgU3RhdGVtZW50PC9hPiA8L2Rpdj4gPC9kaXY+IDwvZGl2PiA8L2JvZHk+'</script>

      </head>
        <body class="valid" valid="valid" title="valid: True, node: 1, level: 1" node_number="1">  <div class="valid" valid="valid" title="valid: True, node: 2, level: 2" node_number="2"> <div class="valid" valid="valid" title="valid: True, node: 3, level: 3" node_number="3"> <h2 class="valid" valid="valid" title="valid: True, node: 4, level: 4" node_number="4">QUIC: A UDP-Based Multiplexed and Secure Transport<small class="valid" valid="valid" title="valid: True, node: 5, level: 5" node_number="5">RFC 9000</small></h2> <ul class="valid" valid="valid" title="valid: True, node: 6, level: 4" node_number="6"> <li class="valid" valid="valid" title="valid: True, node: 7, level: 5" node_number="7"> <a class="valid" valid="valid" title="valid: True, node: 8, level: 6" node_number="8">Status</a> </li> <li class="valid" valid="valid" title="valid: True, node: 9, level: 5" node_number="9"> <a class="valid" valid="valid" title="valid: True, node: 10, level: 6" node_number="10">IESG evaluation record</a> </li> <li class="valid" valid="valid" title="valid: True, node: 11, level: 5" node_number="11"> <a class="valid" valid="valid" title="valid: True, node: 12, level: 6" node_number="12">IESG writeups</a> </li> <li class="valid" valid="valid" title="valid: True, node: 13, level: 5" node_number="13"> <a class="valid" valid="valid" title="valid: True, node: 14, level: 6" node_number="14">Email expansions</a> </li> <li class="valid" valid="valid" title="valid: True, node: 15, level: 5" node_number="15"> <a class="valid" valid="valid" title="valid: True, node: 16, level: 6" node_number="16">History</a> </li> </ul> <ul class="valid" valid="valid" title="valid: True, node: 17, level: 4" node_number="17"> <li class="valid" valid="valid" title="valid: True, node: 18, level: 5" node_number="18"><a class="valid" valid="valid" title="valid: True, node: 19, level: 6" node_number="19"><b class="valid" valid="valid" title="valid: True, node: 20, level: 7" node_number="20">Versions</b></a></li> <li class="valid" valid="valid" title="valid: True, node: 21, level: 5" node_number="21"> <a class="valid" valid="valid" title="valid: True, node: 22, level: 6" node_number="22">00</a> </li> <li class="valid" valid="valid" title="valid: True, node: 23, level: 5" node_number="23"> <a class="valid" valid="valid" title="valid: True, node: 24, level: 6" node_number="24">01</a> </li> <li class="valid" valid="valid" title="valid: True, node: 25, level: 5" node_number="25"> <a class="valid" valid="valid" title="valid: True, node: 26, level: 6" node_number="26">02</a> </li> <li class="valid" valid="valid" title="valid: True, node: 27, level: 5" node_number="27"> <a class="valid" valid="valid" title="valid: True, node: 28, level: 6" node_number="28">03</a> </li> <li class="valid" valid="valid" title="valid: True, node: 29, level: 5" node_number="29"> <a class="valid" valid="valid" title="valid: True, node: 30, level: 6" node_number="30">04</a> </li> <li class="valid" valid="valid" title="valid: True, node: 31, level: 5" node_number="31"> <a class="valid" valid="valid" title="valid: True, node: 32, level: 6" node_number="32">05</a> </li> <li class="valid" valid="valid" title="valid: True, node: 33, level: 5" node_number="33"> <a class="valid" valid="valid" title="valid: True, node: 34, level: 6" node_number="34">06</a> </li> <li class="valid" valid="valid" title="valid: True, node: 35, level: 5" node_number="35"> <a class="valid" valid="valid" title="valid: True, node: 36, level: 6" node_number="36">07</a> </li> <li class="valid" valid="valid" title="valid: True, node: 37, level: 5" node_number="37"> <a class="valid" valid="valid" title="valid: True, node: 38, level: 6" node_number="38">08</a> </li> <li class="valid" valid="valid" title="valid: True, node: 39, level: 5" node_number="39"> <a class="valid" valid="valid" title="valid: True, node: 40, level: 6" node_number="40">09</a> </li> <li class="valid" valid="valid" title="valid: True, node: 41, level: 5" node_number="41"> <a class="valid" valid="valid" title="valid: True, node: 42, level: 6" node_number="42">10</a> </li> <li class="valid" valid="valid" title="valid: True, node: 43, level: 5" node_number="43"> <a class="valid" valid="valid" title="valid: True, node: 44, level: 6" node_number="44">11</a> </li> <li class="valid" valid="valid" title="valid: True, node: 45, level: 5" node_number="45"> <a class="valid" valid="valid" title="valid: True, node: 46, level: 6" node_number="46">12</a> </li> <li class="valid" valid="valid" title="valid: True, node: 47, level: 5" node_number="47"> <a class="valid" valid="valid" title="valid: True, node: 48, level: 6" node_number="48">13</a> </li> <li class="valid" valid="valid" title="valid: True, node: 49, level: 5" node_number="49"> <a class="valid" valid="valid" title="valid: True, node: 50, level: 6" node_number="50">14</a> </li> <li class="valid" valid="valid" title="valid: True, node: 51, level: 5" node_number="51"> <a class="valid" valid="valid" title="valid: True, node: 52, level: 6" node_number="52">15</a> </li> <li class="valid" valid="valid" title="valid: True, node: 53, level: 5" node_number="53"> <a class="valid" valid="valid" title="valid: True, node: 54, level: 6" node_number="54">16</a> </li> <li class="valid" valid="valid" title="valid: True, node: 55, level: 5" node_number="55"> <a class="valid" valid="valid" title="valid: True, node: 56, level: 6" node_number="56">17</a> </li> <li class="valid" valid="valid" title="valid: True, node: 57, level: 5" node_number="57"> <a class="valid" valid="valid" title="valid: True, node: 58, level: 6" node_number="58">18</a> </li> <li class="valid" valid="valid" title="valid: True, node: 59, level: 5" node_number="59"> <a class="valid" valid="valid" title="valid: True, node: 60, level: 6" node_number="60">19</a> </li> <li class="valid" valid="valid" title="valid: True, node: 61, level: 5" node_number="61"> <a class="valid" valid="valid" title="valid: True, node: 62, level: 6" node_number="62">20</a> </li> <li class="valid" valid="valid" title="valid: True, node: 63, level: 5" node_number="63"> <a class="valid" valid="valid" title="valid: True, node: 64, level: 6" node_number="64">21</a> </li> <li class="valid" valid="valid" title="valid: True, node: 65, level: 5" node_number="65"> <a class="valid" valid="valid" title="valid: True, node: 66, level: 6" node_number="66">22</a> </li> <li class="valid" valid="valid" title="valid: True, node: 67, level: 5" node_number="67"> <a class="valid" valid="valid" title="valid: True, node: 68, level: 6" node_number="68">23</a> </li> <li class="valid" valid="valid" title="valid: True, node: 69, level: 5" node_number="69"> <a class="valid" valid="valid" title="valid: True, node: 70, level: 6" node_number="70">24</a> </li> <li class="valid" valid="valid" title="valid: True, node: 71, level: 5" node_number="71"> <a class="valid" valid="valid" title="valid: True, node: 72, level: 6" node_number="72">25</a> </li> <li class="valid" valid="valid" title="valid: True, node: 73, level: 5" node_number="73"> <a class="valid" valid="valid" title="valid: True, node: 74, level: 6" node_number="74">26</a> </li> <li class="valid" valid="valid" title="valid: True, node: 75, level: 5" node_number="75"> <a class="valid" valid="valid" title="valid: True, node: 76, level: 6" node_number="76">27</a> </li> <li class="valid" valid="valid" title="valid: True, node: 77, level: 5" node_number="77"> <a class="valid" valid="valid" title="valid: True, node: 78, level: 6" node_number="78">28</a> </li> <li class="valid" valid="valid" title="valid: True, node: 79, level: 5" node_number="79"> <a class="valid" valid="valid" title="valid: True, node: 80, level: 6" node_number="80">29</a> </li> <li class="valid" valid="valid" title="valid: True, node: 81, level: 5" node_number="81"> <a class="valid" valid="valid" title="valid: True, node: 82, level: 6" node_number="82">30</a> </li> <li class="valid" valid="valid" title="valid: True, node: 83, level: 5" node_number="83"> <a class="valid" valid="valid" title="valid: True, node: 84, level: 6" node_number="84">31</a> </li> <li class="valid" valid="valid" title="valid: True, node: 85, level: 5" node_number="85"> <a class="valid" valid="valid" title="valid: True, node: 86, level: 6" node_number="86">32</a> </li> <li class="valid" valid="valid" title="valid: True, node: 87, level: 5" node_number="87"> <a class="valid" valid="valid" title="valid: True, node: 88, level: 6" node_number="88">33</a> </li> <li class="valid" valid="valid" title="valid: True, node: 89, level: 5" node_number="89"> <a class="valid" valid="valid" title="valid: True, node: 90, level: 6" node_number="90">34</a> </li> </ul> <div class="valid" valid="valid" title="valid: True, node: 91, level: 4" node_number="91"> <a class="valid" valid="valid" title="valid: True, node: 92, level: 5" node_number="92"> Email authors</a> <a class="valid" valid="valid" title="valid: True, node: 93, level: 5" node_number="93"> Email WG</a> <a class="valid" valid="valid" title="valid: True, node: 94, level: 5" node_number="94"> IPR </a> <a class="valid" valid="valid" title="valid: True, node: 95, level: 5" node_number="95"> References</a> <a class="valid" valid="valid" title="valid: True, node: 96, level: 5" node_number="96"> Referenced by</a> <a class="valid" valid="valid" title="valid: True, node: 97, level: 5" node_number="97"> Nits</a> <div class="valid" valid="valid" title="valid: True, node: 98, level: 5" node_number="98"> <ul class="valid" valid="valid" title="valid: True, node: 99, level: 6" node_number="99"> <li class="valid" valid="valid" title="valid: True, node: 100, level: 7" node_number="100">IETF Mail Archive</li> <li class="valid" valid="valid" title="valid: True, node: 101, level: 7" node_number="101"><a class="valid" valid="valid" title="valid: True, node: 102, level: 8" node_number="102">Google</a></li> </ul> </div> </div> <pre class="valid" valid="valid" title="valid: True, node: 103, level: 4" node_number="103">&#65279; Internet Engineering Task Force (IETF) J. Iyengar, Ed. Request for Comments: 9000 Fastly Category: Standards Track M. Thomson, Ed. ISSN: 2070-1721 Mozilla May 2021 QUIC: A UDP-Based Multiplexed and Secure Transport Abstract This document defines the core of the QUIC transport protocol. QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration. QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances. Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm. Status of This Memo This is an Internet Standards Track document. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841. Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9000. Copyright Notice Copyright (c) 2021 IETF Trust and the persons identified as the document authors. All rights reserved. This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License. Table of Contents 1. Overview 1.1. Document Structure 1.2. Terms and Definitions 1.3. Notational Conventions 2. Streams 2.1. Stream Types and Identifiers 2.2. Sending and Receiving Data 2.3. Stream Prioritization 2.4. Operations on Streams 3. Stream States 3.1. Sending Stream States 3.2. Receiving Stream States 3.3. Permitted Frame Types 3.4. Bidirectional Stream States 3.5. Solicited State Transitions 4. Flow Control 4.1. Data Flow Control 4.2. Increasing Flow Control Limits 4.3. Flow Control Performance 4.4. Handling Stream Cancellation 4.5. Stream Final Size 4.6. Controlling Concurrency 5. Connections 5.1. Connection ID 5.1.1. Issuing Connection IDs 5.1.2. Consuming and Retiring Connection IDs 5.2. Matching Packets to Connections 5.2.1. Client Packet Handling 5.2.2. Server Packet Handling 5.2.3. Considerations for Simple Load Balancers 5.3. Operations on Connections 6. Version Negotiation 6.1. Sending Version Negotiation Packets 6.2. Handling Version Negotiation Packets 6.3. Using Reserved Versions 7. Cryptographic and Transport Handshake 7.1. Example Handshake Flows 7.2. Negotiating Connection IDs 7.3. Authenticating Connection IDs 7.4. Transport Parameters 7.4.1. Values of Transport Parameters for 0-RTT 7.4.2. New Transport Parameters 7.5. Cryptographic Message Buffering 8. Address Validation 8.1. Address Validation during Connection Establishment 8.1.1. Token Construction 8.1.2. Address Validation Using Retry Packets 8.1.3. Address Validation for Future Connections 8.1.4. Address Validation Token Integrity 8.2. Path Validation 8.2.1. Initiating Path Validation 8.2.2. Path Validation Responses 8.2.3. Successful Path Validation 8.2.4. Failed Path Validation 9. Connection Migration 9.1. Probing a New Path 9.2. Initiating Connection Migration 9.3. Responding to Connection Migration 9.3.1. Peer Address Spoofing 9.3.2. On-Path Address Spoofing 9.3.3. Off-Path Packet Forwarding 9.4. Loss Detection and Congestion Control 9.5. Privacy Implications of Connection Migration 9.6. Server's Preferred Address 9.6.1. Communicating a Preferred Address 9.6.2. Migration to a Preferred Address 9.6.3. Interaction of Client Migration and Preferred Address 9.7. Use of IPv6 Flow Label and Migration 10. Connection Termination 10.1. Idle Timeout 10.1.1. Liveness Testing 10.1.2. Deferring Idle Timeout 10.2. Immediate Close 10.2.1. Closing Connection State 10.2.2. Draining Connection State 10.2.3. Immediate Close during the Handshake 10.3. Stateless Reset 10.3.1. Detecting a Stateless Reset 10.3.2. Calculating a Stateless Reset Token 10.3.3. Looping 11. Error Handling 11.1. Connection Errors 11.2. Stream Errors 12. Packets and Frames 12.1. Protected Packets 12.2. Coalescing Packets 12.3. Packet Numbers 12.4. Frames and Frame Types 12.5. Frames and Number Spaces 13. Packetization and Reliability 13.1. Packet Processing 13.2. Generating Acknowledgments 13.2.1. Sending ACK Frames 13.2.2. Acknowledgment Frequency 13.2.3. Managing ACK Ranges 13.2.4. Limiting Ranges by Tracking ACK Frames 13.2.5. Measuring and Reporting Host Delay 13.2.6. ACK Frames and Packet Protection 13.2.7. PADDING Frames Consume Congestion Window 13.3. Retransmission of Information 13.4. Explicit Congestion Notification 13.4.1. Reporting ECN Counts 13.4.2. ECN Validation 14. Datagram Size 14.1. Initial Datagram Size 14.2. Path Maximum Transmission Unit 14.2.1. Handling of ICMP Messages by PMTUD 14.3. Datagram Packetization Layer PMTU Discovery 14.3.1. DPLPMTUD and Initial Connectivity 14.3.2. Validating the Network Path with DPLPMTUD 14.3.3. Handling of ICMP Messages by DPLPMTUD 14.4. Sending QUIC PMTU Probes 14.4.1. PMTU Probes Containing Source Connection ID 15. Versions 16. Variable-Length Integer Encoding 17. Packet Formats 17.1. Packet Number Encoding and Decoding 17.2. Long Header Packets 17.2.1. Version Negotiation Packet 17.2.2. Initial Packet 17.2.3. 0-RTT 17.2.4. Handshake Packet 17.2.5. Retry Packet 17.3. Short Header Packets 17.3.1. 1-RTT Packet 17.4. Latency Spin Bit 18. Transport Parameter Encoding 18.1. Reserved Transport Parameters 18.2. Transport Parameter Definitions 19. Frame Types and Formats 19.1. PADDING Frames 19.2. PING Frames 19.3. ACK Frames 19.3.1. ACK Ranges 19.3.2. ECN Counts 19.4. RESET_STREAM Frames 19.5. STOP_SENDING Frames 19.6. CRYPTO Frames 19.7. NEW_TOKEN Frames 19.8. STREAM Frames 19.9. MAX_DATA Frames 19.10. MAX_STREAM_DATA Frames 19.11. MAX_STREAMS Frames 19.12. DATA_BLOCKED Frames 19.13. STREAM_DATA_BLOCKED Frames 19.14. STREAMS_BLOCKED Frames 19.15. NEW_CONNECTION_ID Frames 19.16. RETIRE_CONNECTION_ID Frames 19.17. PATH_CHALLENGE Frames 19.18. PATH_RESPONSE Frames 19.19. CONNECTION_CLOSE Frames 19.20. HANDSHAKE_DONE Frames 19.21. Extension Frames 20. Error Codes 20.1. Transport Error Codes 20.2. Application Protocol Error Codes 21. Security Considerations 21.1. Overview of Security Properties 21.1.1. Handshake 21.1.2. Protected Packets 21.1.3. Connection Migration 21.2. Handshake Denial of Service 21.3. Amplification Attack 21.4. Optimistic ACK Attack 21.5. Request Forgery Attacks 21.5.1. Control Options for Endpoints 21.5.2. Request Forgery with Client Initial Packets 21.5.3. Request Forgery with Preferred Addresses 21.5.4. Request Forgery with Spoofed Migration 21.5.5. Request Forgery with Version Negotiation 21.5.6. Generic Request Forgery Countermeasures 21.6. Slowloris Attacks 21.7. Stream Fragmentation and Reassembly Attacks 21.8. Stream Commitment Attack 21.9. Peer Denial of Service 21.10. Explicit Congestion Notification Attacks 21.11. Stateless Reset Oracle 21.12. Version Downgrade 21.13. Targeted Attacks by Routing 21.14. Traffic Analysis 22. IANA Considerations 22.1. Registration Policies for QUIC Registries 22.1.1. Provisional Registrations 22.1.2. Selecting Codepoints 22.1.3. Reclaiming Provisional Codepoints 22.1.4. Permanent Registrations 22.2. QUIC Versions Registry 22.3. QUIC Transport Parameters Registry 22.4. QUIC Frame Types Registry 22.5. QUIC Transport Error Codes Registry 23. References 23.1. Normative References 23.2. Informative References Appendix A. Pseudocode A.1. Sample Variable-Length Integer Decoding A.2. Sample Packet Number Encoding Algorithm A.3. Sample Packet Number Decoding Algorithm A.4. Sample ECN Validation Algorithm Contributors Authors' Addresses 1. Overview QUIC is a secure general-purpose transport protocol. This document defines version 1 of QUIC, which conforms to the version-independent properties of QUIC defined in [QUIC-INVARIANTS]. QUIC is a connection-oriented protocol that creates a stateful interaction between a client and server. The QUIC handshake combines negotiation of cryptographic and transport parameters. QUIC integrates the TLS handshake [TLS13], although using a customized framing for protecting packets. The integration of TLS and QUIC is described in more detail in [QUIC-TLS]. The handshake is structured to permit the exchange of application data as soon as possible. This includes an option for clients to send data immediately (0-RTT), which requires some form of prior communication or configuration to enable. Endpoints communicate in QUIC by exchanging QUIC packets. Most packets contain frames, which carry control information and application data between endpoints. QUIC authenticates the entirety of each packet and encrypts as much of each packet as is practical. QUIC packets are carried in UDP datagrams [UDP] to better facilitate deployment in existing systems and networks. Application protocols exchange information over a QUIC connection via streams, which are ordered sequences of bytes. Two types of streams can be created: bidirectional streams, which allow both endpoints to send data; and unidirectional streams, which allow a single endpoint to send data. A credit-based scheme is used to limit stream creation and to bound the amount of data that can be sent. QUIC provides the necessary feedback to implement reliable delivery and congestion control. An algorithm for detecting and recovering from loss of data is described in Section 6 of [QUIC-RECOVERY]. QUIC depends on congestion control to avoid network congestion. An exemplary congestion control algorithm is described in Section 7 of [QUIC-RECOVERY]. QUIC connections are not strictly bound to a single network path. Connection migration uses connection identifiers to allow connections to transfer to a new network path. Only clients are able to migrate in this version of QUIC. This design also allows connections to continue after changes in network topology or address mappings, such as might be caused by NAT rebinding. Once established, multiple options are provided for connection termination. Applications can manage a graceful shutdown, endpoints can negotiate a timeout period, errors can cause immediate connection teardown, and a stateless mechanism provides for termination of connections after one endpoint has lost state. 1.1. Document Structure This document describes the core QUIC protocol and is structured as follows: * Streams are the basic service abstraction that QUIC provides. - Section 2 describes core concepts related to streams, - Section 3 provides a reference model for stream states, and - Section 4 outlines the operation of flow control. * Connections are the context in which QUIC endpoints communicate. - Section 5 describes core concepts related to connections, - Section 6 describes version negotiation, - Section 7 details the process for establishing connections, - Section 8 describes address validation and critical denial-of- service mitigations, - Section 9 describes how endpoints migrate a connection to a new network path, - Section 10 lists the options for terminating an open connection, and - Section 11 provides guidance for stream and connection error handling. * Packets and frames are the basic unit used by QUIC to communicate. - Section 12 describes concepts related to packets and frames, - Section 13 defines models for the transmission, retransmission, and acknowledgment of data, and - Section 14 specifies rules for managing the size of datagrams carrying QUIC packets. * Finally, encoding details of QUIC protocol elements are described in: - Section 15 (versions), - Section 16 (integer encoding), - Section 17 (packet headers), - Section 18 (transport parameters), - Section 19 (frames), and - Section 20 (errors). Accompanying documents describe QUIC's loss detection and congestion control [QUIC-RECOVERY], and the use of TLS and other cryptographic mechanisms [QUIC-TLS]. This document defines QUIC version 1, which conforms to the protocol invariants in [QUIC-INVARIANTS]. To refer to QUIC version 1, cite this document. References to the limited set of version-independent properties of QUIC can cite [QUIC-INVARIANTS]. 1.2. Terms and Definitions The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here. Commonly used terms in this document are described below. QUIC: The transport protocol described by this document. QUIC is a name, not an acronym. Endpoint: An entity that can participate in a QUIC connection by generating, receiving, and processing QUIC packets. There are only two types of endpoints in QUIC: client and server. Client: The endpoint that initiates a QUIC connection. Server: The endpoint that accepts a QUIC connection. QUIC packet: A complete processable unit of QUIC that can be encapsulated in a UDP datagram. One or more QUIC packets can be encapsulated in a single UDP datagram. Ack-eliciting packet: A QUIC packet that contains frames other than ACK, PADDING, and CONNECTION_CLOSE. These cause a recipient to send an acknowledgment; see Section 13.2.1. Frame: A unit of structured protocol information. There are multiple frame types, each of which carries different information. Frames are contained in QUIC packets. Address: When used without qualification, the tuple of IP version, IP address, and UDP port number that represents one end of a network path. Connection ID: An identifier that is used to identify a QUIC connection at an endpoint. Each endpoint selects one or more connection IDs for its peer to include in packets sent towards the endpoint. This value is opaque to the peer. Stream: A unidirectional or bidirectional channel of ordered bytes within a QUIC connection. A QUIC connection can carry multiple simultaneous streams. Application: An entity that uses QUIC to send and receive data. This document uses the terms "QUIC packets", "UDP datagrams", and "IP packets" to refer to the units of the respective protocols. That is, one or more QUIC packets can be encapsulated in a UDP datagram, which is in turn encapsulated in an IP packet. 1.3. Notational Conventions Packet and frame diagrams in this document use a custom format. The purpose of this format is to summarize, not define, protocol elements. Prose defines the complete semantics and details of structures. Complex fields are named and then followed by a list of fields surrounded by a pair of matching braces. Each field in this list is separated by commas. Individual fields include length information, plus indications about fixed value, optionality, or repetitions. Individual fields use the following notational conventions, with all lengths in bits: x (A): Indicates that x is A bits long x (i): Indicates that x holds an integer value using the variable- length encoding described in Section 16 x (A..B): Indicates that x can be any length from A to B; A can be omitted to indicate a minimum of zero bits, and B can be omitted to indicate no set upper limit; values in this format always end on a byte boundary x (L) = C: Indicates that x has a fixed value of C; the length of x is described by L, which can use any of the length forms above x (L) = C..D: Indicates that x has a value in the range from C to D, inclusive, with the length described by L, as above [x (L)]: Indicates that x is optional and has a length of L x (L) ...: Indicates that x is repeated zero or more times and that each instance has a length of L This document uses network byte order (that is, big endian) values. Fields are placed starting from the high-order bits of each byte. By convention, individual fields reference a complex field by using the name of the complex field. Figure 1 provides an example: Example Structure { One-bit Field (1), 7-bit Field with Fixed Value (7) = 61, Field with Variable-Length Integer (i), Arbitrary-Length Field (..), Variable-Length Field (8..24), Field With Minimum Length (16..), Field With Maximum Length (..128), [Optional Field (64)], Repeated Field (8) ..., } Figure 1: Example Format When a single-bit field is referenced in prose, the position of that field can be clarified by using the value of the byte that carries the field with the field's value set. For example, the value 0x80 could be used to refer to the single-bit field in the most significant bit of the byte, such as One-bit Field in Figure 1. 2. Streams Streams in QUIC provide a lightweight, ordered byte-stream abstraction to an application. Streams can be unidirectional or bidirectional. Streams can be created by sending data. Other processes associated with stream management -- ending, canceling, and managing flow control -- are all designed to impose minimal overheads. For instance, a single STREAM frame (Section 19.8) can open, carry data for, and close a stream. Streams can also be long-lived and can last the entire duration of a connection. Streams can be created by either endpoint, can concurrently send data interleaved with other streams, and can be canceled. QUIC does not provide any means of ensuring ordering between bytes on different streams. QUIC allows for an arbitrary number of streams to operate concurrently and for an arbitrary amount of data to be sent on any stream, subject to flow control constraints and stream limits; see Section 4. 2.1. Stream Types and Identifiers Streams can be unidirectional or bidirectional. Unidirectional streams carry data in one direction: from the initiator of the stream to its peer. Bidirectional streams allow for data to be sent in both directions. Streams are identified within a connection by a numeric value, referred to as the stream ID. A stream ID is a 62-bit integer (0 to 2^62-1) that is unique for all streams on a connection. Stream IDs are encoded as variable-length integers; see Section 16. A QUIC endpoint MUST NOT reuse a stream ID within a connection. The least significant bit (0x01) of the stream ID identifies the initiator of the stream. Client-initiated streams have even-numbered stream IDs (with the bit set to 0), and server-initiated streams have odd-numbered stream IDs (with the bit set to 1). The second least significant bit (0x02) of the stream ID distinguishes between bidirectional streams (with the bit set to 0) and unidirectional streams (with the bit set to 1). The two least significant bits from a stream ID therefore identify a stream as one of four types, as summarized in Table 1. +======+==================================+ | Bits | Stream Type | +======+==================================+ | 0x00 | Client-Initiated, Bidirectional | +------+----------------------------------+ | 0x01 | Server-Initiated, Bidirectional | +------+----------------------------------+ | 0x02 | Client-Initiated, Unidirectional | +------+----------------------------------+ | 0x03 | Server-Initiated, Unidirectional | +------+----------------------------------+ Table 1: Stream ID Types The stream space for each type begins at the minimum value (0x00 through 0x03, respectively); successive streams of each type are created with numerically increasing stream IDs. A stream ID that is used out of order results in all streams of that type with lower- numbered stream IDs also being opened. 2.2. Sending and Receiving Data STREAM frames (Section 19.8) encapsulate data sent by an application. An endpoint uses the Stream ID and Offset fields in STREAM frames to place data in order. Endpoints MUST be able to deliver stream data to an application as an ordered byte stream. Delivering an ordered byte stream requires that an endpoint buffer any data that is received out of order, up to the advertised flow control limit. QUIC makes no specific allowances for delivery of stream data out of order. However, implementations MAY choose to offer the ability to deliver data out of order to a receiving application. An endpoint could receive data for a stream at the same stream offset multiple times. Data that has already been received can be discarded. The data at a given offset MUST NOT change if it is sent multiple times; an endpoint MAY treat receipt of different data at the same offset within a stream as a connection error of type PROTOCOL_VIOLATION. Streams are an ordered byte-stream abstraction with no other structure visible to QUIC. STREAM frame boundaries are not expected to be preserved when data is transmitted, retransmitted after packet loss, or delivered to the application at a receiver. An endpoint MUST NOT send data on any stream without ensuring that it is within the flow control limits set by its peer. Flow control is described in detail in Section 4. 2.3. Stream Prioritization Stream multiplexing can have a significant effect on application performance if resources allocated to streams are correctly prioritized. QUIC does not provide a mechanism for exchanging prioritization information. Instead, it relies on receiving priority information from the application. A QUIC implementation SHOULD provide ways in which an application can indicate the relative priority of streams. An implementation uses information provided by the application to determine how to allocate resources to active streams. 2.4. Operations on Streams This document does not define an API for QUIC; it instead defines a set of functions on streams that application protocols can rely upon. An application protocol can assume that a QUIC implementation provides an interface that includes the operations described in this section. An implementation designed for use with a specific application protocol might provide only those operations that are used by that protocol. On the sending part of a stream, an application protocol can: * write data, understanding when stream flow control credit (Section 4.1) has successfully been reserved to send the written data; * end the stream (clean termination), resulting in a STREAM frame (Section 19.8) with the FIN bit set; and * reset the stream (abrupt termination), resulting in a RESET_STREAM frame (Section 19.4) if the stream was not already in a terminal state. On the receiving part of a stream, an application protocol can: * read data; and * abort reading of the stream and request closure, possibly resulting in a STOP_SENDING frame (Section 19.5). An application protocol can also request to be informed of state changes on streams, including when the peer has opened or reset a stream, when a peer aborts reading on a stream, when new data is available, and when data can or cannot be written to the stream due to flow control. 3. Stream States This section describes streams in terms of their send or receive components. Two state machines are described: one for the streams on which an endpoint transmits data (Section 3.1) and another for streams on which an endpoint receives data (Section 3.2). Unidirectional streams use either the sending or receiving state machine, depending on the stream type and endpoint role. Bidirectional streams use both state machines at both endpoints. For the most part, the use of these state machines is the same whether the stream is unidirectional or bidirectional. The conditions for opening a stream are slightly more complex for a bidirectional stream because the opening of either the send or receive side causes the stream to open in both directions. The state machines shown in this section are largely informative. This document uses stream states to describe rules for when and how different types of frames can be sent and the reactions that are expected when different types of frames are received. Though these state machines are intended to be useful in implementing QUIC, these states are not intended to constrain implementations. An implementation can define a different state machine as long as its behavior is consistent with an implementation that implements these states. | Note: In some cases, a single event or action can cause a | transition through multiple states. For instance, sending | STREAM with a FIN bit set can cause two state transitions for a | sending stream: from the "Ready" state to the "Send" state, and | from the "Send" state to the "Data Sent" state. 3.1. Sending Stream States Figure 2 shows the states for the part of a stream that sends data to a peer. o | Create Stream (Sending) | Peer Creates Bidirectional Stream v +-------+ | Ready | Send RESET_STREAM | |-----------------------. +-------+ | | | | Send STREAM / | | STREAM_DATA_BLOCKED | v | +-------+ | | Send | Send RESET_STREAM | | |----------------------&gt;| +-------+ | | | | Send STREAM + FIN | v v +-------+ +-------+ | Data | Send RESET_STREAM | Reset | | Sent |------------------&gt;| Sent | +-------+ +-------+ | | | Recv All ACKs | Recv ACK v v +-------+ +-------+ | Data | | Reset | | Recvd | | Recvd | +-------+ +-------+ Figure 2: States for Sending Parts of Streams The sending part of a stream that the endpoint initiates (types 0 and 2 for clients, 1 and 3 for servers) is opened by the application. The "Ready" state represents a newly created stream that is able to accept data from the application. Stream data might be buffered in this state in preparation for sending. Sending the first STREAM or STREAM_DATA_BLOCKED frame causes a sending part of a stream to enter the "Send" state. An implementation might choose to defer allocating a stream ID to a stream until it sends the first STREAM frame and enters this state, which can allow for better stream prioritization. The sending part of a bidirectional stream initiated by a peer (type 0 for a server, type 1 for a client) starts in the "Ready" state when the receiving part is created. In the "Send" state, an endpoint transmits -- and retransmits as necessary -- stream data in STREAM frames. The endpoint respects the flow control limits set by its peer and continues to accept and process MAX_STREAM_DATA frames. An endpoint in the "Send" state generates STREAM_DATA_BLOCKED frames if it is blocked from sending by stream flow control limits (Section 4.1). After the application indicates that all stream data has been sent and a STREAM frame containing the FIN bit is sent, the sending part of the stream enters the "Data Sent" state. From this state, the endpoint only retransmits stream data as necessary. The endpoint does not need to check flow control limits or send STREAM_DATA_BLOCKED frames for a stream in this state. MAX_STREAM_DATA frames might be received until the peer receives the final stream offset. The endpoint can safely ignore any MAX_STREAM_DATA frames it receives from its peer for a stream in this state. Once all stream data has been successfully acknowledged, the sending part of the stream enters the "Data Recvd" state, which is a terminal state. From any state that is one of "Ready", "Send", or "Data Sent", an application can signal that it wishes to abandon transmission of stream data. Alternatively, an endpoint might receive a STOP_SENDING frame from its peer. In either case, the endpoint sends a RESET_STREAM frame, which causes the stream to enter the "Reset Sent" state. An endpoint MAY send a RESET_STREAM as the first frame that mentions a stream; this causes the sending part of that stream to open and then immediately transition to the "Reset Sent" state. Once a packet containing a RESET_STREAM has been acknowledged, the sending part of the stream enters the "Reset Recvd" state, which is a terminal state. 3.2. Receiving Stream States Figure 3 shows the states for the part of a stream that receives data from a peer. The states for a receiving part of a stream mirror only some of the states of the sending part of the stream at the peer. The receiving part of a stream does not track states on the sending part that cannot be observed, such as the "Ready" state. Instead, the receiving part of a stream tracks the delivery of data to the application, some of which cannot be observed by the sender. o | Recv STREAM / STREAM_DATA_BLOCKED / RESET_STREAM | Create Bidirectional Stream (Sending) | Recv MAX_STREAM_DATA / STOP_SENDING (Bidirectional) | Create Higher-Numbered Stream v +-------+ | Recv | Recv RESET_STREAM | |-----------------------. +-------+ | | | | Recv STREAM + FIN | v | +-------+ | | Size | Recv RESET_STREAM | | Known |----------------------&gt;| +-------+ | | | | Recv All Data | v v +-------+ Recv RESET_STREAM +-------+ | Data |--- (optional) ---&gt;| Reset | | Recvd | Recv All Data | Recvd | +-------+&lt;-- (optional) ----+-------+ | | | App Read All Data | App Read Reset v v +-------+ +-------+ | Data | | Reset | | Read | | Read | +-------+ +-------+ Figure 3: States for Receiving Parts of Streams The receiving part of a stream initiated by a peer (types 1 and 3 for a client, or 0 and 2 for a server) is created when the first STREAM, STREAM_DATA_BLOCKED, or RESET_STREAM frame is received for that stream. For bidirectional streams initiated by a peer, receipt of a MAX_STREAM_DATA or STOP_SENDING frame for the sending part of the stream also creates the receiving part. The initial state for the receiving part of a stream is "Recv". For a bidirectional stream, the receiving part enters the "Recv" state when the sending part initiated by the endpoint (type 0 for a client, type 1 for a server) enters the "Ready" state. An endpoint opens a bidirectional stream when a MAX_STREAM_DATA or STOP_SENDING frame is received from the peer for that stream. Receiving a MAX_STREAM_DATA frame for an unopened stream indicates that the remote peer has opened the stream and is providing flow control credit. Receiving a STOP_SENDING frame for an unopened stream indicates that the remote peer no longer wishes to receive data on this stream. Either frame might arrive before a STREAM or STREAM_DATA_BLOCKED frame if packets are lost or reordered. Before a stream is created, all streams of the same type with lower- numbered stream IDs MUST be created. This ensures that the creation order for streams is consistent on both endpoints. In the "Recv" state, the endpoint receives STREAM and STREAM_DATA_BLOCKED frames. Incoming data is buffered and can be reassembled into the correct order for delivery to the application. As data is consumed by the application and buffer space becomes available, the endpoint sends MAX_STREAM_DATA frames to allow the peer to send more data. When a STREAM frame with a FIN bit is received, the final size of the stream is known; see Section 4.5. The receiving part of the stream then enters the "Size Known" state. In this state, the endpoint no longer needs to send MAX_STREAM_DATA frames; it only receives any retransmissions of stream data. Once all data for the stream has been received, the receiving part enters the "Data Recvd" state. This might happen as a result of receiving the same STREAM frame that causes the transition to "Size Known". After all data has been received, any STREAM or STREAM_DATA_BLOCKED frames for the stream can be discarded. The "Data Recvd" state persists until stream data has been delivered to the application. Once stream data has been delivered, the stream enters the "Data Read" state, which is a terminal state. Receiving a RESET_STREAM frame in the "Recv" or "Size Known" state causes the stream to enter the "Reset Recvd" state. This might cause the delivery of stream data to the application to be interrupted. It is possible that all stream data has already been received when a RESET_STREAM is received (that is, in the "Data Recvd" state). Similarly, it is possible for remaining stream data to arrive after receiving a RESET_STREAM frame (the "Reset Recvd" state). An implementation is free to manage this situation as it chooses. Sending a RESET_STREAM means that an endpoint cannot guarantee delivery of stream data; however, there is no requirement that stream data not be delivered if a RESET_STREAM is received. An implementation MAY interrupt delivery of stream data, discard any data that was not consumed, and signal the receipt of the RESET_STREAM. A RESET_STREAM signal might be suppressed or withheld if stream data is completely received and is buffered to be read by the application. If the RESET_STREAM is suppressed, the receiving part of the stream remains in "Data Recvd". Once the application receives the signal indicating that the stream was reset, the receiving part of the stream transitions to the "Reset Read" state, which is a terminal state. 3.3. Permitted Frame Types The sender of a stream sends just three frame types that affect the state of a stream at either the sender or the receiver: STREAM (Section 19.8), STREAM_DATA_BLOCKED (Section 19.13), and RESET_STREAM (Section 19.4). A sender MUST NOT send any of these frames from a terminal state ("Data Recvd" or "Reset Recvd"). A sender MUST NOT send a STREAM or STREAM_DATA_BLOCKED frame for a stream in the "Reset Sent" state or any terminal state -- that is, after sending a RESET_STREAM frame. A receiver could receive any of these three frames in any state, due to the possibility of delayed delivery of packets carrying them. The receiver of a stream sends MAX_STREAM_DATA frames (Section 19.10) and STOP_SENDING frames (Section 19.5). The receiver only sends MAX_STREAM_DATA frames in the "Recv" state. A receiver MAY send a STOP_SENDING frame in any state where it has not received a RESET_STREAM frame -- that is, states other than "Reset Recvd" or "Reset Read". However, there is little value in sending a STOP_SENDING frame in the "Data Recvd" state, as all stream data has been received. A sender could receive either of these two types of frames in any state as a result of delayed delivery of packets. 3.4. Bidirectional Stream States A bidirectional stream is composed of sending and receiving parts. Implementations can represent states of the bidirectional stream as composites of sending and receiving stream states. The simplest model presents the stream as "open" when either sending or receiving parts are in a non-terminal state and "closed" when both sending and receiving streams are in terminal states. Table 2 shows a more complex mapping of bidirectional stream states that loosely correspond to the stream states defined in HTTP/2 [HTTP2]. This shows that multiple states on sending or receiving parts of streams are mapped to the same composite state. Note that this is just one possibility for such a mapping; this mapping requires that data be acknowledged before the transition to a "closed" or "half-closed" state. +===================+=======================+=================+ | Sending Part | Receiving Part | Composite State | +===================+=======================+=================+ | No Stream / Ready | No Stream / Recv (*1) | idle | +-------------------+-----------------------+-----------------+ | Ready / Send / | Recv / Size Known | open | | Data Sent | | | +-------------------+-----------------------+-----------------+ | Ready / Send / | Data Recvd / Data | half-closed | | Data Sent | Read | (remote) | +-------------------+-----------------------+-----------------+ | Ready / Send / | Reset Recvd / Reset | half-closed | | Data Sent | Read | (remote) | +-------------------+-----------------------+-----------------+ | Data Recvd | Recv / Size Known | half-closed | | | | (local) | +-------------------+-----------------------+-----------------+ | Reset Sent / | Recv / Size Known | half-closed | | Reset Recvd | | (local) | +-------------------+-----------------------+-----------------+ | Reset Sent / | Data Recvd / Data | closed | | Reset Recvd | Read | | +-------------------+-----------------------+-----------------+ | Reset Sent / | Reset Recvd / Reset | closed | | Reset Recvd | Read | | +-------------------+-----------------------+-----------------+ | Data Recvd | Data Recvd / Data | closed | | | Read | | +-------------------+-----------------------+-----------------+ | Data Recvd | Reset Recvd / Reset | closed | | | Read | | +-------------------+-----------------------+-----------------+ Table 2: Possible Mapping of Stream States to HTTP/2 | Note (*1): A stream is considered "idle" if it has not yet been | created or if the receiving part of the stream is in the "Recv" | state without yet having received any frames. 3.5. Solicited State Transitions If an application is no longer interested in the data it is receiving on a stream, it can abort reading the stream and specify an application error code. If the stream is in the "Recv" or "Size Known" state, the transport SHOULD signal this by sending a STOP_SENDING frame to prompt closure of the stream in the opposite direction. This typically indicates that the receiving application is no longer reading data it receives from the stream, but it is not a guarantee that incoming data will be ignored. STREAM frames received after sending a STOP_SENDING frame are still counted toward connection and stream flow control, even though these frames can be discarded upon receipt. A STOP_SENDING frame requests that the receiving endpoint send a RESET_STREAM frame. An endpoint that receives a STOP_SENDING frame MUST send a RESET_STREAM frame if the stream is in the "Ready" or "Send" state. If the stream is in the "Data Sent" state, the endpoint MAY defer sending the RESET_STREAM frame until the packets containing outstanding data are acknowledged or declared lost. If any outstanding data is declared lost, the endpoint SHOULD send a RESET_STREAM frame instead of retransmitting the data. An endpoint SHOULD copy the error code from the STOP_SENDING frame to the RESET_STREAM frame it sends, but it can use any application error code. An endpoint that sends a STOP_SENDING frame MAY ignore the error code in any RESET_STREAM frames subsequently received for that stream. STOP_SENDING SHOULD only be sent for a stream that has not been reset by the peer. STOP_SENDING is most useful for streams in the "Recv" or "Size Known" state. An endpoint is expected to send another STOP_SENDING frame if a packet containing a previous STOP_SENDING is lost. However, once either all stream data or a RESET_STREAM frame has been received for the stream -- that is, the stream is in any state other than "Recv" or "Size Known" -- sending a STOP_SENDING frame is unnecessary. An endpoint that wishes to terminate both directions of a bidirectional stream can terminate one direction by sending a RESET_STREAM frame, and it can encourage prompt termination in the opposite direction by sending a STOP_SENDING frame. 4. Flow Control Receivers need to limit the amount of data that they are required to buffer, in order to prevent a fast sender from overwhelming them or a malicious sender from consuming a large amount of memory. To enable a receiver to limit memory commitments for a connection, streams are flow controlled both individually and across a connection as a whole. A QUIC receiver controls the maximum amount of data the sender can send on a stream as well as across all streams at any time, as described in Sections 4.1 and 4.2. Similarly, to limit concurrency within a connection, a QUIC endpoint controls the maximum cumulative number of streams that its peer can initiate, as described in Section 4.6. Data sent in CRYPTO frames is not flow controlled in the same way as stream data. QUIC relies on the cryptographic protocol implementation to avoid excessive buffering of data; see [QUIC-TLS]. To avoid excessive buffering at multiple layers, QUIC implementations SHOULD provide an interface for the cryptographic protocol implementation to communicate its buffering limits. 4.1. Data Flow Control QUIC employs a limit-based flow control scheme where a receiver advertises the limit of total bytes it is prepared to receive on a given stream or for the entire connection. This leads to two levels of data flow control in QUIC: * Stream flow control, which prevents a single stream from consuming the entire receive buffer for a connection by limiting the amount of data that can be sent on each stream. * Connection flow control, which prevents senders from exceeding a receiver's buffer capacity for the connection by limiting the total bytes of stream data sent in STREAM frames on all streams. Senders MUST NOT send data in excess of either limit. A receiver sets initial limits for all streams through transport parameters during the handshake (Section 7.4). Subsequently, a receiver sends MAX_STREAM_DATA frames (Section 19.10) or MAX_DATA frames (Section 19.9) to the sender to advertise larger limits. A receiver can advertise a larger limit for a stream by sending a MAX_STREAM_DATA frame with the corresponding stream ID. A MAX_STREAM_DATA frame indicates the maximum absolute byte offset of a stream. A receiver could determine the flow control offset to be advertised based on the current offset of data consumed on that stream. A receiver can advertise a larger limit for a connection by sending a MAX_DATA frame, which indicates the maximum of the sum of the absolute byte offsets of all streams. A receiver maintains a cumulative sum of bytes received on all streams, which is used to check for violations of the advertised connection or stream data limits. A receiver could determine the maximum data limit to be advertised based on the sum of bytes consumed on all streams. Once a receiver advertises a limit for the connection or a stream, it is not an error to advertise a smaller limit, but the smaller limit has no effect. A receiver MUST close the connection with an error of type FLOW_CONTROL_ERROR if the sender violates the advertised connection or stream data limits; see Section 11 for details on error handling. A sender MUST ignore any MAX_STREAM_DATA or MAX_DATA frames that do not increase flow control limits. If a sender has sent data up to the limit, it will be unable to send new data and is considered blocked. A sender SHOULD send a STREAM_DATA_BLOCKED or DATA_BLOCKED frame to indicate to the receiver that it has data to write but is blocked by flow control limits. If a sender is blocked for a period longer than the idle timeout (Section 10.1), the receiver might close the connection even when the sender has data that is available for transmission. To keep the connection from closing, a sender that is flow control limited SHOULD periodically send a STREAM_DATA_BLOCKED or DATA_BLOCKED frame when it has no ack-eliciting packets in flight. 4.2. Increasing Flow Control Limits Implementations decide when and how much credit to advertise in MAX_STREAM_DATA and MAX_DATA frames, but this section offers a few considerations. To avoid blocking a sender, a receiver MAY send a MAX_STREAM_DATA or MAX_DATA frame multiple times within a round trip or send it early enough to allow time for loss of the frame and subsequent recovery. Control frames contribute to connection overhead. Therefore, frequently sending MAX_STREAM_DATA and MAX_DATA frames with small changes is undesirable. On the other hand, if updates are less frequent, larger increments to limits are necessary to avoid blocking a sender, requiring larger resource commitments at the receiver. There is a trade-off between resource commitment and overhead when determining how large a limit is advertised. A receiver can use an autotuning mechanism to tune the frequency and amount of advertised additional credit based on a round-trip time estimate and the rate at which the receiving application consumes data, similar to common TCP implementations. As an optimization, an endpoint could send frames related to flow control only when there are other frames to send, ensuring that flow control does not cause extra packets to be sent. A blocked sender is not required to send STREAM_DATA_BLOCKED or DATA_BLOCKED frames. Therefore, a receiver MUST NOT wait for a STREAM_DATA_BLOCKED or DATA_BLOCKED frame before sending a MAX_STREAM_DATA or MAX_DATA frame; doing so could result in the sender being blocked for the rest of the connection. Even if the sender sends these frames, waiting for them will result in the sender being blocked for at least an entire round trip. When a sender receives credit after being blocked, it might be able to send a large amount of data in response, resulting in short-term congestion; see Section 7.7 of [QUIC-RECOVERY] for a discussion of how a sender can avoid this congestion. 4.3. Flow Control Performance If an endpoint cannot ensure that its peer always has available flow control credit that is greater than the peer's bandwidth-delay product on this connection, its receive throughput will be limited by flow control. Packet loss can cause gaps in the receive buffer, preventing the application from consuming data and freeing up receive buffer space. Sending timely updates of flow control limits can improve performance. Sending packets only to provide flow control updates can increase network load and adversely affect performance. Sending flow control updates along with other frames, such as ACK frames, reduces the cost of those updates. 4.4. Handling Stream Cancellation Endpoints need to eventually agree on the amount of flow control credit that has been consumed on every stream, to be able to account for all bytes for connection-level flow control. On receipt of a RESET_STREAM frame, an endpoint will tear down state for the matching stream and ignore further data arriving on that stream. RESET_STREAM terminates one direction of a stream abruptly. For a bidirectional stream, RESET_STREAM has no effect on data flow in the opposite direction. Both endpoints MUST maintain flow control state for the stream in the unterminated direction until that direction enters a terminal state. 4.5. Stream Final Size The final size is the amount of flow control credit that is consumed by a stream. Assuming that every contiguous byte on the stream was sent once, the final size is the number of bytes sent. More generally, this is one higher than the offset of the byte with the largest offset sent on the stream, or zero if no bytes were sent. A sender always communicates the final size of a stream to the receiver reliably, no matter how the stream is terminated. The final size is the sum of the Offset and Length fields of a STREAM frame with a FIN flag, noting that these fields might be implicit. Alternatively, the Final Size field of a RESET_STREAM frame carries this value. This guarantees that both endpoints agree on how much flow control credit was consumed by the sender on that stream. An endpoint will know the final size for a stream when the receiving part of the stream enters the "Size Known" or "Reset Recvd" state (Section 3). The receiver MUST use the final size of the stream to account for all bytes sent on the stream in its connection-level flow controller. An endpoint MUST NOT send data on a stream at or beyond the final size. Once a final size for a stream is known, it cannot change. If a RESET_STREAM or STREAM frame is received indicating a change in the final size for the stream, an endpoint SHOULD respond with an error of type FINAL_SIZE_ERROR; see Section 11 for details on error handling. A receiver SHOULD treat receipt of data at or beyond the final size as an error of type FINAL_SIZE_ERROR, even after a stream is closed. Generating these errors is not mandatory, because requiring that an endpoint generate these errors also means that the endpoint needs to maintain the final size state for closed streams, which could mean a significant state commitment. 4.6. Controlling Concurrency An endpoint limits the cumulative number of incoming streams a peer can open. Only streams with a stream ID less than "(max_streams * 4 + first_stream_id_of_type)" can be opened; see Table 1. Initial limits are set in the transport parameters; see Section 18.2. Subsequent limits are advertised using MAX_STREAMS frames; see Section 19.11. Separate limits apply to unidirectional and bidirectional streams. If a max_streams transport parameter or a MAX_STREAMS frame is received with a value greater than 2^60, this would allow a maximum stream ID that cannot be expressed as a variable-length integer; see Section 16. If either is received, the connection MUST be closed immediately with a connection error of type TRANSPORT_PARAMETER_ERROR if the offending value was received in a transport parameter or of type FRAME_ENCODING_ERROR if it was received in a frame; see Section 10.2. Endpoints MUST NOT exceed the limit set by their peer. An endpoint that receives a frame with a stream ID exceeding the limit it has sent MUST treat this as a connection error of type STREAM_LIMIT_ERROR; see Section 11 for details on error handling. Once a receiver advertises a stream limit using the MAX_STREAMS frame, advertising a smaller limit has no effect. MAX_STREAMS frames that do not increase the stream limit MUST be ignored. As with stream and connection flow control, this document leaves implementations to decide when and how many streams should be advertised to a peer via MAX_STREAMS. Implementations might choose to increase limits as streams are closed, to keep the number of streams available to peers roughly consistent. An endpoint that is unable to open a new stream due to the peer's limits SHOULD send a STREAMS_BLOCKED frame (Section 19.14). This signal is considered useful for debugging. An endpoint MUST NOT wait to receive this signal before advertising additional credit, since doing so will mean that the peer will be blocked for at least an entire round trip, and potentially indefinitely if the peer chooses not to send STREAMS_BLOCKED frames. 5. Connections A QUIC connection is shared state between a client and a server. Each connection starts with a handshake phase, during which the two endpoints establish a shared secret using the cryptographic handshake protocol [QUIC-TLS] and negotiate the application protocol. The handshake (Section 7) confirms that both endpoints are willing to communicate (Section 8.1) and establishes parameters for the connection (Section 7.4). An application protocol can use the connection during the handshake phase with some limitations. 0-RTT allows application data to be sent by a client before receiving a response from the server. However, 0-RTT provides no protection against replay attacks; see Section 9.2 of [QUIC-TLS]. A server can also send application data to a client before it receives the final cryptographic handshake messages that allow it to confirm the identity and liveness of the client. These capabilities allow an application protocol to offer the option of trading some security guarantees for reduced latency. The use of connection IDs (Section 5.1) allows connections to migrate to a new network path, both as a direct choice of an endpoint and when forced by a change in a middlebox. Section 9 describes mitigations for the security and privacy issues associated with migration. For connections that are no longer needed or desired, there are several ways for a client and server to terminate a connection, as described in Section 10. 5.1. Connection ID Each connection possesses a set of connection identifiers, or connection IDs, each of which can identify the connection. Connection IDs are independently selected by endpoints; each endpoint selects the connection IDs that its peer uses. The primary function of a connection ID is to ensure that changes in addressing at lower protocol layers (UDP, IP) do not cause packets for a QUIC connection to be delivered to the wrong endpoint. Each endpoint selects connection IDs using an implementation-specific (and perhaps deployment-specific) method that will allow packets with that connection ID to be routed back to the endpoint and to be identified by the endpoint upon receipt. Multiple connection IDs are used so that endpoints can send packets that cannot be identified by an observer as being for the same connection without cooperation from an endpoint; see Section 9.5. Connection IDs MUST NOT contain any information that can be used by an external observer (that is, one that does not cooperate with the issuer) to correlate them with other connection IDs for the same connection. As a trivial example, this means the same connection ID MUST NOT be issued more than once on the same connection. Packets with long headers include Source Connection ID and Destination Connection ID fields. These fields are used to set the connection IDs for new connections; see Section 7.2 for details. Packets with short headers (Section 17.3) only include the Destination Connection ID and omit the explicit length. The length of the Destination Connection ID field is expected to be known to endpoints. Endpoints using a load balancer that routes based on connection ID could agree with the load balancer on a fixed length for connection IDs or agree on an encoding scheme. A fixed portion could encode an explicit length, which allows the entire connection ID to vary in length and still be used by the load balancer. A Version Negotiation (Section 17.2.1) packet echoes the connection IDs selected by the client, both to ensure correct routing toward the client and to demonstrate that the packet is in response to a packet sent by the client. A zero-length connection ID can be used when a connection ID is not needed to route to the correct endpoint. However, multiplexing connections on the same local IP address and port while using zero- length connection IDs will cause failures in the presence of peer connection migration, NAT rebinding, and client port reuse. An endpoint MUST NOT use the same IP address and port for multiple concurrent connections with zero-length connection IDs, unless it is certain that those protocol features are not in use. When an endpoint uses a non-zero-length connection ID, it needs to ensure that the peer has a supply of connection IDs from which to choose for packets sent to the endpoint. These connection IDs are supplied by the endpoint using the NEW_CONNECTION_ID frame (Section 19.15). 5.1.1. Issuing Connection IDs Each connection ID has an associated sequence number to assist in detecting when NEW_CONNECTION_ID or RETIRE_CONNECTION_ID frames refer to the same value. The initial connection ID issued by an endpoint is sent in the Source Connection ID field of the long packet header (Section 17.2) during the handshake. The sequence number of the initial connection ID is 0. If the preferred_address transport parameter is sent, the sequence number of the supplied connection ID is 1. Additional connection IDs are communicated to the peer using NEW_CONNECTION_ID frames (Section 19.15). The sequence number on each newly issued connection ID MUST increase by 1. The connection ID that a client selects for the first Destination Connection ID field it sends and any connection ID provided by a Retry packet are not assigned sequence numbers. When an endpoint issues a connection ID, it MUST accept packets that carry this connection ID for the duration of the connection or until its peer invalidates the connection ID via a RETIRE_CONNECTION_ID frame (Section 19.16). Connection IDs that are issued and not retired are considered active; any active connection ID is valid for use with the current connection at any time, in any packet type. This includes the connection ID issued by the server via the preferred_address transport parameter. An endpoint SHOULD ensure that its peer has a sufficient number of available and unused connection IDs. Endpoints advertise the number of active connection IDs they are willing to maintain using the active_connection_id_limit transport parameter. An endpoint MUST NOT provide more connection IDs than the peer's limit. An endpoint MAY send connection IDs that temporarily exceed a peer's limit if the NEW_CONNECTION_ID frame also requires the retirement of any excess, by including a sufficiently large value in the Retire Prior To field. A NEW_CONNECTION_ID frame might cause an endpoint to add some active connection IDs and retire others based on the value of the Retire Prior To field. After processing a NEW_CONNECTION_ID frame and adding and retiring active connection IDs, if the number of active connection IDs exceeds the value advertised in its active_connection_id_limit transport parameter, an endpoint MUST close the connection with an error of type CONNECTION_ID_LIMIT_ERROR. An endpoint SHOULD supply a new connection ID when the peer retires a connection ID. If an endpoint provided fewer connection IDs than the peer's active_connection_id_limit, it MAY supply a new connection ID when it receives a packet with a previously unused connection ID. An endpoint MAY limit the total number of connection IDs issued for each connection to avoid the risk of running out of connection IDs; see Section 10.3.2. An endpoint MAY also limit the issuance of connection IDs to reduce the amount of per-path state it maintains, such as path validation status, as its peer might interact with it over as many paths as there are issued connection IDs. An endpoint that initiates migration and requires non-zero-length connection IDs SHOULD ensure that the pool of connection IDs available to its peer allows the peer to use a new connection ID on migration, as the peer will be unable to respond if the pool is exhausted. An endpoint that selects a zero-length connection ID during the handshake cannot issue a new connection ID. A zero-length Destination Connection ID field is used in all packets sent toward such an endpoint over any network path. 5.1.2. Consuming and Retiring Connection IDs An endpoint can change the connection ID it uses for a peer to another available one at any time during the connection. An endpoint consumes connection IDs in response to a migrating peer; see Section 9.5 for more details. An endpoint maintains a set of connection IDs received from its peer, any of which it can use when sending packets. When the endpoint wishes to remove a connection ID from use, it sends a RETIRE_CONNECTION_ID frame to its peer. Sending a RETIRE_CONNECTION_ID frame indicates that the connection ID will not be used again and requests that the peer replace it with a new connection ID using a NEW_CONNECTION_ID frame. As discussed in Section 9.5, endpoints limit the use of a connection ID to packets sent from a single local address to a single destination address. Endpoints SHOULD retire connection IDs when they are no longer actively using either the local or destination address for which the connection ID was used. An endpoint might need to stop accepting previously issued connection IDs in certain circumstances. Such an endpoint can cause its peer to retire connection IDs by sending a NEW_CONNECTION_ID frame with an increased Retire Prior To field. The endpoint SHOULD continue to accept the previously issued connection IDs until they are retired by the peer. If the endpoint can no longer process the indicated connection IDs, it MAY close the connection. Upon receipt of an increased Retire Prior To field, the peer MUST stop using the corresponding connection IDs and retire them with RETIRE_CONNECTION_ID frames before adding the newly provided connection ID to the set of active connection IDs. This ordering allows an endpoint to replace all active connection IDs without the possibility of a peer having no available connection IDs and without exceeding the limit the peer sets in the active_connection_id_limit transport parameter; see Section 18.2. Failure to cease using the connection IDs when requested can result in connection failures, as the issuing endpoint might be unable to continue using the connection IDs with the active connection. An endpoint SHOULD limit the number of connection IDs it has retired locally for which RETIRE_CONNECTION_ID frames have not yet been acknowledged. An endpoint SHOULD allow for sending and tracking a number of RETIRE_CONNECTION_ID frames of at least twice the value of the active_connection_id_limit transport parameter. An endpoint MUST NOT forget a connection ID without retiring it, though it MAY choose to treat having connection IDs in need of retirement that exceed this limit as a connection error of type CONNECTION_ID_LIMIT_ERROR. Endpoints SHOULD NOT issue updates of the Retire Prior To field before receiving RETIRE_CONNECTION_ID frames that retire all connection IDs indicated by the previous Retire Prior To value. 5.2. Matching Packets to Connections Incoming packets are classified on receipt. Packets can either be associated with an existing connection or -- for servers -- potentially create a new connection. Endpoints try to associate a packet with an existing connection. If the packet has a non-zero-length Destination Connection ID corresponding to an existing connection, QUIC processes that packet accordingly. Note that more than one connection ID can be associated with a connection; see Section 5.1. If the Destination Connection ID is zero length and the addressing information in the packet matches the addressing information the endpoint uses to identify a connection with a zero-length connection ID, QUIC processes the packet as part of that connection. An endpoint can use just destination IP and port or both source and destination addresses for identification, though this makes connections fragile as described in Section 5.1. Endpoints can send a Stateless Reset (Section 10.3) for any packets that cannot be attributed to an existing connection. A Stateless Reset allows a peer to more quickly identify when a connection becomes unusable. Packets that are matched to an existing connection are discarded if the packets are inconsistent with the state of that connection. For example, packets are discarded if they indicate a different protocol version than that of the connection or if the removal of packet protection is unsuccessful once the expected keys are available. Invalid packets that lack strong integrity protection, such as Initial, Retry, or Version Negotiation, MAY be discarded. An endpoint MUST generate a connection error if processing the contents of these packets prior to discovering an error, or fully revert any changes made during that processing. 5.2.1. Client Packet Handling Valid packets sent to clients always include a Destination Connection ID that matches a value the client selects. Clients that choose to receive zero-length connection IDs can use the local address and port to identify a connection. Packets that do not match an existing connection -- based on Destination Connection ID or, if this value is zero length, local IP address and port -- are discarded. Due to packet reordering or loss, a client might receive packets for a connection that are encrypted with a key it has not yet computed. The client MAY drop these packets, or it MAY buffer them in anticipation of later packets that allow it to compute the key. If a client receives a packet that uses a different version than it initially selected, it MUST discard that packet. 5.2.2. Server Packet Handling If a server receives a packet that indicates an unsupported version and if the packet is large enough to initiate a new connection for any supported version, the server SHOULD send a Version Negotiation packet as described in Section 6.1. A server MAY limit the number of packets to which it responds with a Version Negotiation packet. Servers MUST drop smaller packets that specify unsupported versions. The first packet for an unsupported version can use different semantics and encodings for any version-specific field. In particular, different packet protection keys might be used for different versions. Servers that do not support a particular version are unlikely to be able to decrypt the payload of the packet or properly interpret the result. Servers SHOULD respond with a Version Negotiation packet, provided that the datagram is sufficiently long. Packets with a supported version, or no Version field, are matched to a connection using the connection ID or -- for packets with zero- length connection IDs -- the local address and port. These packets are processed using the selected connection; otherwise, the server continues as described below. If the packet is an Initial packet fully conforming with the specification, the server proceeds with the handshake (Section 7). This commits the server to the version that the client selected. If a server refuses to accept a new connection, it SHOULD send an Initial packet containing a CONNECTION_CLOSE frame with error code CONNECTION_REFUSED. If the packet is a 0-RTT packet, the server MAY buffer a limited number of these packets in anticipation of a late-arriving Initial packet. Clients are not able to send Handshake packets prior to receiving a server response, so servers SHOULD ignore any such packets. Servers MUST drop incoming packets under all other circumstances. 5.2.3. Considerations for Simple Load Balancers A server deployment could load-balance among servers using only source and destination IP addresses and ports. Changes to the client's IP address or port could result in packets being forwarded to the wrong server. Such a server deployment could use one of the following methods for connection continuity when a client's address changes. * Servers could use an out-of-band mechanism to forward packets to the correct server based on connection ID. * If servers can use a dedicated server IP address or port, other than the one that the client initially connects to, they could use the preferred_address transport parameter to request that clients move connections to that dedicated address. Note that clients could choose not to use the preferred address. A server in a deployment that does not implement a solution to maintain connection continuity when the client address changes SHOULD indicate that migration is not supported by using the disable_active_migration transport parameter. The disable_active_migration transport parameter does not prohibit connection migration after a client has acted on a preferred_address transport parameter. Server deployments that use this simple form of load balancing MUST avoid the creation of a stateless reset oracle; see Section 21.11. 5.3. Operations on Connections This document does not define an API for QUIC; it instead defines a set of functions for QUIC connections that application protocols can rely upon. An application protocol can assume that an implementation of QUIC provides an interface that includes the operations described in this section. An implementation designed for use with a specific application protocol might provide only those operations that are used by that protocol. When implementing the client role, an application protocol can: * open a connection, which begins the exchange described in Section 7; * enable Early Data when available; and * be informed when Early Data has been accepted or rejected by a server. When implementing the server role, an application protocol can: * listen for incoming connections, which prepares for the exchange described in Section 7; * if Early Data is supported, embed application-controlled data in the TLS resumption ticket sent to the client; and * if Early Data is supported, retrieve application-controlled data from the client's resumption ticket and accept or reject Early Data based on that information. In either role, an application protocol can: * configure minimum values for the initial number of permitted streams of each type, as communicated in the transport parameters (Section 7.4); * control resource allocation for receive buffers by setting flow control limits both for streams and for the connection; * identify whether the handshake has completed successfully or is still ongoing; * keep a connection from silently closing, by either generating PING frames (Section 19.2) or requesting that the transport send additional frames before the idle timeout expires (Section 10.1); and * immediately close (Section 10.2) the connection. 6. Version Negotiation Version negotiation allows a server to indicate that it does not support the version the client used. A server sends a Version Negotiation packet in response to each packet that might initiate a new connection; see Section 5.2 for details. The size of the first packet sent by a client will determine whether a server sends a Version Negotiation packet. Clients that support multiple QUIC versions SHOULD ensure that the first UDP datagram they send is sized to the largest of the minimum datagram sizes from all versions they support, using PADDING frames (Section 19.1) as necessary. This ensures that the server responds if there is a mutually supported version. A server might not send a Version Negotiation packet if the datagram it receives is smaller than the minimum size specified in a different version; see Section 14.1. 6.1. Sending Version Negotiation Packets If the version selected by the client is not acceptable to the server, the server responds with a Version Negotiation packet; see Section 17.2.1. This includes a list of versions that the server will accept. An endpoint MUST NOT send a Version Negotiation packet in response to receiving a Version Negotiation packet. This system allows a server to process packets with unsupported versions without retaining state. Though either the Initial packet or the Version Negotiation packet that is sent in response could be lost, the client will send new packets until it successfully receives a response or it abandons the connection attempt. A server MAY limit the number of Version Negotiation packets it sends. For instance, a server that is able to recognize packets as 0-RTT might choose not to send Version Negotiation packets in response to 0-RTT packets with the expectation that it will eventually receive an Initial packet. 6.2. Handling Version Negotiation Packets Version Negotiation packets are designed to allow for functionality to be defined in the future that allows QUIC to negotiate the version of QUIC to use for a connection. Future Standards Track specifications might change how implementations that support multiple versions of QUIC react to Version Negotiation packets received in response to an attempt to establish a connection using this version. A client that supports only this version of QUIC MUST abandon the current connection attempt if it receives a Version Negotiation packet, with the following two exceptions. A client MUST discard any Version Negotiation packet if it has received and successfully processed any other packet, including an earlier Version Negotiation packet. A client MUST discard a Version Negotiation packet that lists the QUIC version selected by the client. How to perform version negotiation is left as future work defined by future Standards Track specifications. In particular, that future work will ensure robustness against version downgrade attacks; see Section 21.12. 6.3. Using Reserved Versions For a server to use a new version in the future, clients need to correctly handle unsupported versions. Some version numbers (0x?a?a?a?a, as defined in Section 15) are reserved for inclusion in fields that contain version numbers. Endpoints MAY add reserved versions to any field where unknown or unsupported versions are ignored to test that a peer correctly ignores the value. For instance, an endpoint could include a reserved version in a Version Negotiation packet; see Section 17.2.1. Endpoints MAY send packets with a reserved version to test that a peer correctly discards the packet. 7. Cryptographic and Transport Handshake QUIC relies on a combined cryptographic and transport handshake to minimize connection establishment latency. QUIC uses the CRYPTO frame (Section 19.6) to transmit the cryptographic handshake. The version of QUIC defined in this document is identified as 0x00000001 and uses TLS as described in [QUIC-TLS]; a different QUIC version could indicate that a different cryptographic handshake protocol is in use. QUIC provides reliable, ordered delivery of the cryptographic handshake data. QUIC packet protection is used to encrypt as much of the handshake protocol as possible. The cryptographic handshake MUST provide the following properties: * authenticated key exchange, where - a server is always authenticated, - a client is optionally authenticated, - every connection produces distinct and unrelated keys, and - keying material is usable for packet protection for both 0-RTT and 1-RTT packets. * authenticated exchange of values for transport parameters of both endpoints, and confidentiality protection for server transport parameters (see Section 7.4). * authenticated negotiation of an application protocol (TLS uses Application-Layer Protocol Negotiation (ALPN) [ALPN] for this purpose). The CRYPTO frame can be sent in different packet number spaces (Section 12.3). The offsets used by CRYPTO frames to ensure ordered delivery of cryptographic handshake data start from zero in each packet number space. Figure 4 shows a simplified handshake and the exchange of packets and frames that are used to advance the handshake. Exchange of application data during the handshake is enabled where possible, shown with an asterisk ("*"). Once the handshake is complete, endpoints are able to exchange application data freely. Client Server Initial (CRYPTO) 0-RTT (*) ----------&gt; Initial (CRYPTO) Handshake (CRYPTO) &lt;---------- 1-RTT (*) Handshake (CRYPTO) 1-RTT (*) ----------&gt; &lt;---------- 1-RTT (HANDSHAKE_DONE) 1-RTT &lt;=========&gt; 1-RTT Figure 4: Simplified QUIC Handshake Endpoints can use packets sent during the handshake to test for Explicit Congestion Notification (ECN) support; see Section 13.4. An endpoint validates support for ECN by observing whether the ACK frames acknowledging the first packets it sends carry ECN counts, as described in Section 13.4.2. Endpoints MUST explicitly negotiate an application protocol. This avoids situations where there is a disagreement about the protocol that is in use. 7.1. Example Handshake Flows Details of how TLS is integrated with QUIC are provided in [QUIC-TLS], but some examples are provided here. An extension of this exchange to support client address validation is shown in Section 8.1.2. Once any address validation exchanges are complete, the cryptographic handshake is used to agree on cryptographic keys. The cryptographic handshake is carried in Initial (Section 17.2.2) and Handshake (Section 17.2.4) packets. Figure 5 provides an overview of the 1-RTT handshake. Each line shows a QUIC packet with the packet type and packet number shown first, followed by the frames that are typically contained in those packets. For instance, the first packet is of type Initial, with packet number 0, and contains a CRYPTO frame carrying the ClientHello. Multiple QUIC packets -- even of different packet types -- can be coalesced into a single UDP datagram; see Section 12.2. As a result, this handshake could consist of as few as four UDP datagrams, or any number more (subject to limits inherent to the protocol, such as congestion control and anti-amplification). For instance, the server's first flight contains Initial packets, Handshake packets, and "0.5-RTT data" in 1-RTT packets. Client Server Initial[0]: CRYPTO[CH] -&gt; Initial[0]: CRYPTO[SH] ACK[0] Handshake[0]: CRYPTO[EE, CERT, CV, FIN] &lt;- 1-RTT[0]: STREAM[1, "..."] Initial[1]: ACK[0] Handshake[0]: CRYPTO[FIN], ACK[0] 1-RTT[0]: STREAM[0, "..."], ACK[0] -&gt; Handshake[1]: ACK[0] &lt;- 1-RTT[1]: HANDSHAKE_DONE, STREAM[3, "..."], ACK[0] Figure 5: Example 1-RTT Handshake Figure 6 shows an example of a connection with a 0-RTT handshake and a single packet of 0-RTT data. Note that as described in Section 12.3, the server acknowledges 0-RTT data in 1-RTT packets, and the client sends 1-RTT packets in the same packet number space. Client Server Initial[0]: CRYPTO[CH] 0-RTT[0]: STREAM[0, "..."] -&gt; Initial[0]: CRYPTO[SH] ACK[0] Handshake[0] CRYPTO[EE, FIN] &lt;- 1-RTT[0]: STREAM[1, "..."] ACK[0] Initial[1]: ACK[0] Handshake[0]: CRYPTO[FIN], ACK[0] 1-RTT[1]: STREAM[0, "..."] ACK[0] -&gt; Handshake[1]: ACK[0] &lt;- 1-RTT[1]: HANDSHAKE_DONE, STREAM[3, "..."], ACK[1] Figure 6: Example 0-RTT Handshake 7.2. Negotiating Connection IDs A connection ID is used to ensure consistent routing of packets, as described in Section 5.1. The long header contains two connection IDs: the Destination Connection ID is chosen by the recipient of the packet and is used to provide consistent routing; the Source Connection ID is used to set the Destination Connection ID used by the peer. During the handshake, packets with the long header (Section 17.2) are used to establish the connection IDs used by both endpoints. Each endpoint uses the Source Connection ID field to specify the connection ID that is used in the Destination Connection ID field of packets being sent to them. After processing the first Initial packet, each endpoint sets the Destination Connection ID field in subsequent packets it sends to the value of the Source Connection ID field that it received. When an Initial packet is sent by a client that has not previously received an Initial or Retry packet from the server, the client populates the Destination Connection ID field with an unpredictable value. This Destination Connection ID MUST be at least 8 bytes in length. Until a packet is received from the server, the client MUST use the same Destination Connection ID value on all packets in this connection. The Destination Connection ID field from the first Initial packet sent by a client is used to determine packet protection keys for Initial packets. These keys change after receiving a Retry packet; see Section 5.2 of [QUIC-TLS]. The client populates the Source Connection ID field with a value of its choosing and sets the Source Connection ID Length field to indicate the length. 0-RTT packets in the first flight use the same Destination Connection ID and Source Connection ID values as the client's first Initial packet. Upon first receiving an Initial or Retry packet from the server, the client uses the Source Connection ID supplied by the server as the Destination Connection ID for subsequent packets, including any 0-RTT packets. This means that a client might have to change the connection ID it sets in the Destination Connection ID field twice during connection establishment: once in response to a Retry packet and once in response to an Initial packet from the server. Once a client has received a valid Initial packet from the server, it MUST discard any subsequent packet it receives on that connection with a different Source Connection ID. A client MUST change the Destination Connection ID it uses for sending packets in response to only the first received Initial or Retry packet. A server MUST set the Destination Connection ID it uses for sending packets based on the first received Initial packet. Any further changes to the Destination Connection ID are only permitted if the values are taken from NEW_CONNECTION_ID frames; if subsequent Initial packets include a different Source Connection ID, they MUST be discarded. This avoids unpredictable outcomes that might otherwise result from stateless processing of multiple Initial packets with different Source Connection IDs. The Destination Connection ID that an endpoint sends can change over the lifetime of a connection, especially in response to connection migration (Section 9); see Section 5.1.1 for details. 7.3. Authenticating Connection IDs The choice each endpoint makes about connection IDs during the handshake is authenticated by including all values in transport parameters; see Section 7.4. This ensures that all connection IDs used for the handshake are also authenticated by the cryptographic handshake. Each endpoint includes the value of the Source Connection ID field from the first Initial packet it sent in the initial_source_connection_id transport parameter; see Section 18.2. A server includes the Destination Connection ID field from the first Initial packet it received from the client in the original_destination_connection_id transport parameter; if the server sent a Retry packet, this refers to the first Initial packet received before sending the Retry packet. If it sends a Retry packet, a server also includes the Source Connection ID field from the Retry packet in the retry_source_connection_id transport parameter. The values provided by a peer for these transport parameters MUST match the values that an endpoint used in the Destination and Source Connection ID fields of Initial packets that it sent (and received, for servers). Endpoints MUST validate that received transport parameters match received connection ID values. Including connection ID values in transport parameters and verifying them ensures that an attacker cannot influence the choice of connection ID for a successful connection by injecting packets carrying attacker-chosen connection IDs during the handshake. An endpoint MUST treat the absence of the initial_source_connection_id transport parameter from either endpoint or the absence of the original_destination_connection_id transport parameter from the server as a connection error of type TRANSPORT_PARAMETER_ERROR. An endpoint MUST treat the following as a connection error of type TRANSPORT_PARAMETER_ERROR or PROTOCOL_VIOLATION: * absence of the retry_source_connection_id transport parameter from the server after receiving a Retry packet, * presence of the retry_source_connection_id transport parameter when no Retry packet was received, or * a mismatch between values received from a peer in these transport parameters and the value sent in the corresponding Destination or Source Connection ID fields of Initial packets. If a zero-length connection ID is selected, the corresponding transport parameter is included with a zero-length value. Figure 7 shows the connection IDs (with DCID=Destination Connection ID, SCID=Source Connection ID) that are used in a complete handshake. The exchange of Initial packets is shown, plus the later exchange of 1-RTT packets that includes the connection ID established during the handshake. Client Server Initial: DCID=S1, SCID=C1 -&gt; &lt;- Initial: DCID=C1, SCID=S3 ... 1-RTT: DCID=S3 -&gt; &lt;- 1-RTT: DCID=C1 Figure 7: Use of Connection IDs in a Handshake Figure 8 shows a similar handshake that includes a Retry packet. Client Server Initial: DCID=S1, SCID=C1 -&gt; &lt;- Retry: DCID=C1, SCID=S2 Initial: DCID=S2, SCID=C1 -&gt; &lt;- Initial: DCID=C1, SCID=S3 ... 1-RTT: DCID=S3 -&gt; &lt;- 1-RTT: DCID=C1 Figure 8: Use of Connection IDs in a Handshake with Retry In both cases (Figures 7 and 8), the client sets the value of the initial_source_connection_id transport parameter to "C1". When the handshake does not include a Retry (Figure 7), the server sets original_destination_connection_id to "S1" (note that this value is chosen by the client) and initial_source_connection_id to "S3". In this case, the server does not include a retry_source_connection_id transport parameter. When the handshake includes a Retry (Figure 8), the server sets original_destination_connection_id to "S1", retry_source_connection_id to "S2", and initial_source_connection_id to "S3". 7.4. Transport Parameters During connection establishment, both endpoints make authenticated declarations of their transport parameters. Endpoints are required to comply with the restrictions that each parameter defines; the description of each parameter includes rules for its handling. Transport parameters are declarations that are made unilaterally by each endpoint. Each endpoint can choose values for transport parameters independent of the values chosen by its peer. The encoding of the transport parameters is detailed in Section 18. QUIC includes the encoded transport parameters in the cryptographic handshake. Once the handshake completes, the transport parameters declared by the peer are available. Each endpoint validates the values provided by its peer. Definitions for each of the defined transport parameters are included in Section 18.2. An endpoint MUST treat receipt of a transport parameter with an invalid value as a connection error of type TRANSPORT_PARAMETER_ERROR. An endpoint MUST NOT send a parameter more than once in a given transport parameters extension. An endpoint SHOULD treat receipt of duplicate transport parameters as a connection error of type TRANSPORT_PARAMETER_ERROR. Endpoints use transport parameters to authenticate the negotiation of connection IDs during the handshake; see Section 7.3. ALPN (see [ALPN]) allows clients to offer multiple application protocols during connection establishment. The transport parameters that a client includes during the handshake apply to all application protocols that the client offers. Application protocols can recommend values for transport parameters, such as the initial flow control limits. However, application protocols that set constraints on values for transport parameters could make it impossible for a client to offer multiple application protocols if these constraints conflict. 7.4.1. Values of Transport Parameters for 0-RTT Using 0-RTT depends on both client and server using protocol parameters that were negotiated from a previous connection. To enable 0-RTT, endpoints store the values of the server transport parameters with any session tickets it receives on the connection. Endpoints also store any information required by the application protocol or cryptographic handshake; see Section 4.6 of [QUIC-TLS]. The values of stored transport parameters are used when attempting 0-RTT using the session tickets. Remembered transport parameters apply to the new connection until the handshake completes and the client starts sending 1-RTT packets. Once the handshake completes, the client uses the transport parameters established in the handshake. Not all transport parameters are remembered, as some do not apply to future connections or they have no effect on the use of 0-RTT. The definition of a new transport parameter (Section 7.4.2) MUST specify whether storing the transport parameter for 0-RTT is mandatory, optional, or prohibited. A client need not store a transport parameter it cannot process. A client MUST NOT use remembered values for the following parameters: ack_delay_exponent, max_ack_delay, initial_source_connection_id, original_destination_connection_id, preferred_address, retry_source_connection_id, and stateless_reset_token. The client MUST use the server's new values in the handshake instead; if the server does not provide new values, the default values are used. A client that attempts to send 0-RTT data MUST remember all other transport parameters used by the server that it is able to process. The server can remember these transport parameters or can store an integrity-protected copy of the values in the ticket and recover the information when accepting 0-RTT data. A server uses the transport parameters in determining whether to accept 0-RTT data. If 0-RTT data is accepted by the server, the server MUST NOT reduce any limits or alter any values that might be violated by the client with its 0-RTT data. In particular, a server that accepts 0-RTT data MUST NOT set values for the following parameters (Section 18.2) that are smaller than the remembered values of the parameters. * active_connection_id_limit * initial_max_data * initial_max_stream_data_bidi_local * initial_max_stream_data_bidi_remote * initial_max_stream_data_uni * initial_max_streams_bidi * initial_max_streams_uni Omitting or setting a zero value for certain transport parameters can result in 0-RTT data being enabled but not usable. The applicable subset of transport parameters that permit the sending of application data SHOULD be set to non-zero values for 0-RTT. This includes initial_max_data and either (1) initial_max_streams_bidi and initial_max_stream_data_bidi_remote or (2) initial_max_streams_uni and initial_max_stream_data_uni. A server might provide larger initial stream flow control limits for streams than the remembered values that a client applies when sending 0-RTT. Once the handshake completes, the client updates the flow control limits on all sending streams using the updated values of initial_max_stream_data_bidi_remote and initial_max_stream_data_uni. A server MAY store and recover the previously sent values of the max_idle_timeout, max_udp_payload_size, and disable_active_migration parameters and reject 0-RTT if it selects smaller values. Lowering the values of these parameters while also accepting 0-RTT data could degrade the performance of the connection. Specifically, lowering the max_udp_payload_size could result in dropped packets, leading to worse performance compared to rejecting 0-RTT data outright. A server MUST reject 0-RTT data if the restored values for transport parameters cannot be supported. When sending frames in 0-RTT packets, a client MUST only use remembered transport parameters; importantly, it MUST NOT use updated values that it learns from the server's updated transport parameters or from frames received in 1-RTT packets. Updated values of transport parameters from the handshake apply only to 1-RTT packets. For instance, flow control limits from remembered transport parameters apply to all 0-RTT packets even if those values are increased by the handshake or by frames sent in 1-RTT packets. A server MAY treat the use of updated transport parameters in 0-RTT as a connection error of type PROTOCOL_VIOLATION. 7.4.2. New Transport Parameters New transport parameters can be used to negotiate new protocol behavior. An endpoint MUST ignore transport parameters that it does not support. The absence of a transport parameter therefore disables any optional protocol feature that is negotiated using the parameter. As described in Section 18.1, some identifiers are reserved in order to exercise this requirement. A client that does not understand a transport parameter can discard it and attempt 0-RTT on subsequent connections. However, if the client adds support for a discarded transport parameter, it risks violating the constraints that the transport parameter establishes if it attempts 0-RTT. New transport parameters can avoid this problem by setting a default of the most conservative value. Clients can avoid this problem by remembering all parameters, even those not currently supported. New transport parameters can be registered according to the rules in Section 22.3. 7.5. Cryptographic Message Buffering Implementations need to maintain a buffer of CRYPTO data received out of order. Because there is no flow control of CRYPTO frames, an endpoint could potentially force its peer to buffer an unbounded amount of data. Implementations MUST support buffering at least 4096 bytes of data received in out-of-order CRYPTO frames. Endpoints MAY choose to allow more data to be buffered during the handshake. A larger limit during the handshake could allow for larger keys or credentials to be exchanged. An endpoint's buffer size does not need to remain constant during the life of the connection. Being unable to buffer CRYPTO frames during the handshake can lead to a connection failure. If an endpoint's buffer is exceeded during the handshake, it can expand its buffer temporarily to complete the handshake. If an endpoint does not expand its buffer, it MUST close the connection with a CRYPTO_BUFFER_EXCEEDED error code. Once the handshake completes, if an endpoint is unable to buffer all data in a CRYPTO frame, it MAY discard that CRYPTO frame and all CRYPTO frames received in the future, or it MAY close the connection with a CRYPTO_BUFFER_EXCEEDED error code. Packets containing discarded CRYPTO frames MUST be acknowledged because the packet has been received and processed by the transport even though the CRYPTO frame was discarded. 8. Address Validation Address validation ensures that an endpoint cannot be used for a traffic amplification attack. In such an attack, a packet is sent to a server with spoofed source address information that identifies a victim. If a server generates more or larger packets in response to that packet, the attacker can use the server to send more data toward the victim than it would be able to send on its own. The primary defense against amplification attacks is verifying that a peer is able to receive packets at the transport address that it claims. Therefore, after receiving packets from an address that is not yet validated, an endpoint MUST limit the amount of data it sends to the unvalidated address to three times the amount of data received from that address. This limit on the size of responses is known as the anti-amplification limit. Address validation is performed both during connection establishment (see Section 8.1) and during connection migration (see Section 8.2). 8.1. Address Validation during Connection Establishment Connection establishment implicitly provides address validation for both endpoints. In particular, receipt of a packet protected with Handshake keys confirms that the peer successfully processed an Initial packet. Once an endpoint has successfully processed a Handshake packet from the peer, it can consider the peer address to have been validated. Additionally, an endpoint MAY consider the peer address validated if the peer uses a connection ID chosen by the endpoint and the connection ID contains at least 64 bits of entropy. For the client, the value of the Destination Connection ID field in its first Initial packet allows it to validate the server address as a part of successfully processing any packet. Initial packets from the server are protected with keys that are derived from this value (see Section 5.2 of [QUIC-TLS]). Alternatively, the value is echoed by the server in Version Negotiation packets (Section 6) or included in the Integrity Tag in Retry packets (Section 5.8 of [QUIC-TLS]). Prior to validating the client address, servers MUST NOT send more than three times as many bytes as the number of bytes they have received. This limits the magnitude of any amplification attack that can be mounted using spoofed source addresses. For the purposes of avoiding amplification prior to address validation, servers MUST count all of the payload bytes received in datagrams that are uniquely attributed to a single connection. This includes datagrams that contain packets that are successfully processed and datagrams that contain packets that are all discarded. Clients MUST ensure that UDP datagrams containing Initial packets have UDP payloads of at least 1200 bytes, adding PADDING frames as necessary. A client that sends padded datagrams allows the server to send more data prior to completing address validation. Loss of an Initial or Handshake packet from the server can cause a deadlock if the client does not send additional Initial or Handshake packets. A deadlock could occur when the server reaches its anti- amplification limit and the client has received acknowledgments for all the data it has sent. In this case, when the client has no reason to send additional packets, the server will be unable to send more data because it has not validated the client's address. To prevent this deadlock, clients MUST send a packet on a Probe Timeout (PTO); see Section 6.2 of [QUIC-RECOVERY]. Specifically, the client MUST send an Initial packet in a UDP datagram that contains at least 1200 bytes if it does not have Handshake keys, and otherwise send a Handshake packet. A server might wish to validate the client address before starting the cryptographic handshake. QUIC uses a token in the Initial packet to provide address validation prior to completing the handshake. This token is delivered to the client during connection establishment with a Retry packet (see Section 8.1.2) or in a previous connection using the NEW_TOKEN frame (see Section 8.1.3). In addition to sending limits imposed prior to address validation, servers are also constrained in what they can send by the limits set by the congestion controller. Clients are only constrained by the congestion controller. 8.1.1. Token Construction A token sent in a NEW_TOKEN frame or a Retry packet MUST be constructed in a way that allows the server to identify how it was provided to a client. These tokens are carried in the same field but require different handling from servers. 8.1.2. Address Validation Using Retry Packets Upon receiving the client's Initial packet, the server can request address validation by sending a Retry packet (Section 17.2.5) containing a token. This token MUST be repeated by the client in all Initial packets it sends for that connection after it receives the Retry packet. In response to processing an Initial packet containing a token that was provided in a Retry packet, a server cannot send another Retry packet; it can only refuse the connection or permit it to proceed. As long as it is not possible for an attacker to generate a valid token for its own address (see Section 8.1.4) and the client is able to return that token, it proves to the server that it received the token. A server can also use a Retry packet to defer the state and processing costs of connection establishment. Requiring the server to provide a different connection ID, along with the original_destination_connection_id transport parameter defined in Section 18.2, forces the server to demonstrate that it, or an entity it cooperates with, received the original Initial packet from the client. Providing a different connection ID also grants a server some control over how subsequent packets are routed. This can be used to direct connections to a different server instance. If a server receives a client Initial that contains an invalid Retry token but is otherwise valid, it knows the client will not accept another Retry token. The server can discard such a packet and allow the client to time out to detect handshake failure, but that could impose a significant latency penalty on the client. Instead, the server SHOULD immediately close (Section 10.2) the connection with an INVALID_TOKEN error. Note that a server has not established any state for the connection at this point and so does not enter the closing period. A flow showing the use of a Retry packet is shown in Figure 9. Client Server Initial[0]: CRYPTO[CH] -&gt; &lt;- Retry+Token Initial+Token[1]: CRYPTO[CH] -&gt; Initial[0]: CRYPTO[SH] ACK[1] Handshake[0]: CRYPTO[EE, CERT, CV, FIN] &lt;- 1-RTT[0]: STREAM[1, "..."] Figure 9: Example Handshake with Retry 8.1.3. Address Validation for Future Connections A server MAY provide clients with an address validation token during one connection that can be used on a subsequent connection. Address validation is especially important with 0-RTT because a server potentially sends a significant amount of data to a client in response to 0-RTT data. The server uses the NEW_TOKEN frame (Section 19.7) to provide the client with an address validation token that can be used to validate future connections. In a future connection, the client includes this token in Initial packets to provide address validation. The client MUST include the token in all Initial packets it sends, unless a Retry replaces the token with a newer one. The client MUST NOT use the token provided in a Retry for future connections. Servers MAY discard any Initial packet that does not carry the expected token. Unlike the token that is created for a Retry packet, which is used immediately, the token sent in the NEW_TOKEN frame can be used after some period of time has passed. Thus, a token SHOULD have an expiration time, which could be either an explicit expiration time or an issued timestamp that can be used to dynamically calculate the expiration time. A server can store the expiration time or include it in an encrypted form in the token. A token issued with NEW_TOKEN MUST NOT include information that would allow values to be linked by an observer to the connection on which it was issued. For example, it cannot include the previous connection ID or addressing information, unless the values are encrypted. A server MUST ensure that every NEW_TOKEN frame it sends is unique across all clients, with the exception of those sent to repair losses of previously sent NEW_TOKEN frames. Information that allows the server to distinguish between tokens from Retry and NEW_TOKEN MAY be accessible to entities other than the server. It is unlikely that the client port number is the same on two different connections; validating the port is therefore unlikely to be successful. A token received in a NEW_TOKEN frame is applicable to any server that the connection is considered authoritative for (e.g., server names included in the certificate). When connecting to a server for which the client retains an applicable and unused token, it SHOULD include that token in the Token field of its Initial packet. Including a token might allow the server to validate the client address without an additional round trip. A client MUST NOT include a token that is not applicable to the server that it is connecting to, unless the client has the knowledge that the server that issued the token and the server the client is connecting to are jointly managing the tokens. A client MAY use a token from any previous connection to that server. A token allows a server to correlate activity between the connection where the token was issued and any connection where it is used. Clients that want to break continuity of identity with a server can discard tokens provided using the NEW_TOKEN frame. In comparison, a token obtained in a Retry packet MUST be used immediately during the connection attempt and cannot be used in subsequent connection attempts. A client SHOULD NOT reuse a token from a NEW_TOKEN frame for different connection attempts. Reusing a token allows connections to be linked by entities on the network path; see Section 9.5. Clients might receive multiple tokens on a single connection. Aside from preventing linkability, any token can be used in any connection attempt. Servers can send additional tokens to either enable address validation for multiple connection attempts or replace older tokens that might become invalid. For a client, this ambiguity means that sending the most recent unused token is most likely to be effective. Though saving and using older tokens have no negative consequences, clients can regard older tokens as being less likely to be useful to the server for address validation. When a server receives an Initial packet with an address validation token, it MUST attempt to validate the token, unless it has already completed address validation. If the token is invalid, then the server SHOULD proceed as if the client did not have a validated address, including potentially sending a Retry packet. Tokens provided with NEW_TOKEN frames and Retry packets can be distinguished by servers (see Section 8.1.1), and the latter can be validated more strictly. If the validation succeeds, the server SHOULD then allow the handshake to proceed. | Note: The rationale for treating the client as unvalidated | rather than discarding the packet is that the client might have | received the token in a previous connection using the NEW_TOKEN | frame, and if the server has lost state, it might be unable to | validate the token at all, leading to connection failure if the | packet is discarded. In a stateless design, a server can use encrypted and authenticated tokens to pass information to clients that the server can later recover and use to validate a client address. Tokens are not integrated into the cryptographic handshake, and so they are not authenticated. For instance, a client might be able to reuse a token. To avoid attacks that exploit this property, a server can limit its use of tokens to only the information needed to validate client addresses. Clients MAY use tokens obtained on one connection for any connection attempt using the same version. When selecting a token to use, clients do not need to consider other properties of the connection that is being attempted, including the choice of possible application protocols, session tickets, or other connection properties. 8.1.4. Address Validation Token Integrity An address validation token MUST be difficult to guess. Including a random value with at least 128 bits of entropy in the token would be sufficient, but this depends on the server remembering the value it sends to clients. A token-based scheme allows the server to offload any state associated with validation to the client. For this design to work, the token MUST be covered by integrity protection against modification or falsification by clients. Without integrity protection, malicious clients could generate or guess values for tokens that would be accepted by the server. Only the server requires access to the integrity protection key for tokens. There is no need for a single well-defined format for the token because the server that generates the token also consumes it. Tokens sent in Retry packets SHOULD include information that allows the server to verify that the source IP address and port in client packets remain constant. Tokens sent in NEW_TOKEN frames MUST include information that allows the server to verify that the client IP address has not changed from when the token was issued. Servers can use tokens from NEW_TOKEN frames in deciding not to send a Retry packet, even if the client address has changed. If the client IP address has changed, the server MUST adhere to the anti-amplification limit; see Section 8. Note that in the presence of NAT, this requirement might be insufficient to protect other hosts that share the NAT from amplification attacks. Attackers could replay tokens to use servers as amplifiers in DDoS attacks. To protect against such attacks, servers MUST ensure that replay of tokens is prevented or limited. Servers SHOULD ensure that tokens sent in Retry packets are only accepted for a short time, as they are returned immediately by clients. Tokens that are provided in NEW_TOKEN frames (Section 19.7) need to be valid for longer but SHOULD NOT be accepted multiple times. Servers are encouraged to allow tokens to be used only once, if possible; tokens MAY include additional information about clients to further narrow applicability or reuse. 8.2. Path Validation Path validation is used by both peers during connection migration (see Section 9) to verify reachability after a change of address. In path validation, endpoints test reachability between a specific local address and a specific peer address, where an address is the 2-tuple of IP address and port. Path validation tests that packets sent on a path to a peer are received by that peer. Path validation is used to ensure that packets received from a migrating peer do not carry a spoofed source address. Path validation does not validate that a peer can send in the return direction. Acknowledgments cannot be used for return path validation because they contain insufficient entropy and might be spoofed. Endpoints independently determine reachability on each direction of a path, and therefore return reachability can only be established by the peer. Path validation can be used at any time by either endpoint. For instance, an endpoint might check that a peer is still in possession of its address after a period of quiescence. Path validation is not designed as a NAT traversal mechanism. Though the mechanism described here might be effective for the creation of NAT bindings that support NAT traversal, the expectation is that one endpoint is able to receive packets without first having sent a packet on that path. Effective NAT traversal needs additional synchronization mechanisms that are not provided here. An endpoint MAY include other frames with the PATH_CHALLENGE and PATH_RESPONSE frames used for path validation. In particular, an endpoint can include PADDING frames with a PATH_CHALLENGE frame for Path Maximum Transmission Unit Discovery (PMTUD); see Section 14.2.1. An endpoint can also include its own PATH_CHALLENGE frame when sending a PATH_RESPONSE frame. An endpoint uses a new connection ID for probes sent from a new local address; see Section 9.5. When probing a new path, an endpoint can ensure that its peer has an unused connection ID available for responses. Sending NEW_CONNECTION_ID and PATH_CHALLENGE frames in the same packet, if the peer's active_connection_id_limit permits, ensures that an unused connection ID will be available to the peer when sending a response. An endpoint can choose to simultaneously probe multiple paths. The number of simultaneous paths used for probes is limited by the number of extra connection IDs its peer has previously supplied, since each new local address used for a probe requires a previously unused connection ID. 8.2.1. Initiating Path Validation To initiate path validation, an endpoint sends a PATH_CHALLENGE frame containing an unpredictable payload on the path to be validated. An endpoint MAY send multiple PATH_CHALLENGE frames to guard against packet loss. However, an endpoint SHOULD NOT send multiple PATH_CHALLENGE frames in a single packet. An endpoint SHOULD NOT probe a new path with packets containing a PATH_CHALLENGE frame more frequently than it would send an Initial packet. This ensures that connection migration is no more load on a new path than establishing a new connection. The endpoint MUST use unpredictable data in every PATH_CHALLENGE frame so that it can associate the peer's response with the corresponding PATH_CHALLENGE. An endpoint MUST expand datagrams that contain a PATH_CHALLENGE frame to at least the smallest allowed maximum datagram size of 1200 bytes, unless the anti-amplification limit for the path does not permit sending a datagram of this size. Sending UDP datagrams of this size ensures that the network path from the endpoint to the peer can be used for QUIC; see Section 14. When an endpoint is unable to expand the datagram size to 1200 bytes due to the anti-amplification limit, the path MTU will not be validated. To ensure that the path MTU is large enough, the endpoint MUST perform a second path validation by sending a PATH_CHALLENGE frame in a datagram of at least 1200 bytes. This additional validation can be performed after a PATH_RESPONSE is successfully received or when enough bytes have been received on the path that sending the larger datagram will not result in exceeding the anti- amplification limit. Unlike other cases where datagrams are expanded, endpoints MUST NOT discard datagrams that appear to be too small when they contain PATH_CHALLENGE or PATH_RESPONSE. 8.2.2. Path Validation Responses On receiving a PATH_CHALLENGE frame, an endpoint MUST respond by echoing the data contained in the PATH_CHALLENGE frame in a PATH_RESPONSE frame. An endpoint MUST NOT delay transmission of a packet containing a PATH_RESPONSE frame unless constrained by congestion control. A PATH_RESPONSE frame MUST be sent on the network path where the PATH_CHALLENGE frame was received. This ensures that path validation by a peer only succeeds if the path is functional in both directions. This requirement MUST NOT be enforced by the endpoint that initiates path validation, as that would enable an attack on migration; see Section 9.3.3. An endpoint MUST expand datagrams that contain a PATH_RESPONSE frame to at least the smallest allowed maximum datagram size of 1200 bytes. This verifies that the path is able to carry datagrams of this size in both directions. However, an endpoint MUST NOT expand the datagram containing the PATH_RESPONSE if the resulting data exceeds the anti-amplification limit. This is expected to only occur if the received PATH_CHALLENGE was not sent in an expanded datagram. An endpoint MUST NOT send more than one PATH_RESPONSE frame in response to one PATH_CHALLENGE frame; see Section 13.3. The peer is expected to send more PATH_CHALLENGE frames as necessary to evoke additional PATH_RESPONSE frames. 8.2.3. Successful Path Validation Path validation succeeds when a PATH_RESPONSE frame is received that contains the data that was sent in a previous PATH_CHALLENGE frame. A PATH_RESPONSE frame received on any network path validates the path on which the PATH_CHALLENGE was sent. If an endpoint sends a PATH_CHALLENGE frame in a datagram that is not expanded to at least 1200 bytes and if the response to it validates the peer address, the path is validated but not the path MTU. As a result, the endpoint can now send more than three times the amount of data that has been received. However, the endpoint MUST initiate another path validation with an expanded datagram to verify that the path supports the required MTU. Receipt of an acknowledgment for a packet containing a PATH_CHALLENGE frame is not adequate validation, since the acknowledgment can be spoofed by a malicious peer. 8.2.4. Failed Path Validation Path validation only fails when the endpoint attempting to validate the path abandons its attempt to validate the path. Endpoints SHOULD abandon path validation based on a timer. When setting this timer, implementations are cautioned that the new path could have a longer round-trip time than the original. A value of three times the larger of the current PTO or the PTO for the new path (using kInitialRtt, as defined in [QUIC-RECOVERY]) is RECOMMENDED. This timeout allows for multiple PTOs to expire prior to failing path validation, so that loss of a single PATH_CHALLENGE or PATH_RESPONSE frame does not cause path validation failure. Note that the endpoint might receive packets containing other frames on the new path, but a PATH_RESPONSE frame with appropriate data is required for path validation to succeed. When an endpoint abandons path validation, it determines that the path is unusable. This does not necessarily imply a failure of the connection -- endpoints can continue sending packets over other paths as appropriate. If no paths are available, an endpoint can wait for a new path to become available or close the connection. An endpoint that has no valid network path to its peer MAY signal this using the NO_VIABLE_PATH connection error, noting that this is only possible if the network path exists but does not support the required MTU (Section 14). A path validation might be abandoned for other reasons besides failure. Primarily, this happens if a connection migration to a new path is initiated while a path validation on the old path is in progress. 9. Connection Migration The use of a connection ID allows connections to survive changes to endpoint addresses (IP address and port), such as those caused by an endpoint migrating to a new network. This section describes the process by which an endpoint migrates to a new address. The design of QUIC relies on endpoints retaining a stable address for the duration of the handshake. An endpoint MUST NOT initiate connection migration before the handshake is confirmed, as defined in Section 4.1.2 of [QUIC-TLS]. If the peer sent the disable_active_migration transport parameter, an endpoint also MUST NOT send packets (including probing packets; see Section 9.1) from a different local address to the address the peer used during the handshake, unless the endpoint has acted on a preferred_address transport parameter from the peer. If the peer violates this requirement, the endpoint MUST either drop the incoming packets on that path without generating a Stateless Reset or proceed with path validation and allow the peer to migrate. Generating a Stateless Reset or closing the connection would allow third parties in the network to cause connections to close by spoofing or otherwise manipulating observed traffic. Not all changes of peer address are intentional, or active, migrations. The peer could experience NAT rebinding: a change of address due to a middlebox, usually a NAT, allocating a new outgoing port or even a new outgoing IP address for a flow. An endpoint MUST perform path validation (Section 8.2) if it detects any change to a peer's address, unless it has previously validated that address. When an endpoint has no validated path on which to send packets, it MAY discard connection state. An endpoint capable of connection migration MAY wait for a new path to become available before discarding connection state. This document limits migration of connections to new client addresses, except as described in Section 9.6. Clients are responsible for initiating all migrations. Servers do not send non- probing packets (see Section 9.1) toward a client address until they see a non-probing packet from that address. If a client receives packets from an unknown server address, the client MUST discard these packets. 9.1. Probing a New Path An endpoint MAY probe for peer reachability from a new local address using path validation (Section 8.2) prior to migrating the connection to the new local address. Failure of path validation simply means that the new path is not usable for this connection. Failure to validate a path does not cause the connection to end unless there are no valid alternative paths available. PATH_CHALLENGE, PATH_RESPONSE, NEW_CONNECTION_ID, and PADDING frames are "probing frames", and all other frames are "non-probing frames". A packet containing only probing frames is a "probing packet", and a packet containing any other frame is a "non-probing packet". 9.2. Initiating Connection Migration An endpoint can migrate a connection to a new local address by sending packets containing non-probing frames from that address. Each endpoint validates its peer's address during connection establishment. Therefore, a migrating endpoint can send to its peer knowing that the peer is willing to receive at the peer's current address. Thus, an endpoint can migrate to a new local address without first validating the peer's address. To establish reachability on the new path, an endpoint initiates path validation (Section 8.2) on the new path. An endpoint MAY defer path validation until after a peer sends the next non-probing frame to its new address. When migrating, the new path might not support the endpoint's current sending rate. Therefore, the endpoint resets its congestion controller and RTT estimate, as described in Section 9.4. The new path might not have the same ECN capability. Therefore, the endpoint validates ECN capability as described in Section 13.4. 9.3. Responding to Connection Migration Receiving a packet from a new peer address containing a non-probing frame indicates that the peer has migrated to that address. If the recipient permits the migration, it MUST send subsequent packets to the new peer address and MUST initiate path validation (Section 8.2) to verify the peer's ownership of the address if validation is not already underway. If the recipient has no unused connection IDs from the peer, it will not be able to send anything on the new path until the peer provides one; see Section 9.5. An endpoint only changes the address to which it sends packets in response to the highest-numbered non-probing packet. This ensures that an endpoint does not send packets to an old peer address in the case that it receives reordered packets. An endpoint MAY send data to an unvalidated peer address, but it MUST protect against potential attacks as described in Sections 9.3.1 and 9.3.2. An endpoint MAY skip validation of a peer address if that address has been seen recently. In particular, if an endpoint returns to a previously validated path after detecting some form of spurious migration, skipping address validation and restoring loss detection and congestion state can reduce the performance impact of the attack. After changing the address to which it sends non-probing packets, an endpoint can abandon any path validation for other addresses. Receiving a packet from a new peer address could be the result of a NAT rebinding at the peer. After verifying a new client address, the server SHOULD send new address validation tokens (Section 8) to the client. 9.3.1. Peer Address Spoofing It is possible that a peer is spoofing its source address to cause an endpoint to send excessive amounts of data to an unwilling host. If the endpoint sends significantly more data than the spoofing peer, connection migration might be used to amplify the volume of data that an attacker can generate toward a victim. As described in Section 9.3, an endpoint is required to validate a peer's new address to confirm the peer's possession of the new address. Until a peer's address is deemed valid, an endpoint limits the amount of data it sends to that address; see Section 8. In the absence of this limit, an endpoint risks being used for a denial-of- service attack against an unsuspecting victim. If an endpoint skips validation of a peer address as described above, it does not need to limit its sending rate. 9.3.2. On-Path Address Spoofing An on-path attacker could cause a spurious connection migration by copying and forwarding a packet with a spoofed address such that it arrives before the original packet. The packet with the spoofed address will be seen to come from a migrating connection, and the original packet will be seen as a duplicate and dropped. After a spurious migration, validation of the source address will fail because the entity at the source address does not have the necessary cryptographic keys to read or respond to the PATH_CHALLENGE frame that is sent to it even if it wanted to. To protect the connection from failing due to such a spurious migration, an endpoint MUST revert to using the last validated peer address when validation of a new peer address fails. Additionally, receipt of packets with higher packet numbers from the legitimate peer address will trigger another connection migration. This will cause the validation of the address of the spurious migration to be abandoned, thus containing migrations initiated by the attacker injecting a single packet. If an endpoint has no state about the last validated peer address, it MUST close the connection silently by discarding all connection state. This results in new packets on the connection being handled generically. For instance, an endpoint MAY send a Stateless Reset in response to any further incoming packets. 9.3.3. Off-Path Packet Forwarding An off-path attacker that can observe packets might forward copies of genuine packets to endpoints. If the copied packet arrives before the genuine packet, this will appear as a NAT rebinding. Any genuine packet will be discarded as a duplicate. If the attacker is able to continue forwarding packets, it might be able to cause migration to a path via the attacker. This places the attacker on-path, giving it the ability to observe or drop all subsequent packets. This style of attack relies on the attacker using a path that has approximately the same characteristics as the direct path between endpoints. The attack is more reliable if relatively few packets are sent or if packet loss coincides with the attempted attack. A non-probing packet received on the original path that increases the maximum received packet number will cause the endpoint to move back to that path. Eliciting packets on this path increases the likelihood that the attack is unsuccessful. Therefore, mitigation of this attack relies on triggering the exchange of packets. In response to an apparent migration, endpoints MUST validate the previously active path using a PATH_CHALLENGE frame. This induces the sending of new packets on that path. If the path is no longer viable, the validation attempt will time out and fail; if the path is viable but no longer desired, the validation will succeed but only results in probing packets being sent on the path. An endpoint that receives a PATH_CHALLENGE on an active path SHOULD send a non-probing packet in response. If the non-probing packet arrives before any copy made by an attacker, this results in the connection being migrated back to the original path. Any subsequent migration to another path restarts this entire process. This defense is imperfect, but this is not considered a serious problem. If the path via the attack is reliably faster than the original path despite multiple attempts to use that original path, it is not possible to distinguish between an attack and an improvement in routing. An endpoint could also use heuristics to improve detection of this style of attack. For instance, NAT rebinding is improbable if packets were recently received on the old path; similarly, rebinding is rare on IPv6 paths. Endpoints can also look for duplicated packets. Conversely, a change in connection ID is more likely to indicate an intentional migration rather than an attack. 9.4. Loss Detection and Congestion Control The capacity available on the new path might not be the same as the old path. Packets sent on the old path MUST NOT contribute to congestion control or RTT estimation for the new path. On confirming a peer's ownership of its new address, an endpoint MUST immediately reset the congestion controller and round-trip time estimator for the new path to initial values (see Appendices A.3 and B.3 of [QUIC-RECOVERY]) unless the only change in the peer's address is its port number. Because port-only changes are commonly the result of NAT rebinding or other middlebox activity, the endpoint MAY instead retain its congestion control state and round-trip estimate in those cases instead of reverting to initial values. In cases where congestion control state retained from an old path is used on a new path with substantially different characteristics, a sender could transmit too aggressively until the congestion controller and the RTT estimator have adapted. Generally, implementations are advised to be cautious when using previous values on a new path. There could be apparent reordering at the receiver when an endpoint sends data and probes from/to multiple addresses during the migration period, since the two resulting paths could have different round-trip times. A receiver of packets on multiple paths will still send ACK frames covering all received packets. While multiple paths might be used during connection migration, a single congestion control context and a single loss recovery context (as described in [QUIC-RECOVERY]) could be adequate. For instance, an endpoint might delay switching to a new congestion control context until it is confirmed that an old path is no longer needed (such as the case described in Section 9.3.3). A sender can make exceptions for probe packets so that their loss detection is independent and does not unduly cause the congestion controller to reduce its sending rate. An endpoint might set a separate timer when a PATH_CHALLENGE is sent, which is canceled if the corresponding PATH_RESPONSE is received. If the timer fires before the PATH_RESPONSE is received, the endpoint might send a new PATH_CHALLENGE and restart the timer for a longer period of time. This timer SHOULD be set as described in Section 6.2.1 of [QUIC-RECOVERY] and MUST NOT be more aggressive. 9.5. Privacy Implications of Connection Migration Using a stable connection ID on multiple network paths would allow a passive observer to correlate activity between those paths. An endpoint that moves between networks might not wish to have their activity correlated by any entity other than their peer, so different connection IDs are used when sending from different local addresses, as discussed in Section 5.1. For this to be effective, endpoints need to ensure that connection IDs they provide cannot be linked by any other entity. At any time, endpoints MAY change the Destination Connection ID they transmit with to a value that has not been used on another path. An endpoint MUST NOT reuse a connection ID when sending from more than one local address -- for example, when initiating connection migration as described in Section 9.2 or when probing a new network path as described in Section 9.1. Similarly, an endpoint MUST NOT reuse a connection ID when sending to more than one destination address. Due to network changes outside the control of its peer, an endpoint might receive packets from a new source address with the same Destination Connection ID field value, in which case it MAY continue to use the current connection ID with the new remote address while still sending from the same local address. These requirements regarding connection ID reuse apply only to the sending of packets, as unintentional changes in path without a change in connection ID are possible. For example, after a period of network inactivity, NAT rebinding might cause packets to be sent on a new path when the client resumes sending. An endpoint responds to such an event as described in Section 9.3. Using different connection IDs for packets sent in both directions on each new network path eliminates the use of the connection ID for linking packets from the same connection across different network paths. Header protection ensures that packet numbers cannot be used to correlate activity. This does not prevent other properties of packets, such as timing and size, from being used to correlate activity. An endpoint SHOULD NOT initiate migration with a peer that has requested a zero-length connection ID, because traffic over the new path might be trivially linkable to traffic over the old one. If the server is able to associate packets with a zero-length connection ID to the right connection, it means that the server is using other information to demultiplex packets. For example, a server might provide a unique address to every client -- for instance, using HTTP alternative services [ALTSVC]. Information that might allow correct routing of packets across multiple network paths will also allow activity on those paths to be linked by entities other than the peer. A client might wish to reduce linkability by switching to a new connection ID, source UDP port, or IP address (see [RFC8981]) when sending traffic after a period of inactivity. Changing the address from which it sends packets at the same time might cause the server to detect a connection migration. This ensures that the mechanisms that support migration are exercised even for clients that do not experience NAT rebindings or genuine migrations. Changing address can cause a peer to reset its congestion control state (see Section 9.4), so addresses SHOULD only be changed infrequently. An endpoint that exhausts available connection IDs cannot probe new paths or initiate migration, nor can it respond to probes or attempts by its peer to migrate. To ensure that migration is possible and packets sent on different paths cannot be correlated, endpoints SHOULD provide new connection IDs before peers migrate; see Section 5.1.1. If a peer might have exhausted available connection IDs, a migrating endpoint could include a NEW_CONNECTION_ID frame in all packets sent on a new network path. 9.6. Server's Preferred Address QUIC allows servers to accept connections on one IP address and attempt to transfer these connections to a more preferred address shortly after the handshake. This is particularly useful when clients initially connect to an address shared by multiple servers but would prefer to use a unicast address to ensure connection stability. This section describes the protocol for migrating a connection to a preferred server address. Migrating a connection to a new server address mid-connection is not supported by the version of QUIC specified in this document. If a client receives packets from a new server address when the client has not initiated a migration to that address, the client SHOULD discard these packets. 9.6.1. Communicating a Preferred Address A server conveys a preferred address by including the preferred_address transport parameter in the TLS handshake. Servers MAY communicate a preferred address of each address family (IPv4 and IPv6) to allow clients to pick the one most suited to their network attachment. Once the handshake is confirmed, the client SHOULD select one of the two addresses provided by the server and initiate path validation (see Section 8.2). A client constructs packets using any previously unused active connection ID, taken from either the preferred_address transport parameter or a NEW_CONNECTION_ID frame. As soon as path validation succeeds, the client SHOULD begin sending all future packets to the new server address using the new connection ID and discontinue use of the old server address. If path validation fails, the client MUST continue sending all future packets to the server's original IP address. 9.6.2. Migration to a Preferred Address A client that migrates to a preferred address MUST validate the address it chooses before migrating; see Section 21.5.3. A server might receive a packet addressed to its preferred IP address at any time after it accepts a connection. If this packet contains a PATH_CHALLENGE frame, the server sends a packet containing a PATH_RESPONSE frame as per Section 8.2. The server MUST send non- probing packets from its original address until it receives a non- probing packet from the client at its preferred address and until the server has validated the new path. The server MUST probe on the path toward the client from its preferred address. This helps to guard against spurious migration initiated by an attacker. Once the server has completed its path validation and has received a non-probing packet with a new largest packet number on its preferred address, the server begins sending non-probing packets to the client exclusively from its preferred IP address. The server SHOULD drop newer packets for this connection that are received on the old IP address. The server MAY continue to process delayed packets that are received on the old IP address. The addresses that a server provides in the preferred_address transport parameter are only valid for the connection in which they are provided. A client MUST NOT use these for other connections, including connections that are resumed from the current connection. 9.6.3. Interaction of Client Migration and Preferred Address A client might need to perform a connection migration before it has migrated to the server's preferred address. In this case, the client SHOULD perform path validation to both the original and preferred server address from the client's new address concurrently. If path validation of the server's preferred address succeeds, the client MUST abandon validation of the original address and migrate to using the server's preferred address. If path validation of the server's preferred address fails but validation of the server's original address succeeds, the client MAY migrate to its new address and continue sending to the server's original address. If packets received at the server's preferred address have a different source address than observed from the client during the handshake, the server MUST protect against potential attacks as described in Sections 9.3.1 and 9.3.2. In addition to intentional simultaneous migration, this might also occur because the client's access network used a different NAT binding for the server's preferred address. Servers SHOULD initiate path validation to the client's new address upon receiving a probe packet from a different address; see Section 8. A client that migrates to a new address SHOULD use a preferred address from the same address family for the server. The connection ID provided in the preferred_address transport parameter is not specific to the addresses that are provided. This connection ID is provided to ensure that the client has a connection ID available for migration, but the client MAY use this connection ID on any path. 9.7. Use of IPv6 Flow Label and Migration Endpoints that send data using IPv6 SHOULD apply an IPv6 flow label in compliance with [RFC6437], unless the local API does not allow setting IPv6 flow labels. The flow label generation MUST be designed to minimize the chances of linkability with a previously used flow label, as a stable flow label would enable correlating activity on multiple paths; see Section 9.5. [RFC6437] suggests deriving values using a pseudorandom function to generate flow labels. Including the Destination Connection ID field in addition to source and destination addresses when generating flow labels ensures that changes are synchronized with changes in other observable identifiers. A cryptographic hash function that combines these inputs with a local secret is one way this might be implemented. 10. Connection Termination An established QUIC connection can be terminated in one of three ways: * idle timeout (Section 10.1) * immediate close (Section 10.2) * stateless reset (Section 10.3) An endpoint MAY discard connection state if it does not have a validated path on which it can send packets; see Section 8.2. 10.1. Idle Timeout If a max_idle_timeout is specified by either endpoint in its transport parameters (Section 18.2), the connection is silently closed and its state is discarded when it remains idle for longer than the minimum of the max_idle_timeout value advertised by both endpoints. Each endpoint advertises a max_idle_timeout, but the effective value at an endpoint is computed as the minimum of the two advertised values (or the sole advertised value, if only one endpoint advertises a non-zero value). By announcing a max_idle_timeout, an endpoint commits to initiating an immediate close (Section 10.2) if it abandons the connection prior to the effective value. An endpoint restarts its idle timer when a packet from its peer is received and processed successfully. An endpoint also restarts its idle timer when sending an ack-eliciting packet if no other ack- eliciting packets have been sent since last receiving and processing a packet. Restarting this timer when sending a packet ensures that connections are not closed after new activity is initiated. To avoid excessively small idle timeout periods, endpoints MUST increase the idle timeout period to be at least three times the current Probe Timeout (PTO). This allows for multiple PTOs to expire, and therefore multiple probes to be sent and lost, prior to idle timeout. 10.1.1. Liveness Testing An endpoint that sends packets close to the effective timeout risks having them be discarded at the peer, since the idle timeout period might have expired at the peer before these packets arrive. An endpoint can send a PING or another ack-eliciting frame to test the connection for liveness if the peer could time out soon, such as within a PTO; see Section 6.2 of [QUIC-RECOVERY]. This is especially useful if any available application data cannot be safely retried. Note that the application determines what data is safe to retry. 10.1.2. Deferring Idle Timeout An endpoint might need to send ack-eliciting packets to avoid an idle timeout if it is expecting response data but does not have or is unable to send application data. An implementation of QUIC might provide applications with an option to defer an idle timeout. This facility could be used when the application wishes to avoid losing state that has been associated with an open connection but does not expect to exchange application data for some time. With this option, an endpoint could send a PING frame (Section 19.2) periodically, which will cause the peer to restart its idle timeout period. Sending a packet containing a PING frame restarts the idle timeout for this endpoint also if this is the first ack-eliciting packet sent since receiving a packet. Sending a PING frame causes the peer to respond with an acknowledgment, which also restarts the idle timeout for the endpoint. Application protocols that use QUIC SHOULD provide guidance on when deferring an idle timeout is appropriate. Unnecessary sending of PING frames could have a detrimental effect on performance. A connection will time out if no packets are sent or received for a period longer than the time negotiated using the max_idle_timeout transport parameter; see Section 10. However, state in middleboxes might time out earlier than that. Though REQ-5 in [RFC4787] recommends a 2-minute timeout interval, experience shows that sending packets every 30 seconds is necessary to prevent the majority of middleboxes from losing state for UDP flows [GATEWAY]. 10.2. Immediate Close An endpoint sends a CONNECTION_CLOSE frame (Section 19.19) to terminate the connection immediately. A CONNECTION_CLOSE frame causes all streams to immediately become closed; open streams can be assumed to be implicitly reset. After sending a CONNECTION_CLOSE frame, an endpoint immediately enters the closing state; see Section 10.2.1. After receiving a CONNECTION_CLOSE frame, endpoints enter the draining state; see Section 10.2.2. Violations of the protocol lead to an immediate close. An immediate close can be used after an application protocol has arranged to close a connection. This might be after the application protocol negotiates a graceful shutdown. The application protocol can exchange messages that are needed for both application endpoints to agree that the connection can be closed, after which the application requests that QUIC close the connection. When QUIC consequently closes the connection, a CONNECTION_CLOSE frame with an application-supplied error code will be used to signal closure to the peer. The closing and draining connection states exist to ensure that connections close cleanly and that delayed or reordered packets are properly discarded. These states SHOULD persist for at least three times the current PTO interval as defined in [QUIC-RECOVERY]. Disposing of connection state prior to exiting the closing or draining state could result in an endpoint generating a Stateless Reset unnecessarily when it receives a late-arriving packet. Endpoints that have some alternative means to ensure that late- arriving packets do not induce a response, such as those that are able to close the UDP socket, MAY end these states earlier to allow for faster resource recovery. Servers that retain an open socket for accepting new connections SHOULD NOT end the closing or draining state early. Once its closing or draining state ends, an endpoint SHOULD discard all connection state. The endpoint MAY send a Stateless Reset in response to any further incoming packets belonging to this connection. 10.2.1. Closing Connection State An endpoint enters the closing state after initiating an immediate close. In the closing state, an endpoint retains only enough information to generate a packet containing a CONNECTION_CLOSE frame and to identify packets as belonging to the connection. An endpoint in the closing state sends a packet containing a CONNECTION_CLOSE frame in response to any incoming packet that it attributes to the connection. An endpoint SHOULD limit the rate at which it generates packets in the closing state. For instance, an endpoint could wait for a progressively increasing number of received packets or amount of time before responding to received packets. An endpoint's selected connection ID and the QUIC version are sufficient information to identify packets for a closing connection; the endpoint MAY discard all other connection state. An endpoint that is closing is not required to process any received frame. An endpoint MAY retain packet protection keys for incoming packets to allow it to read and process a CONNECTION_CLOSE frame. An endpoint MAY drop packet protection keys when entering the closing state and send a packet containing a CONNECTION_CLOSE frame in response to any UDP datagram that is received. However, an endpoint that discards packet protection keys cannot identify and discard invalid packets. To avoid being used for an amplification attack, such endpoints MUST limit the cumulative size of packets it sends to three times the cumulative size of the packets that are received and attributed to the connection. To minimize the state that an endpoint maintains for a closing connection, endpoints MAY send the exact same packet in response to any received packet. | Note: Allowing retransmission of a closing packet is an | exception to the requirement that a new packet number be used | for each packet; see Section 12.3. Sending new packet numbers | is primarily of advantage to loss recovery and congestion | control, which are not expected to be relevant for a closed | connection. Retransmitting the final packet requires less | state. While in the closing state, an endpoint could receive packets from a new source address, possibly indicating a connection migration; see Section 9. An endpoint in the closing state MUST either discard packets received from an unvalidated address or limit the cumulative size of packets it sends to an unvalidated address to three times the size of packets it receives from that address. An endpoint is not expected to handle key updates when it is closing (Section 6 of [QUIC-TLS]). A key update might prevent the endpoint from moving from the closing state to the draining state, as the endpoint will not be able to process subsequently received packets, but it otherwise has no impact. 10.2.2. Draining Connection State The draining state is entered once an endpoint receives a CONNECTION_CLOSE frame, which indicates that its peer is closing or draining. While otherwise identical to the closing state, an endpoint in the draining state MUST NOT send any packets. Retaining packet protection keys is unnecessary once a connection is in the draining state. An endpoint that receives a CONNECTION_CLOSE frame MAY send a single packet containing a CONNECTION_CLOSE frame before entering the draining state, using a NO_ERROR code if appropriate. An endpoint MUST NOT send further packets. Doing so could result in a constant exchange of CONNECTION_CLOSE frames until one of the endpoints exits the closing state. An endpoint MAY enter the draining state from the closing state if it receives a CONNECTION_CLOSE frame, which indicates that the peer is also closing or draining. In this case, the draining state ends when the closing state would have ended. In other words, the endpoint uses the same end time but ceases transmission of any packets on this connection. 10.2.3. Immediate Close during the Handshake When sending a CONNECTION_CLOSE frame, the goal is to ensure that the peer will process the frame. Generally, this means sending the frame in a packet with the highest level of packet protection to avoid the packet being discarded. After the handshake is confirmed (see Section 4.1.2 of [QUIC-TLS]), an endpoint MUST send any CONNECTION_CLOSE frames in a 1-RTT packet. However, prior to confirming the handshake, it is possible that more advanced packet protection keys are not available to the peer, so another CONNECTION_CLOSE frame MAY be sent in a packet that uses a lower packet protection level. More specifically: * A client will always know whether the server has Handshake keys (see Section 17.2.2.1), but it is possible that a server does not know whether the client has Handshake keys. Under these circumstances, a server SHOULD send a CONNECTION_CLOSE frame in both Handshake and Initial packets to ensure that at least one of them is processable by the client. * A client that sends a CONNECTION_CLOSE frame in a 0-RTT packet cannot be assured that the server has accepted 0-RTT. Sending a CONNECTION_CLOSE frame in an Initial packet makes it more likely that the server can receive the close signal, even if the application error code might not be received. * Prior to confirming the handshake, a peer might be unable to process 1-RTT packets, so an endpoint SHOULD send a CONNECTION_CLOSE frame in both Handshake and 1-RTT packets. A server SHOULD also send a CONNECTION_CLOSE frame in an Initial packet. Sending a CONNECTION_CLOSE of type 0x1d in an Initial or Handshake packet could expose application state or be used to alter application state. A CONNECTION_CLOSE of type 0x1d MUST be replaced by a CONNECTION_CLOSE of type 0x1c when sending the frame in Initial or Handshake packets. Otherwise, information about the application state might be revealed. Endpoints MUST clear the value of the Reason Phrase field and SHOULD use the APPLICATION_ERROR code when converting to a CONNECTION_CLOSE of type 0x1c. CONNECTION_CLOSE frames sent in multiple packet types can be coalesced into a single UDP datagram; see Section 12.2. An endpoint can send a CONNECTION_CLOSE frame in an Initial packet. This might be in response to unauthenticated information received in Initial or Handshake packets. Such an immediate close might expose legitimate connections to a denial of service. QUIC does not include defensive measures for on-path attacks during the handshake; see Section 21.2. However, at the cost of reducing feedback about errors for legitimate peers, some forms of denial of service can be made more difficult for an attacker if endpoints discard illegal packets rather than terminating a connection with CONNECTION_CLOSE. For this reason, endpoints MAY discard packets rather than immediately close if errors are detected in packets that lack authentication. An endpoint that has not established state, such as a server that detects an error in an Initial packet, does not enter the closing state. An endpoint that has no state for the connection does not enter a closing or draining period on sending a CONNECTION_CLOSE frame. 10.3. Stateless Reset A stateless reset is provided as an option of last resort for an endpoint that does not have access to the state of a connection. A crash or outage might result in peers continuing to send data to an endpoint that is unable to properly continue the connection. An endpoint MAY send a Stateless Reset in response to receiving a packet that it cannot associate with an active connection. A stateless reset is not appropriate for indicating errors in active connections. An endpoint that wishes to communicate a fatal connection error MUST use a CONNECTION_CLOSE frame if it is able. To support this process, an endpoint issues a stateless reset token, which is a 16-byte value that is hard to guess. If the peer subsequently receives a Stateless Reset, which is a UDP datagram that ends in that stateless reset token, the peer will immediately end the connection. A stateless reset token is specific to a connection ID. An endpoint issues a stateless reset token by including the value in the Stateless Reset Token field of a NEW_CONNECTION_ID frame. Servers can also issue a stateless_reset_token transport parameter during the handshake that applies to the connection ID that it selected during the handshake. These exchanges are protected by encryption, so only client and server know their value. Note that clients cannot use the stateless_reset_token transport parameter because their transport parameters do not have confidentiality protection. Tokens are invalidated when their associated connection ID is retired via a RETIRE_CONNECTION_ID frame (Section 19.16). An endpoint that receives packets that it cannot process sends a packet in the following layout (see Section 1.3): Stateless Reset { Fixed Bits (2) = 1, Unpredictable Bits (38..), Stateless Reset Token (128), } Figure 10: Stateless Reset This design ensures that a Stateless Reset is -- to the extent possible -- indistinguishable from a regular packet with a short header. A Stateless Reset uses an entire UDP datagram, starting with the first two bits of the packet header. The remainder of the first byte and an arbitrary number of bytes following it are set to values that SHOULD be indistinguishable from random. The last 16 bytes of the datagram contain a stateless reset token. To entities other than its intended recipient, a Stateless Reset will appear to be a packet with a short header. For the Stateless Reset to appear as a valid QUIC packet, the Unpredictable Bits field needs to include at least 38 bits of data (or 5 bytes, less the two fixed bits). The resulting minimum size of 21 bytes does not guarantee that a Stateless Reset is difficult to distinguish from other packets if the recipient requires the use of a connection ID. To achieve that end, the endpoint SHOULD ensure that all packets it sends are at least 22 bytes longer than the minimum connection ID length that it requests the peer to include in its packets, adding PADDING frames as necessary. This ensures that any Stateless Reset sent by the peer is indistinguishable from a valid packet sent to the endpoint. An endpoint that sends a Stateless Reset in response to a packet that is 43 bytes or shorter SHOULD send a Stateless Reset that is one byte shorter than the packet it responds to. These values assume that the stateless reset token is the same length as the minimum expansion of the packet protection AEAD. Additional unpredictable bytes are necessary if the endpoint could have negotiated a packet protection scheme with a larger minimum expansion. An endpoint MUST NOT send a Stateless Reset that is three times or more larger than the packet it receives to avoid being used for amplification. Section 10.3.3 describes additional limits on Stateless Reset size. Endpoints MUST discard packets that are too small to be valid QUIC packets. To give an example, with the set of AEAD functions defined in [QUIC-TLS], short header packets that are smaller than 21 bytes are never valid. Endpoints MUST send Stateless Resets formatted as a packet with a short header. However, endpoints MUST treat any packet ending in a valid stateless reset token as a Stateless Reset, as other QUIC versions might allow the use of a long header. An endpoint MAY send a Stateless Reset in response to a packet with a long header. Sending a Stateless Reset is not effective prior to the stateless reset token being available to a peer. In this QUIC version, packets with a long header are only used during connection establishment. Because the stateless reset token is not available until connection establishment is complete or near completion, ignoring an unknown packet with a long header might be as effective as sending a Stateless Reset. An endpoint cannot determine the Source Connection ID from a packet with a short header; therefore, it cannot set the Destination Connection ID in the Stateless Reset. The Destination Connection ID will therefore differ from the value used in previous packets. A random Destination Connection ID makes the connection ID appear to be the result of moving to a new connection ID that was provided using a NEW_CONNECTION_ID frame; see Section 19.15. Using a randomized connection ID results in two problems: * The packet might not reach the peer. If the Destination Connection ID is critical for routing toward the peer, then this packet could be incorrectly routed. This might also trigger another Stateless Reset in response; see Section 10.3.3. A Stateless Reset that is not correctly routed is an ineffective error detection and recovery mechanism. In this case, endpoints will need to rely on other methods -- such as timers -- to detect that the connection has failed. * The randomly generated connection ID can be used by entities other than the peer to identify this as a potential Stateless Reset. An endpoint that occasionally uses different connection IDs might introduce some uncertainty about this. This stateless reset design is specific to QUIC version 1. An endpoint that supports multiple versions of QUIC needs to generate a Stateless Reset that will be accepted by peers that support any version that the endpoint might support (or might have supported prior to losing state). Designers of new versions of QUIC need to be aware of this and either (1) reuse this design or (2) use a portion of the packet other than the last 16 bytes for carrying data. 10.3.1. Detecting a Stateless Reset An endpoint detects a potential Stateless Reset using the trailing 16 bytes of the UDP datagram. An endpoint remembers all stateless reset tokens associated with the connection IDs and remote addresses for datagrams it has recently sent. This includes Stateless Reset Token field values from NEW_CONNECTION_ID frames and the server's transport parameters but excludes stateless reset tokens associated with connection IDs that are either unused or retired. The endpoint identifies a received datagram as a Stateless Reset by comparing the last 16 bytes of the datagram with all stateless reset tokens associated with the remote address on which the datagram was received. This comparison can be performed for every inbound datagram. Endpoints MAY skip this check if any packet from a datagram is successfully processed. However, the comparison MUST be performed when the first packet in an incoming datagram either cannot be associated with a connection or cannot be decrypted. An endpoint MUST NOT check for any stateless reset tokens associated with connection IDs it has not used or for connection IDs that have been retired. When comparing a datagram to stateless reset token values, endpoints MUST perform the comparison without leaking information about the value of the token. For example, performing this comparison in constant time protects the value of individual stateless reset tokens from information leakage through timing side channels. Another approach would be to store and compare the transformed values of stateless reset tokens instead of the raw token values, where the transformation is defined as a cryptographically secure pseudorandom function using a secret key (e.g., block cipher, Hashed Message Authentication Code (HMAC) [RFC2104]). An endpoint is not expected to protect information about whether a packet was successfully decrypted or the number of valid stateless reset tokens. If the last 16 bytes of the datagram are identical in value to a stateless reset token, the endpoint MUST enter the draining period and not send any further packets on this connection. 10.3.2. Calculating a Stateless Reset Token The stateless reset token MUST be difficult to guess. In order to create a stateless reset token, an endpoint could randomly generate [RANDOM] a secret for every connection that it creates. However, this presents a coordination problem when there are multiple instances in a cluster or a storage problem for an endpoint that might lose state. Stateless reset specifically exists to handle the case where state is lost, so this approach is suboptimal. A single static key can be used across all connections to the same endpoint by generating the proof using a pseudorandom function that takes a static key and the connection ID chosen by the endpoint (see Section 5.1) as input. An endpoint could use HMAC [RFC2104] (for example, HMAC(static_key, connection_id)) or the HMAC-based Key Derivation Function (HKDF) [RFC5869] (for example, using the static key as input keying material, with the connection ID as salt). The output of this function is truncated to 16 bytes to produce the stateless reset token for that connection. An endpoint that loses state can use the same method to generate a valid stateless reset token. The connection ID comes from the packet that the endpoint receives. This design relies on the peer always sending a connection ID in its packets so that the endpoint can use the connection ID from a packet to reset the connection. An endpoint that uses this design MUST either use the same connection ID length for all connections or encode the length of the connection ID such that it can be recovered without state. In addition, it cannot provide a zero-length connection ID. Revealing the stateless reset token allows any entity to terminate the connection, so a value can only be used once. This method for choosing the stateless reset token means that the combination of connection ID and static key MUST NOT be used for another connection. A denial-of-service attack is possible if the same connection ID is used by instances that share a static key or if an attacker can cause a packet to be routed to an instance that has no state but the same static key; see Section 21.11. A connection ID from a connection that is reset by revealing the stateless reset token MUST NOT be reused for new connections at nodes that share a static key. The same stateless reset token MUST NOT be used for multiple connection IDs. Endpoints are not required to compare new values against all previous values, but a duplicate value MAY be treated as a connection error of type PROTOCOL_VIOLATION. Note that Stateless Resets do not have any cryptographic protection. 10.3.3. Looping The design of a Stateless Reset is such that without knowing the stateless reset token it is indistinguishable from a valid packet. For instance, if a server sends a Stateless Reset to another server, it might receive another Stateless Reset in response, which could lead to an infinite exchange. An endpoint MUST ensure that every Stateless Reset that it sends is smaller than the packet that triggered it, unless it maintains state sufficient to prevent looping. In the event of a loop, this results in packets eventually being too small to trigger a response. An endpoint can remember the number of Stateless Resets that it has sent and stop generating new Stateless Resets once a limit is reached. Using separate limits for different remote addresses will ensure that Stateless Resets can be used to close connections when other peers or connections have exhausted limits. A Stateless Reset that is smaller than 41 bytes might be identifiable as a Stateless Reset by an observer, depending upon the length of the peer's connection IDs. Conversely, not sending a Stateless Reset in response to a small packet might result in Stateless Resets not being useful in detecting cases of broken connections where only very small packets are sent; such failures might only be detected by other means, such as timers. 11. Error Handling An endpoint that detects an error SHOULD signal the existence of that error to its peer. Both transport-level and application-level errors can affect an entire connection; see Section 11.1. Only application- level errors can be isolated to a single stream; see Section 11.2. The most appropriate error code (Section 20) SHOULD be included in the frame that signals the error. Where this specification identifies error conditions, it also identifies the error code that is used; though these are worded as requirements, different implementation strategies might lead to different errors being reported. In particular, an endpoint MAY use any applicable error code when it detects an error condition; a generic error code (such as PROTOCOL_VIOLATION or INTERNAL_ERROR) can always be used in place of specific error codes. A stateless reset (Section 10.3) is not suitable for any error that can be signaled with a CONNECTION_CLOSE or RESET_STREAM frame. A stateless reset MUST NOT be used by an endpoint that has the state necessary to send a frame on the connection. 11.1. Connection Errors Errors that result in the connection being unusable, such as an obvious violation of protocol semantics or corruption of state that affects an entire connection, MUST be signaled using a CONNECTION_CLOSE frame (Section 19.19). Application-specific protocol errors are signaled using the CONNECTION_CLOSE frame with a frame type of 0x1d. Errors that are specific to the transport, including all those described in this document, are carried in the CONNECTION_CLOSE frame with a frame type of 0x1c. A CONNECTION_CLOSE frame could be sent in a packet that is lost. An endpoint SHOULD be prepared to retransmit a packet containing a CONNECTION_CLOSE frame if it receives more packets on a terminated connection. Limiting the number of retransmissions and the time over which this final packet is sent limits the effort expended on terminated connections. An endpoint that chooses not to retransmit packets containing a CONNECTION_CLOSE frame risks a peer missing the first such packet. The only mechanism available to an endpoint that continues to receive data for a terminated connection is to attempt the stateless reset process (Section 10.3). As the AEAD for Initial packets does not provide strong authentication, an endpoint MAY discard an invalid Initial packet. Discarding an Initial packet is permitted even where this specification otherwise mandates a connection error. An endpoint can only discard a packet if it does not process the frames in the packet or reverts the effects of any processing. Discarding invalid Initial packets might be used to reduce exposure to denial of service; see Section 21.2. 11.2. Stream Errors If an application-level error affects a single stream but otherwise leaves the connection in a recoverable state, the endpoint can send a RESET_STREAM frame (Section 19.4) with an appropriate error code to terminate just the affected stream. Resetting a stream without the involvement of the application protocol could cause the application protocol to enter an unrecoverable state. RESET_STREAM MUST only be instigated by the application protocol that uses QUIC. The semantics of the application error code carried in RESET_STREAM are defined by the application protocol. Only the application protocol is able to cause a stream to be terminated. A local instance of the application protocol uses a direct API call, and a remote instance uses the STOP_SENDING frame, which triggers an automatic RESET_STREAM. Application protocols SHOULD define rules for handling streams that are prematurely canceled by either endpoint. 12. Packets and Frames QUIC endpoints communicate by exchanging packets. Packets have confidentiality and integrity protection; see Section 12.1. Packets are carried in UDP datagrams; see Section 12.2. This version of QUIC uses the long packet header during connection establishment; see Section 17.2. Packets with the long header are Initial (Section 17.2.2), 0-RTT (Section 17.2.3), Handshake (Section 17.2.4), and Retry (Section 17.2.5). Version negotiation uses a version-independent packet with a long header; see Section 17.2.1. Packets with the short header are designed for minimal overhead and are used after a connection is established and 1-RTT keys are available; see Section 17.3. 12.1. Protected Packets QUIC packets have different levels of cryptographic protection based on the type of packet. Details of packet protection are found in [QUIC-TLS]; this section includes an overview of the protections that are provided. Version Negotiation packets have no cryptographic protection; see [QUIC-INVARIANTS]. Retry packets use an AEAD function [AEAD] to protect against accidental modification. Initial packets use an AEAD function, the keys for which are derived using a value that is visible on the wire. Initial packets therefore do not have effective confidentiality protection. Initial protection exists to ensure that the sender of the packet is on the network path. Any entity that receives an Initial packet from a client can recover the keys that will allow them to both read the contents of the packet and generate Initial packets that will be successfully authenticated at either endpoint. The AEAD also protects Initial packets against accidental modification. All other packets are protected with keys derived from the cryptographic handshake. The cryptographic handshake ensures that only the communicating endpoints receive the corresponding keys for Handshake, 0-RTT, and 1-RTT packets. Packets protected with 0-RTT and 1-RTT keys have strong confidentiality and integrity protection. The Packet Number field that appears in some packet types has alternative confidentiality protection that is applied as part of header protection; see Section 5.4 of [QUIC-TLS] for details. The underlying packet number increases with each packet sent in a given packet number space; see Section 12.3 for details. 12.2. Coalescing Packets Initial (Section 17.2.2), 0-RTT (Section 17.2.3), and Handshake (Section 17.2.4) packets contain a Length field that determines the end of the packet. The length includes both the Packet Number and Payload fields, both of which are confidentiality protected and initially of unknown length. The length of the Payload field is learned once header protection is removed. Using the Length field, a sender can coalesce multiple QUIC packets into one UDP datagram. This can reduce the number of UDP datagrams needed to complete the cryptographic handshake and start sending data. This can also be used to construct Path Maximum Transmission Unit (PMTU) probes; see Section 14.4.1. Receivers MUST be able to process coalesced packets. Coalescing packets in order of increasing encryption levels (Initial, 0-RTT, Handshake, 1-RTT; see Section 4.1.4 of [QUIC-TLS]) makes it more likely that the receiver will be able to process all the packets in a single pass. A packet with a short header does not include a length, so it can only be the last packet included in a UDP datagram. An endpoint SHOULD include multiple frames in a single packet if they are to be sent at the same encryption level, instead of coalescing multiple packets at the same encryption level. Receivers MAY route based on the information in the first packet contained in a UDP datagram. Senders MUST NOT coalesce QUIC packets with different connection IDs into a single UDP datagram. Receivers SHOULD ignore any subsequent packets with a different Destination Connection ID than the first packet in the datagram. Every QUIC packet that is coalesced into a single UDP datagram is separate and complete. The receiver of coalesced QUIC packets MUST individually process each QUIC packet and separately acknowledge them, as if they were received as the payload of different UDP datagrams. For example, if decryption fails (because the keys are not available or for any other reason), the receiver MAY either discard or buffer the packet for later processing and MUST attempt to process the remaining packets. Retry packets (Section 17.2.5), Version Negotiation packets (Section 17.2.1), and packets with a short header (Section 17.3) do not contain a Length field and so cannot be followed by other packets in the same UDP datagram. Note also that there is no situation where a Retry or Version Negotiation packet is coalesced with another packet. 12.3. Packet Numbers The packet number is an integer in the range 0 to 2^62-1. This number is used in determining the cryptographic nonce for packet protection. Each endpoint maintains a separate packet number for sending and receiving. Packet numbers are limited to this range because they need to be representable in whole in the Largest Acknowledged field of an ACK frame (Section 19.3). When present in a long or short header, however, packet numbers are reduced and encoded in 1 to 4 bytes; see Section 17.1. Version Negotiation (Section 17.2.1) and Retry (Section 17.2.5) packets do not include a packet number. Packet numbers are divided into three spaces in QUIC: Initial space: All Initial packets (Section 17.2.2) are in this space. Handshake space: All Handshake packets (Section 17.2.4) are in this space. Application data space: All 0-RTT (Section 17.2.3) and 1-RTT (Section 17.3.1) packets are in this space. As described in [QUIC-TLS], each packet type uses different protection keys. Conceptually, a packet number space is the context in which a packet can be processed and acknowledged. Initial packets can only be sent with Initial packet protection keys and acknowledged in packets that are also Initial packets. Similarly, Handshake packets are sent at the Handshake encryption level and can only be acknowledged in Handshake packets. This enforces cryptographic separation between the data sent in the different packet number spaces. Packet numbers in each space start at packet number 0. Subsequent packets sent in the same packet number space MUST increase the packet number by at least one. 0-RTT and 1-RTT data exist in the same packet number space to make loss recovery algorithms easier to implement between the two packet types. A QUIC endpoint MUST NOT reuse a packet number within the same packet number space in one connection. If the packet number for sending reaches 2^62-1, the sender MUST close the connection without sending a CONNECTION_CLOSE frame or any further packets; an endpoint MAY send a Stateless Reset (Section 10.3) in response to further packets that it receives. A receiver MUST discard a newly unprotected packet unless it is certain that it has not processed another packet with the same packet number from the same packet number space. Duplicate suppression MUST happen after removing packet protection for the reasons described in Section 9.5 of [QUIC-TLS]. Endpoints that track all individual packets for the purposes of detecting duplicates are at risk of accumulating excessive state. The data required for detecting duplicates can be limited by maintaining a minimum packet number below which all packets are immediately dropped. Any minimum needs to account for large variations in round-trip time, which includes the possibility that a peer might probe network paths with much larger round-trip times; see Section 9. Packet number encoding at a sender and decoding at a receiver are described in Section 17.1. 12.4. Frames and Frame Types The payload of QUIC packets, after removing packet protection, consists of a sequence of complete frames, as shown in Figure 11. Version Negotiation, Stateless Reset, and Retry packets do not contain frames. Packet Payload { Frame (8..) ..., } Figure 11: QUIC Payload The payload of a packet that contains frames MUST contain at least one frame, and MAY contain multiple frames and multiple frame types. An endpoint MUST treat receipt of a packet containing no frames as a connection error of type PROTOCOL_VIOLATION. Frames always fit within a single QUIC packet and cannot span multiple packets. Each frame begins with a Frame Type, indicating its type, followed by additional type-dependent fields: Frame { Frame Type (i), Type-Dependent Fields (..), } Figure 12: Generic Frame Layout Table 3 lists and summarizes information about each frame type that is defined in this specification. A description of this summary is included after the table. +============+======================+===============+======+======+ | Type Value | Frame Type Name | Definition | Pkts | Spec | +============+======================+===============+======+======+ | 0x00 | PADDING | Section 19.1 | IH01 | NP | +------------+----------------------+---------------+------+------+ | 0x01 | PING | Section 19.2 | IH01 | | +------------+----------------------+---------------+------+------+ | 0x02-0x03 | ACK | Section 19.3 | IH_1 | NC | +------------+----------------------+---------------+------+------+ | 0x04 | RESET_STREAM | Section 19.4 | __01 | | +------------+----------------------+---------------+------+------+ | 0x05 | STOP_SENDING | Section 19.5 | __01 | | +------------+----------------------+---------------+------+------+ | 0x06 | CRYPTO | Section 19.6 | IH_1 | | +------------+----------------------+---------------+------+------+ | 0x07 | NEW_TOKEN | Section 19.7 | ___1 | | +------------+----------------------+---------------+------+------+ | 0x08-0x0f | STREAM | Section 19.8 | __01 | F | +------------+----------------------+---------------+------+------+ | 0x10 | MAX_DATA | Section 19.9 | __01 | | +------------+----------------------+---------------+------+------+ | 0x11 | MAX_STREAM_DATA | Section 19.10 | __01 | | +------------+----------------------+---------------+------+------+ | 0x12-0x13 | MAX_STREAMS | Section 19.11 | __01 | | +------------+----------------------+---------------+------+------+ | 0x14 | DATA_BLOCKED | Section 19.12 | __01 | | +------------+----------------------+---------------+------+------+ | 0x15 | STREAM_DATA_BLOCKED | Section 19.13 | __01 | | +------------+----------------------+---------------+------+------+ | 0x16-0x17 | STREAMS_BLOCKED | Section 19.14 | __01 | | +------------+----------------------+---------------+------+------+ | 0x18 | NEW_CONNECTION_ID | Section 19.15 | __01 | P | +------------+----------------------+---------------+------+------+ | 0x19 | RETIRE_CONNECTION_ID | Section 19.16 | __01 | | +------------+----------------------+---------------+------+------+ | 0x1a | PATH_CHALLENGE | Section 19.17 | __01 | P | +------------+----------------------+---------------+------+------+ | 0x1b | PATH_RESPONSE | Section 19.18 | ___1 | P | +------------+----------------------+---------------+------+------+ | 0x1c-0x1d | CONNECTION_CLOSE | Section 19.19 | ih01 | N | +------------+----------------------+---------------+------+------+ | 0x1e | HANDSHAKE_DONE | Section 19.20 | ___1 | | +------------+----------------------+---------------+------+------+ Table 3: Frame Types The format and semantics of each frame type are explained in more detail in Section 19. The remainder of this section provides a summary of important and general information. The Frame Type in ACK, STREAM, MAX_STREAMS, STREAMS_BLOCKED, and CONNECTION_CLOSE frames is used to carry other frame-specific flags. For all other frames, the Frame Type field simply identifies the frame. The "Pkts" column in Table 3 lists the types of packets that each frame type could appear in, indicated by the following characters: I: Initial (Section 17.2.2) H: Handshake (Section 17.2.4) 0: 0-RTT (Section 17.2.3) 1: 1-RTT (Section 17.3.1) ih: Only a CONNECTION_CLOSE frame of type 0x1c can appear in Initial or Handshake packets. For more details about these restrictions, see Section 12.5. Note that all frames can appear in 1-RTT packets. An endpoint MUST treat receipt of a frame in a packet type that is not permitted as a connection error of type PROTOCOL_VIOLATION. The "Spec" column in Table 3 summarizes any special rules governing the processing or generation of the frame type, as indicated by the following characters: N: Packets containing only frames with this marking are not ack- eliciting; see Section 13.2. C: Packets containing only frames with this marking do not count toward bytes in flight for congestion control purposes; see [QUIC-RECOVERY]. P: Packets containing only frames with this marking can be used to probe new network paths during connection migration; see Section 9.1. F: The contents of frames with this marking are flow controlled; see Section 4. The "Pkts" and "Spec" columns in Table 3 do not form part of the IANA registry; see Section 22.4. An endpoint MUST treat the receipt of a frame of unknown type as a connection error of type FRAME_ENCODING_ERROR. All frames are idempotent in this version of QUIC. That is, a valid frame does not cause undesirable side effects or errors when received more than once. The Frame Type field uses a variable-length integer encoding (see Section 16), with one exception. To ensure simple and efficient implementations of frame parsing, a frame type MUST use the shortest possible encoding. For frame types defined in this document, this means a single-byte encoding, even though it is possible to encode these values as a two-, four-, or eight-byte variable-length integer. For instance, though 0x4001 is a legitimate two-byte encoding for a variable-length integer with a value of 1, PING frames are always encoded as a single byte with the value 0x01. This rule applies to all current and future QUIC frame types. An endpoint MAY treat the receipt of a frame type that uses a longer encoding than necessary as a connection error of type PROTOCOL_VIOLATION. 12.5. Frames and Number Spaces Some frames are prohibited in different packet number spaces. The rules here generalize those of TLS, in that frames associated with establishing the connection can usually appear in packets in any packet number space, whereas those associated with transferring data can only appear in the application data packet number space: * PADDING, PING, and CRYPTO frames MAY appear in any packet number space. * CONNECTION_CLOSE frames signaling errors at the QUIC layer (type 0x1c) MAY appear in any packet number space. CONNECTION_CLOSE frames signaling application errors (type 0x1d) MUST only appear in the application data packet number space. * ACK frames MAY appear in any packet number space but can only acknowledge packets that appeared in that packet number space. However, as noted below, 0-RTT packets cannot contain ACK frames. * All other frame types MUST only be sent in the application data packet number space. Note that it is not possible to send the following frames in 0-RTT packets for various reasons: ACK, CRYPTO, HANDSHAKE_DONE, NEW_TOKEN, PATH_RESPONSE, and RETIRE_CONNECTION_ID. A server MAY treat receipt of these frames in 0-RTT packets as a connection error of type PROTOCOL_VIOLATION. 13. Packetization and Reliability A sender sends one or more frames in a QUIC packet; see Section 12.4. A sender can minimize per-packet bandwidth and computational costs by including as many frames as possible in each QUIC packet. A sender MAY wait for a short period of time to collect multiple frames before sending a packet that is not maximally packed, to avoid sending out large numbers of small packets. An implementation MAY use knowledge about application sending behavior or heuristics to determine whether and for how long to wait. This waiting period is an implementation decision, and an implementation should be careful to delay conservatively, since any delay is likely to increase application- visible latency. Stream multiplexing is achieved by interleaving STREAM frames from multiple streams into one or more QUIC packets. A single QUIC packet can include multiple STREAM frames from one or more streams. One of the benefits of QUIC is avoidance of head-of-line blocking across multiple streams. When a packet loss occurs, only streams with data in that packet are blocked waiting for a retransmission to be received, while other streams can continue making progress. Note that when data from multiple streams is included in a single QUIC packet, loss of that packet blocks all those streams from making progress. Implementations are advised to include as few streams as necessary in outgoing packets without losing transmission efficiency to underfilled packets. 13.1. Packet Processing A packet MUST NOT be acknowledged until packet protection has been successfully removed and all frames contained in the packet have been processed. For STREAM frames, this means the data has been enqueued in preparation to be received by the application protocol, but it does not require that data be delivered and consumed. Once the packet has been fully processed, a receiver acknowledges receipt by sending one or more ACK frames containing the packet number of the received packet. An endpoint SHOULD treat receipt of an acknowledgment for a packet it did not send as a connection error of type PROTOCOL_VIOLATION, if it is able to detect the condition. For further discussion of how this might be achieved, see Section 21.4. 13.2. Generating Acknowledgments Endpoints acknowledge all packets they receive and process. However, only ack-eliciting packets cause an ACK frame to be sent within the maximum ack delay. Packets that are not ack-eliciting are only acknowledged when an ACK frame is sent for other reasons. When sending a packet for any reason, an endpoint SHOULD attempt to include an ACK frame if one has not been sent recently. Doing so helps with timely loss detection at the peer. In general, frequent feedback from a receiver improves loss and congestion response, but this has to be balanced against excessive load generated by a receiver that sends an ACK frame in response to every ack-eliciting packet. The guidance offered below seeks to strike this balance. 13.2.1. Sending ACK Frames Every packet SHOULD be acknowledged at least once, and ack-eliciting packets MUST be acknowledged at least once within the maximum delay an endpoint communicated using the max_ack_delay transport parameter; see Section 18.2. max_ack_delay declares an explicit contract: an endpoint promises to never intentionally delay acknowledgments of an ack-eliciting packet by more than the indicated value. If it does, any excess accrues to the RTT estimate and could result in spurious or delayed retransmissions from the peer. A sender uses the receiver's max_ack_delay value in determining timeouts for timer- based retransmission, as detailed in Section 6.2 of [QUIC-RECOVERY]. An endpoint MUST acknowledge all ack-eliciting Initial and Handshake packets immediately and all ack-eliciting 0-RTT and 1-RTT packets within its advertised max_ack_delay, with the following exception. Prior to handshake confirmation, an endpoint might not have packet protection keys for decrypting Handshake, 0-RTT, or 1-RTT packets when they are received. It might therefore buffer them and acknowledge them when the requisite keys become available. Since packets containing only ACK frames are not congestion controlled, an endpoint MUST NOT send more than one such packet in response to receiving an ack-eliciting packet. An endpoint MUST NOT send a non-ack-eliciting packet in response to a non-ack-eliciting packet, even if there are packet gaps that precede the received packet. This avoids an infinite feedback loop of acknowledgments, which could prevent the connection from ever becoming idle. Non-ack-eliciting packets are eventually acknowledged when the endpoint sends an ACK frame in response to other events. An endpoint that is only sending ACK frames will not receive acknowledgments from its peer unless those acknowledgments are included in packets with ack-eliciting frames. An endpoint SHOULD send an ACK frame with other frames when there are new ack-eliciting packets to acknowledge. When only non-ack-eliciting packets need to be acknowledged, an endpoint MAY choose not to send an ACK frame with outgoing frames until an ack-eliciting packet has been received. An endpoint that is only sending non-ack-eliciting packets might choose to occasionally add an ack-eliciting frame to those packets to ensure that it receives an acknowledgment; see Section 13.2.4. In that case, an endpoint MUST NOT send an ack-eliciting frame in all packets that would otherwise be non-ack-eliciting, to avoid an infinite feedback loop of acknowledgments. In order to assist loss detection at the sender, an endpoint SHOULD generate and send an ACK frame without delay when it receives an ack- eliciting packet either: * when the received packet has a packet number less than another ack-eliciting packet that has been received, or * when the packet has a packet number larger than the highest- numbered ack-eliciting packet that has been received and there are missing packets between that packet and this packet. Similarly, packets marked with the ECN Congestion Experienced (CE) codepoint in the IP header SHOULD be acknowledged immediately, to reduce the peer's response time to congestion events. The algorithms in [QUIC-RECOVERY] are expected to be resilient to receivers that do not follow the guidance offered above. However, an implementation should only deviate from these requirements after careful consideration of the performance implications of a change, for connections made by the endpoint and for other users of the network. 13.2.2. Acknowledgment Frequency A receiver determines how frequently to send acknowledgments in response to ack-eliciting packets. This determination involves a trade-off. Endpoints rely on timely acknowledgment to detect loss; see Section 6 of [QUIC-RECOVERY]. Window-based congestion controllers, such as the one described in Section 7 of [QUIC-RECOVERY], rely on acknowledgments to manage their congestion window. In both cases, delaying acknowledgments can adversely affect performance. On the other hand, reducing the frequency of packets that carry only acknowledgments reduces packet transmission and processing cost at both endpoints. It can improve connection throughput on severely asymmetric links and reduce the volume of acknowledgment traffic using return path capacity; see Section 3 of [RFC3449]. A receiver SHOULD send an ACK frame after receiving at least two ack- eliciting packets. This recommendation is general in nature and consistent with recommendations for TCP endpoint behavior [RFC5681]. Knowledge of network conditions, knowledge of the peer's congestion controller, or further research and experimentation might suggest alternative acknowledgment strategies with better performance characteristics. A receiver MAY process multiple available packets before determining whether to send an ACK frame in response. 13.2.3. Managing ACK Ranges When an ACK frame is sent, one or more ranges of acknowledged packets are included. Including acknowledgments for older packets reduces the chance of spurious retransmissions caused by losing previously sent ACK frames, at the cost of larger ACK frames. ACK frames SHOULD always acknowledge the most recently received packets, and the more out of order the packets are, the more important it is to send an updated ACK frame quickly, to prevent the peer from declaring a packet as lost and spuriously retransmitting the frames it contains. An ACK frame is expected to fit within a single QUIC packet. If it does not, then older ranges (those with the smallest packet numbers) are omitted. A receiver limits the number of ACK Ranges (Section 19.3.1) it remembers and sends in ACK frames, both to limit the size of ACK frames and to avoid resource exhaustion. After receiving acknowledgments for an ACK frame, the receiver SHOULD stop tracking those acknowledged ACK Ranges. Senders can expect acknowledgments for most packets, but QUIC does not guarantee receipt of an acknowledgment for every packet that the receiver processes. It is possible that retaining many ACK Ranges could cause an ACK frame to become too large. A receiver can discard unacknowledged ACK Ranges to limit ACK frame size, at the cost of increased retransmissions from the sender. This is necessary if an ACK frame would be too large to fit in a packet. Receivers MAY also limit ACK frame size further to preserve space for other frames or to limit the capacity that acknowledgments consume. A receiver MUST retain an ACK Range unless it can ensure that it will not subsequently accept packets with numbers in that range. Maintaining a minimum packet number that increases as ranges are discarded is one way to achieve this with minimal state. Receivers can discard all ACK Ranges, but they MUST retain the largest packet number that has been successfully processed, as that is used to recover packet numbers from subsequent packets; see Section 17.1. A receiver SHOULD include an ACK Range containing the largest received packet number in every ACK frame. The Largest Acknowledged field is used in ECN validation at a sender, and including a lower value than what was included in a previous ACK frame could cause ECN to be unnecessarily disabled; see Section 13.4.2. Section 13.2.4 describes an exemplary approach for determining what packets to acknowledge in each ACK frame. Though the goal of this algorithm is to generate an acknowledgment for every packet that is processed, it is still possible for acknowledgments to be lost. 13.2.4. Limiting Ranges by Tracking ACK Frames When a packet containing an ACK frame is sent, the Largest Acknowledged field in that frame can be saved. When a packet containing an ACK frame is acknowledged, the receiver can stop acknowledging packets less than or equal to the Largest Acknowledged field in the sent ACK frame. A receiver that sends only non-ack-eliciting packets, such as ACK frames, might not receive an acknowledgment for a long period of time. This could cause the receiver to maintain state for a large number of ACK frames for a long period of time, and ACK frames it sends could be unnecessarily large. In such a case, a receiver could send a PING or other small ack-eliciting frame occasionally, such as once per round trip, to elicit an ACK from the peer. In cases without ACK frame loss, this algorithm allows for a minimum of 1 RTT of reordering. In cases with ACK frame loss and reordering, this approach does not guarantee that every acknowledgment is seen by the sender before it is no longer included in the ACK frame. Packets could be received out of order, and all subsequent ACK frames containing them could be lost. In this case, the loss recovery algorithm could cause spurious retransmissions, but the sender will continue making forward progress. 13.2.5. Measuring and Reporting Host Delay An endpoint measures the delays intentionally introduced between the time the packet with the largest packet number is received and the time an acknowledgment is sent. The endpoint encodes this acknowledgment delay in the ACK Delay field of an ACK frame; see Section 19.3. This allows the receiver of the ACK frame to adjust for any intentional delays, which is important for getting a better estimate of the path RTT when acknowledgments are delayed. A packet might be held in the OS kernel or elsewhere on the host before being processed. An endpoint MUST NOT include delays that it does not control when populating the ACK Delay field in an ACK frame. However, endpoints SHOULD include buffering delays caused by unavailability of decryption keys, since these delays can be large and are likely to be non-repeating. When the measured acknowledgment delay is larger than its max_ack_delay, an endpoint SHOULD report the measured delay. This information is especially useful during the handshake when delays might be large; see Section 13.2.1. 13.2.6. ACK Frames and Packet Protection ACK frames MUST only be carried in a packet that has the same packet number space as the packet being acknowledged; see Section 12.1. For instance, packets that are protected with 1-RTT keys MUST be acknowledged in packets that are also protected with 1-RTT keys. Packets that a client sends with 0-RTT packet protection MUST be acknowledged by the server in packets protected by 1-RTT keys. This can mean that the client is unable to use these acknowledgments if the server cryptographic handshake messages are delayed or lost. Note that the same limitation applies to other data sent by the server protected by the 1-RTT keys. 13.2.7. PADDING Frames Consume Congestion Window Packets containing PADDING frames are considered to be in flight for congestion control purposes [QUIC-RECOVERY]. Packets containing only PADDING frames therefore consume congestion window but do not generate acknowledgments that will open the congestion window. To avoid a deadlock, a sender SHOULD ensure that other frames are sent periodically in addition to PADDING frames to elicit acknowledgments from the receiver. 13.3. Retransmission of Information QUIC packets that are determined to be lost are not retransmitted whole. The same applies to the frames that are contained within lost packets. Instead, the information that might be carried in frames is sent again in new frames as needed. New frames and packets are used to carry information that is determined to have been lost. In general, information is sent again when a packet containing that information is determined to be lost, and sending ceases when a packet containing that information is acknowledged. * Data sent in CRYPTO frames is retransmitted according to the rules in [QUIC-RECOVERY], until all data has been acknowledged. Data in CRYPTO frames for Initial and Handshake packets is discarded when keys for the corresponding packet number space are discarded. * Application data sent in STREAM frames is retransmitted in new STREAM frames unless the endpoint has sent a RESET_STREAM for that stream. Once an endpoint sends a RESET_STREAM frame, no further STREAM frames are needed. * ACK frames carry the most recent set of acknowledgments and the acknowledgment delay from the largest acknowledged packet, as described in Section 13.2.1. Delaying the transmission of packets containing ACK frames or resending old ACK frames can cause the peer to generate an inflated RTT sample or unnecessarily disable ECN. * Cancellation of stream transmission, as carried in a RESET_STREAM frame, is sent until acknowledged or until all stream data is acknowledged by the peer (that is, either the "Reset Recvd" or "Data Recvd" state is reached on the sending part of the stream). The content of a RESET_STREAM frame MUST NOT change when it is sent again. * Similarly, a request to cancel stream transmission, as encoded in a STOP_SENDING frame, is sent until the receiving part of the stream enters either a "Data Recvd" or "Reset Recvd" state; see Section 3.5. * Connection close signals, including packets that contain CONNECTION_CLOSE frames, are not sent again when packet loss is detected. Resending these signals is described in Section 10. * The current connection maximum data is sent in MAX_DATA frames. An updated value is sent in a MAX_DATA frame if the packet containing the most recently sent MAX_DATA frame is declared lost or when the endpoint decides to update the limit. Care is necessary to avoid sending this frame too often, as the limit can increase frequently and cause an unnecessarily large number of MAX_DATA frames to be sent; see Section 4.2. * The current maximum stream data offset is sent in MAX_STREAM_DATA frames. Like MAX_DATA, an updated value is sent when the packet containing the most recent MAX_STREAM_DATA frame for a stream is lost or when the limit is updated, with care taken to prevent the frame from being sent too often. An endpoint SHOULD stop sending MAX_STREAM_DATA frames when the receiving part of the stream enters a "Size Known" or "Reset Recvd" state. * The limit on streams of a given type is sent in MAX_STREAMS frames. Like MAX_DATA, an updated value is sent when a packet containing the most recent MAX_STREAMS for a stream type frame is declared lost or when the limit is updated, with care taken to prevent the frame from being sent too often. * Blocked signals are carried in DATA_BLOCKED, STREAM_DATA_BLOCKED, and STREAMS_BLOCKED frames. DATA_BLOCKED frames have connection scope, STREAM_DATA_BLOCKED frames have stream scope, and STREAMS_BLOCKED frames are scoped to a specific stream type. A new frame is sent if a packet containing the most recent frame for a scope is lost, but only while the endpoint is blocked on the corresponding limit. These frames always include the limit that is causing blocking at the time that they are transmitted. * A liveness or path validation check using PATH_CHALLENGE frames is sent periodically until a matching PATH_RESPONSE frame is received or until there is no remaining need for liveness or path validation checking. PATH_CHALLENGE frames include a different payload each time they are sent. * Responses to path validation using PATH_RESPONSE frames are sent just once. The peer is expected to send more PATH_CHALLENGE frames as necessary to evoke additional PATH_RESPONSE frames. * New connection IDs are sent in NEW_CONNECTION_ID frames and retransmitted if the packet containing them is lost. Retransmissions of this frame carry the same sequence number value. Likewise, retired connection IDs are sent in RETIRE_CONNECTION_ID frames and retransmitted if the packet containing them is lost. * NEW_TOKEN frames are retransmitted if the packet containing them is lost. No special support is made for detecting reordered and duplicated NEW_TOKEN frames other than a direct comparison of the frame contents. * PING and PADDING frames contain no information, so lost PING or PADDING frames do not require repair. * The HANDSHAKE_DONE frame MUST be retransmitted until it is acknowledged. Endpoints SHOULD prioritize retransmission of data over sending new data, unless priorities specified by the application indicate otherwise; see Section 2.3. Even though a sender is encouraged to assemble frames containing up- to-date information every time it sends a packet, it is not forbidden to retransmit copies of frames from lost packets. A sender that retransmits copies of frames needs to handle decreases in available payload size due to changes in packet number length, connection ID length, and path MTU. A receiver MUST accept packets containing an outdated frame, such as a MAX_DATA frame carrying a smaller maximum data value than one found in an older packet. A sender SHOULD avoid retransmitting information from packets once they are acknowledged. This includes packets that are acknowledged after being declared lost, which can happen in the presence of network reordering. Doing so requires senders to retain information about packets after they are declared lost. A sender can discard this information after a period of time elapses that adequately allows for reordering, such as a PTO (Section 6.2 of [QUIC-RECOVERY]), or based on other events, such as reaching a memory limit. Upon detecting losses, a sender MUST take appropriate congestion control action. The details of loss detection and congestion control are described in [QUIC-RECOVERY]. 13.4. Explicit Congestion Notification QUIC endpoints can use ECN [RFC3168] to detect and respond to network congestion. ECN allows an endpoint to set an ECN-Capable Transport (ECT) codepoint in the ECN field of an IP packet. A network node can then indicate congestion by setting the ECN-CE codepoint in the ECN field instead of dropping the packet [RFC8087]. Endpoints react to reported congestion by reducing their sending rate in response, as described in [QUIC-RECOVERY]. To enable ECN, a sending QUIC endpoint first determines whether a path supports ECN marking and whether the peer reports the ECN values in received IP headers; see Section 13.4.2. 13.4.1. Reporting ECN Counts The use of ECN requires the receiving endpoint to read the ECN field from an IP packet, which is not possible on all platforms. If an endpoint does not implement ECN support or does not have access to received ECN fields, it does not report ECN counts for packets it receives. Even if an endpoint does not set an ECT field in packets it sends, the endpoint MUST provide feedback about ECN markings it receives, if these are accessible. Failing to report the ECN counts will cause the sender to disable the use of ECN for this connection. On receiving an IP packet with an ECT(0), ECT(1), or ECN-CE codepoint, an ECN-enabled endpoint accesses the ECN field and increases the corresponding ECT(0), ECT(1), or ECN-CE count. These ECN counts are included in subsequent ACK frames; see Sections 13.2 and 19.3. Each packet number space maintains separate acknowledgment state and separate ECN counts. Coalesced QUIC packets (see Section 12.2) share the same IP header so the ECN counts are incremented once for each coalesced QUIC packet. For example, if one each of an Initial, Handshake, and 1-RTT QUIC packet are coalesced into a single UDP datagram, the ECN counts for all three packet number spaces will be incremented by one each, based on the ECN field of the single IP header. ECN counts are only incremented when QUIC packets from the received IP packet are processed. As such, duplicate QUIC packets are not processed and do not increase ECN counts; see Section 21.10 for relevant security concerns. 13.4.2. ECN Validation It is possible for faulty network devices to corrupt or erroneously drop packets that carry a non-zero ECN codepoint. To ensure connectivity in the presence of such devices, an endpoint validates the ECN counts for each network path and disables the use of ECN on that path if errors are detected. To perform ECN validation for a new path: * The endpoint sets an ECT(0) codepoint in the IP header of early outgoing packets sent on a new path to the peer [RFC8311]. * The endpoint monitors whether all packets sent with an ECT codepoint are eventually deemed lost (Section 6 of [QUIC-RECOVERY]), indicating that ECN validation has failed. If an endpoint has cause to expect that IP packets with an ECT codepoint might be dropped by a faulty network element, the endpoint could set an ECT codepoint for only the first ten outgoing packets on a path, or for a period of three PTOs (see Section 6.2 of [QUIC-RECOVERY]). If all packets marked with non-zero ECN codepoints are subsequently lost, it can disable marking on the assumption that the marking caused the loss. An endpoint thus attempts to use ECN and validates this for each new connection, when switching to a server's preferred address, and on active connection migration to a new path. Appendix A.4 describes one possible algorithm. Other methods of probing paths for ECN support are possible, as are different marking strategies. Implementations MAY use other methods defined in RFCs; see [RFC8311]. Implementations that use the ECT(1) codepoint need to perform ECN validation using the reported ECT(1) counts. 13.4.2.1. Receiving ACK Frames with ECN Counts Erroneous application of ECN-CE markings by the network can result in degraded connection performance. An endpoint that receives an ACK frame with ECN counts therefore validates the counts before using them. It performs this validation by comparing newly received counts against those from the last successfully processed ACK frame. Any increase in the ECN counts is validated based on the ECN markings that were applied to packets that are newly acknowledged in the ACK frame. If an ACK frame newly acknowledges a packet that the endpoint sent with either the ECT(0) or ECT(1) codepoint set, ECN validation fails if the corresponding ECN counts are not present in the ACK frame. This check detects a network element that zeroes the ECN field or a peer that does not report ECN markings. ECN validation also fails if the sum of the increase in ECT(0) and ECN-CE counts is less than the number of newly acknowledged packets that were originally sent with an ECT(0) marking. Similarly, ECN validation fails if the sum of the increases to ECT(1) and ECN-CE counts is less than the number of newly acknowledged packets sent with an ECT(1) marking. These checks can detect remarking of ECN-CE markings by the network. An endpoint could miss acknowledgments for a packet when ACK frames are lost. It is therefore possible for the total increase in ECT(0), ECT(1), and ECN-CE counts to be greater than the number of packets that are newly acknowledged by an ACK frame. This is why ECN counts are permitted to be larger than the total number of packets that are acknowledged. Validating ECN counts from reordered ACK frames can result in failure. An endpoint MUST NOT fail ECN validation as a result of processing an ACK frame that does not increase the largest acknowledged packet number. ECN validation can fail if the received total count for either ECT(0) or ECT(1) exceeds the total number of packets sent with each corresponding ECT codepoint. In particular, validation will fail when an endpoint receives a non-zero ECN count corresponding to an ECT codepoint that it never applied. This check detects when packets are remarked to ECT(0) or ECT(1) in the network. 13.4.2.2. ECN Validation Outcomes If validation fails, then the endpoint MUST disable ECN. It stops setting the ECT codepoint in IP packets that it sends, assuming that either the network path or the peer does not support ECN. Even if validation fails, an endpoint MAY revalidate ECN for the same path at any later time in the connection. An endpoint could continue to periodically attempt validation. Upon successful validation, an endpoint MAY continue to set an ECT codepoint in subsequent packets it sends, with the expectation that the path is ECN capable. Network routing and path elements can change mid-connection; an endpoint MUST disable ECN if validation later fails. 14. Datagram Size A UDP datagram can include one or more QUIC packets. The datagram size refers to the total UDP payload size of a single UDP datagram carrying QUIC packets. The datagram size includes one or more QUIC packet headers and protected payloads, but not the UDP or IP headers. The maximum datagram size is defined as the largest size of UDP payload that can be sent across a network path using a single UDP datagram. QUIC MUST NOT be used if the network path cannot support a maximum datagram size of at least 1200 bytes. QUIC assumes a minimum IP packet size of at least 1280 bytes. This is the IPv6 minimum size [IPv6] and is also supported by most modern IPv4 networks. Assuming the minimum IP header size of 40 bytes for IPv6 and 20 bytes for IPv4 and a UDP header size of 8 bytes, this results in a maximum datagram size of 1232 bytes for IPv6 and 1252 bytes for IPv4. Thus, modern IPv4 and all IPv6 network paths are expected to be able to support QUIC. | Note: This requirement to support a UDP payload of 1200 bytes | limits the space available for IPv6 extension headers to 32 | bytes or IPv4 options to 52 bytes if the path only supports the | IPv6 minimum MTU of 1280 bytes. This affects Initial packets | and path validation. Any maximum datagram size larger than 1200 bytes can be discovered using Path Maximum Transmission Unit Discovery (PMTUD) (see Section 14.2.1) or Datagram Packetization Layer PMTU Discovery (DPLPMTUD) (see Section 14.3). Enforcement of the max_udp_payload_size transport parameter (Section 18.2) might act as an additional limit on the maximum datagram size. A sender can avoid exceeding this limit, once the value is known. However, prior to learning the value of the transport parameter, endpoints risk datagrams being lost if they send datagrams larger than the smallest allowed maximum datagram size of 1200 bytes. UDP datagrams MUST NOT be fragmented at the IP layer. In IPv4 [IPv4], the Don't Fragment (DF) bit MUST be set if possible, to prevent fragmentation on the path. QUIC sometimes requires datagrams to be no smaller than a certain size; see Section 8.1 as an example. However, the size of a datagram is not authenticated. That is, if an endpoint receives a datagram of a certain size, it cannot know that the sender sent the datagram at the same size. Therefore, an endpoint MUST NOT close a connection when it receives a datagram that does not meet size constraints; the endpoint MAY discard such datagrams. 14.1. Initial Datagram Size A client MUST expand the payload of all UDP datagrams carrying Initial packets to at least the smallest allowed maximum datagram size of 1200 bytes by adding PADDING frames to the Initial packet or by coalescing the Initial packet; see Section 12.2. Initial packets can even be coalesced with invalid packets, which a receiver will discard. Similarly, a server MUST expand the payload of all UDP datagrams carrying ack-eliciting Initial packets to at least the smallest allowed maximum datagram size of 1200 bytes. Sending UDP datagrams of this size ensures that the network path supports a reasonable Path Maximum Transmission Unit (PMTU), in both directions. Additionally, a client that expands Initial packets helps reduce the amplitude of amplification attacks caused by server responses toward an unverified client address; see Section 8. Datagrams containing Initial packets MAY exceed 1200 bytes if the sender believes that the network path and peer both support the size that it chooses. A server MUST discard an Initial packet that is carried in a UDP datagram with a payload that is smaller than the smallest allowed maximum datagram size of 1200 bytes. A server MAY also immediately close the connection by sending a CONNECTION_CLOSE frame with an error code of PROTOCOL_VIOLATION; see Section 10.2.3. The server MUST also limit the number of bytes it sends before validating the address of the client; see Section 8. 14.2. Path Maximum Transmission Unit The PMTU is the maximum size of the entire IP packet, including the IP header, UDP header, and UDP payload. The UDP payload includes one or more QUIC packet headers and protected payloads. The PMTU can depend on path characteristics and can therefore change over time. The largest UDP payload an endpoint sends at any given time is referred to as the endpoint's maximum datagram size. An endpoint SHOULD use DPLPMTUD (Section 14.3) or PMTUD (Section 14.2.1) to determine whether the path to a destination will support a desired maximum datagram size without fragmentation. In the absence of these mechanisms, QUIC endpoints SHOULD NOT send datagrams larger than the smallest allowed maximum datagram size. Both DPLPMTUD and PMTUD send datagrams that are larger than the current maximum datagram size, referred to as PMTU probes. All QUIC packets that are not sent in a PMTU probe SHOULD be sized to fit within the maximum datagram size to avoid the datagram being fragmented or dropped [RFC8085]. If a QUIC endpoint determines that the PMTU between any pair of local and remote IP addresses cannot support the smallest allowed maximum datagram size of 1200 bytes, it MUST immediately cease sending QUIC packets, except for those in PMTU probes or those containing CONNECTION_CLOSE frames, on the affected path. An endpoint MAY terminate the connection if an alternative path cannot be found. Each pair of local and remote addresses could have a different PMTU. QUIC implementations that implement any kind of PMTU discovery therefore SHOULD maintain a maximum datagram size for each combination of local and remote IP addresses. A QUIC implementation MAY be more conservative in computing the maximum datagram size to allow for unknown tunnel overheads or IP header options/extensions. 14.2.1. Handling of ICMP Messages by PMTUD PMTUD [RFC1191] [RFC8201] relies on reception of ICMP messages (that is, IPv6 Packet Too Big (PTB) messages) that indicate when an IP packet is dropped because it is larger than the local router MTU. DPLPMTUD can also optionally use these messages. This use of ICMP messages is potentially vulnerable to attacks by entities that cannot observe packets but might successfully guess the addresses used on the path. These attacks could reduce the PMTU to a bandwidth- inefficient value. An endpoint MUST ignore an ICMP message that claims the PMTU has decreased below QUIC's smallest allowed maximum datagram size. The requirements for generating ICMP [RFC1812] [RFC4443] state that the quoted packet should contain as much of the original packet as possible without exceeding the minimum MTU for the IP version. The size of the quoted packet can actually be smaller, or the information unintelligible, as described in Section 1.1 of [DPLPMTUD]. QUIC endpoints using PMTUD SHOULD validate ICMP messages to protect from packet injection as specified in [RFC8201] and Section 5.2 of [RFC8085]. This validation SHOULD use the quoted packet supplied in the payload of an ICMP message to associate the message with a corresponding transport connection (see Section 4.6.1 of [DPLPMTUD]). ICMP message validation MUST include matching IP addresses and UDP ports [RFC8085] and, when possible, connection IDs to an active QUIC session. The endpoint SHOULD ignore all ICMP messages that fail validation. An endpoint MUST NOT increase the PMTU based on ICMP messages; see Item 6 in Section 3 of [DPLPMTUD]. Any reduction in QUIC's maximum datagram size in response to ICMP messages MAY be provisional until QUIC's loss detection algorithm determines that the quoted packet has actually been lost. 14.3. Datagram Packetization Layer PMTU Discovery DPLPMTUD [DPLPMTUD] relies on tracking loss or acknowledgment of QUIC packets that are carried in PMTU probes. PMTU probes for DPLPMTUD that use the PADDING frame implement "Probing using padding data", as defined in Section 4.1 of [DPLPMTUD]. Endpoints SHOULD set the initial value of BASE_PLPMTU (Section 5.1 of [DPLPMTUD]) to be consistent with QUIC's smallest allowed maximum datagram size. The MIN_PLPMTU is the same as the BASE_PLPMTU. QUIC endpoints implementing DPLPMTUD maintain a DPLPMTUD Maximum Packet Size (MPS) (Section 4.4 of [DPLPMTUD]) for each combination of local and remote IP addresses. This corresponds to the maximum datagram size. 14.3.1. DPLPMTUD and Initial Connectivity From the perspective of DPLPMTUD, QUIC is an acknowledged Packetization Layer (PL). A QUIC sender can therefore enter the DPLPMTUD BASE state (Section 5.2 of [DPLPMTUD]) when the QUIC connection handshake has been completed. 14.3.2. Validating the Network Path with DPLPMTUD QUIC is an acknowledged PL; therefore, a QUIC sender does not implement a DPLPMTUD CONFIRMATION_TIMER while in the SEARCH_COMPLETE state; see Section 5.2 of [DPLPMTUD]. 14.3.3. Handling of ICMP Messages by DPLPMTUD An endpoint using DPLPMTUD requires the validation of any received ICMP PTB message before using the PTB information, as defined in Section 4.6 of [DPLPMTUD]. In addition to UDP port validation, QUIC validates an ICMP message by using other PL information (e.g., validation of connection IDs in the quoted packet of any received ICMP message). The considerations for processing ICMP messages described in Section 14.2.1 also apply if these messages are used by DPLPMTUD. 14.4. Sending QUIC PMTU Probes PMTU probes are ack-eliciting packets. Endpoints could limit the content of PMTU probes to PING and PADDING frames, since packets that are larger than the current maximum datagram size are more likely to be dropped by the network. Loss of a QUIC packet that is carried in a PMTU probe is therefore not a reliable indication of congestion and SHOULD NOT trigger a congestion control reaction; see Item 7 in Section 3 of [DPLPMTUD]. However, PMTU probes consume congestion window, which could delay subsequent transmission by an application. 14.4.1. PMTU Probes Containing Source Connection ID Endpoints that rely on the Destination Connection ID field for routing incoming QUIC packets are likely to require that the connection ID be included in PMTU probes to route any resulting ICMP messages (Section 14.2.1) back to the correct endpoint. However, only long header packets (Section 17.2) contain the Source Connection ID field, and long header packets are not decrypted or acknowledged by the peer once the handshake is complete. One way to construct a PMTU probe is to coalesce (see Section 12.2) a packet with a long header, such as a Handshake or 0-RTT packet (Section 17.2), with a short header packet in a single UDP datagram. If the resulting PMTU probe reaches the endpoint, the packet with the long header will be ignored, but the short header packet will be acknowledged. If the PMTU probe causes an ICMP message to be sent, the first part of the probe will be quoted in that message. If the Source Connection ID field is within the quoted portion of the probe, that could be used for routing or validation of the ICMP message. | Note: The purpose of using a packet with a long header is only | to ensure that the quoted packet contained in the ICMP message | contains a Source Connection ID field. This packet does not | need to be a valid packet, and it can be sent even if there is | no current use for packets of that type. 15. Versions QUIC versions are identified using a 32-bit unsigned number. The version 0x00000000 is reserved to represent version negotiation. This version of the specification is identified by the number 0x00000001. Other versions of QUIC might have different properties from this version. The properties of QUIC that are guaranteed to be consistent across all versions of the protocol are described in [QUIC-INVARIANTS]. Version 0x00000001 of QUIC uses TLS as a cryptographic handshake protocol, as described in [QUIC-TLS]. Versions with the most significant 16 bits of the version number cleared are reserved for use in future IETF consensus documents. Versions that follow the pattern 0x?a?a?a?a are reserved for use in forcing version negotiation to be exercised -- that is, any version number where the low four bits of all bytes is 1010 (in binary). A client or server MAY advertise support for any of these reserved versions. Reserved version numbers will never represent a real protocol; a client MAY use one of these version numbers with the expectation that the server will initiate version negotiation; a server MAY advertise support for one of these versions and can expect that clients ignore the value. 16. Variable-Length Integer Encoding QUIC packets and frames commonly use a variable-length encoding for non-negative integer values. This encoding ensures that smaller integer values need fewer bytes to encode. The QUIC variable-length integer encoding reserves the two most significant bits of the first byte to encode the base-2 logarithm of the integer encoding length in bytes. The integer value is encoded on the remaining bits, in network byte order. This means that integers are encoded on 1, 2, 4, or 8 bytes and can encode 6-, 14-, 30-, or 62-bit values, respectively. Table 4 summarizes the encoding properties. +======+========+=============+=======================+ | 2MSB | Length | Usable Bits | Range | +======+========+=============+=======================+ | 00 | 1 | 6 | 0-63 | +------+--------+-------------+-----------------------+ | 01 | 2 | 14 | 0-16383 | +------+--------+-------------+-----------------------+ | 10 | 4 | 30 | 0-1073741823 | +------+--------+-------------+-----------------------+ | 11 | 8 | 62 | 0-4611686018427387903 | +------+--------+-------------+-----------------------+ Table 4: Summary of Integer Encodings An example of a decoding algorithm and sample encodings are shown in Appendix A.1. Values do not need to be encoded on the minimum number of bytes necessary, with the sole exception of the Frame Type field; see Section 12.4. Versions (Section 15), packet numbers sent in the header (Section 17.1), and the length of connection IDs in long header packets (Section 17.2) are described using integers but do not use this encoding. 17. Packet Formats All numeric values are encoded in network byte order (that is, big endian), and all field sizes are in bits. Hexadecimal notation is used for describing the value of fields. 17.1. Packet Number Encoding and Decoding Packet numbers are integers in the range 0 to 2^62-1 (Section 12.3). When present in long or short packet headers, they are encoded in 1 to 4 bytes. The number of bits required to represent the packet number is reduced by including only the least significant bits of the packet number. The encoded packet number is protected as described in Section 5.4 of [QUIC-TLS]. Prior to receiving an acknowledgment for a packet number space, the full packet number MUST be included; it is not to be truncated, as described below. After an acknowledgment is received for a packet number space, the sender MUST use a packet number size able to represent more than twice as large a range as the difference between the largest acknowledged packet number and the packet number being sent. A peer receiving the packet will then correctly decode the packet number, unless the packet is delayed in transit such that it arrives after many higher-numbered packets have been received. An endpoint SHOULD use a large enough packet number encoding to allow the packet number to be recovered even if the packet arrives after packets that are sent afterwards. As a result, the size of the packet number encoding is at least one bit more than the base-2 logarithm of the number of contiguous unacknowledged packet numbers, including the new packet. Pseudocode and an example for packet number encoding can be found in Appendix A.2. At a receiver, protection of the packet number is removed prior to recovering the full packet number. The full packet number is then reconstructed based on the number of significant bits present, the value of those bits, and the largest packet number received in a successfully authenticated packet. Recovering the full packet number is necessary to successfully complete the removal of packet protection. Once header protection is removed, the packet number is decoded by finding the packet number value that is closest to the next expected packet. The next expected packet is the highest received packet number plus one. Pseudocode and an example for packet number decoding can be found in Appendix A.3. 17.2. Long Header Packets Long Header Packet { Header Form (1) = 1, Fixed Bit (1) = 1, Long Packet Type (2), Type-Specific Bits (4), Version (32), Destination Connection ID Length (8), Destination Connection ID (0..160), Source Connection ID Length (8), Source Connection ID (0..160), Type-Specific Payload (..), } Figure 13: Long Header Packet Format Long headers are used for packets that are sent prior to the establishment of 1-RTT keys. Once 1-RTT keys are available, a sender switches to sending packets using the short header (Section 17.3). The long form allows for special packets -- such as the Version Negotiation packet -- to be represented in this uniform fixed-length packet format. Packets that use the long header contain the following fields: Header Form: The most significant bit (0x80) of byte 0 (the first byte) is set to 1 for long headers. Fixed Bit: The next bit (0x40) of byte 0 is set to 1, unless the packet is a Version Negotiation packet. Packets containing a zero value for this bit are not valid packets in this version and MUST be discarded. A value of 1 for this bit allows QUIC to coexist with other protocols; see [RFC7983]. Long Packet Type: The next two bits (those with a mask of 0x30) of byte 0 contain a packet type. Packet types are listed in Table 5. Type-Specific Bits: The semantics of the lower four bits (those with a mask of 0x0f) of byte 0 are determined by the packet type. Version: The QUIC Version is a 32-bit field that follows the first byte. This field indicates the version of QUIC that is in use and determines how the rest of the protocol fields are interpreted. Destination Connection ID Length: The byte following the version contains the length in bytes of the Destination Connection ID field that follows it. This length is encoded as an 8-bit unsigned integer. In QUIC version 1, this value MUST NOT exceed 20 bytes. Endpoints that receive a version 1 long header with a value larger than 20 MUST drop the packet. In order to properly form a Version Negotiation packet, servers SHOULD be able to read longer connection IDs from other QUIC versions. Destination Connection ID: The Destination Connection ID field follows the Destination Connection ID Length field, which indicates the length of this field. Section 7.2 describes the use of this field in more detail. Source Connection ID Length: The byte following the Destination Connection ID contains the length in bytes of the Source Connection ID field that follows it. This length is encoded as an 8-bit unsigned integer. In QUIC version 1, this value MUST NOT exceed 20 bytes. Endpoints that receive a version 1 long header with a value larger than 20 MUST drop the packet. In order to properly form a Version Negotiation packet, servers SHOULD be able to read longer connection IDs from other QUIC versions. Source Connection ID: The Source Connection ID field follows the Source Connection ID Length field, which indicates the length of this field. Section 7.2 describes the use of this field in more detail. Type-Specific Payload: The remainder of the packet, if any, is type specific. In this version of QUIC, the following packet types with the long header are defined: +======+===========+================+ | Type | Name | Section | +======+===========+================+ | 0x00 | Initial | Section 17.2.2 | +------+-----------+----------------+ | 0x01 | 0-RTT | Section 17.2.3 | +------+-----------+----------------+ | 0x02 | Handshake | Section 17.2.4 | +------+-----------+----------------+ | 0x03 | Retry | Section 17.2.5 | +------+-----------+----------------+ Table 5: Long Header Packet Types The header form bit, Destination and Source Connection ID lengths, Destination and Source Connection ID fields, and Version fields of a long header packet are version independent. The other fields in the first byte are version specific. See [QUIC-INVARIANTS] for details on how packets from different versions of QUIC are interpreted. The interpretation of the fields and the payload are specific to a version and packet type. While type-specific semantics for this version are described in the following sections, several long header packets in this version of QUIC contain these additional fields: Reserved Bits: Two bits (those with a mask of 0x0c) of byte 0 are reserved across multiple packet types. These bits are protected using header protection; see Section 5.4 of [QUIC-TLS]. The value included prior to protection MUST be set to 0. An endpoint MUST treat receipt of a packet that has a non-zero value for these bits after removing both packet and header protection as a connection error of type PROTOCOL_VIOLATION. Discarding such a packet after only removing header protection can expose the endpoint to attacks; see Section 9.5 of [QUIC-TLS]. Packet Number Length: In packet types that contain a Packet Number field, the least significant two bits (those with a mask of 0x03) of byte 0 contain the length of the Packet Number field, encoded as an unsigned two-bit integer that is one less than the length of the Packet Number field in bytes. That is, the length of the Packet Number field is the value of this field plus one. These bits are protected using header protection; see Section 5.4 of [QUIC-TLS]. Length: This is the length of the remainder of the packet (that is, the Packet Number and Payload fields) in bytes, encoded as a variable-length integer (Section 16). Packet Number: This field is 1 to 4 bytes long. The packet number is protected using header protection; see Section 5.4 of [QUIC-TLS]. The length of the Packet Number field is encoded in the Packet Number Length bits of byte 0; see above. Packet Payload: This is the payload of the packet -- containing a sequence of frames -- that is protected using packet protection. 17.2.1. Version Negotiation Packet A Version Negotiation packet is inherently not version specific. Upon receipt by a client, it will be identified as a Version Negotiation packet based on the Version field having a value of 0. The Version Negotiation packet is a response to a client packet that contains a version that is not supported by the server. It is only sent by servers. The layout of a Version Negotiation packet is: Version Negotiation Packet { Header Form (1) = 1, Unused (7), Version (32) = 0, Destination Connection ID Length (8), Destination Connection ID (0..2040), Source Connection ID Length (8), Source Connection ID (0..2040), Supported Version (32) ..., } Figure 14: Version Negotiation Packet The value in the Unused field is set to an arbitrary value by the server. Clients MUST ignore the value of this field. Where QUIC might be multiplexed with other protocols (see [RFC7983]), servers SHOULD set the most significant bit of this field (0x40) to 1 so that Version Negotiation packets appear to have the Fixed Bit field. Note that other versions of QUIC might not make a similar recommendation. The Version field of a Version Negotiation packet MUST be set to 0x00000000. The server MUST include the value from the Source Connection ID field of the packet it receives in the Destination Connection ID field. The value for Source Connection ID MUST be copied from the Destination Connection ID of the received packet, which is initially randomly selected by a client. Echoing both connection IDs gives clients some assurance that the server received the packet and that the Version Negotiation packet was not generated by an entity that did not observe the Initial packet. Future versions of QUIC could have different requirements for the lengths of connection IDs. In particular, connection IDs might have a smaller minimum length or a greater maximum length. Version- specific rules for the connection ID therefore MUST NOT influence a decision about whether to send a Version Negotiation packet. The remainder of the Version Negotiation packet is a list of 32-bit versions that the server supports. A Version Negotiation packet is not acknowledged. It is only sent in response to a packet that indicates an unsupported version; see Section 5.2.2. The Version Negotiation packet does not include the Packet Number and Length fields present in other packets that use the long header form. Consequently, a Version Negotiation packet consumes an entire UDP datagram. A server MUST NOT send more than one Version Negotiation packet in response to a single UDP datagram. See Section 6 for a description of the version negotiation process. 17.2.2. Initial Packet An Initial packet uses long headers with a type value of 0x00. It carries the first CRYPTO frames sent by the client and server to perform key exchange, and it carries ACK frames in either direction. Initial Packet { Header Form (1) = 1, Fixed Bit (1) = 1, Long Packet Type (2) = 0, Reserved Bits (2), Packet Number Length (2), Version (32), Destination Connection ID Length (8), Destination Connection ID (0..160), Source Connection ID Length (8), Source Connection ID (0..160), Token Length (i), Token (..), Length (i), Packet Number (8..32), Packet Payload (8..), } Figure 15: Initial Packet The Initial packet contains a long header as well as the Length and Packet Number fields; see Section 17.2. The first byte contains the Reserved and Packet Number Length bits; see also Section 17.2. Between the Source Connection ID and Length fields, there are two additional fields specific to the Initial packet. Token Length: A variable-length integer specifying the length of the Token field, in bytes. This value is 0 if no token is present. Initial packets sent by the server MUST set the Token Length field to 0; clients that receive an Initial packet with a non-zero Token Length field MUST either discard the packet or generate a connection error of type PROTOCOL_VIOLATION. Token: The value of the token that was previously provided in a Retry packet or NEW_TOKEN frame; see Section 8.1. In order to prevent tampering by version-unaware middleboxes, Initial packets are protected with connection- and version-specific keys (Initial keys) as described in [QUIC-TLS]. This protection does not provide confidentiality or integrity against attackers that can observe packets, but it does prevent attackers that cannot observe packets from spoofing Initial packets. The client and server use the Initial packet type for any packet that contains an initial cryptographic handshake message. This includes all cases where a new packet containing the initial cryptographic message needs to be created, such as the packets sent after receiving a Retry packet; see Section 17.2.5. A server sends its first Initial packet in response to a client Initial. A server MAY send multiple Initial packets. The cryptographic key exchange could require multiple round trips or retransmissions of this data. The payload of an Initial packet includes a CRYPTO frame (or frames) containing a cryptographic handshake message, ACK frames, or both. PING, PADDING, and CONNECTION_CLOSE frames of type 0x1c are also permitted. An endpoint that receives an Initial packet containing other frames can either discard the packet as spurious or treat it as a connection error. The first packet sent by a client always includes a CRYPTO frame that contains the start or all of the first cryptographic handshake message. The first CRYPTO frame sent always begins at an offset of 0; see Section 7. Note that if the server sends a TLS HelloRetryRequest (see Section 4.7 of [QUIC-TLS]), the client will send another series of Initial packets. These Initial packets will continue the cryptographic handshake and will contain CRYPTO frames starting at an offset matching the size of the CRYPTO frames sent in the first flight of Initial packets. 17.2.2.1. Abandoning Initial Packets A client stops both sending and processing Initial packets when it sends its first Handshake packet. A server stops sending and processing Initial packets when it receives its first Handshake packet. Though packets might still be in flight or awaiting acknowledgment, no further Initial packets need to be exchanged beyond this point. Initial packet protection keys are discarded (see Section 4.9.1 of [QUIC-TLS]) along with any loss recovery and congestion control state; see Section 6.4 of [QUIC-RECOVERY]. Any data in CRYPTO frames is discarded -- and no longer retransmitted -- when Initial keys are discarded. 17.2.3. 0-RTT A 0-RTT packet uses long headers with a type value of 0x01, followed by the Length and Packet Number fields; see Section 17.2. The first byte contains the Reserved and Packet Number Length bits; see Section 17.2. A 0-RTT packet is used to carry "early" data from the client to the server as part of the first flight, prior to handshake completion. As part of the TLS handshake, the server can accept or reject this early data. See Section 2.3 of [TLS13] for a discussion of 0-RTT data and its limitations. 0-RTT Packet { Header Form (1) = 1, Fixed Bit (1) = 1, Long Packet Type (2) = 1, Reserved Bits (2), Packet Number Length (2), Version (32), Destination Connection ID Length (8), Destination Connection ID (0..160), Source Connection ID Length (8), Source Connection ID (0..160), Length (i), Packet Number (8..32), Packet Payload (8..), } Figure 16: 0-RTT Packet Packet numbers for 0-RTT protected packets use the same space as 1-RTT protected packets. After a client receives a Retry packet, 0-RTT packets are likely to have been lost or discarded by the server. A client SHOULD attempt to resend data in 0-RTT packets after it sends a new Initial packet. New packet numbers MUST be used for any new packets that are sent; as described in Section 17.2.5.3, reusing packet numbers could compromise packet protection. A client only receives acknowledgments for its 0-RTT packets once the handshake is complete, as defined in Section 4.1.1 of [QUIC-TLS]. A client MUST NOT send 0-RTT packets once it starts processing 1-RTT packets from the server. This means that 0-RTT packets cannot contain any response to frames from 1-RTT packets. For instance, a client cannot send an ACK frame in a 0-RTT packet, because that can only acknowledge a 1-RTT packet. An acknowledgment for a 1-RTT packet MUST be carried in a 1-RTT packet. A server SHOULD treat a violation of remembered limits (Section 7.4.1) as a connection error of an appropriate type (for instance, a FLOW_CONTROL_ERROR for exceeding stream data limits). 17.2.4. Handshake Packet A Handshake packet uses long headers with a type value of 0x02, followed by the Length and Packet Number fields; see Section 17.2. The first byte contains the Reserved and Packet Number Length bits; see Section 17.2. It is used to carry cryptographic handshake messages and acknowledgments from the server and client. Handshake Packet { Header Form (1) = 1, Fixed Bit (1) = 1, Long Packet Type (2) = 2, Reserved Bits (2), Packet Number Length (2), Version (32), Destination Connection ID Length (8), Destination Connection ID (0..160), Source Connection ID Length (8), Source Connection ID (0..160), Length (i), Packet Number (8..32), Packet Payload (8..), } Figure 17: Handshake Protected Packet Once a client has received a Handshake packet from a server, it uses Handshake packets to send subsequent cryptographic handshake messages and acknowledgments to the server. The Destination Connection ID field in a Handshake packet contains a connection ID that is chosen by the recipient of the packet; the Source Connection ID includes the connection ID that the sender of the packet wishes to use; see Section 7.2. Handshake packets have their own packet number space, and thus the first Handshake packet sent by a server contains a packet number of 0. The payload of this packet contains CRYPTO frames and could contain PING, PADDING, or ACK frames. Handshake packets MAY contain CONNECTION_CLOSE frames of type 0x1c. Endpoints MUST treat receipt of Handshake packets with other frames as a connection error of type PROTOCOL_VIOLATION. Like Initial packets (see Section 17.2.2.1), data in CRYPTO frames for Handshake packets is discarded -- and no longer retransmitted -- when Handshake protection keys are discarded. 17.2.5. Retry Packet As shown in Figure 18, a Retry packet uses a long packet header with a type value of 0x03. It carries an address validation token created by the server. It is used by a server that wishes to perform a retry; see Section 8.1. Retry Packet { Header Form (1) = 1, Fixed Bit (1) = 1, Long Packet Type (2) = 3, Unused (4), Version (32), Destination Connection ID Length (8), Destination Connection ID (0..160), Source Connection ID Length (8), Source Connection ID (0..160), Retry Token (..), Retry Integrity Tag (128), } Figure 18: Retry Packet A Retry packet does not contain any protected fields. The value in the Unused field is set to an arbitrary value by the server; a client MUST ignore these bits. In addition to the fields from the long header, it contains these additional fields: Retry Token: An opaque token that the server can use to validate the client's address. Retry Integrity Tag: Defined in Section 5.8 ("Retry Packet Integrity") of [QUIC-TLS]. 17.2.5.1. Sending a Retry Packet The server populates the Destination Connection ID with the connection ID that the client included in the Source Connection ID of the Initial packet. The server includes a connection ID of its choice in the Source Connection ID field. This value MUST NOT be equal to the Destination Connection ID field of the packet sent by the client. A client MUST discard a Retry packet that contains a Source Connection ID field that is identical to the Destination Connection ID field of its Initial packet. The client MUST use the value from the Source Connection ID field of the Retry packet in the Destination Connection ID field of subsequent packets that it sends. A server MAY send Retry packets in response to Initial and 0-RTT packets. A server can either discard or buffer 0-RTT packets that it receives. A server can send multiple Retry packets as it receives Initial or 0-RTT packets. A server MUST NOT send more than one Retry packet in response to a single UDP datagram. 17.2.5.2. Handling a Retry Packet A client MUST accept and process at most one Retry packet for each connection attempt. After the client has received and processed an Initial or Retry packet from the server, it MUST discard any subsequent Retry packets that it receives. Clients MUST discard Retry packets that have a Retry Integrity Tag that cannot be validated; see Section 5.8 of [QUIC-TLS]. This diminishes an attacker's ability to inject a Retry packet and protects against accidental corruption of Retry packets. A client MUST discard a Retry packet with a zero-length Retry Token field. The client responds to a Retry packet with an Initial packet that includes the provided Retry token to continue connection establishment. A client sets the Destination Connection ID field of this Initial packet to the value from the Source Connection ID field in the Retry packet. Changing the Destination Connection ID field also results in a change to the keys used to protect the Initial packet. It also sets the Token field to the token provided in the Retry packet. The client MUST NOT change the Source Connection ID because the server could include the connection ID as part of its token validation logic; see Section 8.1.4. A Retry packet does not include a packet number and cannot be explicitly acknowledged by a client. 17.2.5.3. Continuing a Handshake after Retry Subsequent Initial packets from the client include the connection ID and token values from the Retry packet. The client copies the Source Connection ID field from the Retry packet to the Destination Connection ID field and uses this value until an Initial packet with an updated value is received; see Section 7.2. The value of the Token field is copied to all subsequent Initial packets; see Section 8.1.2. Other than updating the Destination Connection ID and Token fields, the Initial packet sent by the client is subject to the same restrictions as the first Initial packet. A client MUST use the same cryptographic handshake message it included in this packet. A server MAY treat a packet that contains a different cryptographic handshake message as a connection error or discard it. Note that including a Token field reduces the available space for the cryptographic handshake message, which might result in the client needing to send multiple Initial packets. A client MAY attempt 0-RTT after receiving a Retry packet by sending 0-RTT packets to the connection ID provided by the server. A client MUST NOT reset the packet number for any packet number space after processing a Retry packet. In particular, 0-RTT packets contain confidential information that will most likely be retransmitted on receiving a Retry packet. The keys used to protect these new 0-RTT packets will not change as a result of responding to a Retry packet. However, the data sent in these packets could be different than what was sent earlier. Sending these new packets with the same packet number is likely to compromise the packet protection for those packets because the same key and nonce could be used to protect different content. A server MAY abort the connection if it detects that the client reset the packet number. The connection IDs used in Initial and Retry packets exchanged between client and server are copied to the transport parameters and validated as described in Section 7.3. 17.3. Short Header Packets This version of QUIC defines a single packet type that uses the short packet header. 17.3.1. 1-RTT Packet A 1-RTT packet uses a short packet header. It is used after the version and 1-RTT keys are negotiated. 1-RTT Packet { Header Form (1) = 0, Fixed Bit (1) = 1, Spin Bit (1), Reserved Bits (2), Key Phase (1), Packet Number Length (2), Destination Connection ID (0..160), Packet Number (8..32), Packet Payload (8..), } Figure 19: 1-RTT Packet 1-RTT packets contain the following fields: Header Form: The most significant bit (0x80) of byte 0 is set to 0 for the short header. Fixed Bit: The next bit (0x40) of byte 0 is set to 1. Packets containing a zero value for this bit are not valid packets in this version and MUST be discarded. A value of 1 for this bit allows QUIC to coexist with other protocols; see [RFC7983]. Spin Bit: The third most significant bit (0x20) of byte 0 is the latency spin bit, set as described in Section 17.4. Reserved Bits: The next two bits (those with a mask of 0x18) of byte 0 are reserved. These bits are protected using header protection; see Section 5.4 of [QUIC-TLS]. The value included prior to protection MUST be set to 0. An endpoint MUST treat receipt of a packet that has a non-zero value for these bits, after removing both packet and header protection, as a connection error of type PROTOCOL_VIOLATION. Discarding such a packet after only removing header protection can expose the endpoint to attacks; see Section 9.5 of [QUIC-TLS]. Key Phase: The next bit (0x04) of byte 0 indicates the key phase, which allows a recipient of a packet to identify the packet protection keys that are used to protect the packet. See [QUIC-TLS] for details. This bit is protected using header protection; see Section 5.4 of [QUIC-TLS]. Packet Number Length: The least significant two bits (those with a mask of 0x03) of byte 0 contain the length of the Packet Number field, encoded as an unsigned two-bit integer that is one less than the length of the Packet Number field in bytes. That is, the length of the Packet Number field is the value of this field plus one. These bits are protected using header protection; see Section 5.4 of [QUIC-TLS]. Destination Connection ID: The Destination Connection ID is a connection ID that is chosen by the intended recipient of the packet. See Section 5.1 for more details. Packet Number: The Packet Number field is 1 to 4 bytes long. The packet number is protected using header protection; see Section 5.4 of [QUIC-TLS]. The length of the Packet Number field is encoded in Packet Number Length field. See Section 17.1 for details. Packet Payload: 1-RTT packets always include a 1-RTT protected payload. The header form bit and the Destination Connection ID field of a short header packet are version independent. The remaining fields are specific to the selected QUIC version. See [QUIC-INVARIANTS] for details on how packets from different versions of QUIC are interpreted. 17.4. Latency Spin Bit The latency spin bit, which is defined for 1-RTT packets (Section 17.3.1), enables passive latency monitoring from observation points on the network path throughout the duration of a connection. The server reflects the spin value received, while the client "spins" it after one RTT. On-path observers can measure the time between two spin bit toggle events to estimate the end-to-end RTT of a connection. The spin bit is only present in 1-RTT packets, since it is possible to measure the initial RTT of a connection by observing the handshake. Therefore, the spin bit is available after version negotiation and connection establishment are completed. On-path measurement and use of the latency spin bit are further discussed in [QUIC-MANAGEABILITY]. The spin bit is an OPTIONAL feature of this version of QUIC. An endpoint that does not support this feature MUST disable it, as defined below. Each endpoint unilaterally decides if the spin bit is enabled or disabled for a connection. Implementations MUST allow administrators of clients and servers to disable the spin bit either globally or on a per-connection basis. Even when the spin bit is not disabled by the administrator, endpoints MUST disable their use of the spin bit for a random selection of at least one in every 16 network paths, or for one in every 16 connection IDs, in order to ensure that QUIC connections that disable the spin bit are commonly observed on the network. As each endpoint disables the spin bit independently, this ensures that the spin bit signal is disabled on approximately one in eight network paths. When the spin bit is disabled, endpoints MAY set the spin bit to any value and MUST ignore any incoming value. It is RECOMMENDED that endpoints set the spin bit to a random value either chosen independently for each packet or chosen independently for each connection ID. If the spin bit is enabled for the connection, the endpoint maintains a spin value for each network path and sets the spin bit in the packet header to the currently stored value when a 1-RTT packet is sent on that path. The spin value is initialized to 0 in the endpoint for each network path. Each endpoint also remembers the highest packet number seen from its peer on each path. When a server receives a 1-RTT packet that increases the highest packet number seen by the server from the client on a given network path, it sets the spin value for that path to be equal to the spin bit in the received packet. When a client receives a 1-RTT packet that increases the highest packet number seen by the client from the server on a given network path, it sets the spin value for that path to the inverse of the spin bit in the received packet. An endpoint resets the spin value for a network path to 0 when changing the connection ID being used on that network path. 18. Transport Parameter Encoding The extension_data field of the quic_transport_parameters extension defined in [QUIC-TLS] contains the QUIC transport parameters. They are encoded as a sequence of transport parameters, as shown in Figure 20: Transport Parameters { Transport Parameter (..) ..., } Figure 20: Sequence of Transport Parameters Each transport parameter is encoded as an (identifier, length, value) tuple, as shown in Figure 21: Transport Parameter { Transport Parameter ID (i), Transport Parameter Length (i), Transport Parameter Value (..), } Figure 21: Transport Parameter Encoding The Transport Parameter Length field contains the length of the Transport Parameter Value field in bytes. QUIC encodes transport parameters into a sequence of bytes, which is then included in the cryptographic handshake. 18.1. Reserved Transport Parameters Transport parameters with an identifier of the form "31 * N + 27" for integer values of N are reserved to exercise the requirement that unknown transport parameters be ignored. These transport parameters have no semantics and can carry arbitrary values. 18.2. Transport Parameter Definitions This section details the transport parameters defined in this document. Many transport parameters listed here have integer values. Those transport parameters that are identified as integers use a variable- length integer encoding; see Section 16. Transport parameters have a default value of 0 if the transport parameter is absent, unless otherwise stated. The following transport parameters are defined: original_destination_connection_id (0x00): This parameter is the value of the Destination Connection ID field from the first Initial packet sent by the client; see Section 7.3. This transport parameter is only sent by a server. max_idle_timeout (0x01): The maximum idle timeout is a value in milliseconds that is encoded as an integer; see (Section 10.1). Idle timeout is disabled when both endpoints omit this transport parameter or specify a value of 0. stateless_reset_token (0x02): A stateless reset token is used in verifying a stateless reset; see Section 10.3. This parameter is a sequence of 16 bytes. This transport parameter MUST NOT be sent by a client but MAY be sent by a server. A server that does not send this transport parameter cannot use stateless reset (Section 10.3) for the connection ID negotiated during the handshake. max_udp_payload_size (0x03): The maximum UDP payload size parameter is an integer value that limits the size of UDP payloads that the endpoint is willing to receive. UDP datagrams with payloads larger than this limit are not likely to be processed by the receiver. The default for this parameter is the maximum permitted UDP payload of 65527. Values below 1200 are invalid. This limit does act as an additional constraint on datagram size in the same way as the path MTU, but it is a property of the endpoint and not the path; see Section 14. It is expected that this is the space an endpoint dedicates to holding incoming packets. initial_max_data (0x04): The initial maximum data parameter is an integer value that contains the initial value for the maximum amount of data that can be sent on the connection. This is equivalent to sending a MAX_DATA (Section 19.9) for the connection immediately after completing the handshake. initial_max_stream_data_bidi_local (0x05): This parameter is an integer value specifying the initial flow control limit for locally initiated bidirectional streams. This limit applies to newly created bidirectional streams opened by the endpoint that sends the transport parameter. In client transport parameters, this applies to streams with an identifier with the least significant two bits set to 0x00; in server transport parameters, this applies to streams with the least significant two bits set to 0x01. initial_max_stream_data_bidi_remote (0x06): This parameter is an integer value specifying the initial flow control limit for peer- initiated bidirectional streams. This limit applies to newly created bidirectional streams opened by the endpoint that receives the transport parameter. In client transport parameters, this applies to streams with an identifier with the least significant two bits set to 0x01; in server transport parameters, this applies to streams with the least significant two bits set to 0x00. initial_max_stream_data_uni (0x07): This parameter is an integer value specifying the initial flow control limit for unidirectional streams. This limit applies to newly created unidirectional streams opened by the endpoint that receives the transport parameter. In client transport parameters, this applies to streams with an identifier with the least significant two bits set to 0x03; in server transport parameters, this applies to streams with the least significant two bits set to 0x02. initial_max_streams_bidi (0x08): The initial maximum bidirectional streams parameter is an integer value that contains the initial maximum number of bidirectional streams the endpoint that receives this transport parameter is permitted to initiate. If this parameter is absent or zero, the peer cannot open bidirectional streams until a MAX_STREAMS frame is sent. Setting this parameter is equivalent to sending a MAX_STREAMS (Section 19.11) of the corresponding type with the same value. initial_max_streams_uni (0x09): The initial maximum unidirectional streams parameter is an integer value that contains the initial maximum number of unidirectional streams the endpoint that receives this transport parameter is permitted to initiate. If this parameter is absent or zero, the peer cannot open unidirectional streams until a MAX_STREAMS frame is sent. Setting this parameter is equivalent to sending a MAX_STREAMS (Section 19.11) of the corresponding type with the same value. ack_delay_exponent (0x0a): The acknowledgment delay exponent is an integer value indicating an exponent used to decode the ACK Delay field in the ACK frame (Section 19.3). If this value is absent, a default value of 3 is assumed (indicating a multiplier of 8). Values above 20 are invalid. max_ack_delay (0x0b): The maximum acknowledgment delay is an integer value indicating the maximum amount of time in milliseconds by which the endpoint will delay sending acknowledgments. This value SHOULD include the receiver's expected delays in alarms firing. For example, if a receiver sets a timer for 5ms and alarms commonly fire up to 1ms late, then it should send a max_ack_delay of 6ms. If this value is absent, a default of 25 milliseconds is assumed. Values of 2^14 or greater are invalid. disable_active_migration (0x0c): The disable active migration transport parameter is included if the endpoint does not support active connection migration (Section 9) on the address being used during the handshake. An endpoint that receives this transport parameter MUST NOT use a new local address when sending to the address that the peer used during the handshake. This transport parameter does not prohibit connection migration after a client has acted on a preferred_address transport parameter. This parameter is a zero-length value. preferred_address (0x0d): The server's preferred address is used to effect a change in server address at the end of the handshake, as described in Section 9.6. This transport parameter is only sent by a server. Servers MAY choose to only send a preferred address of one address family by sending an all-zero address and port (0.0.0.0:0 or [::]:0) for the other family. IP addresses are encoded in network byte order. The preferred_address transport parameter contains an address and port for both IPv4 and IPv6. The four-byte IPv4 Address field is followed by the associated two-byte IPv4 Port field. This is followed by a 16-byte IPv6 Address field and two-byte IPv6 Port field. After address and port pairs, a Connection ID Length field describes the length of the following Connection ID field. Finally, a 16-byte Stateless Reset Token field includes the stateless reset token associated with the connection ID. The format of this transport parameter is shown in Figure 22 below. The Connection ID field and the Stateless Reset Token field contain an alternative connection ID that has a sequence number of 1; see Section 5.1.1. Having these values sent alongside the preferred address ensures that there will be at least one unused active connection ID when the client initiates migration to the preferred address. The Connection ID and Stateless Reset Token fields of a preferred address are identical in syntax and semantics to the corresponding fields of a NEW_CONNECTION_ID frame (Section 19.15). A server that chooses a zero-length connection ID MUST NOT provide a preferred address. Similarly, a server MUST NOT include a zero- length connection ID in this transport parameter. A client MUST treat a violation of these requirements as a connection error of type TRANSPORT_PARAMETER_ERROR. Preferred Address { IPv4 Address (32), IPv4 Port (16), IPv6 Address (128), IPv6 Port (16), Connection ID Length (8), Connection ID (..), Stateless Reset Token (128), } Figure 22: Preferred Address Format active_connection_id_limit (0x0e): This is an integer value specifying the maximum number of connection IDs from the peer that an endpoint is willing to store. This value includes the connection ID received during the handshake, that received in the preferred_address transport parameter, and those received in NEW_CONNECTION_ID frames. The value of the active_connection_id_limit parameter MUST be at least 2. An endpoint that receives a value less than 2 MUST close the connection with an error of type TRANSPORT_PARAMETER_ERROR. If this transport parameter is absent, a default of 2 is assumed. If an endpoint issues a zero-length connection ID, it will never send a NEW_CONNECTION_ID frame and therefore ignores the active_connection_id_limit value received from its peer. initial_source_connection_id (0x0f): This is the value that the endpoint included in the Source Connection ID field of the first Initial packet it sends for the connection; see Section 7.3. retry_source_connection_id (0x10): This is the value that the server included in the Source Connection ID field of a Retry packet; see Section 7.3. This transport parameter is only sent by a server. If present, transport parameters that set initial per-stream flow control limits (initial_max_stream_data_bidi_local, initial_max_stream_data_bidi_remote, and initial_max_stream_data_uni) are equivalent to sending a MAX_STREAM_DATA frame (Section 19.10) on every stream of the corresponding type immediately after opening. If the transport parameter is absent, streams of that type start with a flow control limit of 0. A client MUST NOT include any server-only transport parameter: original_destination_connection_id, preferred_address, retry_source_connection_id, or stateless_reset_token. A server MUST treat receipt of any of these transport parameters as a connection error of type TRANSPORT_PARAMETER_ERROR. 19. Frame Types and Formats As described in Section 12.4, packets contain one or more frames. This section describes the format and semantics of the core QUIC frame types. 19.1. PADDING Frames A PADDING frame (type=0x00) has no semantic value. PADDING frames can be used to increase the size of a packet. Padding can be used to increase an Initial packet to the minimum required size or to provide protection against traffic analysis for protected packets. PADDING frames are formatted as shown in Figure 23, which shows that PADDING frames have no content. That is, a PADDING frame consists of the single byte that identifies the frame as a PADDING frame. PADDING Frame { Type (i) = 0x00, } Figure 23: PADDING Frame Format 19.2. PING Frames Endpoints can use PING frames (type=0x01) to verify that their peers are still alive or to check reachability to the peer. PING frames are formatted as shown in Figure 24, which shows that PING frames have no content. PING Frame { Type (i) = 0x01, } Figure 24: PING Frame Format The receiver of a PING frame simply needs to acknowledge the packet containing this frame. The PING frame can be used to keep a connection alive when an application or application protocol wishes to prevent the connection from timing out; see Section 10.1.2. 19.3. ACK Frames Receivers send ACK frames (types 0x02 and 0x03) to inform senders of packets they have received and processed. The ACK frame contains one or more ACK Ranges. ACK Ranges identify acknowledged packets. If the frame type is 0x03, ACK frames also contain the cumulative count of QUIC packets with associated ECN marks received on the connection up until this point. QUIC implementations MUST properly handle both types, and, if they have enabled ECN for packets they send, they SHOULD use the information in the ECN section to manage their congestion state. QUIC acknowledgments are irrevocable. Once acknowledged, a packet remains acknowledged, even if it does not appear in a future ACK frame. This is unlike reneging for TCP Selective Acknowledgments (SACKs) [RFC2018]. Packets from different packet number spaces can be identified using the same numeric value. An acknowledgment for a packet needs to indicate both a packet number and a packet number space. This is accomplished by having each ACK frame only acknowledge packet numbers in the same space as the packet in which the ACK frame is contained. Version Negotiation and Retry packets cannot be acknowledged because they do not contain a packet number. Rather than relying on ACK frames, these packets are implicitly acknowledged by the next Initial packet sent by the client. ACK frames are formatted as shown in Figure 25. ACK Frame { Type (i) = 0x02..0x03, Largest Acknowledged (i), ACK Delay (i), ACK Range Count (i), First ACK Range (i), ACK Range (..) ..., [ECN Counts (..)], } Figure 25: ACK Frame Format ACK frames contain the following fields: Largest Acknowledged: A variable-length integer representing the largest packet number the peer is acknowledging; this is usually the largest packet number that the peer has received prior to generating the ACK frame. Unlike the packet number in the QUIC long or short header, the value in an ACK frame is not truncated. ACK Delay: A variable-length integer encoding the acknowledgment delay in microseconds; see Section 13.2.5. It is decoded by multiplying the value in the field by 2 to the power of the ack_delay_exponent transport parameter sent by the sender of the ACK frame; see Section 18.2. Compared to simply expressing the delay as an integer, this encoding allows for a larger range of values within the same number of bytes, at the cost of lower resolution. ACK Range Count: A variable-length integer specifying the number of ACK Range fields in the frame. First ACK Range: A variable-length integer indicating the number of contiguous packets preceding the Largest Acknowledged that are being acknowledged. That is, the smallest packet acknowledged in the range is determined by subtracting the First ACK Range value from the Largest Acknowledged field. ACK Ranges: Contains additional ranges of packets that are alternately not acknowledged (Gap) and acknowledged (ACK Range); see Section 19.3.1. ECN Counts: The three ECN counts; see Section 19.3.2. 19.3.1. ACK Ranges Each ACK Range consists of alternating Gap and ACK Range Length values in descending packet number order. ACK Ranges can be repeated. The number of Gap and ACK Range Length values is determined by the ACK Range Count field; one of each value is present for each value in the ACK Range Count field. ACK Ranges are structured as shown in Figure 26. ACK Range { Gap (i), ACK Range Length (i), } Figure 26: ACK Ranges The fields that form each ACK Range are: Gap: A variable-length integer indicating the number of contiguous unacknowledged packets preceding the packet number one lower than the smallest in the preceding ACK Range. ACK Range Length: A variable-length integer indicating the number of contiguous acknowledged packets preceding the largest packet number, as determined by the preceding Gap. Gap and ACK Range Length values use a relative integer encoding for efficiency. Though each encoded value is positive, the values are subtracted, so that each ACK Range describes progressively lower- numbered packets. Each ACK Range acknowledges a contiguous range of packets by indicating the number of acknowledged packets that precede the largest packet number in that range. A value of 0 indicates that only the largest packet number is acknowledged. Larger ACK Range values indicate a larger range, with corresponding lower values for the smallest packet number in the range. Thus, given a largest packet number for the range, the smallest value is determined by the following formula: smallest = largest - ack_range An ACK Range acknowledges all packets between the smallest packet number and the largest, inclusive. The largest value for an ACK Range is determined by cumulatively subtracting the size of all preceding ACK Range Lengths and Gaps. Each Gap indicates a range of packets that are not being acknowledged. The number of packets in the gap is one higher than the encoded value of the Gap field. The value of the Gap field establishes the largest packet number value for the subsequent ACK Range using the following formula: largest = previous_smallest - gap - 2 If any computed packet number is negative, an endpoint MUST generate a connection error of type FRAME_ENCODING_ERROR. 19.3.2. ECN Counts The ACK frame uses the least significant bit of the type value (that is, type 0x03) to indicate ECN feedback and report receipt of QUIC packets with associated ECN codepoints of ECT(0), ECT(1), or ECN-CE in the packet's IP header. ECN counts are only present when the ACK frame type is 0x03. When present, there are three ECN counts, as shown in Figure 27. ECN Counts { ECT0 Count (i), ECT1 Count (i), ECN-CE Count (i), } Figure 27: ECN Count Format The ECN count fields are: ECT0 Count: A variable-length integer representing the total number of packets received with the ECT(0) codepoint in the packet number space of the ACK frame. ECT1 Count: A variable-length integer representing the total number of packets received with the ECT(1) codepoint in the packet number space of the ACK frame. ECN-CE Count: A variable-length integer representing the total number of packets received with the ECN-CE codepoint in the packet number space of the ACK frame. ECN counts are maintained separately for each packet number space. 19.4. RESET_STREAM Frames An endpoint uses a RESET_STREAM frame (type=0x04) to abruptly terminate the sending part of a stream. After sending a RESET_STREAM, an endpoint ceases transmission and retransmission of STREAM frames on the identified stream. A receiver of RESET_STREAM can discard any data that it already received on that stream. An endpoint that receives a RESET_STREAM frame for a send-only stream MUST terminate the connection with error STREAM_STATE_ERROR. RESET_STREAM frames are formatted as shown in Figure 28. RESET_STREAM Frame { Type (i) = 0x04, Stream ID (i), Application Protocol Error Code (i), Final Size (i), } Figure 28: RESET_STREAM Frame Format RESET_STREAM frames contain the following fields: Stream ID: A variable-length integer encoding of the stream ID of the stream being terminated. Application Protocol Error Code: A variable-length integer containing the application protocol error code (see Section 20.2) that indicates why the stream is being closed. Final Size: A variable-length integer indicating the final size of the stream by the RESET_STREAM sender, in units of bytes; see Section 4.5. 19.5. STOP_SENDING Frames An endpoint uses a STOP_SENDING frame (type=0x05) to communicate that incoming data is being discarded on receipt per application request. STOP_SENDING requests that a peer cease transmission on a stream. A STOP_SENDING frame can be sent for streams in the "Recv" or "Size Known" states; see Section 3.2. Receiving a STOP_SENDING frame for a locally initiated stream that has not yet been created MUST be treated as a connection error of type STREAM_STATE_ERROR. An endpoint that receives a STOP_SENDING frame for a receive-only stream MUST terminate the connection with error STREAM_STATE_ERROR. STOP_SENDING frames are formatted as shown in Figure 29. STOP_SENDING Frame { Type (i) = 0x05, Stream ID (i), Application Protocol Error Code (i), } Figure 29: STOP_SENDING Frame Format STOP_SENDING frames contain the following fields: Stream ID: A variable-length integer carrying the stream ID of the stream being ignored. Application Protocol Error Code: A variable-length integer containing the application-specified reason the sender is ignoring the stream; see Section 20.2. 19.6. CRYPTO Frames A CRYPTO frame (type=0x06) is used to transmit cryptographic handshake messages. It can be sent in all packet types except 0-RTT. The CRYPTO frame offers the cryptographic protocol an in-order stream of bytes. CRYPTO frames are functionally identical to STREAM frames, except that they do not bear a stream identifier; they are not flow controlled; and they do not carry markers for optional offset, optional length, and the end of the stream. CRYPTO frames are formatted as shown in Figure 30. CRYPTO Frame { Type (i) = 0x06, Offset (i), Length (i), Crypto Data (..), } Figure 30: CRYPTO Frame Format CRYPTO frames contain the following fields: Offset: A variable-length integer specifying the byte offset in the stream for the data in this CRYPTO frame. Length: A variable-length integer specifying the length of the Crypto Data field in this CRYPTO frame. Crypto Data: The cryptographic message data. There is a separate flow of cryptographic handshake data in each encryption level, each of which starts at an offset of 0. This implies that each encryption level is treated as a separate CRYPTO stream of data. The largest offset delivered on a stream -- the sum of the offset and data length -- cannot exceed 2^62-1. Receipt of a frame that exceeds this limit MUST be treated as a connection error of type FRAME_ENCODING_ERROR or CRYPTO_BUFFER_EXCEEDED. Unlike STREAM frames, which include a stream ID indicating to which stream the data belongs, the CRYPTO frame carries data for a single stream per encryption level. The stream does not have an explicit end, so CRYPTO frames do not have a FIN bit. 19.7. NEW_TOKEN Frames A server sends a NEW_TOKEN frame (type=0x07) to provide the client with a token to send in the header of an Initial packet for a future connection. NEW_TOKEN frames are formatted as shown in Figure 31. NEW_TOKEN Frame { Type (i) = 0x07, Token Length (i), Token (..), } Figure 31: NEW_TOKEN Frame Format NEW_TOKEN frames contain the following fields: Token Length: A variable-length integer specifying the length of the token in bytes. Token: An opaque blob that the client can use with a future Initial packet. The token MUST NOT be empty. A client MUST treat receipt of a NEW_TOKEN frame with an empty Token field as a connection error of type FRAME_ENCODING_ERROR. A client might receive multiple NEW_TOKEN frames that contain the same token value if packets containing the frame are incorrectly determined to be lost. Clients are responsible for discarding duplicate values, which might be used to link connection attempts; see Section 8.1.3. Clients MUST NOT send NEW_TOKEN frames. A server MUST treat receipt of a NEW_TOKEN frame as a connection error of type PROTOCOL_VIOLATION. 19.8. STREAM Frames STREAM frames implicitly create a stream and carry stream data. The Type field in the STREAM frame takes the form 0b00001XXX (or the set of values from 0x08 to 0x0f). The three low-order bits of the frame type determine the fields that are present in the frame: * The OFF bit (0x04) in the frame type is set to indicate that there is an Offset field present. When set to 1, the Offset field is present. When set to 0, the Offset field is absent and the Stream Data starts at an offset of 0 (that is, the frame contains the first bytes of the stream, or the end of a stream that includes no data). * The LEN bit (0x02) in the frame type is set to indicate that there is a Length field present. If this bit is set to 0, the Length field is absent and the Stream Data field extends to the end of the packet. If this bit is set to 1, the Length field is present. * The FIN bit (0x01) indicates that the frame marks the end of the stream. The final size of the stream is the sum of the offset and the length of this frame. An endpoint MUST terminate the connection with error STREAM_STATE_ERROR if it receives a STREAM frame for a locally initiated stream that has not yet been created, or for a send-only stream. STREAM frames are formatted as shown in Figure 32. STREAM Frame { Type (i) = 0x08..0x0f, Stream ID (i), [Offset (i)], [Length (i)], Stream Data (..), } Figure 32: STREAM Frame Format STREAM frames contain the following fields: Stream ID: A variable-length integer indicating the stream ID of the stream; see Section 2.1. Offset: A variable-length integer specifying the byte offset in the stream for the data in this STREAM frame. This field is present when the OFF bit is set to 1. When the Offset field is absent, the offset is 0. Length: A variable-length integer specifying the length of the Stream Data field in this STREAM frame. This field is present when the LEN bit is set to 1. When the LEN bit is set to 0, the Stream Data field consumes all the remaining bytes in the packet. Stream Data: The bytes from the designated stream to be delivered. When a Stream Data field has a length of 0, the offset in the STREAM frame is the offset of the next byte that would be sent. The first byte in the stream has an offset of 0. The largest offset delivered on a stream -- the sum of the offset and data length -- cannot exceed 2^62-1, as it is not possible to provide flow control credit for that data. Receipt of a frame that exceeds this limit MUST be treated as a connection error of type FRAME_ENCODING_ERROR or FLOW_CONTROL_ERROR. 19.9. MAX_DATA Frames A MAX_DATA frame (type=0x10) is used in flow control to inform the peer of the maximum amount of data that can be sent on the connection as a whole. MAX_DATA frames are formatted as shown in Figure 33. MAX_DATA Frame { Type (i) = 0x10, Maximum Data (i), } Figure 33: MAX_DATA Frame Format MAX_DATA frames contain the following field: Maximum Data: A variable-length integer indicating the maximum amount of data that can be sent on the entire connection, in units of bytes. All data sent in STREAM frames counts toward this limit. The sum of the final sizes on all streams -- including streams in terminal states -- MUST NOT exceed the value advertised by a receiver. An endpoint MUST terminate a connection with an error of type FLOW_CONTROL_ERROR if it receives more data than the maximum data value that it has sent. This includes violations of remembered limits in Early Data; see Section 7.4.1. 19.10. MAX_STREAM_DATA Frames A MAX_STREAM_DATA frame (type=0x11) is used in flow control to inform a peer of the maximum amount of data that can be sent on a stream. A MAX_STREAM_DATA frame can be sent for streams in the "Recv" state; see Section 3.2. Receiving a MAX_STREAM_DATA frame for a locally initiated stream that has not yet been created MUST be treated as a connection error of type STREAM_STATE_ERROR. An endpoint that receives a MAX_STREAM_DATA frame for a receive-only stream MUST terminate the connection with error STREAM_STATE_ERROR. MAX_STREAM_DATA frames are formatted as shown in Figure 34. MAX_STREAM_DATA Frame { Type (i) = 0x11, Stream ID (i), Maximum Stream Data (i), } Figure 34: MAX_STREAM_DATA Frame Format MAX_STREAM_DATA frames contain the following fields: Stream ID: The stream ID of the affected stream, encoded as a variable-length integer. Maximum Stream Data: A variable-length integer indicating the maximum amount of data that can be sent on the identified stream, in units of bytes. When counting data toward this limit, an endpoint accounts for the largest received offset of data that is sent or received on the stream. Loss or reordering can mean that the largest received offset on a stream can be greater than the total size of data received on that stream. Receiving STREAM frames might not increase the largest received offset. The data sent on a stream MUST NOT exceed the largest maximum stream data value advertised by the receiver. An endpoint MUST terminate a connection with an error of type FLOW_CONTROL_ERROR if it receives more data than the largest maximum stream data that it has sent for the affected stream. This includes violations of remembered limits in Early Data; see Section 7.4.1. 19.11. MAX_STREAMS Frames A MAX_STREAMS frame (type=0x12 or 0x13) informs the peer of the cumulative number of streams of a given type it is permitted to open. A MAX_STREAMS frame with a type of 0x12 applies to bidirectional streams, and a MAX_STREAMS frame with a type of 0x13 applies to unidirectional streams. MAX_STREAMS frames are formatted as shown in Figure 35. MAX_STREAMS Frame { Type (i) = 0x12..0x13, Maximum Streams (i), } Figure 35: MAX_STREAMS Frame Format MAX_STREAMS frames contain the following field: Maximum Streams: A count of the cumulative number of streams of the corresponding type that can be opened over the lifetime of the connection. This value cannot exceed 2^60, as it is not possible to encode stream IDs larger than 2^62-1. Receipt of a frame that permits opening of a stream larger than this limit MUST be treated as a connection error of type FRAME_ENCODING_ERROR. Loss or reordering can cause an endpoint to receive a MAX_STREAMS frame with a lower stream limit than was previously received. MAX_STREAMS frames that do not increase the stream limit MUST be ignored. An endpoint MUST NOT open more streams than permitted by the current stream limit set by its peer. For instance, a server that receives a unidirectional stream limit of 3 is permitted to open streams 3, 7, and 11, but not stream 15. An endpoint MUST terminate a connection with an error of type STREAM_LIMIT_ERROR if a peer opens more streams than was permitted. This includes violations of remembered limits in Early Data; see Section 7.4.1. Note that these frames (and the corresponding transport parameters) do not describe the number of streams that can be opened concurrently. The limit includes streams that have been closed as well as those that are open. 19.12. DATA_BLOCKED Frames A sender SHOULD send a DATA_BLOCKED frame (type=0x14) when it wishes to send data but is unable to do so due to connection-level flow control; see Section 4. DATA_BLOCKED frames can be used as input to tuning of flow control algorithms; see Section 4.2. DATA_BLOCKED frames are formatted as shown in Figure 36. DATA_BLOCKED Frame { Type (i) = 0x14, Maximum Data (i), } Figure 36: DATA_BLOCKED Frame Format DATA_BLOCKED frames contain the following field: Maximum Data: A variable-length integer indicating the connection- level limit at which blocking occurred. 19.13. STREAM_DATA_BLOCKED Frames A sender SHOULD send a STREAM_DATA_BLOCKED frame (type=0x15) when it wishes to send data but is unable to do so due to stream-level flow control. This frame is analogous to DATA_BLOCKED (Section 19.12). An endpoint that receives a STREAM_DATA_BLOCKED frame for a send-only stream MUST terminate the connection with error STREAM_STATE_ERROR. STREAM_DATA_BLOCKED frames are formatted as shown in Figure 37. STREAM_DATA_BLOCKED Frame { Type (i) = 0x15, Stream ID (i), Maximum Stream Data (i), } Figure 37: STREAM_DATA_BLOCKED Frame Format STREAM_DATA_BLOCKED frames contain the following fields: Stream ID: A variable-length integer indicating the stream that is blocked due to flow control. Maximum Stream Data: A variable-length integer indicating the offset of the stream at which the blocking occurred. 19.14. STREAMS_BLOCKED Frames A sender SHOULD send a STREAMS_BLOCKED frame (type=0x16 or 0x17) when it wishes to open a stream but is unable to do so due to the maximum stream limit set by its peer; see Section 19.11. A STREAMS_BLOCKED frame of type 0x16 is used to indicate reaching the bidirectional stream limit, and a STREAMS_BLOCKED frame of type 0x17 is used to indicate reaching the unidirectional stream limit. A STREAMS_BLOCKED frame does not open the stream, but informs the peer that a new stream was needed and the stream limit prevented the creation of the stream. STREAMS_BLOCKED frames are formatted as shown in Figure 38. STREAMS_BLOCKED Frame { Type (i) = 0x16..0x17, Maximum Streams (i), } Figure 38: STREAMS_BLOCKED Frame Format STREAMS_BLOCKED frames contain the following field: Maximum Streams: A variable-length integer indicating the maximum number of streams allowed at the time the frame was sent. This value cannot exceed 2^60, as it is not possible to encode stream IDs larger than 2^62-1. Receipt of a frame that encodes a larger stream ID MUST be treated as a connection error of type STREAM_LIMIT_ERROR or FRAME_ENCODING_ERROR. 19.15. NEW_CONNECTION_ID Frames An endpoint sends a NEW_CONNECTION_ID frame (type=0x18) to provide its peer with alternative connection IDs that can be used to break linkability when migrating connections; see Section 9.5. NEW_CONNECTION_ID frames are formatted as shown in Figure 39. NEW_CONNECTION_ID Frame { Type (i) = 0x18, Sequence Number (i), Retire Prior To (i), Length (8), Connection ID (8..160), Stateless Reset Token (128), } Figure 39: NEW_CONNECTION_ID Frame Format NEW_CONNECTION_ID frames contain the following fields: Sequence Number: The sequence number assigned to the connection ID by the sender, encoded as a variable-length integer; see Section 5.1.1. Retire Prior To: A variable-length integer indicating which connection IDs should be retired; see Section 5.1.2. Length: An 8-bit unsigned integer containing the length of the connection ID. Values less than 1 and greater than 20 are invalid and MUST be treated as a connection error of type FRAME_ENCODING_ERROR. Connection ID: A connection ID of the specified length. Stateless Reset Token: A 128-bit value that will be used for a stateless reset when the associated connection ID is used; see Section 10.3. An endpoint MUST NOT send this frame if it currently requires that its peer send packets with a zero-length Destination Connection ID. Changing the length of a connection ID to or from zero length makes it difficult to identify when the value of the connection ID changed. An endpoint that is sending packets with a zero-length Destination Connection ID MUST treat receipt of a NEW_CONNECTION_ID frame as a connection error of type PROTOCOL_VIOLATION. Transmission errors, timeouts, and retransmissions might cause the same NEW_CONNECTION_ID frame to be received multiple times. Receipt of the same frame multiple times MUST NOT be treated as a connection error. A receiver can use the sequence number supplied in the NEW_CONNECTION_ID frame to handle receiving the same NEW_CONNECTION_ID frame multiple times. If an endpoint receives a NEW_CONNECTION_ID frame that repeats a previously issued connection ID with a different Stateless Reset Token field value or a different Sequence Number field value, or if a sequence number is used for different connection IDs, the endpoint MAY treat that receipt as a connection error of type PROTOCOL_VIOLATION. The Retire Prior To field applies to connection IDs established during connection setup and the preferred_address transport parameter; see Section 5.1.2. The value in the Retire Prior To field MUST be less than or equal to the value in the Sequence Number field. Receiving a value in the Retire Prior To field that is greater than that in the Sequence Number field MUST be treated as a connection error of type FRAME_ENCODING_ERROR. Once a sender indicates a Retire Prior To value, smaller values sent in subsequent NEW_CONNECTION_ID frames have no effect. A receiver MUST ignore any Retire Prior To fields that do not increase the largest received Retire Prior To value. An endpoint that receives a NEW_CONNECTION_ID frame with a sequence number smaller than the Retire Prior To field of a previously received NEW_CONNECTION_ID frame MUST send a corresponding RETIRE_CONNECTION_ID frame that retires the newly received connection ID, unless it has already done so for that sequence number. 19.16. RETIRE_CONNECTION_ID Frames An endpoint sends a RETIRE_CONNECTION_ID frame (type=0x19) to indicate that it will no longer use a connection ID that was issued by its peer. This includes the connection ID provided during the handshake. Sending a RETIRE_CONNECTION_ID frame also serves as a request to the peer to send additional connection IDs for future use; see Section 5.1. New connection IDs can be delivered to a peer using the NEW_CONNECTION_ID frame (Section 19.15). Retiring a connection ID invalidates the stateless reset token associated with that connection ID. RETIRE_CONNECTION_ID frames are formatted as shown in Figure 40. RETIRE_CONNECTION_ID Frame { Type (i) = 0x19, Sequence Number (i), } Figure 40: RETIRE_CONNECTION_ID Frame Format RETIRE_CONNECTION_ID frames contain the following field: Sequence Number: The sequence number of the connection ID being retired; see Section 5.1.2. Receipt of a RETIRE_CONNECTION_ID frame containing a sequence number greater than any previously sent to the peer MUST be treated as a connection error of type PROTOCOL_VIOLATION. The sequence number specified in a RETIRE_CONNECTION_ID frame MUST NOT refer to the Destination Connection ID field of the packet in which the frame is contained. The peer MAY treat this as a connection error of type PROTOCOL_VIOLATION. An endpoint cannot send this frame if it was provided with a zero- length connection ID by its peer. An endpoint that provides a zero- length connection ID MUST treat receipt of a RETIRE_CONNECTION_ID frame as a connection error of type PROTOCOL_VIOLATION. 19.17. PATH_CHALLENGE Frames Endpoints can use PATH_CHALLENGE frames (type=0x1a) to check reachability to the peer and for path validation during connection migration. PATH_CHALLENGE frames are formatted as shown in Figure 41. PATH_CHALLENGE Frame { Type (i) = 0x1a, Data (64), } Figure 41: PATH_CHALLENGE Frame Format PATH_CHALLENGE frames contain the following field: Data: This 8-byte field contains arbitrary data. Including 64 bits of entropy in a PATH_CHALLENGE frame ensures that it is easier to receive the packet than it is to guess the value correctly. The recipient of this frame MUST generate a PATH_RESPONSE frame (Section 19.18) containing the same Data value. 19.18. PATH_RESPONSE Frames A PATH_RESPONSE frame (type=0x1b) is sent in response to a PATH_CHALLENGE frame. PATH_RESPONSE frames are formatted as shown in Figure 42. The format of a PATH_RESPONSE frame is identical to that of the PATH_CHALLENGE frame; see Section 19.17. PATH_RESPONSE Frame { Type (i) = 0x1b, Data (64), } Figure 42: PATH_RESPONSE Frame Format If the content of a PATH_RESPONSE frame does not match the content of a PATH_CHALLENGE frame previously sent by the endpoint, the endpoint MAY generate a connection error of type PROTOCOL_VIOLATION. 19.19. CONNECTION_CLOSE Frames An endpoint sends a CONNECTION_CLOSE frame (type=0x1c or 0x1d) to notify its peer that the connection is being closed. The CONNECTION_CLOSE frame with a type of 0x1c is used to signal errors at only the QUIC layer, or the absence of errors (with the NO_ERROR code). The CONNECTION_CLOSE frame with a type of 0x1d is used to signal an error with the application that uses QUIC. If there are open streams that have not been explicitly closed, they are implicitly closed when the connection is closed. CONNECTION_CLOSE frames are formatted as shown in Figure 43. CONNECTION_CLOSE Frame { Type (i) = 0x1c..0x1d, Error Code (i), [Frame Type (i)], Reason Phrase Length (i), Reason Phrase (..), } Figure 43: CONNECTION_CLOSE Frame Format CONNECTION_CLOSE frames contain the following fields: Error Code: A variable-length integer that indicates the reason for closing this connection. A CONNECTION_CLOSE frame of type 0x1c uses codes from the space defined in Section 20.1. A CONNECTION_CLOSE frame of type 0x1d uses codes defined by the application protocol; see Section 20.2. Frame Type: A variable-length integer encoding the type of frame that triggered the error. A value of 0 (equivalent to the mention of the PADDING frame) is used when the frame type is unknown. The application-specific variant of CONNECTION_CLOSE (type 0x1d) does not include this field. Reason Phrase Length: A variable-length integer specifying the length of the reason phrase in bytes. Because a CONNECTION_CLOSE frame cannot be split between packets, any limits on packet size will also limit the space available for a reason phrase. Reason Phrase: Additional diagnostic information for the closure. This can be zero length if the sender chooses not to give details beyond the Error Code value. This SHOULD be a UTF-8 encoded string [RFC3629], though the frame does not carry information, such as language tags, that would aid comprehension by any entity other than the one that created the text. The application-specific variant of CONNECTION_CLOSE (type 0x1d) can only be sent using 0-RTT or 1-RTT packets; see Section 12.5. When an application wishes to abandon a connection during the handshake, an endpoint can send a CONNECTION_CLOSE frame (type 0x1c) with an error code of APPLICATION_ERROR in an Initial or Handshake packet. 19.20. HANDSHAKE_DONE Frames The server uses a HANDSHAKE_DONE frame (type=0x1e) to signal confirmation of the handshake to the client. HANDSHAKE_DONE frames are formatted as shown in Figure 44, which shows that HANDSHAKE_DONE frames have no content. HANDSHAKE_DONE Frame { Type (i) = 0x1e, } Figure 44: HANDSHAKE_DONE Frame Format A HANDSHAKE_DONE frame can only be sent by the server. Servers MUST NOT send a HANDSHAKE_DONE frame before completing the handshake. A server MUST treat receipt of a HANDSHAKE_DONE frame as a connection error of type PROTOCOL_VIOLATION. 19.21. Extension Frames QUIC frames do not use a self-describing encoding. An endpoint therefore needs to understand the syntax of all frames before it can successfully process a packet. This allows for efficient encoding of frames, but it means that an endpoint cannot send a frame of a type that is unknown to its peer. An extension to QUIC that wishes to use a new type of frame MUST first ensure that a peer is able to understand the frame. An endpoint can use a transport parameter to signal its willingness to receive extension frame types. One transport parameter can indicate support for one or more extension frame types. Extensions that modify or replace core protocol functionality (including frame types) will be difficult to combine with other extensions that modify or replace the same functionality unless the behavior of the combination is explicitly defined. Such extensions SHOULD define their interaction with previously defined extensions modifying the same protocol components. Extension frames MUST be congestion controlled and MUST cause an ACK frame to be sent. The exception is extension frames that replace or supplement the ACK frame. Extension frames are not included in flow control unless specified in the extension. An IANA registry is used to manage the assignment of frame types; see Section 22.4. 20. Error Codes QUIC transport error codes and application error codes are 62-bit unsigned integers. 20.1. Transport Error Codes This section lists the defined QUIC transport error codes that can be used in a CONNECTION_CLOSE frame with a type of 0x1c. These errors apply to the entire connection. NO_ERROR (0x00): An endpoint uses this with CONNECTION_CLOSE to signal that the connection is being closed abruptly in the absence of any error. INTERNAL_ERROR (0x01): The endpoint encountered an internal error and cannot continue with the connection. CONNECTION_REFUSED (0x02): The server refused to accept a new connection. FLOW_CONTROL_ERROR (0x03): An endpoint received more data than it permitted in its advertised data limits; see Section 4. STREAM_LIMIT_ERROR (0x04): An endpoint received a frame for a stream identifier that exceeded its advertised stream limit for the corresponding stream type. STREAM_STATE_ERROR (0x05): An endpoint received a frame for a stream that was not in a state that permitted that frame; see Section 3. FINAL_SIZE_ERROR (0x06): (1) An endpoint received a STREAM frame containing data that exceeded the previously established final size, (2) an endpoint received a STREAM frame or a RESET_STREAM frame containing a final size that was lower than the size of stream data that was already received, or (3) an endpoint received a STREAM frame or a RESET_STREAM frame containing a different final size to the one already established. FRAME_ENCODING_ERROR (0x07): An endpoint received a frame that was badly formatted -- for instance, a frame of an unknown type or an ACK frame that has more acknowledgment ranges than the remainder of the packet could carry. TRANSPORT_PARAMETER_ERROR (0x08): An endpoint received transport parameters that were badly formatted, included an invalid value, omitted a mandatory transport parameter, included a forbidden transport parameter, or were otherwise in error. CONNECTION_ID_LIMIT_ERROR (0x09): The number of connection IDs provided by the peer exceeds the advertised active_connection_id_limit. PROTOCOL_VIOLATION (0x0a): An endpoint detected an error with protocol compliance that was not covered by more specific error codes. INVALID_TOKEN (0x0b): A server received a client Initial that contained an invalid Token field. APPLICATION_ERROR (0x0c): The application or application protocol caused the connection to be closed. CRYPTO_BUFFER_EXCEEDED (0x0d): An endpoint has received more data in CRYPTO frames than it can buffer. KEY_UPDATE_ERROR (0x0e): An endpoint detected errors in performing key updates; see Section 6 of [QUIC-TLS]. AEAD_LIMIT_REACHED (0x0f): An endpoint has reached the confidentiality or integrity limit for the AEAD algorithm used by the given connection. NO_VIABLE_PATH (0x10): An endpoint has determined that the network path is incapable of supporting QUIC. An endpoint is unlikely to receive a CONNECTION_CLOSE frame carrying this code except when the path does not support a large enough MTU. CRYPTO_ERROR (0x0100-0x01ff): The cryptographic handshake failed. A range of 256 values is reserved for carrying error codes specific to the cryptographic handshake that is used. Codes for errors occurring when TLS is used for the cryptographic handshake are described in Section 4.8 of [QUIC-TLS]. See Section 22.5 for details on registering new error codes. In defining these error codes, several principles are applied. Error conditions that might require specific action on the part of a recipient are given unique codes. Errors that represent common conditions are given specific codes. Absent either of these conditions, error codes are used to identify a general function of the stack, like flow control or transport parameter handling. Finally, generic errors are provided for conditions where implementations are unable or unwilling to use more specific codes. 20.2. Application Protocol Error Codes The management of application error codes is left to application protocols. Application protocol error codes are used for the RESET_STREAM frame (Section 19.4), the STOP_SENDING frame (Section 19.5), and the CONNECTION_CLOSE frame with a type of 0x1d (Section 19.19). 21. Security Considerations The goal of QUIC is to provide a secure transport connection. Section 21.1 provides an overview of those properties; subsequent sections discuss constraints and caveats regarding these properties, including descriptions of known attacks and countermeasures. 21.1. Overview of Security Properties A complete security analysis of QUIC is outside the scope of this document. This section provides an informal description of the desired security properties as an aid to implementers and to help guide protocol analysis. QUIC assumes the threat model described in [SEC-CONS] and provides protections against many of the attacks that arise from that model. For this purpose, attacks are divided into passive and active attacks. Passive attackers have the ability to read packets from the network, while active attackers also have the ability to write packets into the network. However, a passive attack could involve an attacker with the ability to cause a routing change or other modification in the path taken by packets that comprise a connection. Attackers are additionally categorized as either on-path attackers or off-path attackers. An on-path attacker can read, modify, or remove any packet it observes such that the packet no longer reaches its destination, while an off-path attacker observes the packets but cannot prevent the original packet from reaching its intended destination. Both types of attackers can also transmit arbitrary packets. This definition differs from that of Section 3.5 of [SEC-CONS] in that an off-path attacker is able to observe packets. Properties of the handshake, protected packets, and connection migration are considered separately. 21.1.1. Handshake The QUIC handshake incorporates the TLS 1.3 handshake and inherits the cryptographic properties described in Appendix E.1 of [TLS13]. Many of the security properties of QUIC depend on the TLS handshake providing these properties. Any attack on the TLS handshake could affect QUIC. Any attack on the TLS handshake that compromises the secrecy or uniqueness of session keys, or the authentication of the participating peers, affects other security guarantees provided by QUIC that depend on those keys. For instance, migration (Section 9) depends on the efficacy of confidentiality protections, both for the negotiation of keys using the TLS handshake and for QUIC packet protection, to avoid linkability across network paths. An attack on the integrity of the TLS handshake might allow an attacker to affect the selection of application protocol or QUIC version. In addition to the properties provided by TLS, the QUIC handshake provides some defense against DoS attacks on the handshake. 21.1.1.1. Anti-Amplification Address validation (Section 8) is used to verify that an entity that claims a given address is able to receive packets at that address. Address validation limits amplification attack targets to addresses for which an attacker can observe packets. Prior to address validation, endpoints are limited in what they are able to send. Endpoints cannot send data toward an unvalidated address in excess of three times the data received from that address. | Note: The anti-amplification limit only applies when an | endpoint responds to packets received from an unvalidated | address. The anti-amplification limit does not apply to | clients when establishing a new connection or when initiating | connection migration. 21.1.1.2. Server-Side DoS Computing the server's first flight for a full handshake is potentially expensive, requiring both a signature and a key exchange computation. In order to prevent computational DoS attacks, the Retry packet provides a cheap token exchange mechanism that allows servers to validate a client's IP address prior to doing any expensive computations at the cost of a single round trip. After a successful handshake, servers can issue new tokens to a client, which will allow new connection establishment without incurring this cost. 21.1.1.3. On-Path Handshake Termination An on-path or off-path attacker can force a handshake to fail by replacing or racing Initial packets. Once valid Initial packets have been exchanged, subsequent Handshake packets are protected with the Handshake keys, and an on-path attacker cannot force handshake failure other than by dropping packets to cause endpoints to abandon the attempt. An on-path attacker can also replace the addresses of packets on either side and therefore cause the client or server to have an incorrect view of the remote addresses. Such an attack is indistinguishable from the functions performed by a NAT. 21.1.1.4. Parameter Negotiation The entire handshake is cryptographically protected, with the Initial packets being encrypted with per-version keys and the Handshake and later packets being encrypted with keys derived from the TLS key exchange. Further, parameter negotiation is folded into the TLS transcript and thus provides the same integrity guarantees as ordinary TLS negotiation. An attacker can observe the client's transport parameters (as long as it knows the version-specific salt) but cannot observe the server's transport parameters and cannot influence parameter negotiation. Connection IDs are unencrypted but integrity protected in all packets. This version of QUIC does not incorporate a version negotiation mechanism; implementations of incompatible versions will simply fail to establish a connection. 21.1.2. Protected Packets Packet protection (Section 12.1) applies authenticated encryption to all packets except Version Negotiation packets, though Initial and Retry packets have limited protection due to the use of version- specific keying material; see [QUIC-TLS] for more details. This section considers passive and active attacks against protected packets. Both on-path and off-path attackers can mount a passive attack in which they save observed packets for an offline attack against packet protection at a future time; this is true for any observer of any packet on any network. An attacker that injects packets without being able to observe valid packets for a connection is unlikely to be successful, since packet protection ensures that valid packets are only generated by endpoints that possess the key material established during the handshake; see Sections 7 and 21.1.1. Similarly, any active attacker that observes packets and attempts to insert new data or modify existing data in those packets should not be able to generate packets deemed valid by the receiving endpoint, other than Initial packets. A spoofing attack, in which an active attacker rewrites unprotected parts of a packet that it forwards or injects, such as the source or destination address, is only effective if the attacker can forward packets to the original endpoint. Packet protection ensures that the packet payloads can only be processed by the endpoints that completed the handshake, and invalid packets are ignored by those endpoints. An attacker can also modify the boundaries between packets and UDP datagrams, causing multiple packets to be coalesced into a single datagram or splitting coalesced packets into multiple datagrams. Aside from datagrams containing Initial packets, which require padding, modification of how packets are arranged in datagrams has no functional effect on a connection, although it might change some performance characteristics. 21.1.3. Connection Migration Connection migration (Section 9) provides endpoints with the ability to transition between IP addresses and ports on multiple paths, using one path at a time for transmission and receipt of non-probing frames. Path validation (Section 8.2) establishes that a peer is both willing and able to receive packets sent on a particular path. This helps reduce the effects of address spoofing by limiting the number of packets sent to a spoofed address. This section describes the intended security properties of connection migration under various types of DoS attacks. 21.1.3.1. On-Path Active Attacks An attacker that can cause a packet it observes to no longer reach its intended destination is considered an on-path attacker. When an attacker is present between a client and server, endpoints are required to send packets through the attacker to establish connectivity on a given path. An on-path attacker can: * Inspect packets * Modify IP and UDP packet headers * Inject new packets * Delay packets * Reorder packets * Drop packets * Split and merge datagrams along packet boundaries An on-path attacker cannot: * Modify an authenticated portion of a packet and cause the recipient to accept that packet An on-path attacker has the opportunity to modify the packets that it observes; however, any modifications to an authenticated portion of a packet will cause it to be dropped by the receiving endpoint as invalid, as packet payloads are both authenticated and encrypted. QUIC aims to constrain the capabilities of an on-path attacker as follows: 1. An on-path attacker can prevent the use of a path for a connection, causing the connection to fail if it cannot use a different path that does not contain the attacker. This can be achieved by dropping all packets, modifying them so that they fail to decrypt, or other methods. 2. An on-path attacker can prevent migration to a new path for which the attacker is also on-path by causing path validation to fail on the new path. 3. An on-path attacker cannot prevent a client from migrating to a path for which the attacker is not on-path. 4. An on-path attacker can reduce the throughput of a connection by delaying packets or dropping them. 5. An on-path attacker cannot cause an endpoint to accept a packet for which it has modified an authenticated portion of that packet. 21.1.3.2. Off-Path Active Attacks An off-path attacker is not directly on the path between a client and server but could be able to obtain copies of some or all packets sent between the client and the server. It is also able to send copies of those packets to either endpoint. An off-path attacker can: * Inspect packets * Inject new packets * Reorder injected packets An off-path attacker cannot: * Modify packets sent by endpoints * Delay packets * Drop packets * Reorder original packets An off-path attacker can create modified copies of packets that it has observed and inject those copies into the network, potentially with spoofed source and destination addresses. For the purposes of this discussion, it is assumed that an off-path attacker has the ability to inject a modified copy of a packet into the network that will reach the destination endpoint prior to the arrival of the original packet observed by the attacker. In other words, an attacker has the ability to consistently "win" a race with the legitimate packets between the endpoints, potentially causing the original packet to be ignored by the recipient. It is also assumed that an attacker has the resources necessary to affect NAT state. In particular, an attacker can cause an endpoint to lose its NAT binding and then obtain the same port for use with its own traffic. QUIC aims to constrain the capabilities of an off-path attacker as follows: 1. An off-path attacker can race packets and attempt to become a "limited" on-path attacker. 2. An off-path attacker can cause path validation to succeed for forwarded packets with the source address listed as the off-path attacker as long as it can provide improved connectivity between the client and the server. 3. An off-path attacker cannot cause a connection to close once the handshake has completed. 4. An off-path attacker cannot cause migration to a new path to fail if it cannot observe the new path. 5. An off-path attacker can become a limited on-path attacker during migration to a new path for which it is also an off-path attacker. 6. An off-path attacker can become a limited on-path attacker by affecting shared NAT state such that it sends packets to the server from the same IP address and port that the client originally used. 21.1.3.3. Limited On-Path Active Attacks A limited on-path attacker is an off-path attacker that has offered improved routing of packets by duplicating and forwarding original packets between the server and the client, causing those packets to arrive before the original copies such that the original packets are dropped by the destination endpoint. A limited on-path attacker differs from an on-path attacker in that it is not on the original path between endpoints, and therefore the original packets sent by an endpoint are still reaching their destination. This means that a future failure to route copied packets to the destination faster than their original path will not prevent the original packets from reaching the destination. A limited on-path attacker can: * Inspect packets * Inject new packets * Modify unencrypted packet headers * Reorder packets A limited on-path attacker cannot: * Delay packets so that they arrive later than packets sent on the original path * Drop packets * Modify the authenticated and encrypted portion of a packet and cause the recipient to accept that packet A limited on-path attacker can only delay packets up to the point that the original packets arrive before the duplicate packets, meaning that it cannot offer routing with worse latency than the original path. If a limited on-path attacker drops packets, the original copy will still arrive at the destination endpoint. QUIC aims to constrain the capabilities of a limited off-path attacker as follows: 1. A limited on-path attacker cannot cause a connection to close once the handshake has completed. 2. A limited on-path attacker cannot cause an idle connection to close if the client is first to resume activity. 3. A limited on-path attacker can cause an idle connection to be deemed lost if the server is the first to resume activity. Note that these guarantees are the same guarantees provided for any NAT, for the same reasons. 21.2. Handshake Denial of Service As an encrypted and authenticated transport, QUIC provides a range of protections against denial of service. Once the cryptographic handshake is complete, QUIC endpoints discard most packets that are not authenticated, greatly limiting the ability of an attacker to interfere with existing connections. Once a connection is established, QUIC endpoints might accept some unauthenticated ICMP packets (see Section 14.2.1), but the use of these packets is extremely limited. The only other type of packet that an endpoint might accept is a stateless reset (Section 10.3), which relies on the token being kept secret until it is used. During the creation of a connection, QUIC only provides protection against attacks from off the network path. All QUIC packets contain proof that the recipient saw a preceding packet from its peer. Addresses cannot change during the handshake, so endpoints can discard packets that are received on a different network path. The Source and Destination Connection ID fields are the primary means of protection against an off-path attack during the handshake; see Section 8.1. These are required to match those set by a peer. Except for Initial and Stateless Resets, an endpoint only accepts packets that include a Destination Connection ID field that matches a value the endpoint previously chose. This is the only protection offered for Version Negotiation packets. The Destination Connection ID field in an Initial packet is selected by a client to be unpredictable, which serves an additional purpose. The packets that carry the cryptographic handshake are protected with a key that is derived from this connection ID and a salt specific to the QUIC version. This allows endpoints to use the same process for authenticating packets that they receive as they use after the cryptographic handshake completes. Packets that cannot be authenticated are discarded. Protecting packets in this fashion provides a strong assurance that the sender of the packet saw the Initial packet and understood it. These protections are not intended to be effective against an attacker that is able to receive QUIC packets prior to the connection being established. Such an attacker can potentially send packets that will be accepted by QUIC endpoints. This version of QUIC attempts to detect this sort of attack, but it expects that endpoints will fail to establish a connection rather than recovering. For the most part, the cryptographic handshake protocol [QUIC-TLS] is responsible for detecting tampering during the handshake. Endpoints are permitted to use other methods to detect and attempt to recover from interference with the handshake. Invalid packets can be identified and discarded using other methods, but no specific method is mandated in this document. 21.3. Amplification Attack An attacker might be able to receive an address validation token (Section 8) from a server and then release the IP address it used to acquire that token. At a later time, the attacker can initiate a 0-RTT connection with a server by spoofing this same address, which might now address a different (victim) endpoint. The attacker can thus potentially cause the server to send an initial congestion window's worth of data towards the victim. Servers SHOULD provide mitigations for this attack by limiting the usage and lifetime of address validation tokens; see Section 8.1.3. 21.4. Optimistic ACK Attack An endpoint that acknowledges packets it has not received might cause a congestion controller to permit sending at rates beyond what the network supports. An endpoint MAY skip packet numbers when sending packets to detect this behavior. An endpoint can then immediately close the connection with a connection error of type PROTOCOL_VIOLATION; see Section 10.2. 21.5. Request Forgery Attacks A request forgery attack occurs where an endpoint causes its peer to issue a request towards a victim, with the request controlled by the endpoint. Request forgery attacks aim to provide an attacker with access to capabilities of its peer that might otherwise be unavailable to the attacker. For a networking protocol, a request forgery attack is often used to exploit any implicit authorization conferred on the peer by the victim due to the peer's location in the network. For request forgery to be effective, an attacker needs to be able to influence what packets the peer sends and where these packets are sent. If an attacker can target a vulnerable service with a controlled payload, that service might perform actions that are attributed to the attacker's peer but are decided by the attacker. For example, cross-site request forgery [CSRF] exploits on the Web cause a client to issue requests that include authorization cookies [COOKIE], allowing one site access to information and actions that are intended to be restricted to a different site. As QUIC runs over UDP, the primary attack modality of concern is one where an attacker can select the address to which its peer sends UDP datagrams and can control some of the unprotected content of those packets. As much of the data sent by QUIC endpoints is protected, this includes control over ciphertext. An attack is successful if an attacker can cause a peer to send a UDP datagram to a host that will perform some action based on content in the datagram. This section discusses ways in which QUIC might be used for request forgery attacks. This section also describes limited countermeasures that can be implemented by QUIC endpoints. These mitigations can be employed unilaterally by a QUIC implementation or deployment, without potential targets for request forgery attacks taking action. However, these countermeasures could be insufficient if UDP-based services do not properly authorize requests. Because the migration attack described in Section 21.5.4 is quite powerful and does not have adequate countermeasures, QUIC server implementations should assume that attackers can cause them to generate arbitrary UDP payloads to arbitrary destinations. QUIC servers SHOULD NOT be deployed in networks that do not deploy ingress filtering [BCP38] and also have inadequately secured UDP endpoints. Although it is not generally possible to ensure that clients are not co-located with vulnerable endpoints, this version of QUIC does not allow servers to migrate, thus preventing spoofed migration attacks on clients. Any future extension that allows server migration MUST also define countermeasures for forgery attacks. 21.5.1. Control Options for Endpoints QUIC offers some opportunities for an attacker to influence or control where its peer sends UDP datagrams: * initial connection establishment (Section 7), where a server is able to choose where a client sends datagrams -- for example, by populating DNS records; * preferred addresses (Section 9.6), where a server is able to choose where a client sends datagrams; * spoofed connection migrations (Section 9.3.1), where a client is able to use source address spoofing to select where a server sends subsequent datagrams; and * spoofed packets that cause a server to send a Version Negotiation packet (Section 21.5.5). In all cases, the attacker can cause its peer to send datagrams to a victim that might not understand QUIC. That is, these packets are sent by the peer prior to address validation; see Section 8. Outside of the encrypted portion of packets, QUIC offers an endpoint several options for controlling the content of UDP datagrams that its peer sends. The Destination Connection ID field offers direct control over bytes that appear early in packets sent by the peer; see Section 5.1. The Token field in Initial packets offers a server control over other bytes of Initial packets; see Section 17.2.2. There are no measures in this version of QUIC to prevent indirect control over the encrypted portions of packets. It is necessary to assume that endpoints are able to control the contents of frames that a peer sends, especially those frames that convey application data, such as STREAM frames. Though this depends to some degree on details of the application protocol, some control is possible in many protocol usage contexts. As the attacker has access to packet protection keys, they are likely to be capable of predicting how a peer will encrypt future packets. Successful control over datagram content then only requires that the attacker be able to predict the packet number and placement of frames in packets with some amount of reliability. This section assumes that limiting control over datagram content is not feasible. The focus of the mitigations in subsequent sections is on limiting the ways in which datagrams that are sent prior to address validation can be used for request forgery. 21.5.2. Request Forgery with Client Initial Packets An attacker acting as a server can choose the IP address and port on which it advertises its availability, so Initial packets from clients are assumed to be available for use in this sort of attack. The address validation implicit in the handshake ensures that -- for a new connection -- a client will not send other types of packets to a destination that does not understand QUIC or is not willing to accept a QUIC connection. Initial packet protection (Section 5.2 of [QUIC-TLS]) makes it difficult for servers to control the content of Initial packets sent by clients. A client choosing an unpredictable Destination Connection ID ensures that servers are unable to control any of the encrypted portion of Initial packets from clients. However, the Token field is open to server control and does allow a server to use clients to mount request forgery attacks. The use of tokens provided with the NEW_TOKEN frame (Section 8.1.3) offers the only option for request forgery during connection establishment. Clients, however, are not obligated to use the NEW_TOKEN frame. Request forgery attacks that rely on the Token field can be avoided if clients send an empty Token field when the server address has changed from when the NEW_TOKEN frame was received. Clients could avoid using NEW_TOKEN if the server address changes. However, not including a Token field could adversely affect performance. Servers could rely on NEW_TOKEN to enable the sending of data in excess of the three-times limit on sending data; see Section 8.1. In particular, this affects cases where clients use 0-RTT to request data from servers. Sending a Retry packet (Section 17.2.5) offers a server the option to change the Token field. After sending a Retry, the server can also control the Destination Connection ID field of subsequent Initial packets from the client. This also might allow indirect control over the encrypted content of Initial packets. However, the exchange of a Retry packet validates the server's address, thereby preventing the use of subsequent Initial packets for request forgery. 21.5.3. Request Forgery with Preferred Addresses Servers can specify a preferred address, which clients then migrate to after confirming the handshake; see Section 9.6. The Destination Connection ID field of packets that the client sends to a preferred address can be used for request forgery. A client MUST NOT send non-probing frames to a preferred address prior to validating that address; see Section 8. This greatly reduces the options that a server has to control the encrypted portion of datagrams. This document does not offer any additional countermeasures that are specific to the use of preferred addresses and can be implemented by endpoints. The generic measures described in Section 21.5.6 could be used as further mitigation. 21.5.4. Request Forgery with Spoofed Migration Clients are able to present a spoofed source address as part of an apparent connection migration to cause a server to send datagrams to that address. The Destination Connection ID field in any packets that a server subsequently sends to this spoofed address can be used for request forgery. A client might also be able to influence the ciphertext. A server that only sends probing packets (Section 9.1) to an address prior to address validation provides an attacker with only limited control over the encrypted portion of datagrams. However, particularly for NAT rebinding, this can adversely affect performance. If the server sends frames carrying application data, an attacker might be able to control most of the content of datagrams. This document does not offer specific countermeasures that can be implemented by endpoints, aside from the generic measures described in Section 21.5.6. However, countermeasures for address spoofing at the network level -- in particular, ingress filtering [BCP38] -- are especially effective against attacks that use spoofing and originate from an external network. 21.5.5. Request Forgery with Version Negotiation Clients that are able to present a spoofed source address on a packet can cause a server to send a Version Negotiation packet (Section 17.2.1) to that address. The absence of size restrictions on the connection ID fields for packets of an unknown version increases the amount of data that the client controls from the resulting datagram. The first byte of this packet is not under client control and the next four bytes are zero, but the client is able to control up to 512 bytes starting from the fifth byte. No specific countermeasures are provided for this attack, though generic protections (Section 21.5.6) could apply. In this case, ingress filtering [BCP38] is also effective. 21.5.6. Generic Request Forgery Countermeasures The most effective defense against request forgery attacks is to modify vulnerable services to use strong authentication. However, this is not always something that is within the control of a QUIC deployment. This section outlines some other steps that QUIC endpoints could take unilaterally. These additional steps are all discretionary because, depending on circumstances, they could interfere with or prevent legitimate uses. Services offered over loopback interfaces often lack proper authentication. Endpoints MAY prevent connection attempts or migration to a loopback address. Endpoints SHOULD NOT allow connections or migration to a loopback address if the same service was previously available at a different interface or if the address was provided by a service at a non-loopback address. Endpoints that depend on these capabilities could offer an option to disable these protections. Similarly, endpoints could regard a change in address to a link-local address [RFC4291] or an address in a private-use range [RFC1918] from a global, unique-local [RFC4193], or non-private address as a potential attempt at request forgery. Endpoints could refuse to use these addresses entirely, but that carries a significant risk of interfering with legitimate uses. Endpoints SHOULD NOT refuse to use an address unless they have specific knowledge about the network indicating that sending datagrams to unvalidated addresses in a given range is not safe. Endpoints MAY choose to reduce the risk of request forgery by not including values from NEW_TOKEN frames in Initial packets or by only sending probing frames in packets prior to completing address validation. Note that this does not prevent an attacker from using the Destination Connection ID field for an attack. Endpoints are not expected to have specific information about the location of servers that could be vulnerable targets of a request forgery attack. However, it might be possible over time to identify specific UDP ports that are common targets of attacks or particular patterns in datagrams that are used for attacks. Endpoints MAY choose to avoid sending datagrams to these ports or not send datagrams that match these patterns prior to validating the destination address. Endpoints MAY retire connection IDs containing patterns known to be problematic without using them. | Note: Modifying endpoints to apply these protections is more | efficient than deploying network-based protections, as | endpoints do not need to perform any additional processing when | sending to an address that has been validated. 21.6. Slowloris Attacks The attacks commonly known as Slowloris [SLOWLORIS] try to keep many connections to the target endpoint open and hold them open as long as possible. These attacks can be executed against a QUIC endpoint by generating the minimum amount of activity necessary to avoid being closed for inactivity. This might involve sending small amounts of data, gradually opening flow control windows in order to control the sender rate, or manufacturing ACK frames that simulate a high loss rate. QUIC deployments SHOULD provide mitigations for the Slowloris attacks, such as increasing the maximum number of clients the server will allow, limiting the number of connections a single IP address is allowed to make, imposing restrictions on the minimum transfer speed a connection is allowed to have, and restricting the length of time an endpoint is allowed to stay connected. 21.7. Stream Fragmentation and Reassembly Attacks An adversarial sender might intentionally not send portions of the stream data, causing the receiver to commit resources for the unsent data. This could cause a disproportionate receive buffer memory commitment and/or the creation of a large and inefficient data structure at the receiver. An adversarial receiver might intentionally not acknowledge packets containing stream data in an attempt to force the sender to store the unacknowledged stream data for retransmission. The attack on receivers is mitigated if flow control windows correspond to available memory. However, some receivers will overcommit memory and advertise flow control offsets in the aggregate that exceed actual available memory. The overcommitment strategy can lead to better performance when endpoints are well behaved, but renders endpoints vulnerable to the stream fragmentation attack. QUIC deployments SHOULD provide mitigations for stream fragmentation attacks. Mitigations could consist of avoiding overcommitting memory, limiting the size of tracking data structures, delaying reassembly of STREAM frames, implementing heuristics based on the age and duration of reassembly holes, or some combination of these. 21.8. Stream Commitment Attack An adversarial endpoint can open a large number of streams, exhausting state on an endpoint. The adversarial endpoint could repeat the process on a large number of connections, in a manner similar to SYN flooding attacks in TCP. Normally, clients will open streams sequentially, as explained in Section 2.1. However, when several streams are initiated at short intervals, loss or reordering can cause STREAM frames that open streams to be received out of sequence. On receiving a higher- numbered stream ID, a receiver is required to open all intervening streams of the same type; see Section 3.2. Thus, on a new connection, opening stream 4000000 opens 1 million and 1 client- initiated bidirectional streams. The number of active streams is limited by the initial_max_streams_bidi and initial_max_streams_uni transport parameters as updated by any received MAX_STREAMS frames, as explained in Section 4.6. If chosen judiciously, these limits mitigate the effect of the stream commitment attack. However, setting the limit too low could affect performance when applications expect to open a large number of streams. 21.9. Peer Denial of Service QUIC and TLS both contain frames or messages that have legitimate uses in some contexts, but these frames or messages can be abused to cause a peer to expend processing resources without having any observable impact on the state of the connection. Messages can also be used to change and revert state in small or inconsequential ways, such as by sending small increments to flow control limits. If processing costs are disproportionately large in comparison to bandwidth consumption or effect on state, then this could allow a malicious peer to exhaust processing capacity. While there are legitimate uses for all messages, implementations SHOULD track cost of processing relative to progress and treat excessive quantities of any non-productive packets as indicative of an attack. Endpoints MAY respond to this condition with a connection error or by dropping packets. 21.10. Explicit Congestion Notification Attacks An on-path attacker could manipulate the value of ECN fields in the IP header to influence the sender's rate. [RFC3168] discusses manipulations and their effects in more detail. A limited on-path attacker can duplicate and send packets with modified ECN fields to affect the sender's rate. If duplicate packets are discarded by a receiver, an attacker will need to race the duplicate packet against the original to be successful in this attack. Therefore, QUIC endpoints ignore the ECN field in an IP packet unless at least one QUIC packet in that IP packet is successfully processed; see Section 13.4. 21.11. Stateless Reset Oracle Stateless resets create a possible denial-of-service attack analogous to a TCP reset injection. This attack is possible if an attacker is able to cause a stateless reset token to be generated for a connection with a selected connection ID. An attacker that can cause this token to be generated can reset an active connection with the same connection ID. If a packet can be routed to different instances that share a static key -- for example, by changing an IP address or port -- then an attacker can cause the server to send a stateless reset. To defend against this style of denial of service, endpoints that share a static key for stateless resets (see Section 10.3.2) MUST be arranged so that packets with a given connection ID always arrive at an instance that has connection state, unless that connection is no longer active. More generally, servers MUST NOT generate a stateless reset if a connection with the corresponding connection ID could be active on any endpoint using the same static key. In the case of a cluster that uses dynamic load balancing, it is possible that a change in load-balancer configuration could occur while an active instance retains connection state. Even if an instance retains connection state, the change in routing and resulting stateless reset will result in the connection being terminated. If there is no chance of the packet being routed to the correct instance, it is better to send a stateless reset than wait for the connection to time out. However, this is acceptable only if the routing cannot be influenced by an attacker. 21.12. Version Downgrade This document defines QUIC Version Negotiation packets (Section 6), which can be used to negotiate the QUIC version used between two endpoints. However, this document does not specify how this negotiation will be performed between this version and subsequent future versions. In particular, Version Negotiation packets do not contain any mechanism to prevent version downgrade attacks. Future versions of QUIC that use Version Negotiation packets MUST define a mechanism that is robust against version downgrade attacks. 21.13. Targeted Attacks by Routing Deployments should limit the ability of an attacker to target a new connection to a particular server instance. Ideally, routing decisions are made independently of client-selected values, including addresses. Once an instance is selected, a connection ID can be selected so that later packets are routed to the same instance. 21.14. Traffic Analysis The length of QUIC packets can reveal information about the length of the content of those packets. The PADDING frame is provided so that endpoints have some ability to obscure the length of packet content; see Section 19.1. Defeating traffic analysis is challenging and the subject of active research. Length is not the only way that information might leak. Endpoints might also reveal sensitive information through other side channels, such as the timing of packets. 22. IANA Considerations This document establishes several registries for the management of codepoints in QUIC. These registries operate on a common set of policies as defined in Section 22.1. 22.1. Registration Policies for QUIC Registries All QUIC registries allow for both provisional and permanent registration of codepoints. This section documents policies that are common to these registries. 22.1.1. Provisional Registrations Provisional registrations of codepoints are intended to allow for private use and experimentation with extensions to QUIC. Provisional registrations only require the inclusion of the codepoint value and contact information. However, provisional registrations could be reclaimed and reassigned for another purpose. Provisional registrations require Expert Review, as defined in Section 4.5 of [RFC8126]. The designated expert or experts are advised that only registrations for an excessive proportion of remaining codepoint space or the very first unassigned value (see Section 22.1.2) can be rejected. Provisional registrations will include a Date field that indicates when the registration was last updated. A request to update the date on any provisional registration can be made without review from the designated expert(s). All QUIC registries include the following fields to support provisional registration: Value: The assigned codepoint. Status: "permanent" or "provisional". Specification: A reference to a publicly available specification for the value. Date: The date of the last update to the registration. Change Controller: The entity that is responsible for the definition of the registration. Contact: Contact details for the registrant. Notes: Supplementary notes about the registration. Provisional registrations MAY omit the Specification and Notes fields, plus any additional fields that might be required for a permanent registration. The Date field is not required as part of requesting a registration, as it is set to the date the registration is created or updated. 22.1.2. Selecting Codepoints New requests for codepoints from QUIC registries SHOULD use a randomly selected codepoint that excludes both existing allocations and the first unallocated codepoint in the selected space. Requests for multiple codepoints MAY use a contiguous range. This minimizes the risk that differing semantics are attributed to the same codepoint by different implementations. The use of the first unassigned codepoint is reserved for allocation using the Standards Action policy; see Section 4.9 of [RFC8126]. The early codepoint assignment process [EARLY-ASSIGN] can be used for these values. For codepoints that are encoded in variable-length integers (Section 16), such as frame types, codepoints that encode to four or eight bytes (that is, values 2^14 and above) SHOULD be used unless the usage is especially sensitive to having a longer encoding. Applications to register codepoints in QUIC registries MAY include a requested codepoint as part of the registration. IANA MUST allocate the selected codepoint if the codepoint is unassigned and the requirements of the registration policy are met. 22.1.3. Reclaiming Provisional Codepoints A request might be made to remove an unused provisional registration from the registry to reclaim space in a registry, or a portion of the registry (such as the 64-16383 range for codepoints that use variable-length encodings). This SHOULD be done only for the codepoints with the earliest recorded date, and entries that have been updated less than a year prior SHOULD NOT be reclaimed. A request to remove a codepoint MUST be reviewed by the designated experts. The experts MUST attempt to determine whether the codepoint is still in use. Experts are advised to contact the listed contacts for the registration, plus as wide a set of protocol implementers as possible in order to determine whether any use of the codepoint is known. The experts are also advised to allow at least four weeks for responses. If any use of the codepoints is identified by this search or a request to update the registration is made, the codepoint MUST NOT be reclaimed. Instead, the date on the registration is updated. A note might be added for the registration recording relevant information that was learned. If no use of the codepoint was identified and no request was made to update the registration, the codepoint MAY be removed from the registry. This review and consultation process also applies to requests to change a provisional registration into a permanent registration, except that the goal is not to determine whether there is no use of the codepoint but to determine that the registration is an accurate representation of any deployed usage. 22.1.4. Permanent Registrations Permanent registrations in QUIC registries use the Specification Required policy (Section 4.6 of [RFC8126]), unless otherwise specified. The designated expert or experts verify that a specification exists and is readily accessible. Experts are encouraged to be biased towards approving registrations unless they are abusive, frivolous, or actively harmful (not merely aesthetically displeasing or architecturally dubious). The creation of a registry MAY specify additional constraints on permanent registrations. The creation of a registry MAY identify a range of codepoints where registrations are governed by a different registration policy. For instance, the "QUIC Frame Types" registry (Section 22.4) has a stricter policy for codepoints in the range from 0 to 63. Any stricter requirements for permanent registrations do not prevent provisional registrations for affected codepoints. For instance, a provisional registration for a frame type of 61 could be requested. All registrations made by Standards Track publications MUST be permanent. All registrations in this document are assigned a permanent status and list a change controller of the IETF and a contact of the QUIC Working Group (quic@ietf.org). 22.2. QUIC Versions Registry IANA has added a registry for "QUIC Versions" under a "QUIC" heading. The "QUIC Versions" registry governs a 32-bit space; see Section 15. This registry follows the registration policy from Section 22.1. Permanent registrations in this registry are assigned using the Specification Required policy (Section 4.6 of [RFC8126]). The codepoint of 0x00000001 for the protocol is assigned with permanent status to the protocol defined in this document. The codepoint of 0x00000000 is permanently reserved; the note for this codepoint indicates that this version is reserved for version negotiation. All codepoints that follow the pattern 0x?a?a?a?a are reserved, MUST NOT be assigned by IANA, and MUST NOT appear in the listing of assigned values. 22.3. QUIC Transport Parameters Registry IANA has added a registry for "QUIC Transport Parameters" under a "QUIC" heading. The "QUIC Transport Parameters" registry governs a 62-bit space. This registry follows the registration policy from Section 22.1. Permanent registrations in this registry are assigned using the Specification Required policy (Section 4.6 of [RFC8126]), except for values between 0x00 and 0x3f (in hexadecimal), inclusive, which are assigned using Standards Action or IESG Approval as defined in Sections 4.9 and 4.10 of [RFC8126]. In addition to the fields listed in Section 22.1.1, permanent registrations in this registry MUST include the following field: Parameter Name: A short mnemonic for the parameter. The initial contents of this registry are shown in Table 6. +=======+=====================================+===============+ | Value | Parameter Name | Specification | +=======+=====================================+===============+ | 0x00 | original_destination_connection_id | Section 18.2 | +-------+-------------------------------------+---------------+ | 0x01 | max_idle_timeout | Section 18.2 | +-------+-------------------------------------+---------------+ | 0x02 | stateless_reset_token | Section 18.2 | +-------+-------------------------------------+---------------+ | 0x03 | max_udp_payload_size | Section 18.2 | +-------+-------------------------------------+---------------+ | 0x04 | initial_max_data | Section 18.2 | +-------+-------------------------------------+---------------+ | 0x05 | initial_max_stream_data_bidi_local | Section 18.2 | +-------+-------------------------------------+---------------+ | 0x06 | initial_max_stream_data_bidi_remote | Section 18.2 | +-------+-------------------------------------+---------------+ | 0x07 | initial_max_stream_data_uni | Section 18.2 | +-------+-------------------------------------+---------------+ | 0x08 | initial_max_streams_bidi | Section 18.2 | +-------+-------------------------------------+---------------+ | 0x09 | initial_max_streams_uni | Section 18.2 | +-------+-------------------------------------+---------------+ | 0x0a | ack_delay_exponent | Section 18.2 | +-------+-------------------------------------+---------------+ | 0x0b | max_ack_delay | Section 18.2 | +-------+-------------------------------------+---------------+ | 0x0c | disable_active_migration | Section 18.2 | +-------+-------------------------------------+---------------+ | 0x0d | preferred_address | Section 18.2 | +-------+-------------------------------------+---------------+ | 0x0e | active_connection_id_limit | Section 18.2 | +-------+-------------------------------------+---------------+ | 0x0f | initial_source_connection_id | Section 18.2 | +-------+-------------------------------------+---------------+ | 0x10 | retry_source_connection_id | Section 18.2 | +-------+-------------------------------------+---------------+ Table 6: Initial QUIC Transport Parameters Registry Entries Each value of the form "31 * N + 27" for integer values of N (that is, 27, 58, 89, ...) are reserved; these values MUST NOT be assigned by IANA and MUST NOT appear in the listing of assigned values. 22.4. QUIC Frame Types Registry IANA has added a registry for "QUIC Frame Types" under a "QUIC" heading. The "QUIC Frame Types" registry governs a 62-bit space. This registry follows the registration policy from Section 22.1. Permanent registrations in this registry are assigned using the Specification Required policy (Section 4.6 of [RFC8126]), except for values between 0x00 and 0x3f (in hexadecimal), inclusive, which are assigned using Standards Action or IESG Approval as defined in Sections 4.9 and 4.10 of [RFC8126]. In addition to the fields listed in Section 22.1.1, permanent registrations in this registry MUST include the following field: Frame Type Name: A short mnemonic for the frame type. In addition to the advice in Section 22.1, specifications for new permanent registrations SHOULD describe the means by which an endpoint might determine that it can send the identified type of frame. An accompanying transport parameter registration is expected for most registrations; see Section 22.3. Specifications for permanent registrations also need to describe the format and assigned semantics of any fields in the frame. The initial contents of this registry are tabulated in Table 3. Note that the registry does not include the "Pkts" and "Spec" columns from Table 3. 22.5. QUIC Transport Error Codes Registry IANA has added a registry for "QUIC Transport Error Codes" under a "QUIC" heading. The "QUIC Transport Error Codes" registry governs a 62-bit space. This space is split into three ranges that are governed by different policies. Permanent registrations in this registry are assigned using the Specification Required policy (Section 4.6 of [RFC8126]), except for values between 0x00 and 0x3f (in hexadecimal), inclusive, which are assigned using Standards Action or IESG Approval as defined in Sections 4.9 and 4.10 of [RFC8126]. In addition to the fields listed in Section 22.1.1, permanent registrations in this registry MUST include the following fields: Code: A short mnemonic for the parameter. Description: A brief description of the error code semantics, which MAY be a summary if a specification reference is provided. The initial contents of this registry are shown in Table 7. +=======+===========================+================+==============+ |Value | Code |Description |Specification | +=======+===========================+================+==============+ |0x00 | NO_ERROR |No error |Section 20 | +-------+---------------------------+----------------+--------------+ |0x01 | INTERNAL_ERROR |Implementation |Section 20 | | | |error | | +-------+---------------------------+----------------+--------------+ |0x02 | CONNECTION_REFUSED |Server refuses a|Section 20 | | | |connection | | +-------+---------------------------+----------------+--------------+ |0x03 | FLOW_CONTROL_ERROR |Flow control |Section 20 | | | |error | | +-------+---------------------------+----------------+--------------+ |0x04 | STREAM_LIMIT_ERROR |Too many streams|Section 20 | | | |opened | | +-------+---------------------------+----------------+--------------+ |0x05 | STREAM_STATE_ERROR |Frame received |Section 20 | | | |in invalid | | | | |stream state | | +-------+---------------------------+----------------+--------------+ |0x06 | FINAL_SIZE_ERROR |Change to final |Section 20 | | | |size | | +-------+---------------------------+----------------+--------------+ |0x07 | FRAME_ENCODING_ERROR |Frame encoding |Section 20 | | | |error | | +-------+---------------------------+----------------+--------------+ |0x08 | TRANSPORT_PARAMETER_ERROR |Error in |Section 20 | | | |transport | | | | |parameters | | +-------+---------------------------+----------------+--------------+ |0x09 | CONNECTION_ID_LIMIT_ERROR |Too many |Section 20 | | | |connection IDs | | | | |received | | +-------+---------------------------+----------------+--------------+ |0x0a | PROTOCOL_VIOLATION |Generic protocol|Section 20 | | | |violation | | +-------+---------------------------+----------------+--------------+ |0x0b | INVALID_TOKEN |Invalid Token |Section 20 | | | |received | | +-------+---------------------------+----------------+--------------+ |0x0c | APPLICATION_ERROR |Application |Section 20 | | | |error | | +-------+---------------------------+----------------+--------------+ |0x0d | CRYPTO_BUFFER_EXCEEDED |CRYPTO data |Section 20 | | | |buffer | | | | |overflowed | | +-------+---------------------------+----------------+--------------+ |0x0e | KEY_UPDATE_ERROR |Invalid packet |Section 20 | | | |protection | | | | |update | | +-------+---------------------------+----------------+--------------+ |0x0f | AEAD_LIMIT_REACHED |Excessive use of|Section 20 | | | |packet | | | | |protection keys | | +-------+---------------------------+----------------+--------------+ |0x10 | NO_VIABLE_PATH |No viable |Section 20 | | | |network path | | | | |exists | | +-------+---------------------------+----------------+--------------+ |0x0100-| CRYPTO_ERROR |TLS alert code |Section 20 | |0x01ff | | | | +-------+---------------------------+----------------+--------------+ Table 7: Initial QUIC Transport Error Codes Registry Entries 23. References 23.1. Normative References [BCP38] Ferguson, P. and D. Senie, "Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing", BCP 38, RFC 2827, May 2000. &lt;https://www.rfc-editor.org/info/bcp38&gt; [DPLPMTUD] Fairhurst, G., Jones, T., T&#252;xen, M., R&#252;ngeler, I., and T. V&#246;lker, "Packetization Layer Path MTU Discovery for Datagram Transports", RFC 8899, DOI 10.17487/RFC8899, September 2020, &lt;https://www.rfc-editor.org/info/rfc8899&gt;. [EARLY-ASSIGN] Cotton, M., "Early IANA Allocation of Standards Track Code Points", BCP 100, RFC 7120, DOI 10.17487/RFC7120, January 2014, &lt;https://www.rfc-editor.org/info/rfc7120&gt;. [IPv4] Postel, J., "Internet Protocol", STD 5, RFC 791, DOI 10.17487/RFC0791, September 1981, &lt;https://www.rfc-editor.org/info/rfc791&gt;. [QUIC-INVARIANTS] Thomson, M., "Version-Independent Properties of QUIC", RFC 8999, DOI 10.17487/RFC8999, May 2021, &lt;https://www.rfc-editor.org/info/rfc8999&gt;. [QUIC-RECOVERY] Iyengar, J., Ed. and I. Swett, Ed., "QUIC Loss Detection and Congestion Control", RFC 9002, DOI 10.17487/RFC9002, May 2021, &lt;https://www.rfc-editor.org/info/rfc9002&gt;. [QUIC-TLS] Thomson, M., Ed. and S. Turner, Ed., "Using TLS to Secure QUIC", RFC 9001, DOI 10.17487/RFC9001, May 2021, &lt;https://www.rfc-editor.org/info/rfc9001&gt;. [RFC1191] Mogul, J. and S. Deering, "Path MTU discovery", RFC 1191, DOI 10.17487/RFC1191, November 1990, &lt;https://www.rfc-editor.org/info/rfc1191&gt;. [RFC2119] Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;. [RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, "The Addition of Explicit Congestion Notification (ECN) to IP", RFC 3168, DOI 10.17487/RFC3168, September 2001, &lt;https://www.rfc-editor.org/info/rfc3168&gt;. [RFC3629] Yergeau, F., "UTF-8, a transformation format of ISO 10646", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, &lt;https://www.rfc-editor.org/info/rfc3629&gt;. [RFC6437] Amante, S., Carpenter, B., Jiang, S., and J. Rajahalme, "IPv6 Flow Label Specification", RFC 6437, DOI 10.17487/RFC6437, November 2011, &lt;https://www.rfc-editor.org/info/rfc6437&gt;. [RFC8085] Eggert, L., Fairhurst, G., and G. Shepherd, "UDP Usage Guidelines", BCP 145, RFC 8085, DOI 10.17487/RFC8085, March 2017, &lt;https://www.rfc-editor.org/info/rfc8085&gt;. [RFC8126] Cotton, M., Leiba, B., and T. Narten, "Guidelines for Writing an IANA Considerations Section in RFCs", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, &lt;https://www.rfc-editor.org/info/rfc8126&gt;. [RFC8174] Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;. [RFC8201] McCann, J., Deering, S., Mogul, J., and R. Hinden, Ed., "Path MTU Discovery for IP version 6", STD 87, RFC 8201, DOI 10.17487/RFC8201, July 2017, &lt;https://www.rfc-editor.org/info/rfc8201&gt;. [RFC8311] Black, D., "Relaxing Restrictions on Explicit Congestion Notification (ECN) Experimentation", RFC 8311, DOI 10.17487/RFC8311, January 2018, &lt;https://www.rfc-editor.org/info/rfc8311&gt;. [TLS13] Rescorla, E., "The Transport Layer Security (TLS) Protocol Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018, &lt;https://www.rfc-editor.org/info/rfc8446&gt;. [UDP] Postel, J., "User Datagram Protocol", STD 6, RFC 768, DOI 10.17487/RFC0768, August 1980, &lt;https://www.rfc-editor.org/info/rfc768&gt;. 23.2. Informative References [AEAD] McGrew, D., "An Interface and Algorithms for Authenticated Encryption", RFC 5116, DOI 10.17487/RFC5116, January 2008, &lt;https://www.rfc-editor.org/info/rfc5116&gt;. [ALPN] Friedl, S., Popov, A., Langley, A., and E. Stephan, "Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension", RFC 7301, DOI 10.17487/RFC7301, July 2014, &lt;https://www.rfc-editor.org/info/rfc7301&gt;. [ALTSVC] Nottingham, M., McManus, P., and J. Reschke, "HTTP Alternative Services", RFC 7838, DOI 10.17487/RFC7838, April 2016, &lt;https://www.rfc-editor.org/info/rfc7838&gt;. [COOKIE] Barth, A., "HTTP State Management Mechanism", RFC 6265, DOI 10.17487/RFC6265, April 2011, &lt;https://www.rfc-editor.org/info/rfc6265&gt;. [CSRF] Barth, A., Jackson, C., and J. Mitchell, "Robust defenses for cross-site request forgery", Proceedings of the 15th ACM conference on Computer and communications security - CCS '08, DOI 10.1145/1455770.1455782, 2008, &lt;https://doi.org/10.1145/1455770.1455782&gt;. [EARLY-DESIGN] Roskind, J., "QUIC: Multiplexed Stream Transport Over UDP", 2 December 2013, &lt;https://docs.google.com/document/ d/1RNHkx_VvKWyWg6Lr8SZ-saqsQx7rFV-ev2jRFUoVD34/ edit?usp=sharing&gt;. [GATEWAY] H&#228;t&#246;nen, S., Nyrhinen, A., Eggert, L., Strowes, S., Sarolahti, P., and M. Kojo, "An experimental study of home gateway characteristics", Proceedings of the 10th ACM SIGCOMM conference on Internet measurement - IMC '10, DOI 10.1145/1879141.1879174, November 2010, &lt;https://doi.org/10.1145/1879141.1879174&gt;. [HTTP2] Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext Transfer Protocol Version 2 (HTTP/2)", RFC 7540, DOI 10.17487/RFC7540, May 2015, &lt;https://www.rfc-editor.org/info/rfc7540&gt;. [IPv6] Deering, S. and R. Hinden, "Internet Protocol, Version 6 (IPv6) Specification", STD 86, RFC 8200, DOI 10.17487/RFC8200, July 2017, &lt;https://www.rfc-editor.org/info/rfc8200&gt;. [QUIC-MANAGEABILITY] Kuehlewind, M. and B. Trammell, "Manageability of the QUIC Transport Protocol", Work in Progress, Internet-Draft, draft-ietf-quic-manageability-11, 21 April 2021, &lt;https://tools.ietf.org/html/draft-ietf-quic- manageability-11&gt;. [RANDOM] Eastlake 3rd, D., Schiller, J., and S. Crocker, "Randomness Requirements for Security", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, &lt;https://www.rfc-editor.org/info/rfc4086&gt;. [RFC1812] Baker, F., Ed., "Requirements for IP Version 4 Routers", RFC 1812, DOI 10.17487/RFC1812, June 1995, &lt;https://www.rfc-editor.org/info/rfc1812&gt;. [RFC1918] Rekhter, Y., Moskowitz, B., Karrenberg, D., de Groot, G. J., and E. Lear, "Address Allocation for Private Internets", BCP 5, RFC 1918, DOI 10.17487/RFC1918, February 1996, &lt;https://www.rfc-editor.org/info/rfc1918&gt;. [RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, "TCP Selective Acknowledgment Options", RFC 2018, DOI 10.17487/RFC2018, October 1996, &lt;https://www.rfc-editor.org/info/rfc2018&gt;. [RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed- Hashing for Message Authentication", RFC 2104, DOI 10.17487/RFC2104, February 1997, &lt;https://www.rfc-editor.org/info/rfc2104&gt;. [RFC3449] Balakrishnan, H., Padmanabhan, V., Fairhurst, G., and M. Sooriyabandara, "TCP Performance Implications of Network Path Asymmetry", BCP 69, RFC 3449, DOI 10.17487/RFC3449, December 2002, &lt;https://www.rfc-editor.org/info/rfc3449&gt;. [RFC4193] Hinden, R. and B. Haberman, "Unique Local IPv6 Unicast Addresses", RFC 4193, DOI 10.17487/RFC4193, October 2005, &lt;https://www.rfc-editor.org/info/rfc4193&gt;. [RFC4291] Hinden, R. and S. Deering, "IP Version 6 Addressing Architecture", RFC 4291, DOI 10.17487/RFC4291, February 2006, &lt;https://www.rfc-editor.org/info/rfc4291&gt;. [RFC4443] Conta, A., Deering, S., and M. Gupta, Ed., "Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification", STD 89, RFC 4443, DOI 10.17487/RFC4443, March 2006, &lt;https://www.rfc-editor.org/info/rfc4443&gt;. [RFC4787] Audet, F., Ed. and C. Jennings, "Network Address Translation (NAT) Behavioral Requirements for Unicast UDP", BCP 127, RFC 4787, DOI 10.17487/RFC4787, January 2007, &lt;https://www.rfc-editor.org/info/rfc4787&gt;. [RFC5681] Allman, M., Paxson, V., and E. Blanton, "TCP Congestion Control", RFC 5681, DOI 10.17487/RFC5681, September 2009, &lt;https://www.rfc-editor.org/info/rfc5681&gt;. [RFC5869] Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand Key Derivation Function (HKDF)", RFC 5869, DOI 10.17487/RFC5869, May 2010, &lt;https://www.rfc-editor.org/info/rfc5869&gt;. [RFC7983] Petit-Huguenin, M. and G. Salgueiro, "Multiplexing Scheme Updates for Secure Real-time Transport Protocol (SRTP) Extension for Datagram Transport Layer Security (DTLS)", RFC 7983, DOI 10.17487/RFC7983, September 2016, &lt;https://www.rfc-editor.org/info/rfc7983&gt;. [RFC8087] Fairhurst, G. and M. Welzl, "The Benefits of Using Explicit Congestion Notification (ECN)", RFC 8087, DOI 10.17487/RFC8087, March 2017, &lt;https://www.rfc-editor.org/info/rfc8087&gt;. [RFC8981] Gont, F., Krishnan, S., Narten, T., and R. Draves, "Temporary Address Extensions for Stateless Address Autoconfiguration in IPv6", RFC 8981, DOI 10.17487/RFC8981, February 2021, &lt;https://www.rfc-editor.org/info/rfc8981&gt;. [SEC-CONS] Rescorla, E. and B. Korver, "Guidelines for Writing RFC Text on Security Considerations", BCP 72, RFC 3552, DOI 10.17487/RFC3552, July 2003, &lt;https://www.rfc-editor.org/info/rfc3552&gt;. [SLOWLORIS] "RSnake" Hansen, R., "Welcome to Slowloris - the low bandwidth, yet greedy and poisonous HTTP client!", June 2009, &lt;https://web.archive.org/web/20150315054838/ http://ha.ckers.org/slowloris/&gt;. Appendix A. Pseudocode The pseudocode in this section describes sample algorithms. These algorithms are intended to be correct and clear, rather than being optimally performant. The pseudocode segments in this section are licensed as Code Components; see the Copyright Notice. A.1. Sample Variable-Length Integer Decoding The pseudocode in Figure 45 shows how a variable-length integer can be read from a stream of bytes. The function ReadVarint takes a single argument -- a sequence of bytes, which can be read in network byte order. ReadVarint(data): // The length of variable-length integers is encoded in the // first two bits of the first byte. v = data.next_byte() prefix = v &gt;&gt; 6 length = 1 &lt;&lt; prefix // Once the length is known, remove these bits and read any // remaining bytes. v = v 0x3f repeat length-1 times: v = (v &lt;&lt; 8) + data.next_byte() return v Figure 45: Sample Variable-Length Integer Decoding Algorithm For example, the eight-byte sequence 0xc2197c5eff14e88c decodes to the decimal value 151,288,809,941,952,652; the four-byte sequence 0x9d7f3e7d decodes to 494,878,333; the two-byte sequence 0x7bbd decodes to 15,293; and the single byte 0x25 decodes to 37 (as does the two-byte sequence 0x4025). A.2. Sample Packet Number Encoding Algorithm The pseudocode in Figure 46 shows how an implementation can select an appropriate size for packet number encodings. The EncodePacketNumber function takes two arguments: * full_pn is the full packet number of the packet being sent. * largest_acked is the largest packet number that has been acknowledged by the peer in the current packet number space, if any. EncodePacketNumber(full_pn, largest_acked): // The number of bits must be at least one more // than the base-2 logarithm of the number of contiguous // unacknowledged packet numbers, including the new packet. if largest_acked is None: num_unacked = full_pn + 1 else: num_unacked = full_pn - largest_acked min_bits = log(num_unacked, 2) + 1 num_bytes = ceil(min_bits / 8) // Encode the integer value and truncate to // the num_bytes least significant bytes. return encode(full_pn, num_bytes) Figure 46: Sample Packet Number Encoding Algorithm For example, if an endpoint has received an acknowledgment for packet 0xabe8b3 and is sending a packet with a number of 0xac5c02, there are 29,519 (0x734f) outstanding packet numbers. In order to represent at least twice this range (59,038 packets, or 0xe69e), 16 bits are required. In the same state, sending a packet with a number of 0xace8fe uses the 24-bit encoding, because at least 18 bits are required to represent twice the range (131,222 packets, or 0x020096). A.3. Sample Packet Number Decoding Algorithm The pseudocode in Figure 47 includes an example algorithm for decoding packet numbers after header protection has been removed. The DecodePacketNumber function takes three arguments: * largest_pn is the largest packet number that has been successfully processed in the current packet number space. * truncated_pn is the value of the Packet Number field. * pn_nbits is the number of bits in the Packet Number field (8, 16, 24, or 32). DecodePacketNumber(largest_pn, truncated_pn, pn_nbits): expected_pn = largest_pn + 1 pn_win = 1 &lt;&lt; pn_nbits pn_hwin = pn_win / 2 pn_mask = pn_win - 1 // The incoming packet number should be greater than // expected_pn - pn_hwin and less than or equal to // expected_pn + pn_hwin // // This means we cannot just strip the trailing bits from // expected_pn and add the truncated_pn because that might // yield a value outside the window. // // The following code calculates a candidate value and // makes sure it's within the packet number window. // Note the extra checks to prevent overflow and underflow. candidate_pn = (expected_pn ~pn_mask) | truncated_pn if candidate_pn &lt;= expected_pn - pn_hwin and candidate_pn &lt; (1 &lt;&lt; 62) - pn_win: return candidate_pn + pn_win if candidate_pn &gt; expected_pn + pn_hwin and candidate_pn &gt;= pn_win: return candidate_pn - pn_win return candidate_pn Figure 47: Sample Packet Number Decoding Algorithm For example, if the highest successfully authenticated packet had a packet number of 0xa82f30ea, then a packet containing a 16-bit value of 0x9b32 will be decoded as 0xa82f9b32. A.4. Sample ECN Validation Algorithm Each time an endpoint commences sending on a new network path, it determines whether the path supports ECN; see Section 13.4. If the path supports ECN, the goal is to use ECN. Endpoints might also periodically reassess a path that was determined to not support ECN. This section describes one method for testing new paths. This algorithm is intended to show how a path might be tested for ECN support. Endpoints can implement different methods. The path is assigned an ECN state that is one of "testing", "unknown", "failed", or "capable". On paths with a "testing" or "capable" state, the endpoint sends packets with an ECT marking -- ECT(0) by default; otherwise, the endpoint sends unmarked packets. To start testing a path, the ECN state is set to "testing", and existing ECN counts are remembered as a baseline. The testing period runs for a number of packets or a limited time, as determined by the endpoint. The goal is not to limit the duration of the testing period but to ensure that enough marked packets are sent for received ECN counts to provide a clear indication of how the path treats marked packets. Section 13.4.2 suggests limiting this to ten packets or three times the PTO. After the testing period ends, the ECN state for the path becomes "unknown". From the "unknown" state, successful validation of the ECN counts in an ACK frame (see Section 13.4.2.1) causes the ECN state for the path to become "capable", unless no marked packet has been acknowledged. If validation of ECN counts fails at any time, the ECN state for the affected path becomes "failed". An endpoint can also mark the ECN state for a path as "failed" if marked packets are all declared lost or if they are all ECN-CE marked. Following this algorithm ensures that ECN is rarely disabled for paths that properly support ECN. Any path that incorrectly modifies markings will cause ECN to be disabled. For those rare cases where marked packets are discarded by the path, the short duration of the testing period limits the number of losses incurred. Contributors The original design and rationale behind this protocol draw significantly from work by Jim Roskind [EARLY-DESIGN]. The IETF QUIC Working Group received an enormous amount of support from many people. The following people provided substantive contributions to this document: * Alessandro Ghedini * Alyssa Wilk * Antoine Delignat-Lavaud * Brian Trammell * Christian Huitema * Colin Perkins * David Schinazi * Dmitri Tikhonov * Eric Kinnear * Eric Rescorla * Gorry Fairhurst * Ian Swett * Igor Lubashev * &#22885; &#19968;&#31298; (Kazuho Oku) * Lars Eggert * Lucas Pardue * Magnus Westerlund * Marten Seemann * Martin Duke * Mike Bishop * Mikkel Fahn&#248;e J&#248;rgensen * Mirja K&#252;hlewind * Nick Banks * Nick Harper * Patrick McManus * Roberto Peon * Ryan Hamilton * Subodh Iyengar * Tatsuhiro Tsujikawa * Ted Hardie * Tom Jones * Victor Vasiliev Authors' Addresses Jana Iyengar (editor) Fastly Email: jri.ietf@gmail.com Martin Thomson (editor) Mozilla Email: mt@lowentropy.net </pre> </div> <div class="valid" valid="valid" title="valid: True, node: 104, level: 3" node_number="104"> <div class="valid" valid="valid" title="valid: True, node: 105, level: 4" node_number="105"> <a class="valid" valid="valid" title="valid: True, node: 106, level: 5" node_number="106">RFC&#160;Editor</a> <a class="valid" valid="valid" title="valid: True, node: 107, level: 5" node_number="107">IASA IETF&#160;LLC</a> <a class="valid" valid="valid" title="valid: True, node: 108, level: 5" node_number="108">IETF&#160;Trust</a> <a class="valid" valid="valid" title="valid: True, node: 109, level: 5" node_number="109">IRTF</a> <a class="valid" valid="valid" title="valid: True, node: 110, level: 5" node_number="110">IETF</a> <a class="valid" valid="valid" title="valid: True, node: 111, level: 5" node_number="111">IESG</a> <a class="valid" valid="valid" title="valid: True, node: 112, level: 5" node_number="112">IAB</a> <a class="valid" valid="valid" title="valid: True, node: 113, level: 5" node_number="113">IANA</a> <a class="valid" valid="valid" title="valid: True, node: 114, level: 5" node_number="114">Privacy&#160;Statement</a> </div> </div> </div> </body>
        <style tyle='text/css'>
body{
    position: relative;
    padding-left: 30px;
    top: 60px;
}
* {
    border: 1px solid #eee;
    padding: 5px 12px;
    margin: 3px 0;
    box-sizing: content-box;
    background-color: #fff;
    cursor: no-drop;
}
main:hover > *, section:hover > *, header:hover > *, nav:hover > *, a:hover > *, div:hover > *, p:hover > *, ul:hover > *, h1:hover > *, h2:hover > *, h3:hover > *, li:hover > *, span:hover > *{
    border: 2px solid green;
    background-color: #fffeee;
    padding: 5px 23px !important;
    margin: 1px 0;
    color: green;
}
main:hover, section:hover, header:hover, nav:hover, a:hover, div:hover, p:hover, ul:hover, h1:hover, h2:hover, h3:hover, li:hover, span:hover{
    border: 1px solid #fff;
    background-color: #eee;
}
a, span {
    display: block;
}
.selected {
    border: 2px solid orchid !important;
    opacity: 0.8;
    color: orchid !important;
}
.selected * {
    padding: 2px !important;
    color: orchid !important;
}
.valid {
  cursor: pointer;
}
.btn{
  cursor: pointer;
  font-weight: bolder;
  padding: 8px;
}
</style> 
        <script>function OpenOriginalLink($event){
    $event.stopPropagation();
    console.log(url);
}

function removeItem($event){
    $event.stopPropagation();
    console.log('Remove item: ', url)
    localStorage.removeItem(url)
}

function exportData($event){
    $event.stopPropagation();

    result = []
    for(let i=0; i<localStorage.length; i++) {
        let key = localStorage.key(i);
        result.push(localStorage.getItem(key))
    }
    const _url = URL.createObjectURL(new Blob([result.join("\n")], {type: 'text/plain'}))
    $event.target.href = _url;
    localStorage.clear()
}

var removeItemBtn = document.createElement("BUTTON");   // Create a <button> element
removeItemBtn.innerHTML = "Remove Item";
removeItemBtn.classList.add('btn');
removeItemBtn.style.position = "fixed";
removeItemBtn.style.left = '5px';
removeItemBtn.style.top = 0;
removeItemBtn.style.border = "1px solid";
removeItemBtn.style.boxShadow = "3px 3px #888";
removeItemBtn.onclick = removeItem;
document.body.appendChild(removeItemBtn);

var goToOriginLink = document.createElement("A");   // Create a <button> element
goToOriginLink.innerHTML = "GoToOrigin";
goToOriginLink.classList.add('btn');
goToOriginLink.style.position = "fixed"
goToOriginLink.style.left = '115px'
goToOriginLink.style.top = 0;
goToOriginLink.onclick = OpenOriginalLink;
goToOriginLink.setAttribute('href', decodeURIComponent(url));
goToOriginLink.target = '_blank';
document.body.appendChild(goToOriginLink);

var current = new Date
var exportDataLink = document.createElement("A");   // Create a <button> element
exportDataLink.innerHTML = "Export data";
exportDataLink.classList.add('btn');
exportDataLink.download = current.toISOString() + '.exported.txt';
exportDataLink.style.position = "fixed";
exportDataLink.style.right = '5px';
exportDataLink.style.top = 0;
exportDataLink.style.border = "1px solid #888";
exportDataLink.style.boxShadow = "3px 3px #888";
exportDataLink.onclick = exportData;
document.body.appendChild(exportDataLink);

data = {
    'title': null ,
    'article': null
}

var body = document.getElementsByTagName("body")[0];

body.onclick = function($e){
    var num = $e.target.getAttribute('node_number')
    var valid = $e.target.getAttribute('valid')

    if(!valid){
        console.log("Element is invalid")
        return
    }

    if(data.length > 2){
        data = data.splice(0, 2)
    }

    console.log("node:", $e.target)

    if(!data.title && !data.article){
        data.title = num;
        console.log("data:", data)
        $e.target.classList.add('selected')
    }else if (data.title && !data.article){
        data.article = num;
        console.log("data:", data)
        $e.target.classList.add('selected')
    }else{
        selected = Array.from(document.getElementsByClassName("selected"))
        selected.forEach(function(el){
            el.classList.remove('selected')
        })

        data.title = num;
        data.article = null;
        $e.target.classList.add('selected')

    }

    if(data.title && data.article){
        var obj = {
            url: url,
            text: body_html,
            title: data.title,
            article: data.article,
        }

        var datasetItem = JSON.stringify(obj)
        localStorage.setItem(url, datasetItem)
    }
}
</script> 
      </html>