<!DOCTYPE html>
<html>
<head>

      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

        <script> var url = encodeURIComponent('https://www.cnblogs.com/rossiXYZ/p/15646816.html');</script>

        <script> var body_html = 'PGJvZHkgPiA8ZGl2ID4gIDwvZGl2PiA8ZGl2ID4gPGRpdiA+IDxkaXYgPiA8ZGl2ID48YSA+572X6KW/55qE5oCd6ICDPC9hPiA8L2Rpdj4gPGRpdiA+5LiA5omL5Ly45ZCR5oqA5pyv77yM5LiA5omL5Ly45ZCR55Sf5rS7PC9kaXY+IDwvZGl2PiA8ZGl2ID4gPHVsID4gPGxpID48YSA+IOWNmuWuouWbrTwvYT4gPC9saT4gPGxpID4gPGEgPiDpppbpobU8L2E+IDwvbGk+IDxsaSA+IDxhID4g5paw6ZqP56yUPC9hPiA8L2xpPiA8bGkgPiA8YSA+IOiBlOezuzwvYT48L2xpPiA8bGkgPiA8YSA+IOiuoumYhTwvYT48L2xpPiA8bGkgPiA8YSA+IOeuoeeQhjwvYT4gPC9saT4gPC91bD4gPC9kaXY+IDwvZGl2PiA8ZGl2ID4gPGRpdiA+IDxkaXYgPiA8ZGl2ID4gPGRpdiA+IDxkaXYgPiA8aDEgPiA8YSA+IFvmupDnoIHop6PmnpBdIFB5VG9yY2gg5YiG5biD5byPIEF1dG9ncmFkICg2KSAtLS0tIOW8leaTjijkuIspIDwvYT4gPC9oMT4gPGRpdiA+IDxkaXYgPiDkuIrmlofmiJHku6zku4vnu43kuoblvJXmk47lpoLkvZXojrflvpflkI7lkJHorqHnrpflm77nmoTkvp3otZbvvIzmnKzmlofmiJHku6zlsLHmjqXnnYDnnIvnnIvlvJXmk47lpoLkvZXkvp3mja7ov5nkupvkvp3otZbov5vooYzlkI7lkJHkvKDmkq3jgIIgPC9kaXY+IDxkaXYgPiA8aDEgPlvmupDnoIHop6PmnpBdIFB5VHRvcmNoIOWIhuW4g+W8jyBBdXRvZ3JhZCAoNikgLS0tLSDlvJXmk44o5LiLKTwvaDE+IDxkaXYgPjxkaXYgPuebruW9lTwvZGl2Pjx1bD48bGk+W+a6kOeggeino+aekF0gUHlUdG9yY2gg5YiG5biD5byPIEF1dG9ncmFkICg2KSAtLS0tIOW8leaTjijkuIspPHVsPjxsaT48YSA+MHgwMCDmkZjopoE8L2E+PC9saT48bGk+PGEgPjB4MDEg5Zue6aG+PC9hPjwvbGk+PGxpPjxhID4weDAyIOaJp+ihjEdyYXBoVGFzazwvYT48dWw+PGxpPjxhID4yLjEgcnVuRW5naW5lQW5kQWNjdW11bGF0ZUdyYWRpZW50czwvYT48L2xpPjxsaT48YSA+Mi4yIGV4ZWN1dGVfZ3JhcGhfdGFza191bnRpbF9yZWFkeV9xdWV1ZV9lbXB0eTwvYT48L2xpPjxsaT48YSA+Mi4zIGV2YWx1YXRlX2Z1bmN0aW9uPC9hPjwvbGk+PGxpPjxhID4yLjQgZ2xvYmFsQ3B1VGhyZWFkPC9hPjwvbGk+PGxpPjxhID4yLjUg5bCP57uTPC9hPjwvbGk+PC91bD48L2xpPjxsaT48YSA+MHgwMyBSUEPosIPnlKg8L2E+PHVsPjxsaT48YSA+My4xIFJlY3ZScGNCYWNrd2FyZDwvYT48dWw+PGxpPjxhID4zLjEuMSDlrprkuYk8L2E+PC9saT48bGk+PGEgPjMuMS4yIOaehOW7ujwvYT48L2xpPjxsaT48YSA+My4xLjMgYXBwbHk8L2E+PC9saT48L3VsPjwvbGk+PGxpPjxhID4zLjIgUHJvcGFnYXRlR3JhZGllbnRzUmVxPC9hPjx1bD48bGk+PGEgPjMuMi4xIOWumuS5iTwvYT48L2xpPjwvdWw+PC9saT48bGk+PGEgPjMuMyDmjqXlj5fmlrk8L2E+PHVsPjxsaT48YSA+My4zLjEg5o6l5Y+X5raI5oGvPC9hPjwvbGk+PGxpPjxhID4zLjMuMiBwcm9jZXNzQmFja3dhcmRBdXRvZ3JhZFJlcTwvYT48L2xpPjxsaT48YSA+My4zLjMgZXhlY3V0ZVNlbmRGdW5jdGlvbkFzeW5jPC9hPjwvbGk+PC91bD48L2xpPjwvdWw+PC9saT48bGk+PGEgPjB4MDQgRGlzdEFjY3VtdWxhdGVHcmFkQ2FwdHVyZUhvb2s8L2E+PHVsPjxsaT48YSA+NC4xIOWumuS5iTwvYT48L2xpPjxsaT48YSA+NC4yIOeUn+aIkDwvYT48L2xpPjxsaT48YSA+NC4zIOS9v+eUqDwvYT48L2xpPjxsaT48YSA+NC40IOe0r+enr+air+W6pjwvYT48dWw+PGxpPjxhID40LjQuMSDkuIrkuIvmlofntK/np688L2E+PC9saT48bGk+PGEgPjQuNC4yIOeul+WtkOe0r+enrzwvYT48L2xpPjwvdWw+PC9saT48L3VsPjwvbGk+PGxpPjxhID4weDA1IOetieW+heWujOaIkDwvYT48L2xpPjxsaT48YSA+MHhGRiDlj4LogIM8L2E+PC9saT48L3VsPjwvbGk+PC91bD48L2Rpdj4gPGgyID4weDAwIOaRmOimgTwvaDI+IDxwPuS4iuaWh+aIkeS7rOS7i+e7jeS6huW8leaTjuWmguS9leiOt+W+l+WQjuWQkeiuoeeul+WbvueahOS+nei1lu+8jOacrOaWh+aIkeS7rOWwseaOpeedgOeci+eci+W8leaTjuWmguS9leS+neaNrui/meS6m+S+nei1lui/m+ihjOWQjuWQkeS8oOaSreOAgumAmui/h+acrOaWh+eahOWtpuS5oO+8jOWkp+WutuWPr+S7pe+8mjwvcD4gPHVsPiA8bGk+5LqG6KejIFJlY3ZScGNCYWNrd2FyZCDlpoLkvZXnu5nlr7nlupTnmoTkuIvmuLjoioLngrnlj5HpgIEgUlBDIOa2iOaBr++8jOWPr+S7peWGjeasoeais+eQhuS4gOS4i3dvcmtlcuS5i+mXtOWQjuWQkeS8oOaSreeahOS6pOS6kua1geeoi+OAgjwvbGk+IDxsaT7kuobop6MgQWNjdW11bGF0ZUdyYWQg5aaC5L2V5Zyo5LiK5LiL5paH57Sv56ev5qKv5bqm44CCPC9saT4gPC91bD4gPHA+UHlUb3JjaOWIhuW4g+W8j+WFtuS7luaWh+eroOWmguS4i++8mjwvcD4gPHA+PGEgPua3seW6puWtpuS5oOWIqeWZqOS5i+iHquWKqOW+ruWIhigxKTwvYT48L3A+IDxwPjxhID7mt7HluqblrabkuaDliKnlmajkuYvoh6rliqjlvq7liIYoMik8L2E+PC9wPiA8cD5bPGEgPua6kOeggeino+aekF3mt7HluqblrabkuaDliKnlmajkuYvoh6rliqjlvq7liIYoMykgLS0tIOekuuS+i+ino+ivuzwvYT48L3A+IDxwPls8YSA+5rqQ56CB6Kej5p6QXVB5VG9yY2jlpoLkvZXlrp7njrDliY3lkJHkvKDmkq0oMSkgLS0tIOWfuuehgOexuyjkuIopPC9hPjwvcD4gPHA+WzxhID7mupDnoIHop6PmnpBdUHlUb3JjaOWmguS9leWunueOsOWJjeWQkeS8oOaSrSgyKSAtLS0g5Z+656GA57G7KOS4iyk8L2E+PC9wPiA8cD5bPGEgPua6kOeggeino+aekF0gUHlUb3JjaOWmguS9leWunueOsOWJjeWQkeS8oOaSrSgzKSAtLS0g5YW35L2T5a6e546wPC9hPjwvcD4gPHA+WzxhID7mupDnoIHop6PmnpBdIFB5dG9yY2gg5aaC5L2V5a6e546w5ZCO5ZCR5Lyg5pKtICgxKS0tLS0g6LCD55So5byV5pOOPC9hPjwvcD4gPHA+WzxhID7mupDnoIHop6PmnpBdIFB5dG9yY2gg5aaC5L2V5a6e546w5ZCO5ZCR5Lyg5pKtICgyKS0tLS0g5byV5pOO6Z2Z5oCB57uT5p6EPC9hPjwvcD4gPHA+WzxhID7mupDnoIHop6PmnpBdIFB5dG9yY2gg5aaC5L2V5a6e546w5ZCO5ZCR5Lyg5pKtICgzKS0tLS0g5byV5pOO5Yqo5oCB6YC76L6RPC9hPjwvcD4gPHA+WzxhID7mupDnoIHop6PmnpBdIFB5VG9yY2gg5aaC5L2V5a6e546w5ZCO5ZCR5Lyg5pKtICg0KS0tLS0g5YW35L2T566X5rOVPC9hPjwvcD4gPHA+WzxhID7mupDnoIHop6PmnpBdIFB5VG9yY2gg5YiG5biD5byPKDEpLS0tLS0t5Y6G5Y+y5ZKM5qaC6L+wPC9hPjwvcD4gPHA+WzxhID7mupDnoIHop6PmnpBdIFB5VG9yY2gg5YiG5biD5byPKDIpIC0tLS0tIERhdGFQYXJhbGxlbCjkuIopPC9hPjwvcD4gPHA+WzxhID7mupDnoIHop6PmnpBdIFB5VG9yY2gg5YiG5biD5byPKDMpIC0tLS0tIERhdGFQYXJhbGxlbCjkuIspPC9hPjwvcD4gPHA+WzxhID7mupDnoIHop6PmnpBdIFB5VG9yY2gg5YiG5biD5byPKDQpLS0tLS0t5YiG5biD5byP5bqU55So5Z+656GA5qaC5b+1PC9hPjwvcD4gPHA+WzxhID7mupDnoIHop6PmnpBdIFB5VG9yY2jliIbluIPlvI8oNSkgLS0tLS0tIERpc3RyaWJ1dGVkRGF0YVBhcmFsbGVsIOaAu+i/sOWmguS9leS9v+eUqDwvYT48L3A+IDxwPls8YSA+5rqQ56CB6Kej5p6QXSBQeVRvcmNo5YiG5biD5byPKDYpIC0tLURpc3RyaWJ1dGVkRGF0YVBhcmFsbGVsIC0tIOWIneWni+WMlnN0b3JlPC9hPjwvcD4gPHA+WzxhID7mupDnoIHop6PmnpBdIFB5VG9yY2gg5YiG5biD5byPKDcpIC0tLS0tIERpc3RyaWJ1dGVkRGF0YVBhcmFsbGVsIOS5i+i/m+eoi+e7hDwvYT48L3A+IDxwPls8YSA+5rqQ56CB6Kej5p6QXSBQeVRvcmNoIOWIhuW4g+W8jyg4KSAtLS0tLS0tLSBEaXN0cmlidXRlZERhdGFQYXJhbGxlbOS5i+iuuuaWh+evhzwvYT48L3A+IDxwPls8YSA+5rqQ56CB6Kej5p6QXSBQeVRvcmNoIOWIhuW4g+W8jyg5KSAtLS0tLSBEaXN0cmlidXRlZERhdGFQYXJhbGxlbCDkuYvliJ3lp4vljJY8L2E+PC9wPiA8cD5bPGEgPua6kOeggeino+aekF0gUHlUb3JjaCDliIbluIPlvI8oMTApLS0tLS0tRGlzdHJpYnV0ZWREYXRhUGFyYWxsZWwg5LmLIFJlZHVjZXLpnZnmgIHmnrbmnoQ8L2E+PC9wPiA8cD5bPGEgPua6kOeggeino+aekF0gUHlUb3JjaCDliIbluIPlvI8oMTEpIC0tLS0tIERpc3RyaWJ1dGVkRGF0YVBhcmFsbGVsIOS5iyDmnoTlu7pSZWR1Y2Vy5ZKMSm9pbuaTjeS9nDwvYT48L3A+IDxwPls8YSA+5rqQ56CB6Kej5p6QXSBQeVRvcmNoIOWIhuW4g+W8jygxMikgLS0tLS0gRGlzdHJpYnV0ZWREYXRhUGFyYWxsZWwg5LmLIOWJjeWQkeS8oOaSrTwvYT48L3A+IDxwPls8YSA+5rqQ56CB6Kej5p6QXSBQeVRvcmNoIOWIhuW4g+W8jygxMykgLS0tLS0gRGlzdHJpYnV0ZWREYXRhUGFyYWxsZWwg5LmLIOWPjeWQkeS8oOaSrTwvYT48L3A+IDxwPls8YSA+5rqQ56CB6Kej5p6QXSBQeVRvcmNoIOWIhuW4g+W8jyBBdXRvZ3JhZCAoMSkgLS0tLSDorr7orqE8L2E+PC9wPiA8cD5bPGEgPua6kOeggeino+aekF0gUHlUb3JjaCDliIbluIPlvI8gQXV0b2dyYWQgKDIpIC0tLS0gUlBD5Z+656GAPC9hPjwvcD4gPHA+WzxhID7mupDnoIHop6PmnpBdIFB5VG9yY2gg5YiG5biD5byPIEF1dG9ncmFkICgzKSAtLS0tIOS4iuS4i+aWh+ebuOWFszwvYT48L3A+IDxwPls8YSA+5rqQ56CB6Kej5p6QXSBQeVRvcmNoIOWIhuW4g+W8jyBBdXRvZ3JhZCAoNCkgLS0tLSDlpoLkvZXliIflhaXlvJXmk448L2E+PC9wPiA8cD5bPGEgPua6kOeggeino+aekF0gUHlUb3JjaCDliIbluIPlvI8gQXV0b2dyYWQgKDUpIC0tLS0g5byV5pOOKOS4iik8L2E+PC9wPiA8cD7kuLrkuobmm7Tlpb3nmoTor7TmmI7vvIzmnKzmlofku6PnoIHkvJrkvp3mja7lhbfkvZPmg4XlhrXmnaXov5vooYznm7jlupTnsr7nroDjgII8L3A+IDxoMiA+MHgwMSDlm57pob48L2gyPiA8cD7miJHku6zpppblhYjlm57pob5GQVNU5qih5byP566X5rOV566X5rOV5aaC5LiL77yM5pys5paH6ZyA6KaB6K6o6K665ZCO6Z2i6Iul5bmy6YOo5YiG44CCPC9wPiA8b2w+IDxsaT7miJHku6zku47lhbfmnInlj43lkJHkvKDmkq3moLnnmoR3b3JrZXLlvIDlp4vvvIjmiYDmnInmoLnpg73lv4XpobvmmK/mnKzlnLDnmoTvvInjgII8L2xpPiA8bGk+5p+l5om+5b2T5YmNRGlzdHJpYnV0ZWQgQXV0b2dyYWQgQ29udGV4dCDnmoTmiYDmnIk8Y29kZT5zZW5kPC9jb2RlPuWHveaVsCDjgII8L2xpPiA8bGk+5LuO5o+Q5L6b55qE5qC55ZKM5oiR5Lus5qOA57Si5Yiw55qE5omA5pyJPGNvZGU+c2VuZDwvY29kZT7lh73mlbDlvIDlp4vvvIzmiJHku6zlnKjmnKzlnLDorqHnrpfkvp3otZbpobkg44CCPC9saT4gPGxpPuiuoeeul+S+nei1lumhueWQju+8jOS9v+eUqOaPkOS+m+eahOagueadpeWQr+WKqOacrOWcsCBhdXRvZ3JhZCDlvJXmk47jgII8L2xpPiA8bGk+5b2TIGF1dG9ncmFkIOW8leaTjuaJp+ihjOivpTxjb2RlPnJlY3Y8L2NvZGU+5Ye95pWw5pe277yM6K+lPGNvZGU+cmVjdjwvY29kZT4g5Ye95pWw6YCa6L+HIFJQQyDlsIbovpPlhaXmoq/luqblj5HpgIHliLDpgILlvZPnmoR3b3JrZXLjgILmr4/kuKo8Y29kZT5yZWN2PC9jb2RlPuWHveaVsOmDveefpemBk+ebruaghyB3b3JrZXIgaWTvvIzlm6DkuLrlroPooqvorrDlvZXkuLrliY3lkJHkvKDmkq3nmoTkuIDpg6jliIbjgILpgJrov4c8Y29kZT5hdXRvZ3JhZF9jb250ZXh0X2lkPC9jb2RlPuWSjCA8Y29kZT5hdXRvZ3JhZF9tZXNzYWdlX2lkPC9jb2RlPiDor6U8Y29kZT5yZWN2PC9jb2RlPuWHveaVsOiiq+WPkemAgeWIsOi/nOeoi+S4u+acuuOAgjwvbGk+IDxsaT7lvZPov5znqIvkuLvmnLrmlLbliLDov5nkuKror7fmsYLml7bvvIzmiJHku6zkvb/nlKggPGNvZGU+YXV0b2dyYWRfY29udGV4dF9pZDwvY29kZT7lkow8Y29kZT5hdXRvZ3JhZF9tZXNzYWdlX2lkPC9jb2RlPuadpeafpeaJvumAguW9k+eahDxjb2RlPnNlbmQ8L2NvZGU+5Ye95pWw44CCPC9saT4gPGxpPuWmguaenOi/meaYr3dvcmtlcuesrOS4gOasoeaUtuWIsOWvuee7meWumiA8Y29kZT5hdXRvZ3JhZF9jb250ZXh0X2lkPC9jb2RlPueahOivt+axgu+8jOWug+WwhuaMieeFp+S4iumdoueahOesrCAxLTMg54K55omA6L+w5Zyo5pys5Zyw6K6h566X5L6d6LWW6aG544CCPC9saT4gPGxpPueEtuWQjuWwhuWcqOesrDbngrnmjqXlj5fliLDnmoQ8Y29kZT5zZW5kPC9jb2RlPuaWueazleaPkuWFpemYn+WIl++8jOS7peS+v+WcqOivpXdvcmtlcueahOacrOWcsCBhdXRvZ3JhZCDlvJXmk47kuIrmiafooYzjgII8L2xpPiA8bGk+5pyA5ZCO77yM5oiR5Lus5LiN5piv5ZyoIFRlbnNvcueahDxjb2RlPi5ncmFkPC9jb2RlPuS5i+S4iue0r+enr+air+W6pu+8jOiAjOaYr+WcqOavj+S4qkRpc3RyaWJ1dGVkIEF1dG9ncmFkIENvbnRleHTkuYvkuIrliIbliKvntK/np6/moq/luqYg44CC5qKv5bqm5a2Y5YKo5ZyoPGNvZGU+RGljdFtUZW5zb3IsIFRlbnNvcl08L2NvZGU+5LmL5LitIO+8jDxjb2RlPkRpY3RbVGVuc29yLCBUZW5zb3JdPC9jb2RlPuWfuuacrOS4iuaYr+S7jiBUZW5zb3Ig5Yiw5YW25YWz6IGU5qKv5bqm55qE5pig5bCE77yM5bm25LiU5Y+v5Lul5L2/55SoIGdldF9ncmFkaWVudHMoKSBBUEnmo4DntKLor6XmmKDlsIQg44CCPC9saT4gPC9vbD4gPHA+5YW25qyh77yM5oiR5Lus55yL55yL5oC75L2T5omn6KGM5Luj56CB77yM5oC75L2T5omn6KGM5piv5ZyoIERpc3RFbmdpbmU6OmV4ZWN1dGUg5LmL5Lit5a6M5oiQ77yM5YW35L2T5YiG5Li65aaC5LiL5q2l6aqk77yaPC9wPiA8dWw+IDxsaT7kvb/nlKggY29udGV4dElkIOW+l+WIsOWJjeWQkeeahOS4iuS4i+aWh+OAgjwvbGk+IDxsaT7kvb/nlKggdmFsaWRhdGVSb290c0FuZFJldHJpZXZlRWRnZXMg6L+b6KGM6aqM6K+B44CCPC9saT4gPGxpPuaehOmAoOS4gOS4qkdyYXBoUm9vdO+8jOeUqOWug+adpempseWKqOWQjuWQkeS8oOaSre+8jOWPr+S7peiupOS4uuaYr+S4gOS4quiZmuaLn+agueOAgjwvbGk+IDxsaT7kvb/nlKggY29tcHV0ZURlcGVuZGVuY2llcyDorqHnrpfkvp3otZbjgII8L2xpPiA8bGk+5L2/55SoIHJ1bkVuZ2luZUFuZEFjY3VtdWxhdGVHcmFkaWVudHMg6L+b6KGM5Y+N5ZCR5Lyg5pKt6K6h566X44CCPC9saT4gPGxpPuS9v+eUqCBjbGVhckFuZFdhaXRGb3JPdXRzdGFuZGluZ1JwY3NBc3luYyDnrYnlvoUgUlBDIOWujOaIkOOAgjwvbGk+IDwvdWw+IDxwcmU+PGNvZGUgPnZvaWQgRGlzdEVuZ2luZTo6ZXhlY3V0ZSggaW50NjRfdCBjb250ZXh0SWQsIGNvbnN0IHZhcmlhYmxlX2xpc3Qgcm9vdHMsIGJvb2wgcmV0YWluR3JhcGgpIHsgLy8gUmV0cmlldmUgdGhlIGNvbnRleHQgZm9yIHRoZSBnaXZlbiBjb250ZXh0X2lkLiBUaGlzIHdpbGwgdGhyb3cgaWYgdGhlIC8vIGNvbnRleHRfaWQgaXMgaW52YWxpZC4gYXV0byBhdXRvZ3JhZENvbnRleHQgPSBEaXN0QXV0b2dyYWRDb250YWluZXI6OmdldEluc3RhbmNlKCkucmV0cmlldmVDb250ZXh0KGNvbnRleHRJZCk7IC8vIFBlcmZvcm0gaW5pdGlhbCBwcmUtcHJvY2Vzc2luZy4gZWRnZV9saXN0IHJvb3RFZGdlczsgdmFyaWFibGVfbGlzdCBncmFkczsgdmFsaWRhdGVSb290c0FuZFJldHJpZXZlRWRnZXMocm9vdHMsIHJvb3RFZGdlcywgZ3JhZHMpOyAvLyDmnoTpgKDkuIDkuKpHcmFwaFJvb3TvvIznlKjlroPmnaXpqbHliqjlkI7lkJHkvKDmkq3vvIzlj6/ku6XorqTkuLrmmK/kuIDkuKromZrmi5/moLkgc3RkOjpzaGFyZWRfcHRyJmx0O05vZGUmZ3Q7IGdyYXBoUm9vdCA9IHN0ZDo6bWFrZV9zaGFyZWQmbHQ7R3JhcGhSb290Jmd0Oyhyb290RWRnZXMsIGdyYWRzKTsgZWRnZV9saXN0IG91dHB1dEVkZ2VzOyAvLyBDb21wdXRlIGRlcGVuZGVuY2llcyBsb2NhbGx5LCBzdGFydGluZyBmcm9tIGFsbCByb290cyBhbmQgYWxsICdzZW5kJyAvLyBmdW5jdGlvbnMuIHsgc3RkOjpsb2NrX2d1YXJkJmx0O3N0ZDo6bXV0ZXgmZ3Q7IGd1YXJkKGluaXRpYWxpemVkQ29udGV4dElkc0xvY2tfKTsgLy8gQ29udGV4dCBzaG91bGQgbm90IGhhdmUgYmVlbiBpbml0aWFsaXplZCBhbHJlYWR5LiBUT1JDSF9JTlRFUk5BTF9BU1NFUlQoIGluaXRpYWxpemVkQ29udGV4dElkc18uZmluZChhdXRvZ3JhZENvbnRleHQtJmd0O2NvbnRleHRJZCgpKSA9PSBpbml0aWFsaXplZENvbnRleHRJZHNfLmVuZCgpKTsgLy8g6K6h566X5L6d6LWWIGNvbXB1dGVEZXBlbmRlbmNpZXMoIGF1dG9ncmFkQ29udGV4dCwgcm9vdEVkZ2VzLCBncmFkcywgZ3JhcGhSb290LCBvdXRwdXRFZGdlcywgcmV0YWluR3JhcGgpOyAvLyBNYXJrIHRoZSBhdXRvZ3JhZCBjb250ZXh0IGlkIGFzIGluaXRpYWxpemVkLiBpbml0aWFsaXplZENvbnRleHRJZHNfLmluc2VydChhdXRvZ3JhZENvbnRleHQtJmd0O2NvbnRleHRJZCgpKTsgfSBCYWNrd2FyZFBhc3NDbGVhbnVwR3VhcmQgZ3VhcmQoYXV0b2dyYWRDb250ZXh0KTsgLy8gVGhpcyBuZWVkcyB0byBiZSBibG9ja2luZyBhbmQgYXMgYSByZXN1bHQgd2Ugd2FpdCBmb3IgdGhlIGZ1dHVyZSB0byAvLyBjb21wbGV0ZS4gcnVuRW5naW5lQW5kQWNjdW11bGF0ZUdyYWRpZW50cyhhdXRvZ3JhZENvbnRleHQsIGdyYXBoUm9vdCwgb3V0cHV0RWRnZXMpIC0mZ3Q7d2FpdEFuZFRocm93KCk7IC8vIOWPjeWQkeS8oOaSreiuoeeulyAvLyBXYWl0IGZvciBhbGwgb2YgdGhlIG91dHN0YW5kaW5nIHJwY3MgdG8gY29tcGxldGUuIGF1dG9ncmFkQ29udGV4dC0mZ3Q7Y2xlYXJBbmRXYWl0Rm9yT3V0c3RhbmRpbmdScGNzQXN5bmMoKS0mZ3Q7d2FpdEFuZFRocm93KCk7IH0gPC9jb2RlPjwvcHJlPiA8cD7lho3mrKHvvIw8dT7ku47liY3mlofmiJHku6znn6XpgZPvvIzkvp3otZbpobnlt7Lnu4/lnKggY29tcHV0ZURlcGVuZGVuY2llcyDkuYvkuK3lpITnkIblrozmr5XvvIzmiYDmnInpnIDopoHorqHnrpfnmoTlh73mlbDkv6Hmga/pg73kvY3kuo4gR3JhcGhUYXNrLmV4ZWNfaW5mb18g5LmL5LiKPC91PuOAguaIkeS7rOaOpeS4i+adpeWwseeci+eci+WmguS9leiuoeeul++8jOWwseaYryBydW5FbmdpbmVBbmRBY2N1bXVsYXRlR3JhZGllbnRzIOWSjCBjbGVhckFuZFdhaXRGb3JPdXRzdGFuZGluZ1JwY3NBc3luYyDov5nkuKTkuKrmlrnms5XjgII8L3A+IDxoMiA+MHgwMiDmiafooYxHcmFwaFRhc2s8L2gyPiA8cD7miJHku6zpppblhYjnnIvnnIvlpoLkvZXkvb/nlKggcnVuRW5naW5lQW5kQWNjdW11bGF0ZUdyYWRpZW50cyDov5vooYzlj43lkJHkvKDmkq3orqHnrpfvvIzntK/np6/moq/luqbjgII8L3A+IDxoMyA+Mi4xIHJ1bkVuZ2luZUFuZEFjY3VtdWxhdGVHcmFkaWVudHM8L2gzPiA8cD7lvJXmk47kuYvkuK3vvIzpppblhYjosIPnlKjkuoYgcnVuRW5naW5lQW5kQWNjdW11bGF0ZUdyYWRpZW50c+OAguS4u+imgeaYr+WwgeijheS6huS4gOS4qiBOb2RlVGFza++8jOeEtuWQjuS7peatpOiwg+eUqCBleGVjdXRlX2dyYXBoX3Rhc2tfdW50aWxfcmVhZHlfcXVldWVfZW1wdHnjgILlhbbkuK3kvb/nlKggYXQ6OmxhdW5jaCDmnaXlkK/liqjnur/nqIvjgII8L3A+IDxwcmU+PGNvZGUgPmMxMDo6aW50cnVzaXZlX3B0ciZsdDtjMTA6Oml2YWx1ZTo6RnV0dXJlJmd0OyBEaXN0RW5naW5lOjogcnVuRW5naW5lQW5kQWNjdW11bGF0ZUdyYWRpZW50cyggY29uc3QgQ29udGV4dFB0ciBhdXRvZ3JhZENvbnRleHQsIGNvbnN0IHN0ZDo6c2hhcmVkX3B0ciZsdDtOb2RlJmd0OyBncmFwaFJvb3QsIGNvbnN0IGVkZ2VfbGlzdCBvdXRwdXRFZGdlcywgYm9vbCBpbmNyZW1lbnRPdXRzdGFuZGluZ1Rhc2tzKSB7IC8vIENsZWFudXAgcHJldmlvdXMgc3RhdGUgZm9yIG91dHN0YW5kaW5nIFJQQ3MuIE91dHN0YW5kaW5nIFJQQ3MgY291bGQgYmUgLy8gbGluZ2VyaW5nIGlmIHdlJ3JlIHJ1bm5pbmcgYmFja3dhcmQgbXVsdGlwbGUgdGltZXMgYW5kIHNvbWUgb2YgdGhlIC8vIHBhc3NlcyByYW4gaW50byBlcnJvcnMuIGF1dG9ncmFkQ29udGV4dC0mZ3Q7Y2xlYXJPdXRzdGFuZGluZ1JwY3MoKTsgLy8g5b6X5YiwR3JhcGhUYXNrIGF1dG8gZ3JhcGhUYXNrID0gYXV0b2dyYWRDb250ZXh0LSZndDtyZXRyaWV2ZUdyYXBoVGFzaygpOyAvLyDlkK/liqjkuobkuIDkuKrnur/nqIvmnaXov5DooYwgZXhlY3V0ZV9ncmFwaF90YXNrX3VudGlsX3JlYWR5X3F1ZXVlX2VtcHR5IGF0OjpsYXVuY2goW3RoaXMsIGdyYXBoVGFzaywgZ3JhcGhSb290LCBpbmNyZW1lbnRPdXRzdGFuZGluZ1Rhc2tzXSgpIHsgZXhlY3V0ZV9ncmFwaF90YXNrX3VudGlsX3JlYWR5X3F1ZXVlX2VtcHR5KCAvKm5vZGVfdGFzayovIE5vZGVUYXNrKGdyYXBoVGFzaywgZ3JhcGhSb290LCBJbnB1dEJ1ZmZlcigwKSksIC8qaW5jcmVtZW50T3V0c3RhbmRpbmdUYXNrcyovIGluY3JlbWVudE91dHN0YW5kaW5nVGFza3MpOyB9KTsgLy8gVXNlIGEgcmVmZXJlbmNlIGhlcmUgdG8gYXZvaWQgcmVmY291bnQgYnVtcCBvbiBmdXR1cmVHcmFkcy4gLy8g5aSE55CG57uT5p6cIGF1dG8gZnV0dXJlR3JhZHMgPSBncmFwaFRhc2stJmd0O2Z1dHVyZV9yZXN1bHRfOyAvLyBCdWlsZCBhIGZ1dHVyZSB0aGF0IHdhaXRzIGZvciB0aGUgY2FsbGJhY2tzIHRvIGV4ZWN1dGUgKHNpbmNlIGNhbGxiYWNrcyAvLyBleGVjdXRlIGFmdGVyIHRoZSBvcmlnaW5hbCBmdXR1cmUgaXMgY29tcGxldGVkKS4gVGhpcyBlbnN1cmVzIHdlIHJldHVybiBhIC8vIGZ1dHVyZSB0aGF0IHdhaXRzIGZvciBhbGwgZ3JhZGllbnQgYWNjdW11bGF0aW9uIHRvIGZpbmlzaC4gYXV0byBhY2N1bXVsYXRlR3JhZEZ1dHVyZSA9IGMxMDo6bWFrZV9pbnRydXNpdmUmbHQ7YzEwOjppdmFsdWU6OkZ1dHVyZSZndDsoYzEwOjpOb25lVHlwZTo6Z2V0KCkpOyBmdXR1cmVHcmFkcy0mZ3Q7YWRkQ2FsbGJhY2soIFthdXRvZ3JhZENvbnRleHQsIG91dHB1dEVkZ2VzLCBhY2N1bXVsYXRlR3JhZEZ1dHVyZV0oYzEwOjppdmFsdWU6OkZ1dHVyZSBmdXR1cmVHcmFkcykgeyBpZiAoZnV0dXJlR3JhZHMuaGFzRXJyb3IoKSkgeyAvLyDnnIHnlaXplJnor6/lpITnkIbpg6jliIYgcmV0dXJuOyB9IHRyeSB7IGNvbnN0IHZhcmlhYmxlX2xpc3QgZ3JhZHMgPSBmdXR1cmVHcmFkcy5jb25zdFZhbHVlKCkudG9UZW5zb3JWZWN0b3IoKTsgLy8g5qCH6K+G5bey57uP57uT5p2fIGFjY3VtdWxhdGVHcmFkRnV0dXJlLSZndDttYXJrQ29tcGxldGVkKGMxMDo6SVZhbHVlKCkpOyB9IGNhdGNoIChzdGQ6OmV4Y2VwdGlvbiBlKSB7IGFjY3VtdWxhdGVHcmFkRnV0dXJlLSZndDtzZXRFcnJvcklmTmVlZGVkKHN0ZDo6Y3VycmVudF9leGNlcHRpb24oKSk7IH0gfSk7IHJldHVybiBhY2N1bXVsYXRlR3JhZEZ1dHVyZTsgfSA8L2NvZGU+PC9wcmU+IDxwPmF0OjpsYXVuY2gg5L2N5LqOIGF0ZW4vc3JjL0FUZW4vUGFyYWxsZWxUaHJlYWRQb29sTmF0aXZlLmNwcO+8jOi/memHjOS8muWcqOe6v+eoi+S5i+S4reiwg+eUqOS8oOWFpeeahCBmdW5j44CCPC9wPiA8cHJlPjxjb2RlID52b2lkIGxhdW5jaChzdGQ6OmZ1bmN0aW9uJmx0O3ZvaWQoKSZndDsgZnVuYykgeyBpbnRlcm5hbDo6bGF1bmNoX25vX3RocmVhZF9zdGF0ZShzdGQ6OmJpbmQoW10oIHN0ZDo6ZnVuY3Rpb24mbHQ7dm9pZCgpJmd0OyBmLCBUaHJlYWRMb2NhbFN0YXRlIHRocmVhZF9sb2NhbHMpIHsgVGhyZWFkTG9jYWxTdGF0ZUd1YXJkIGd1YXJkKHN0ZDo6bW92ZSh0aHJlYWRfbG9jYWxzKSk7IGYoKTsgfSwgc3RkOjptb3ZlKGZ1bmMpLCBUaHJlYWRMb2NhbFN0YXRlKCkgKSk7IH0gbmFtZXNwYWNlIGludGVybmFsIHsgdm9pZCBsYXVuY2hfbm9fdGhyZWFkX3N0YXRlKHN0ZDo6ZnVuY3Rpb24mbHQ7dm9pZCgpJmd0OyBmbikgeyAjaWYgQVRfRVhQRVJJTUVOVEFMX1NJTkdMRV9USFJFQURfUE9PTCBpbnRyYW9wX2xhdW5jaChzdGQ6Om1vdmUoZm4pKTsgI2Vsc2UgZ2V0X3Bvb2woKS5ydW4oc3RkOjptb3ZlKGZuKSk7ICNlbmRpZiB9IH0gPC9jb2RlPjwvcHJlPiA8cD7miJHku6zmjqXkuIvmnaXkuIDkuIDnnIvnnIvlhoXpg6jov5nlh6DkuKrmlrnms5XlpoLkvZXmiafooYzjgII8L3A+IDxoMyA+Mi4yIGV4ZWN1dGVfZ3JhcGhfdGFza191bnRpbF9yZWFkeV9xdWV1ZV9lbXB0eTwvaDM+IDxwPuatpOWHveaVsOexu+S8vCBFbmdpbmU6OnRocmVhZF9tYWlu77yM6YCa6L+H5LiA5LiqIE5vZGVUYXNrIOadpeWujOaIkOacrCBHcmFwaFRhc2vnmoTmiafooYzvvIzlhbbkuK0gZXZhbHVhdGVfZnVuY3Rpb24g5Lya5LiN5YGc55qE5ZCRIGNwdV9yZWFkeV9xdWV1ZSDmj5LlhaXmlrDnmoQgTm9kZVRhc2vjgIJlbmdpbmVfLmV2YWx1YXRlX2Z1bmN0aW9uIOaWueazleS8mu+8mjwvcD4gPHVsPiA8bGk+6aaW5YWI77yM5Yid5aeL5YyW5Y6f55Sf5byV5pOO57q/56iL44CCPC9saT4gPGxpPuWFtuasoe+8jOavj+S4quiwg+eUqOW7uueri+S4gOS4qiBjcHVfcmVhZHlfcXVldWXvvIznlKjmnaXku45yb290X3RvX2V4ZWN1dGXlvIDlp4vpgY3ljoZncmFwaF90YXNr77yM6L+Z5YWB6K6455So5LiN5ZCM55qE57q/56iL5p2l5a+5R3JhcGhUYXNr5bm26KGM5omn6KGM77yM6L+Z5piv5LiA5LiqQ1BV55u45YWz55qEcXVldWXjgII8L2xpPiA8bGk+5oqK5Lyg5YWl55qEIG5vZGVfdGFzayDmj5LlhaXliLAgY3B1X3JlYWR5X3F1ZXVl44CCPC9saT4gPGxpPuayv+edgOWPjeWQkeiuoeeul+WbvuS7juaguemDqOW8gOWni++8jOS4gOebtOiuoeeul+WIsOWPtuWtkOiKgueCueOAgjwvbGk+IDxsaT4gPHVsPiA8bGk+IDxwPui/memHjOWPtuWtkOiKgueCuemDveaYryBBY2N1bXVsYXRlR3JhZCDmiJbogIUgUmVjdlJwY0JhY2t3YXJk44CCPC9wPiA8L2xpPiA8bGk+IDxwPuWmguaenOaYr+S4remXtOiKgueCue+8jOWImeato+W4uOiuoeeul+OAgjwvcD4gPC9saT4gPGxpPiA8cD48dT7lpoLmnpzmmK8gUmVjdlJwY0JhY2t3YXJkIOWImeS8mue7meWvueW6lOeahOS4i+a4uOiKgueCueWPkemAgSBSUEMg5raI5oGvPC91PuOAgjwvcD4gPC9saT4gPGxpPiA8cD48dT7lpoLmnpzmmK8gQWNjdW11bGF0ZUdyYWTvvIzliJnlnKjkuIrkuIvmlofntK/np6/moq/luqY8L3U+44CCPC9wPiA8L2xpPiA8L3VsPiA8L2xpPiA8L3VsPiA8cD7lhbfkvZPku6PnoIHlpoLkuIvvvJo8L3A+IDxwcmU+PGNvZGUgPnZvaWQgRGlzdEVuZ2luZTo6ZXhlY3V0ZV9ncmFwaF90YXNrX3VudGlsX3JlYWR5X3F1ZXVlX2VtcHR5KCBOb2RlVGFzayBub2RlX3Rhc2ssIGJvb2wgaW5jcmVtZW50T3V0c3RhbmRpbmdUYXNrcykgeyAvLyDliJ3lp4vljJbljp/nlJ/lvJXmk47nur/nqIsgZW5naW5lXy5pbml0aWFsaXplX2RldmljZV90aHJlYWRzX3Bvb2woKTsgLy8gQ3JlYXRlIGEgcmVhZHkgcXVldWUgcGVyIGNhbGwgdG8gdHJhdmVyc2UgdGhlIGdyYXBoX3Rhc2sgZnJvbSAvLyByb290X3RvX2V4ZWN1dGUgVGhpcyBhbGxvdyBjb25jdXJyZW50IGV4ZWN1dGlvbiBvZiB0aGUgc2FtZSBHcmFwaFRhc2sgZnJvbSAvLyBkaWZmZXJlbnQgdGhyZWFkcyAvLyDmr4/kuKrosIPnlKjlu7rnq4vkuIDkuKogcmVhZHkgcXVldWXvvIznlKjmnaXku45yb290X3RvX2V4ZWN1dGXlvIDlp4vpgY3ljoZncmFwaF90YXNr77yM6L+Z5YWB6K6455So5LiN5ZCM55qE57q/56iL5p2l5a+5R3JhcGhUYXNr5bm26KGM5omn6KGM77yM6L+Z5piv5LiA5LiqQ1BV55u45YWz55qEcXVldWUgc3RkOjpzaGFyZWRfcHRyJmx0O1JlYWR5UXVldWUmZ3Q7IGNwdV9yZWFkeV9xdWV1ZSA9IHN0ZDo6bWFrZV9zaGFyZWQmbHQ7UmVhZHlRdWV1ZSZndDsoKTsgYXV0byBncmFwaF90YXNrID0gbm9kZV90YXNrLmJhc2VfLmxvY2soKTsgaWYgKGdyYXBoX3Rhc2sgPT0gbnVsbHB0cikgeyBMT0coRVJST1IpICZsdDsmbHQ7ICJHcmFwaFRhc2sgaGFzIGV4cGlyZWQgZm9yIE5vZGVUYXNrOiAiICZsdDsmbHQ7IG5vZGVfdGFzay5mbl8tJmd0O25hbWUoKSAmbHQ7Jmx0OyAiLCBza2lwcGluZyBleGVjdXRpb24uIjsgcmV0dXJuOyB9IGNwdV9yZWFkeV9xdWV1ZS0mZ3Q7cHVzaChzdGQ6Om1vdmUobm9kZV90YXNrKSwgaW5jcmVtZW50T3V0c3RhbmRpbmdUYXNrcyk7IHRvcmNoOjphdXRvZ3JhZDo6c2V0X2RldmljZSh0b3JjaDo6YXV0b2dyYWQ6OkNQVV9ERVZJQ0UpOyBncmFwaF90YXNrLSZndDtvd25lcl8gPSB0b3JjaDo6YXV0b2dyYWQ6OkNQVV9ERVZJQ0U7IHdoaWxlICghY3B1X3JlYWR5X3F1ZXVlLSZndDtlbXB0eSgpKSB7IHN0ZDo6c2hhcmVkX3B0ciZsdDtHcmFwaFRhc2smZ3Q7IGxvY2FsX2dyYXBoX3Rhc2s7IHsgLy8gU2NvcGUgdGhpcyBibG9jayBvZiBleGVjdXRpb24gc2luY2UgTm9kZVRhc2sgaXMgbm90IG5lZWRlZCBhZnRlciB0aGlzIC8vIGJsb2NrIGFuZCBjYW4gYmUgZGVhbGxvY2F0ZWQgKHJlbGVhc2UgYW55IHJlZmVyZW5jZXMgdG8gZ3JhZCB0ZW5zb3JzIC8vIGFzIHBhcnQgb2YgaW5wdXRzXykgTm9kZVRhc2sgdGFzayA9IGNwdV9yZWFkeV9xdWV1ZS0mZ3Q7cG9wKCk7IC8vIOWPluWHuuS4gOS4qk5vZGVUYXNrIGlmICghKGxvY2FsX2dyYXBoX3Rhc2sgPSB0YXNrLmJhc2VfLmxvY2soKSkpIHsgY29udGludWU7IH0gaWYgKHRhc2suZm5fICFsb2NhbF9ncmFwaF90YXNrLSZndDtoYXNfZXJyb3JfLmxvYWQoKSkgeyBBdXRvR3JhZE1vZGUgZ3JhZF9tb2RlKGxvY2FsX2dyYXBoX3Rhc2stJmd0O2dyYWRfbW9kZV8pOyB0cnkgeyBHcmFwaFRhc2tHdWFyZCBndWFyZChsb2NhbF9ncmFwaF90YXNrKTsgZW5naW5lXy5ldmFsdWF0ZV9mdW5jdGlvbiggLy8g6L+Z6YeM5Lya6LCD55So5YW35L2TTm9kZeWvueW6lOeahOWHveaVsCBsb2NhbF9ncmFwaF90YXNrLCB0YXNrLmZuXy5nZXQoKSwgdGFzay5pbnB1dHNfLCBjcHVfcmVhZHlfcXVldWUpOyB9IGNhdGNoIChzdGQ6OmV4Y2VwdGlvbiBlKSB7IGVuZ2luZV8udGhyZWFkX29uX2V4Y2VwdGlvbihsb2NhbF9ncmFwaF90YXNrLCB0YXNrLmZuXywgZSk7IC8vIGJyZWFrIHRoZSBsb29wIGluIGVycm9yIHNvIHRoYXQgd2UgaW1tZWRpYXRlbHkgc3RvcCB0aGUgZXhlY3V0aW9uIC8vIG9mIHRoaXMgR3JhcGhUYXNrLCBtYXJrIGl0IGNvbXBsZXRlZCBpZiBuZWNlc3NhcnkgYW5kIHJldHVybiB0aGUgLy8gZnV0dXJlIHdpdGggcHJvcGVyIEVycm9yTWVzc2FnZSBicmVhazsgfSB9IH0gLy8gRGVjcmVtZW50IHRoZSBvdXRzdGFuZGluZyB0YXNrLiAtLWxvY2FsX2dyYXBoX3Rhc2stJmd0O291dHN0YW5kaW5nX3Rhc2tzXzsgLy8g5aSE55CG5LqG5LiA5LiqTm9kZVRhc2sgfSAvLyBDaGVjayBpZiB3ZSd2ZSBjb21wbGV0ZWQgZXhlY3V0aW9uLiBpZiAoZ3JhcGhfdGFzay0mZ3Q7Y29tcGxldGVkKCkpIHsgLy8gV2UgZG9uJ3QgbmVlZCB0byBleHBsaWNpdGx5IG5vdGlmeSB0aGUgb3duZXIgdGhyZWFkLCBzaW5jZSAvLyAnbWFya19hc19jb21wbGV0ZWRfYW5kX3J1bl9wb3N0X3Byb2Nlc3NpbmcnIHdvdWxkIG1hcmsgdGhlIEZ1dHVyZSBhcyAvLyBjb21wbGV0ZWQgYW5kIHRoaXMgd291bGQgbm90aWZ5IHRoZSBvd25lciB0aHJlYWQgdGhhdCB0aGUgdGFzayBoYXMgYmVlbiAvLyBjb21wbGV0ZWQuIGdyYXBoX3Rhc2stJmd0O21hcmtfYXNfY29tcGxldGVkX2FuZF9ydW5fcG9zdF9wcm9jZXNzaW5nKCk7IH0gfSA8L2NvZGU+PC9wcmU+IDxwPuWPpuWklu+8jOS4gOWFseacieS4ieS4quWcsOaWueiwg+eUqCBleGVjdXRlX2dyYXBoX3Rhc2tfdW50aWxfcmVhZHlfcXVldWVfZW1wdHnjgII8L3A+IDxvbD4gPGxpPnJ1bkVuZ2luZUFuZEFjY3VtdWxhdGVHcmFkaWVudHMg5Lya6LCD55So77yMPHU+6L+Z6YeM5bCx5piv55So5oi35Li75Yqo6LCD55SoIGJhY2t3YXJkIOeahOaDheW9ojwvdT7vvIzlsLHmmK/mnKzoioLku4vnu43nmoTjgII8L2xpPiA8bGk+ZXhlY3V0ZVNlbmRGdW5jdGlvbkFzeW5jIOS8muiwg+eUqO+8jDx1Pui/memHjOWvueW6lOS6huafkOiKgueCueS7juWPjeWQkeS8oOaSreS4iuS4gOiKgueCueaOpeWPl+WIsOair+W6puS5i+WQjueahOaTjeS9nDwvdT7vvIzmiJHku6zkvJrlnKjkuIvkuIDoioLku4vnu43jgII8L2xpPiA8bGk+Z2xvYmFsQ3B1VGhyZWFkIOS8muiwg+eUqO+8jOi/meaYr0NQVeW3peS9nOS4k+eUqOe6v+eoi++8jOaIkeS7rOmprOS4iuS8muS7i+e7jeOAgjwvbGk+IDxsaT7lnKggRW5naW5lLmV2YWx1YXRlX2Z1bmN0aW9uIOS5i+S4re+8jOS8mumSiOWvuSBBY2N1bXVsYXRlR3JhZCDmnaXntK/np6/moq/luqbjgII8L2xpPiA8bGk+5ZyoIEVuZ2luZS5ldmFsdWF0ZV9mdW5jdGlvbiDkuYvkuK3vvIzkvJrosIPnlKggUmVjdlJwY0JhY2t3YXJkIOadpeWQkeWPjeWQkeS8oOaSreS4i+a4uOWPkemAgea2iOaBr+OAgjwvbGk+IDwvb2w+IDxwPuaIkeS7rOaAu+e7k+S4gOS4i+WHoOS4quiuoeeul+air+W6pueahOa1geeoi++8jOWIhuWIq+WvueW6lOS4i+mdouS4ieS4quaVsOWtl+OAgjwvcD4gPHByZT48Y29kZSA+IFVzZXIgVHJhaW5pbmcgU2NyaXB0IFJQQyBCQUNLV0FSRF9BVVRPR1JBRF9SRVEgKyArIHwgfCB8IDEgfCAyIHYgdiBiYWNrd2FyZCBSZXF1ZXN0Q2FsbGJhY2tOb1B5dGhvbi5wcm9jZXNzUnBjICsgKyB8IHwgfCB8IHYgdiBEaXN0RW5naW5lLmV4ZWN1dGUgUmVxdWVzdENhbGxiYWNrTm9QeXRob24ucHJvY2Vzc0JhY2t3YXJkQXV0b2dyYWRSZXEgKyArIHwgfCB8IHwgfCB2IHwgKy0tLS0tLS0tLS0rIERpc3RFbmdpbmUuZXhlY3V0ZVNlbmRGdW5jdGlvbkFzeW5jIHwgfCArIHwgfCB8IHYgdiB8IERpc3RFbmdpbmUuY29tcHV0ZURlcGVuZGVuY2llcyB8IHwgfCB8IHwgdiB8IERpc3RFbmdpbmUucnVuRW5naW5lQW5kQWNjdW11bGF0ZUdyYWRpZW50cyB8IERpc3RFbmdpbmUuZ2xvYmFsQ3B1VGhyZWFkICsgfCArIHwgKy0tLS0tLS0tLS0tLS0tLS0tLSsgfCB8IHwgfCAzIHwgfCArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyB8IHwgfCB8IHwgfCB2IHYgdiBEaXN0RW5naW5lLmV4ZWN1dGVfZ3JhcGhfdGFza191bnRpbF9yZWFkeV9xdWV1ZV9lbXB0eSArIHwgfCB2IERpc3RFbmdpbmUuZXZhbHVhdGVfZnVuY3Rpb24gKyB8ICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgfCB8IHwgNCBBY2N1bXVsYXRlR3JhZCB8IDUgUmVjdlJwY0JhY2t3YXJkIHYgdiAoKmhvb2spKGNhcHR1cmVkX2dyYWQpIGNhbGxfZnVuY3Rpb24oZ3JhcGhfdGFzaywgZnVuYywgaW5wdXRzKSA8L2NvZGU+PC9wcmU+IDxoMyA+Mi4zIGV2YWx1YXRlX2Z1bmN0aW9uPC9oMz4gPHA+5LiK6Z2i5Luj56CB5LmL5Lit77yM5a6e6ZmF5LiK5Lya6LCD55So5Y6f55Sf5byV5pOO55qEIGV2YWx1YXRlX2Z1bmN0aW9uIOadpeWujOaIkOaTjeS9nOOAgjwvcD4gPHA+5oiR5Lus55yL55yL5aaC5L2V5L2/55SoIDxjb2RlPmV4ZWNfaW5mb188L2NvZGU+77yM5aaC5p6c5rKh5pyJ6K6+572u5Li66ZyA6KaB5omn6KGM77yM5YiZ5bCx5LiN5aSE55CG44CC5Zyo5q2k5aSE77yM5oiR5Lus5Y+v5Lul55yL5YiwIOS4iuaWh+aPkOWIsOeahDxjb2RlPnJlY3ZCYWNrd2FyZEVkZ2VzPC9jb2RlPiDlpoLkvZXkuI4gPGNvZGU+ZXhlY19pbmZvXzwvY29kZT4g5Lqk5LqS44CCPC9wPiA8YmxvY2txdW90ZT4gPHA+6YGN5Y6GIHJlY3ZCYWNrd2FyZEVkZ2Vz77yM5a+55LqO5q+P5LiqIHJlY3ZCYWNrd2FyZO+8jOWcqCBHcmFwaFRhc2suZXhlY19pbmZvXyDkuYvkuK3lr7nlupTpobnkuYvkuIrorr7mraLkuLrpnIDopoHmiafooYzjgII8L3A+IDwvYmxvY2txdW90ZT4gPHA+5YW35L2T5Luj56CB5aaC5LiL77yM6L+Z6YeM5Lya77yaPC9wPiA8dWw+IDxsaT7pkojlr7kgQWNjdW11bGF0ZUdyYWQg5p2l57Sv56ev5qKv5bqm44CCPC9saT4gPGxpPuiwg+eUqCBSZWN2UnBjQmFja3dhcmQg5p2l5ZCR5Y+N5ZCR5Lyg5pKt5LiL5ri45Y+R6YCB5raI5oGv44CCPC9saT4gPC91bD4gPHByZT48Y29kZSA+dm9pZCBFbmdpbmU6OmV2YWx1YXRlX2Z1bmN0aW9uKCBzdGQ6OnNoYXJlZF9wdHImbHQ7R3JhcGhUYXNrJmd0OyBncmFwaF90YXNrLCBOb2RlKiBmdW5jLCBJbnB1dEJ1ZmZlciBpbnB1dHMsIGNvbnN0IHN0ZDo6c2hhcmVkX3B0ciZsdDtSZWFkeVF1ZXVlJmd0OyBjcHVfcmVhZHlfcXVldWUpIHsgLy8gSWYgZXhlY19pbmZvXyBpcyBub3QgZW1wdHksIHdlIGhhdmUgdG8gaW5zdHJ1bWVudCB0aGUgZXhlY3V0aW9uIGF1dG8gZXhlY19pbmZvXyA9IGdyYXBoX3Rhc2stJmd0O2V4ZWNfaW5mb187IGlmICghZXhlY19pbmZvXy5lbXB0eSgpKSB7IGF1dG8gZm5faW5mbyA9IGV4ZWNfaW5mb18uYXQoZnVuYyk7IGlmIChhdXRvKiBjYXB0dXJlX3ZlYyA9IGZuX2luZm8uY2FwdHVyZXNfLmdldCgpKSB7IC8vIExvY2sgbXV0ZXggZm9yIHdyaXRpbmcgdG8gZ3JhcGhfdGFzay0mZ3Q7Y2FwdHVyZWRfdmFyc18uIHN0ZDo6bG9ja19ndWFyZCZsdDtzdGQ6Om11dGV4Jmd0OyBsb2NrKGdyYXBoX3Rhc2stJmd0O211dGV4Xyk7IGZvciAoY29uc3QgYXV0byBjYXB0dXJlIDogKmNhcHR1cmVfdmVjKSB7IGF1dG8gY2FwdHVyZWRfZ3JhZCA9IGdyYXBoX3Rhc2stJmd0O2NhcHR1cmVkX3ZhcnNfW2NhcHR1cmUub3V0cHV0X2lkeF9dOyBjYXB0dXJlZF9ncmFkID0gaW5wdXRzW2NhcHR1cmUuaW5wdXRfaWR4X107IGZvciAoYXV0byBob29rIDogY2FwdHVyZS5ob29rc18pIHsgY2FwdHVyZWRfZ3JhZCA9ICgqaG9vaykoY2FwdHVyZWRfZ3JhZCk7IC8v6L+Z6YeM6LCD55SoIGhvb2vvvIzlsLHmmK8gRGlzdEFjY3VtdWxhdGVHcmFkQ2FwdHVyZUhvb2sg55qEIG9wZXJhdG9yKCnvvIxjYXB0dXJlZF9ncmFkIOWwseaYr+e0r+enr+eahOair+W6piB9IH0gfSBpZiAoIWZuX2luZm8ubmVlZGVkXykgeyAvLyBTa2lwIGV4ZWN1dGlvbiBpZiB3ZSBkb24ndCBuZWVkIHRvIGV4ZWN1dGUgdGhlIGZ1bmN0aW9uLiByZXR1cm47IC8vIOWmguaenOayoeacieiuvue9rumcgOimgeaJp+ihjO+8jOWImeebtOaOpei/lOWbnuOAgnJlY3ZCYWNrd2FyZCDkvJrorr7nva7pnIDopoHmiafooYwgfSB9IC8vIOi/memHjOWwseaYr+iwg+eUqCByZWN2QmFja3dhcmQgYXV0byBvdXRwdXRzID0gY2FsbF9mdW5jdGlvbihncmFwaF90YXNrLCBmdW5jLCBpbnB1dHMpOyAvLyDlkI7nu63ku6PnoIHnnIHnlaUgPC9jb2RlPjwvcHJlPiA8aDMgPjIuNCBnbG9iYWxDcHVUaHJlYWQ8L2gzPiA8cD5nbG9iYWxDcHVUaHJlYWQg5Y+v5Lul5Y+C6KeB5LiK5paH55qEIFtHUFUgdG8gQ1BVIGNvbnRpbnVhdGlvbnNdIOS4gOiKgu+8jGdsb2JhbENwdVRocmVhZOaYr+W3peS9nOe6v+eoi++8jOWFtuWwseaYr+S7jiByZWFkeSBxdWV1ZSDph4zpnaLlvLnlh7ogTm9kZVRhc2vvvIznhLblkI7miafooYzjgII8L3A+IDxwPuWvueS6jmdsb2JhbENwdVRocmVhZO+8jOWFtuWPguaVsCByZWFkeV9xdWV1ZSDmmK8gZ2xvYmFsX2NwdV9yZWFkeV9xdWV1ZV88L3A+IDxwcmU+PGNvZGUgPnZvaWQgRGlzdEVuZ2luZTo6Z2xvYmFsQ3B1VGhyZWFkKCBjb25zdCBzdGQ6OnNoYXJlZF9wdHImbHQ7UmVhZHlRdWV1ZSZndDsgcmVhZHlfcXVldWUpIHsgd2hpbGUgKHRydWUpIHsgTm9kZVRhc2sgdGFzayA9IHJlYWR5X3F1ZXVlLSZndDtwb3AoKTsgaWYgKHRhc2suaXNTaHV0ZG93blRhc2tfKSB7IC8vIE5lZWQgdG8gc2h1dGRvd24gdGhpcyB0aHJlYWQuIGJyZWFrOyB9IGF1dG8gZ3JhcGhUYXNrID0gdGFzay5iYXNlXy5sb2NrKCk7IGlmIChncmFwaFRhc2sgPT0gbnVsbHB0cikgeyAvLyBHcmFwaFRhc2sgaGFzIGV4cGlyZWQsIGlnbm9yZSBhbmQgY29udGludWUgcHJvY2Vzc2luZy4gY29udGludWU7IH0gLy8gTGF1bmNoIHRoZSBleGVjdXRpb24gb24gYSBKSVQgdGhyZWFkLiBhdDo6bGF1bmNoKFt0aGlzLCBncmFwaFRhc2ssIGdyYXBoUm9vdCA9IHRhc2suZm5fLCB2YXJpYWJsZXMgPSBJbnB1dEJ1ZmZlcjo6dmFyaWFibGVzKHN0ZDo6bW92ZSh0YXNrLmlucHV0c18pKV0oKSBtdXRhYmxlIHsgSW5wdXRCdWZmZXIgaW5wdXRzKHZhcmlhYmxlcy5zaXplKCkpOyBmb3IgKHNpemVfdCBpID0gMDsgaSAmbHQ7IHZhcmlhYmxlcy5zaXplKCk7IGkrKykgeyBpbnB1dHMuYWRkKGksIHN0ZDo6bW92ZSh2YXJpYWJsZXNbaV0pLCBjMTA6Om51bGxvcHQsIGMxMDo6bnVsbG9wdCk7IH0gZXhlY3V0ZV9ncmFwaF90YXNrX3VudGlsX3JlYWR5X3F1ZXVlX2VtcHR5KCAvLyDov5nph4zkvJrosIPnlKggLypub2RlX3Rhc2sqLyBOb2RlVGFzayhncmFwaFRhc2ssIGdyYXBoUm9vdCwgc3RkOjptb3ZlKGlucHV0cykpLCAvKmluY3JlbWVudE91dHN0YW5kaW5nVGFza3MqLyBmYWxzZSk7IH0pOyB9IH0gPC9jb2RlPjwvcHJlPiA8cD7lr7nkuo7mma7pgJrlvJXmk47kuZ/kvJrorr7nva7kuIDkuKogY3B1IOS4k+eUqCBxdWV1ZeOAgjwvcD4gPHByZT48Y29kZSA+YXV0byBncmFwaF90YXNrID0gc3RkOjptYWtlX3NoYXJlZCZsdDtHcmFwaFRhc2smZ3Q7KCAvKiBrZWVwX2dyYXBoICovIGtlZXBfZ3JhcGgsIC8qIGNyZWF0ZV9ncmFwaCAqLyBjcmVhdGVfZ3JhcGgsIC8qIGRlcHRoICovIG5vdF9yZWVudHJhbnRfYmFja3dhcmRfY2FsbCA/IDAgOiB0b3RhbF9kZXB0aCArIDEsIC8qIGNwdV9yZWFkeV9xdWV1ZSAqLyBsb2NhbF9yZWFkeV9xdWV1ZSk7IDwvY29kZT48L3ByZT4gPGgzID4yLjUg5bCP57uTPC9oMz4gPHA+5a+55LqO5YiG5biD5byP5byV5pOO77yM5LiO5pmu6YCa5byV5pOO5Zyo6K6h566X6YOo5YiG5Li76KaB5LiN5ZCM5LmL5aSE5Li677yaPC9wPiA8dWw+IDxsaT4gPHA+PHU+5aaC5p6c5pivIFJlY3ZScGNCYWNrd2FyZCDliJnkvJrnu5nlr7nlupTnmoTkuIvmuLjoioLngrnlj5HpgIEgUlBDIOa2iOaBrzwvdT7jgII8L3A+IDwvbGk+IDxsaT4gPHA+PHU+5aaC5p6c5pivIEFjY3VtdWxhdGVHcmFk77yM5YiZ5Zyo5LiK5LiL5paH57Sv56ev5qKv5bqmPC91PuOAgjwvcD4gPC9saT4gPC91bD4gPHA+5omA5Lul5oiR5Lus5o6l5LiL5p2l55yL55yL5YW35L2T6L+Z5Lik6YOo5YiG5aaC5L2V5aSE55CG44CCPC9wPiA8aDIgPjB4MDMgUlBD6LCD55SoPC9oMj4gPHA+5Zyo5LmL5YmN5paH56ug5Lit77yM5oiR5Lus55yL5Yiw5LqG5o6l5Y+X5pa55aaC5L2V5aSE55CG5Y+N5ZCR5Lyg5pKtIFJQQyDosIPnlKjvvIzmiJHku6zmjqXkuIvmnaXnnIvnnIvlvJXmk47lpoLkvZXlj5Hotbflj43lkJHkvKDmkq0gUlBDIOiwg+eUqO+8jOWwseaYr+WmguS9leiwg+eUqCByZWN2IOaWueazleOAgjwvcD4gPHA+6L+Z6YeM5bCx6YCC55So5LqO5LiL6Z2id29ya2VyIDAg6LCD55SoIHJlY3Yg77yM5omn6KGM5p2l5YiwIHdvcmtlciAxIOi/meenjeaDheWGte+8jOWvueW6lOiuvuiuoeaWh+aho+S4reWmguS4i+OAgjwvcD4gPGJsb2NrcXVvdGU+IDxwPuW9kyBhdXRvZ3JhZCDlvJXmk47miafooYzor6U8Y29kZT5yZWN2PC9jb2RlPuWHveaVsOaXtu+8jOivpTxjb2RlPnJlY3Y8L2NvZGU+IOWHveaVsOmAmui/hyBSUEMg5bCG6L6T5YWl5qKv5bqm5Y+R6YCB5Yiw6YCC5b2T55qEd29ya2Vy44CC5q+P5LiqPGNvZGU+cmVjdjwvY29kZT7lh73mlbDpg73nn6XpgZPnm67moIcgd29ya2VyIGlk77yM5Zug5Li65a6D6KKr6K6w5b2V5Li65YmN5ZCR5Lyg5pKt55qE5LiA6YOo5YiG44CC6YCa6L+HPGNvZGU+YXV0b2dyYWRfY29udGV4dF9pZDwvY29kZT7lkowgPGNvZGU+YXV0b2dyYWRfbWVzc2FnZV9pZDwvY29kZT4g6K+lPGNvZGU+cmVjdjwvY29kZT7lh73mlbDooqvlj5HpgIHliLDov5znqIvkuLvmnLrjgII8L3A+IDwvYmxvY2txdW90ZT4gPHA+5oiR5Lus5bCx55yL55yL5aaC5L2V5omn6KGMIHJlY3Yg5Ye95pWw44CCPC9wPiA8cD48dT7lhbfkvZPnu5PlkIjliLDliIbluIPlvI/lvJXmk47vvIzlsLHmmK/lvZPlvJXmk47lj5HnjrDmn5DkuIDkuKogTm9kZSDmmK8gUmVjdlJwY0JhY2t3YXJk77yM5bCx6LCD55So5YW2IGFwcGx5IOWHveaVsDwvdT7jgII8L3A+IDxwcmU+PGNvZGUgPnZvaWQgRW5naW5lOjpldmFsdWF0ZV9mdW5jdGlvbiggc3RkOjpzaGFyZWRfcHRyJmx0O0dyYXBoVGFzayZndDsgZ3JhcGhfdGFzaywgTm9kZSogZnVuYywgSW5wdXRCdWZmZXIgaW5wdXRzLCBjb25zdCBzdGQ6OnNoYXJlZF9wdHImbHQ7UmVhZHlRdWV1ZSZndDsgY3B1X3JlYWR5X3F1ZXVlKSB7IC8vIElmIGV4ZWNfaW5mb18gaXMgbm90IGVtcHR5LCB3ZSBoYXZlIHRvIGluc3RydW1lbnQgdGhlIGV4ZWN1dGlvbiBhdXRvIGV4ZWNfaW5mb18gPSBncmFwaF90YXNrLSZndDtleGVjX2luZm9fOyBpZiAoIWV4ZWNfaW5mb18uZW1wdHkoKSkgeyAvLyDnnIHnlaXkuobmoq/luqbntK/np6/pg6jliIbku6PnoIHvvIzlhbfkvZPlj6/ku6Xlj4Lop4HkuIrpnaLnq6DoioIgaWYgKCFmbl9pbmZvLm5lZWRlZF8pIHsgLy8gU2tpcCBleGVjdXRpb24gaWYgd2UgZG9uJ3QgbmVlZCB0byBleGVjdXRlIHRoZSBmdW5jdGlvbi4gcmV0dXJuOyAvLyDlpoLmnpzmsqHmnInorr7nva7pnIDopoHmiafooYzvvIzliJnnm7TmjqXov5Tlm57jgIJyZWN2QmFja3dhcmQg5Lya6K6+572u6ZyA6KaB5omn6KGMIH0gfSAvLyDov5nph4zlsLHmmK/osIPnlKggcmVjdkJhY2t3YXJkLmFwcGx5IOWHveaVsCBhdXRvIG91dHB1dHMgPSBjYWxsX2Z1bmN0aW9uKGdyYXBoX3Rhc2ssIGZ1bmMsIGlucHV0cyk7IC8vIOWQjue7reS7o+eggeecgeeVpSA8L2NvZGU+PC9wcmU+IDxoMyA+My4xIFJlY3ZScGNCYWNrd2FyZDwvaDM+IDxoNCA+My4xLjEg5a6a5LmJPC9oND4gPHA+UmVjdlJwY0JhY2t3YXJkIOWumuS5ieWmguS4i++8jDwvcD4gPHByZT48Y29kZSA+Y2xhc3MgVE9SQ0hfQVBJIFJlY3ZScGNCYWNrd2FyZCA6IHB1YmxpYyB0b3JjaDo6YXV0b2dyYWQ6Ok5vZGUgeyBwdWJsaWM6IGV4cGxpY2l0IFJlY3ZScGNCYWNrd2FyZCggY29uc3QgQXV0b2dyYWRNZXRhZGF0YSBhdXRvZ3JhZE1ldGFkYXRhLCBzdGQ6OnNoYXJlZF9wdHImbHQ7RGlzdEF1dG9ncmFkQ29udGV4dCZndDsgYXV0b2dyYWRDb250ZXh0LCBycGM6Ondvcmtlcl9pZF90IGZyb21Xb3JrZXJJZCwgc3RkOjp1bm9yZGVyZWRfbWFwJmx0O2MxMDo6RGV2aWNlLCBjMTA6OkRldmljZSZndDsgZGV2aWNlTWFwKTsgdG9yY2g6OmF1dG9ncmFkOjp2YXJpYWJsZV9saXN0IGFwcGx5KCB0b3JjaDo6YXV0b2dyYWQ6OnZhcmlhYmxlX2xpc3QgZ3JhZHMpIG92ZXJyaWRlOyBwcml2YXRlOiBjb25zdCBBdXRvZ3JhZE1ldGFkYXRhIGF1dG9ncmFkTWV0YWRhdGFfOyAvLyBIb2xkIGEgd2VhayByZWZlcmVuY2UgdG8gdGhlIGF1dG9ncmFkIGNvbnRleHQgdG8gYXZvaWQgY2lyY3VsYXIgLy8gZGVwZW5kZW5jaWVzIHdpdGggdGhlIGNvbnRleHQgKHNpbmNlIGl0IGhvbGRzIGEgcmVmZXJlbmNlIHRvIC8vIFJlY3ZScGNCYWNrd2FyZCkuIHN0ZDo6d2Vha19wdHImbHQ7RGlzdEF1dG9ncmFkQ29udGV4dCZndDsgYXV0b2dyYWRDb250ZXh0XzsgLy8gVGhlIHdvcmtlciBpZCBmcm9tIHdoaWNoIHRoZSBSUEMgd2FzIHJlY2VpdmVkLiBEdXJpbmcgdGhlIGJhY2t3YXJkIHBhc3MsIC8vIHdlIG5lZWQgdG8gcHJvcGFnYXRlIHRoZSBncmFkaWVudHMgdG8gdGhpcyB3b3JrZXJJZC4gcnBjOjp3b3JrZXJfaWRfdCBmcm9tV29ya2VySWRfOyAvLyBEZXZpY2UgbWFwcGluZyBmb3IgdGVuc29ycyBzZW50IG92ZXIgUlBDLiBjb25zdCBzdGQ6OnVub3JkZXJlZF9tYXAmbHQ7YzEwOjpEZXZpY2UsIGMxMDo6RGV2aWNlJmd0OyBkZXZpY2VNYXBfOyB9OyA8L2NvZGU+PC9wcmU+IDxoNCA+My4xLjIg5p6E5bu6PC9oND4gPHA+5p6E6YCg5Ye95pWw5aaC5LiL44CCPC9wPiA8cHJlPjxjb2RlID5SZWN2UnBjQmFja3dhcmQ6OlJlY3ZScGNCYWNrd2FyZCggY29uc3QgQXV0b2dyYWRNZXRhZGF0YSBhdXRvZ3JhZE1ldGFkYXRhLCBDb250ZXh0UHRyIGF1dG9ncmFkQ29udGV4dCwgcnBjOjp3b3JrZXJfaWRfdCBmcm9tV29ya2VySWQsIHN0ZDo6dW5vcmRlcmVkX21hcCZsdDtjMTA6OkRldmljZSwgYzEwOjpEZXZpY2UmZ3Q7IGRldmljZU1hcCkgOiBhdXRvZ3JhZE1ldGFkYXRhXyhhdXRvZ3JhZE1ldGFkYXRhKSwgYXV0b2dyYWRDb250ZXh0XyhzdGQ6Om1vdmUoYXV0b2dyYWRDb250ZXh0KSksIGZyb21Xb3JrZXJJZF8oZnJvbVdvcmtlcklkKSwgZGV2aWNlTWFwXyhzdGQ6Om1vdmUoZGV2aWNlTWFwKSkge30gPC9jb2RlPjwvcHJlPiA8aDQgPjMuMS4zIGFwcGx5PC9oND4gPHA+dG9yY2gvY3NyYy9kaXN0cmlidXRlZC9hdXRvZ3JhZC9mdW5jdGlvbnMvcmVjdnJwY19iYWNrd2FyZC5jcHAg5a6a5LmJ5LqG5YW2IGFwcGx5IOWHveaVsO+8jOWFtuS9nOeUqOWwseaYr++8mjwvcD4gPHVsPiA8bGk+5oqK5Lyg5YWl55qE5qKv5bqmIGdyYWRzIOaUvuWFpW91dHB1dEdyYWRz77yM5Zug5Li66KaB6L6T5Ye657uZ5LiL5LiA546v6IqC44CCPC9saT4gPGxpPuaehOW7uiBQcm9wYWdhdGVHcmFkaWVudHNSZXHvvIzov5nlsLHmmK8gQkFDS1dBUkRfQVVUT0dSQURfUkVR44CCPC9saT4gPGxpPuWPkemAgSBSUEMg57uZ5LiL5LiA546v6IqC44CCPC9saT4gPC91bD4gPHByZT48Y29kZSA+dmFyaWFibGVfbGlzdCBSZWN2UnBjQmFja3dhcmQ6OmFwcGx5KHZhcmlhYmxlX2xpc3QgZ3JhZHMpIHsgc3RkOjp2ZWN0b3ImbHQ7VmFyaWFibGUmZ3Q7IG91dHB1dEdyYWRzOyBmb3IgKHNpemVfdCBpID0gMDsgaSAmbHQ7IGdyYWRzLnNpemUoKTsgaSsrKSB7IC8vIOS4i+mdouWwseaYr+aKiuS8oOWFpeeahOair+W6piBncmFkcyDmlL7lhaVvdXRwdXRHcmFkcyBjb25zdCBhdXRvIGdyYWQgPSBncmFkc1tpXTsgaWYgKGdyYWQuZGVmaW5lZCgpKSB7IG91dHB1dEdyYWRzLmVtcGxhY2VfYmFjayhncmFkKTsgfSBlbHNlIHsgLy8gUHV0IGluIHplcm9zIGZvciBhIHRlbnNvciB3aXRoIG5vIGdyYWQuIG91dHB1dEdyYWRzLmVtcGxhY2VfYmFjayhpbnB1dF9tZXRhZGF0YShpKS56ZXJvc19saWtlKCkpOyB9IH0gYXV0byBzaGFyZWRDb250ZXh0ID0gYXV0b2dyYWRDb250ZXh0Xy5sb2NrKCk7IC8vIFNlbmQgdGhlIGdyYWRpZW50cyBvdmVyIHRoZSB3aXJlIGFuZCByZWNvcmQgdGhlIGZ1dHVyZSBpbiB0aGUgYXV0b2dyYWQgLy8gY29udGV4dC4gUHJvcGFnYXRlR3JhZGllbnRzUmVxIGdyYWRDYWxsKCAvLyDmnoTlu7ogUHJvcGFnYXRlR3JhZGllbnRzUmVxIGF1dG9ncmFkTWV0YWRhdGFfLCBvdXRwdXRHcmFkcywgc2hhcmVkQ29udGV4dC0mZ3Q7cmV0cmlldmVHcmFwaFRhc2soKS0mZ3Q7a2VlcF9ncmFwaF8pOyAvLyBTZW5kIHRoZSBncmFkaWVudHMgb3ZlciB0byB0aGUgYXBwcm9wcmlhdGUgbm9kZS4gYXV0byBycGNBZ2VudCA9IHJwYzo6UnBjQWdlbnQ6OmdldEN1cnJlbnRScGNBZ2VudCgpOyBhdXRvIGppdEZ1dHVyZSA9IHJwY0FnZW50LSZndDtzZW5kKCAvLyDlj5HpgIEgUlBDIHJwY0FnZW50LSZndDtnZXRXb3JrZXJJbmZvKGZyb21Xb3JrZXJJZF8pLCBzdGQ6Om1vdmUoZ3JhZENhbGwpLnRvTWVzc2FnZSgpLCAvLyDosIPnlKjkuoZ0b01lc3NhZ2VJbXBsIHJwYzo6a1Vuc2V0UnBjVGltZW91dCwgZGV2aWNlTWFwXyk7IC8vIFJlY29yZCB0aGUgZnV0dXJlIGluIHRoZSBjb250ZXh0LiBzaGFyZWRDb250ZXh0LSZndDthZGRPdXRzdGFuZGluZ1JwYyhqaXRGdXR1cmUpOyAvLyAncmVjdicgZnVuY3Rpb24gc2VuZHMgdGhlIGdyYWRpZW50cyBvdmVyIHRoZSB3aXJlIHVzaW5nIFJQQywgaXQgZG9lc24ndCAvLyBuZWVkIHRvIHJldHVybiBhbnl0aGluZyBmb3IgYW55IGRvd25zdHJlYW0gYXV0b2dyYWQgZnVuY3Rpb24uIHJldHVybiB2YXJpYWJsZV9saXN0KCk7IH0gPC9jb2RlPjwvcHJlPiA8cD7lm6DkuLrov5nph4zlj5HpgIHkuoYgUHJvcGFnYXRlR3JhZGllbnRzUmVx77yM5omA5Lul5oiR5Lus5o6l552A55yL44CCPC9wPiA8aDMgPjMuMiBQcm9wYWdhdGVHcmFkaWVudHNSZXE8L2gzPiA8aDQgPjMuMi4xIOWumuS5iTwvaDQ+IDxwPlByb3BhZ2F0ZUdyYWRpZW50c1JlcSDmianlsZXkuoYgUnBjQ29tbWFuZEJhc2XjgII8L3A+IDxwcmU+PGNvZGUgPi8vIFVzZWQgdG8gcHJvcGFnYXRlIGdyYWRpZW50cyBmcm9tIG9uZSBub2RlIHRvIGFub3RoZXIgZHVyaW5nIGEgZGlzdHJpYnV0ZWQgLy8gYmFja3dhcmRzIHBhc3MuIFRoaXMgUlBDIGNhbGwgaXMgaW52b2tlZCB3aGVuIHdlIGhpdCBhIGByZWN2YCBhdXRvZ3JhZCAvLyBmdW5jdGlvbiBkdXJpbmcgYmFja3dhcmQgcGFzcyBleGVjdXRpb24uIGNsYXNzIFRPUkNIX0FQSSBQcm9wYWdhdGVHcmFkaWVudHNSZXEgOiBwdWJsaWMgcnBjOjpScGNDb21tYW5kQmFzZSB7IHB1YmxpYzogUHJvcGFnYXRlR3JhZGllbnRzUmVxKCBjb25zdCBBdXRvZ3JhZE1ldGFkYXRhIGF1dG9ncmFkTWV0YWRhdGEsIHN0ZDo6dmVjdG9yJmx0O3RvcmNoOjphdXRvZ3JhZDo6VmFyaWFibGUmZ3Q7IGdyYWRzLCBib29sIHJldGFpbkdyYXBoID0gZmFsc2UpOyBjb25zdCBBdXRvZ3JhZE1ldGFkYXRhIGdldEF1dG9ncmFkTWV0YWRhdGEoKTsgY29uc3Qgc3RkOjp2ZWN0b3ImbHQ7dG9yY2g6OmF1dG9ncmFkOjpWYXJpYWJsZSZndDsgZ2V0R3JhZHMoKTsgLy8gU2VyaWFsaXphdGlvbiBhbmQgZGVzZXJpYWxpemF0aW9uIG1ldGhvZHMuIHJwYzo6TWVzc2FnZSB0b01lc3NhZ2VJbXBsKCkgb3ZlcnJpZGU7IHN0YXRpYyBzdGQ6OnVuaXF1ZV9wdHImbHQ7UHJvcGFnYXRlR3JhZGllbnRzUmVxJmd0OyBmcm9tTWVzc2FnZSggY29uc3QgcnBjOjpNZXNzYWdlIG1lc3NhZ2UpOyAvLyBXaGV0aGVyIG9yIG5vdCB0byByZXRhaW4gdGhlIGF1dG9ncmFkIGdyYXBoLiBib29sIHJldGFpbkdyYXBoKCk7IHByaXZhdGU6IEF1dG9ncmFkTWV0YWRhdGEgYXV0b2dyYWRNZXRhZGF0YV87IHN0ZDo6dmVjdG9yJmx0O3RvcmNoOjphdXRvZ3JhZDo6VmFyaWFibGUmZ3Q7IGdyYWRzXzsgYm9vbCByZXRhaW5HcmFwaF87IH07IDwvY29kZT48L3ByZT4gPHA+5YW2IHRvTWVzc2FnZUltcGwg5oyH5piO5LqG5pys5raI5oGv5pivIEJBQ0tXQVJEX0FVVE9HUkFEX1JFUeOAgjwvcD4gPHByZT48Y29kZSA+TWVzc2FnZSBQcm9wYWdhdGVHcmFkaWVudHNSZXE6OnRvTWVzc2FnZUltcGwoKSB7IHN0ZDo6dmVjdG9yJmx0O2F0OjpJVmFsdWUmZ3Q7IGl2YWx1ZXM7IC8vIEFkZCBhbGwgdGhlIGdyYWQgdGVuc29ycy4gZm9yIChjb25zdCBhdXRvIGdyYWQgOiBncmFkc18pIHsgaXZhbHVlcy5lbXBsYWNlX2JhY2soZ3JhZCk7IH0gLy8gTm93IGFkZCBhdXRvZ3JhZCBtZXRhZGF0YS4gaXZhbHVlcy5lbXBsYWNlX2JhY2soYXV0b2dyYWRNZXRhZGF0YV8uYXV0b2dyYWRDb250ZXh0SWQpOyBpdmFsdWVzLmVtcGxhY2VfYmFjayhhdXRvZ3JhZE1ldGFkYXRhXy5hdXRvZ3JhZE1lc3NhZ2VJZCk7IC8vIEFkZCByZXRhaW4gZ3JhcGguIGl2YWx1ZXMuZW1wbGFjZV9iYWNrKHJldGFpbkdyYXBoXyk7IC8vIE5vdyBwaWNrbGUgdXNpbmcgSklUIHBpY2tsZXIuIHN0ZDo6dmVjdG9yJmx0O3RvcmNoOjpUZW5zb3ImZ3Q7IHRlbnNvclRhYmxlOyBzdGQ6OnZlY3RvciZsdDtjaGFyJmd0OyBwYXlsb2FkID0gaml0OjpwaWNrbGUoYzEwOjppdmFsdWU6OlR1cGxlOjpjcmVhdGUoc3RkOjptb3ZlKGl2YWx1ZXMpKSwgdGVuc29yVGFibGUpOyByZXR1cm4gTWVzc2FnZSggc3RkOjptb3ZlKHBheWxvYWQpLCBzdGQ6Om1vdmUodGVuc29yVGFibGUpLCBNZXNzYWdlVHlwZTo6QkFDS1dBUkRfQVVUT0dSQURfUkVRKTsgLy8g6L+Z6YeM5oyH5piO5LqG5raI5oGv57G75Z6L44CCIH0gPC9jb2RlPjwvcHJlPiA8aDMgPjMuMyDmjqXlj5fmlrk8L2gzPiA8cD7kuLrkuoborrrov7DlrozmlbTvvIzmiJHku6zmjqXkuIvmnaXnnIvnnIvmjqXmlLbmlrnlpoLkvZXlpITnkIblj43lkJHkvKDmkq3jgII8L3A+IDxoNCA+My4zLjEg5o6l5Y+X5raI5oGvPC9oND4gPHA+5Zyo55Sf5oiQIFRlbnNvclBpcGVBZ2VudCDml7blgJnvvIzmioogUmVxdWVzdENhbGxiYWNrSW1wbCDphY3nva7kuLrlm57osIPlh73mlbDjgILov5nmmK8gYWdlbnQg55qE57uf5LiA5ZON5bqU5Ye95pWw44CC5YmN6Z2i5YWz5LqO5Luj55CG5o6l5pS26YC76L6R5pe25YCZ77yM5oiR5Lus5Lmf5o+Q5Yiw5LqG77yM5Lya6L+b5YWlIFJlcXVlc3RDYWxsYmFja05vUHl0aG9uOjpwcm9jZXNzUnBjIOWHveaVsOOAguWFtuS4reWPr+S7peeci+WIsOacieWvuSBCQUNLV0FSRF9BVVRPR1JBRF9SRVEg55qE5aSE55CG6YC76L6R44CCPC9wPiA8cD7ov5nnp43mmK8gUlBDIOeahOato+W4uOa1geeoi+OAgjwvcD4gPHByZT48Y29kZSA+dm9pZCBSZXF1ZXN0Q2FsbGJhY2tOb1B5dGhvbjo6cHJvY2Vzc1JwYyggUnBjQ29tbWFuZEJhc2UgcnBjLCBjb25zdCBNZXNzYWdlVHlwZSBtZXNzYWdlVHlwZSwgY29uc3QgaW50NjRfdCBtZXNzYWdlSWQsIGNvbnN0IGMxMDo6aW50cnVzaXZlX3B0ciZsdDtKaXRGdXR1cmUmZ3Q7IHJlc3BvbnNlRnV0dXJlLCBzdGQ6OnNoYXJlZF9wdHImbHQ7TGF6eVN0cmVhbUNvbnRleHQmZ3Q7IGN0eCkgY29uc3QgeyBzd2l0Y2ggKG1lc3NhZ2VUeXBlKSB7IGNhc2UgTWVzc2FnZVR5cGU6OkJBQ0tXQVJEX0FVVE9HUkFEX1JFUTogeyBwcm9jZXNzQmFja3dhcmRBdXRvZ3JhZFJlcShycGMsIG1lc3NhZ2VJZCwgcmVzcG9uc2VGdXR1cmUpOyAvLyDov5nph4zosIPnlKggcmV0dXJuOyB9OyA8L2NvZGU+PC9wcmU+IDxoNCA+My4zLjIgcHJvY2Vzc0JhY2t3YXJkQXV0b2dyYWRSZXE8L2g0PiA8cD7lnKggcHJvY2Vzc0JhY2t3YXJkQXV0b2dyYWRSZXEg5LmL5Lit5Lya77yaPC9wPiA8dWw+IDxsaT7ojrflj5YgRGlzdEF1dG9ncmFkQ29udGFpbmVy44CCPC9saT4gPGxpPuiOt+WPliDkuIrkuIvmlofjgII8L2xpPiA8bGk+6LCD55SoIGV4ZWN1dGVTZW5kRnVuY3Rpb25Bc3luYyDov5vooYzlvJXmk47lpITnkIbjgII8L2xpPiA8L3VsPiA8cD7nlLHmraTvvIzmiJHku6zlj6/ku6XnnIvliLDmnInkuKTkuKrpgJTlvoTov5vlhaXlvJXmk47vvJo8L3A+IDx1bD4gPGxpPuS4gOS4quaYr+ekuuS+i+S7o+eggeaYvuW8j+S4u+WKqOiwg+eUqCBiYWNrd2FyZO+8jOi/m+iAjOiwg+eUqOWIsCBEaXN0RW5naW5lOjpnZXRJbnN0YW5jZSgpLmV4ZWN1dGXvvIzlsLHmmK8gd29ya2VyIDDjgII8L2xpPiA8bGk+5LiA5Liq5piv6KKr5Yqo6LCD55SoIERpc3RFbmdpbmU6OmdldEluc3RhbmNlKCkuZXhlY3V0ZVNlbmRGdW5jdGlvbkFzeW5j77yM5bCx5pivIHdvcmtlciAx44CCPC9saT4gPC91bD4gPHByZT48Y29kZSA+dm9pZCBSZXF1ZXN0Q2FsbGJhY2tOb1B5dGhvbjo6cHJvY2Vzc0JhY2t3YXJkQXV0b2dyYWRSZXEoIFJwY0NvbW1hbmRCYXNlIHJwYywgY29uc3QgaW50NjRfdCBtZXNzYWdlSWQsIGNvbnN0IGMxMDo6aW50cnVzaXZlX3B0ciZsdDtKaXRGdXR1cmUmZ3Q7IHJlc3BvbnNlRnV0dXJlKSBjb25zdCB7IGF1dG8gZ3JhZGllbnRzQ2FsbCA9IHN0YXRpY19jYXN0Jmx0O1Byb3BhZ2F0ZUdyYWRpZW50c1JlcSZndDsocnBjKTsgY29uc3QgYXV0byBhdXRvZ3JhZE1ldGFkYXRhID0gZ3JhZGllbnRzQ2FsbC5nZXRBdXRvZ3JhZE1ldGFkYXRhKCk7IC8vIFJldHJpZXZlIHRoZSBhcHByb3ByaWF0ZSBhdXRvZ3JhZCBjb250ZXh0LiBhdXRvIGF1dG9ncmFkQ29udGV4dCA9IERpc3RBdXRvZ3JhZENvbnRhaW5lcjo6Z2V0SW5zdGFuY2UoKS5yZXRyaWV2ZUNvbnRleHQoIGF1dG9ncmFkTWV0YWRhdGEuYXV0b2dyYWRDb250ZXh0SWQpOyAvLyDlvpfliLDlj5HpgIHogIXnmoRjb250ZXh0IGlkIC8vIExvb2t1cCB0aGUgYXBwcm9wcmlhdGUgJ3NlbmQnIGZ1bmN0aW9uIHRvIGVucXVldWUuIHN0ZDo6c2hhcmVkX3B0ciZsdDtTZW5kUnBjQmFja3dhcmQmZ3Q7IHNlbmRGdW5jdGlvbiA9IC8vIOS+neaNruWPkemAgeiAhWNvbnRleHQgaWTlkozmtojmga9pZOW+l+WIsHNlbmRGdW5jdGlvbiBhdXRvZ3JhZENvbnRleHQtJmd0O3JldHJpZXZlU2VuZEZ1bmN0aW9uKGF1dG9ncmFkTWV0YWRhdGEuYXV0b2dyYWRNZXNzYWdlSWQpOyAvLyBBdHRhY2ggdGhlIGdyYWRpZW50cyB0byB0aGUgc2VuZCBmdW5jdGlvbi4gc2VuZEZ1bmN0aW9uLSZndDtzZXRHcmFkcyhncmFkaWVudHNDYWxsLmdldEdyYWRzKCkpOyAvLyDorr7nva7moq/luqYgLy8gTm93IGV4ZWN1dGUgdGhlIGF1dG9ncmFkIGdyYXBoIHVzaW5nIHRoZSAiZGlzdHJpYnV0ZWQgZW5naW5lLiIgYXV0byBleGVjRnV0dXJlID0gRGlzdEVuZ2luZTo6Z2V0SW5zdGFuY2UoKS5leGVjdXRlU2VuZEZ1bmN0aW9uQXN5bmMoIC8vIOiwg+eUqOW8leaTjiBhdXRvZ3JhZENvbnRleHQsIHNlbmRGdW5jdGlvbiwgZ3JhZGllbnRzQ2FsbC5yZXRhaW5HcmFwaCgpKTsgLy8gT3VyIHJlc3BvbnNlIGlzIHNhdGlzZmllZCB3aGVuIHRoZSBycGNzIGNvbWUgYmFjay4gZXhlY0Z1dHVyZS0mZ3Q7YWRkQ2FsbGJhY2soW3Jlc3BvbnNlRnV0dXJlLCBtZXNzYWdlSWRdKEppdEZ1dHVyZSBleGVjRnV0dXJlKSB7IGlmICghZXhlY0Z1dHVyZS5oYXNFcnJvcigpKSB7IE1lc3NhZ2UgbSA9IHN0ZDo6bW92ZShQcm9wYWdhdGVHcmFkaWVudHNSZXNwKCkpLnRvTWVzc2FnZSgpOyBtLnNldElkKG1lc3NhZ2VJZCk7IHJlc3BvbnNlRnV0dXJlLSZndDttYXJrQ29tcGxldGVkKCBJVmFsdWUoYzEwOjptYWtlX2ludHJ1c2l2ZSZsdDtNZXNzYWdlJmd0OyhzdGQ6Om1vdmUobSkpKSk7IH0gZWxzZSB7IHJlc3BvbnNlRnV0dXJlLSZndDtzZXRFcnJvcihleGVjRnV0dXJlLmV4Y2VwdGlvbl9wdHIoKSk7IH0gfSk7IH0gPC9jb2RlPjwvcHJlPiA8aDQgPjMuMy4zIGV4ZWN1dGVTZW5kRnVuY3Rpb25Bc3luYzwvaDQ+IDxwPmV4ZWN1dGVTZW5kRnVuY3Rpb25Bc3luYyDov5nph4zlvIDlp4vov5vlhaXkuoblvJXmk47vvIzms6jmhI/vvIzov5nph4zmmK/mjqXmlLbmlrnkuZ/ov5vlhaXkuoblvJXmk47vvIzlnKjmjqXmlLbmlrnkuIrov5vooYzorqHnrpfjgIJleGVjdXRlU2VuZEZ1bmN0aW9uQXN5bmMg5Lya55u05o6l6LCD55SoIGV4ZWN1dGVfZ3JhcGhfdGFza191bnRpbF9yZWFkeV9xdWV1ZV9lbXB0ee+8jOS5n+WPr+iDveWFiOiuoeeul+S+nei1lueEtuWQjue7p+e7reaJp+ihjOOAguatpOWkhOWPr+S7peWPguiAg+iuvuiuoeS5i+S4reeahO+8mjwvcD4gPHVsPiA8bGk+Nu+8ieW9k+i/nOeoi+S4u+acuuaUtuWIsOi/meS4quivt+axguaXtu+8jOaIkeS7rOS9v+eUqCA8Y29kZT5hdXRvZ3JhZF9jb250ZXh0X2lkPC9jb2RlPuWSjDxjb2RlPmF1dG9ncmFkX21lc3NhZ2VfaWQ8L2NvZGU+5p2l5p+l5om+6YCC5b2T55qEPGNvZGU+c2VuZDwvY29kZT7lh73mlbDjgII8L2xpPiA8bGk+N++8ieWmguaenOi/meaYr3dvcmtlcuesrOS4gOasoeaUtuWIsOWvuee7meWumiA8Y29kZT5hdXRvZ3JhZF9jb250ZXh0X2lkPC9jb2RlPueahOivt+axgu+8jOWug+WwhuaMieeFp+S4iumdoueahOesrCAxLTMg54K55omA6L+w5Zyo5pys5Zyw6K6h566X5L6d6LWW6aG544CCPC9saT4gPGxpPjjvvInnhLblkI7lsIblnKjnrKw254K55o6l5Y+X5Yiw55qEPGNvZGU+c2VuZDwvY29kZT7mlrnms5Xmj5LlhaXpmJ/liJfvvIzku6Xkvr/lnKjor6V3b3JrZXLnmoTmnKzlnLAgYXV0b2dyYWQg5byV5pOO5LiK5omn6KGM44CCPC9saT4gPC91bD4gPHA+5YW35L2T5Luj56CB5aaC5LiL77yaPC9wPiA8cHJlPjxjb2RlID5jMTA6OmludHJ1c2l2ZV9wdHImbHQ7YzEwOjppdmFsdWU6OkZ1dHVyZSZndDsgRGlzdEVuZ2luZTo6ZXhlY3V0ZVNlbmRGdW5jdGlvbkFzeW5jKCBjb25zdCBDb250ZXh0UHRyIGF1dG9ncmFkQ29udGV4dCwgY29uc3Qgc3RkOjpzaGFyZWRfcHRyJmx0O1NlbmRScGNCYWNrd2FyZCZndDsgc2VuZEZ1bmN0aW9uLCBib29sIHJldGFpbkdyYXBoKSB7IC8vIFR5cGljYWxseSB0aGUgbG9jYWwgYXV0b2dyYWQgZW5naW5lIGVuc3VyZXMgc3RyZWFtIHN5bmNocm9uaXphdGlvbnMgYmV0d2VlbiAvLyBub2RlcyBpbiB0aGUgZ3JhcGguIEhvd2V2ZXIsIGZvciBkaXN0cmlidXRlZCBhdXRvZ3JhZCB0aGUgc2VuZEZ1bmN0aW9uIC8vIGlucHV0cyBtaWdodCBoYXZlIGJlZW4gcmV0cmlldmVkIG92ZXIgdGhlIHdpcmUgb24gYSBzZXBhcmF0ZSBzdHJlYW0gYW5kIHRoZSAvLyBzZW5kRnVuY3Rpb24gaXRzZWxmIHJ1bnMgb24gYSBkaWZmZXJlbnQgc3RyZWFtLiBBcyBhIHJlc3VsdCwgd2UgbmVlZCB0byAvLyBtYW51YWxseSBzeW5jaHJvbml6ZSB0aG9zZSB0d28gc3RyZWFtcyBoZXJlLiBjb25zdCBhdXRvIHNlbmRfYmFja3dhcmRfc3RyZWFtID0gc2VuZEZ1bmN0aW9uLSZndDtzdHJlYW0oYzEwOjpEZXZpY2VUeXBlOjpDVURBKTsgaWYgKHNlbmRfYmFja3dhcmRfc3RyZWFtKSB7IC8vIOaLv+WIsOacrOasoeaJp+ihjOWvueW6lOeahFN0cmVhbSBmb3IgKGNvbnN0IGF1dG8gZ3JhZCA6IHNlbmRGdW5jdGlvbi0mZ3Q7Z2V0R3JhZHMoKSkgeyBjb25zdCBhdXRvIGd1YXJkID0gYzEwOjppbXBsOjpWaXJ0dWFsR3VhcmRJbXBse2MxMDo6RGV2aWNlVHlwZTo6Q1VEQX07IGNvbnN0IGF1dG8gZGVmYXVsdF9zdHJlYW0gPSBndWFyZC5nZXRTdHJlYW0oZ3JhZC5kZXZpY2UoKSk7IGlmIChzZW5kX2JhY2t3YXJkX3N0cmVhbSAhPSBkZWZhdWx0X3N0cmVhbSkgeyBhdXRvIGV2ZW50ID0gYzEwOjpFdmVudHtjMTA6OkRldmljZVR5cGU6OkNVREF9OyBldmVudC5yZWNvcmQoZGVmYXVsdF9zdHJlYW0pOyBzZW5kX2JhY2t3YXJkX3N0cmVhbS0mZ3Q7d2FpdChldmVudCk7IC8vIOmcgOimgeWQjOatpe+8jOS/neivgeW9k+WJjeaTjeS9nOWujOaIkCB9IH0gfSBzdGQ6OnVuaXF1ZV9sb2NrJmx0O3N0ZDo6bXV0ZXgmZ3Q7IGxvY2soaW5pdGlhbGl6ZWRDb250ZXh0SWRzTG9ja18pOyBpZiAoaW5pdGlhbGl6ZWRDb250ZXh0SWRzXy5maW5kKGF1dG9ncmFkQ29udGV4dC0mZ3Q7Y29udGV4dElkKCkpID09IGluaXRpYWxpemVkQ29udGV4dElkc18uZW5kKCkpIHsgLy8g6YGN5Y6G77yM5p+l5om+c2VuZEZ1bmN0aW9u5a+55bqU55qE5LiK5LiL5paH5piv5ZCm5Zyo5pys6IqC54K55LmL5Lit5bey57uP6K6w5b2VIC8vIOayoeacieaJvuWIsOS4iuS4i+aWh++8jOmcgOimgeiuoeeul+S+nei1liBlZGdlX2xpc3Qgb3V0cHV0RWRnZXM7IC8vIFBhc3MgaW4gYSBkdW1teSBncmFwaFJvb3Qgc2luY2UgYWxsIHNlbmQgZnVuY3Rpb25zIGFyZSB0aGUgcm9vdHMuIGF1dG8gZHVtbXlSb290ID0gc3RkOjptYWtlX3NoYXJlZCZsdDtHcmFwaFJvb3QmZ3Q7KGVkZ2VfbGlzdCgpLCB2YXJpYWJsZV9saXN0KCkpOyBjb21wdXRlRGVwZW5kZW5jaWVzKCAvLyDorqHnrpfkvp3otZYgYXV0b2dyYWRDb250ZXh0LCB7fSwge30sIGR1bW15Um9vdCwgb3V0cHV0RWRnZXMsIHJldGFpbkdyYXBoKTsgLy8gTWFyayB0aGUgYXV0b2dyYWQgY29udGV4dCBpZCBhcyBpbml0aWFsaXplZCBhbmQgdW5sb2NrLiBpbml0aWFsaXplZENvbnRleHRJZHNfLmluc2VydChhdXRvZ3JhZENvbnRleHQtJmd0O2NvbnRleHRJZCgpKTsgbG9jay51bmxvY2soKTsgLy8gRW5xdWV1ZSB0aGUgY3VycmVudCBzZW5kIGZ1bmN0aW9uLiBhdXRvIGdyYXBoVGFzayA9IGF1dG9ncmFkQ29udGV4dC0mZ3Q7cmV0cmlldmVHcmFwaFRhc2soKTsgLy8gUnVuIHRoZSBhdXRvZ3JhZCBlbmdpbmUuIGF1dG8gYWNjdW11bGF0ZUdyYWRGdXR1cmUgPSBydW5FbmdpbmVBbmRBY2N1bXVsYXRlR3JhZGllbnRzKCAvLyDorqHnrpfmoq/luqYgYXV0b2dyYWRDb250ZXh0LCBzZW5kRnVuY3Rpb24sIG91dHB1dEVkZ2VzLCAvKmluY3JlbWVudE91dHN0YW5kaW5nVGFza3M9Ki9mYWxzZSk7IC8vIEJ1aWxkIHRoZSAndWJlcicgZnV0dXJlIHRoYXQgd2FpdHMgZm9yIGV2ZXJ5dGhpbmcuIGF1dG8gY2FsbGJhY2tGdXR1cmUgPSBjMTA6Om1ha2VfaW50cnVzaXZlJmx0O2MxMDo6aXZhbHVlOjpGdXR1cmUmZ3Q7KGMxMDo6Tm9uZVR5cGU6OmdldCgpKTsgLy8g5rOo5YaM5Zue6LCDIGFjY3VtdWxhdGVHcmFkRnV0dXJlLSZndDthZGRDYWxsYmFjayhbYXV0b2dyYWRDb250ZXh0LCBjYWxsYmFja0Z1dHVyZV0oYzEwOjppdmFsdWU6OkZ1dHVyZSBhY2N1bXVsYXRlR3JhZEZ1dHVyZSkgeyB0cnkgeyBpZiAoYWNjdW11bGF0ZUdyYWRGdXR1cmUuaGFzRXJyb3IoKSkgeyAvLyBQZXJmb3JtIGNsZWFudXAgYXQgdGhlIGVuZCBvZiB0aGUgYmFja3dhcmQgcGFzcyAoYmVmb3JlIHdlIG1hcmsgLy8gdGhlIGZ1dHVyZSBhcyBjb21wbGV0ZWQpLiBEaXN0RW5naW5lOjpnZXRJbnN0YW5jZSgpLmNsZWFudXBCYWNrd2FyZFBhc3MoYXV0b2dyYWRDb250ZXh0KTsgLy8gU2tpcCBhbnkgZnVydGhlciBwcm9jZXNzaW5nIG9uIGVycm9ycy4gY2FsbGJhY2tGdXR1cmUtJmd0O3NldEVycm9yKGFjY3VtdWxhdGVHcmFkRnV0dXJlLmV4Y2VwdGlvbl9wdHIoKSk7IHJldHVybjsgfSAvLyBXYWl0IGZvciBhbGwgUlBDcyBhZnRlciB0aGUgYXV0b2dyYWQgZW5naW5lIGlzIGRvbmUuIGF1dG8gcnBjRnV0dXJlID0gYXV0b2dyYWRDb250ZXh0LSZndDtjbGVhckFuZFdhaXRGb3JPdXRzdGFuZGluZ1JwY3NBc3luYygpOyBycGNGdXR1cmUtJmd0O2FkZENhbGxiYWNrKFtjYWxsYmFja0Z1dHVyZSwgYXV0b2dyYWRDb250ZXh0XShjMTA6Oml2YWx1ZTo6RnV0dXJlIHJwY0Z1dHVyZSkgeyB0cnkgeyAvLyBQZXJmb3JtIGNsZWFudXAgYXQgdGhlIGVuZCBvZiB0aGUgYmFja3dhcmQgcGFzcyAoYmVmb3JlIC8vIHdlIG1hcmsgdGhlIGZ1dHVyZSBhcyBjb21wbGV0ZWQpLiBEaXN0RW5naW5lOjpnZXRJbnN0YW5jZSgpLmNsZWFudXBCYWNrd2FyZFBhc3MoYXV0b2dyYWRDb250ZXh0KTsgfSBjYXRjaCAoc3RkOjpleGNlcHRpb24gZSkgeyBjYWxsYmFja0Z1dHVyZS0mZ3Q7c2V0RXJyb3JJZk5lZWRlZChzdGQ6OmN1cnJlbnRfZXhjZXB0aW9uKCkpOyByZXR1cm47IH0gLy8gRmluYWxseSBtYXJrIHRoZSAndWJlcicgZnV0dXJlIGFzIGNvbXBsZXRlZC4gaWYgKCFycGNGdXR1cmUuaGFzRXJyb3IoKSkgeyBjYWxsYmFja0Z1dHVyZS0mZ3Q7bWFya0NvbXBsZXRlZChjMTA6OklWYWx1ZSgpKTsgfSBlbHNlIHsgY2FsbGJhY2tGdXR1cmUtJmd0O3NldEVycm9yKHJwY0Z1dHVyZS5leGNlcHRpb25fcHRyKCkpOyB9IH0pOyB9IGNhdGNoIChzdGQ6OmV4Y2VwdGlvbiBlKSB7IGNhbGxiYWNrRnV0dXJlLSZndDtzZXRFcnJvcklmTmVlZGVkKHN0ZDo6Y3VycmVudF9leGNlcHRpb24oKSk7IH0gfSk7IC8vIFJldHVybiB0aGUgZnV0dXJlIHdoaWNoIHdhaXRzIGZvciBhbGwgYXN5bmMgcHJvY2Vzc2luZyB0byBiZSBkb25lLiByZXR1cm4gY2FsbGJhY2tGdXR1cmU7IH0gZWxzZSB7IC8vIOWPr+S7peWcqOW9k+WJjU5vZGXmib7liLDkuIrkuIvmlocgbG9jay51bmxvY2soKTsgYXV0byBncmFwaFRhc2sgPSBhdXRvZ3JhZENvbnRleHQtJmd0O3JldHJpZXZlR3JhcGhUYXNrKCk7IGF0OjpsYXVuY2goW3RoaXMsIGdyYXBoVGFzaywgc2VuZEZ1bmN0aW9uXSgpIHsgZXhlY3V0ZV9ncmFwaF90YXNrX3VudGlsX3JlYWR5X3F1ZXVlX2VtcHR5KCAvKm5vZGVfdGFzayovIE5vZGVUYXNrKGdyYXBoVGFzaywgc2VuZEZ1bmN0aW9uLCBJbnB1dEJ1ZmZlcigwKSksIC8qaW5jcmVtZW50T3V0c3RhbmRpbmdUYXNrcyovIGZhbHNlKTsgfSk7IGF1dG8gZnV0ID0gYzEwOjptYWtlX2ludHJ1c2l2ZSZsdDtjMTA6Oml2YWx1ZTo6RnV0dXJlJmd0OyhjMTA6Ok5vbmVUeXBlOjpnZXQoKSk7IGZ1dC0mZ3Q7bWFya0NvbXBsZXRlZChjMTA6OklWYWx1ZSgpKTsgcmV0dXJuIGZ1dDsgfSB9IDwvY29kZT48L3ByZT4gPHA+5YW35L2T5aaC5LiL5Zu+77yaPC9wPiA8cHJlPjxjb2RlID4gKyB3b3JrZXIgMCB8IHdvcmtlciAxIHwgRW5naW5lIFJlY3ZScGNCYWNrd2FyZCBScGNBZ2VudCB8IFJlcXVlc3RDYWxsYmFja05vUHl0aG9uIERpc3RFbmdpbmUgKyArICsgfCArICsgfCB8IHwgfCB8IHwgfCB8IHwgfCB8IHwgZXZhbHVhdGVfZnVuY3Rpb24gfCB8IHwgfCB8ICsgfCB8IHwgfCB8IHwgfCB8IHwgfCB8ICsgfCB8IHwgfCB8IGNhbGxfZnVuY3Rpb24gfCB8IHwgfCB8ICsgfCB8IHwgfCB8IHwgZ3JhZHMgdiB8IHwgfCB8ICstLS0tLS0tLS0tLS0tLS0tJmd0OyBhcHBseSB8IHwgfCB8IHwgKyB8IHwgfCB8IHwgfCB8IHwgfCB8IHwgKyB8IHwgfCB8IHwgZ3JhZENhbGwgfCB8IHwgfCB8ICsgfCB8IHwgfCB8IHwgUHJvcGFnYXRlR3JhZGllbnRzUmVxIHwgfCB8IHwgfCArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJmd0OyB8IHwgfCB8IHwgfCB8ICsgfCB8IHwgfCArIEJBQ0tXQVJEX0FVVE9HUkFEX1JFUSB8IHwgfCB8IHNlbmQgKy0tLS0tLS0tLSstLS0tLS0tLS0mZ3Q7IHwgfCB8IHwgKyB8IHwgfCB8IHwgfCB8ICsgfCB8IHwgfCB8IHByb2Nlc3NCYWNrd2FyZEF1dG9ncmFkUmVxIHwgfCB8IHwgfCArIHwgfCB8IHwgfCB8ICsgfCB8IHwgfCArLS0tLS0tLS0tLS0tJmd0OyBleGVjdXRlU2VuZEZ1bmN0aW9uQXN5bmMgfCB8IHwgfCB8ICsgfCB8IHwgfCB8IHwgfCB8IHwgfCB8IHwgdiB2IHYgKyB2IHYgPC9jb2RlPjwvcHJlPiA8cD7miYvmnLrlpoLkuIvvvJo8L3A+IDxoMiA+MHgwNCBEaXN0QWNjdW11bGF0ZUdyYWRDYXB0dXJlSG9vazwvaDI+IDxwPuebruWJjeeci+i1t+adpeaAu+S9k+mAu+i+keW3sue7j+WujOaIkOS6hu+8jOS9huaYr+WunumZheS4iue8uuS6huS4gOWdl++8jOWvueW6lOS6huiuvuiuoeaWh+aho+S4reeahO+8mjwvcD4gPGJsb2NrcXVvdGU+IDxwPuacgOWQju+8jOaIkeS7rOS4jeaYr+WcqCBUZW5zb3LnmoQ8Y29kZT4uZ3JhZDwvY29kZT7kuYvkuIrntK/np6/moq/luqbvvIzogIzmmK/lnKjmr4/kuKpEaXN0cmlidXRlZCBBdXRvZ3JhZCBDb250ZXh05LmL5LiK5YiG5Yir57Sv56ev5qKv5bqmIOOAguair+W6puWtmOWCqOWcqDxjb2RlPkRpY3RbVGVuc29yLCBUZW5zb3JdPC9jb2RlPuS5i+S4rSDvvIw8Y29kZT5EaWN0W1RlbnNvciwgVGVuc29yXTwvY29kZT7ln7rmnKzkuIrmmK/ku44gVGVuc29yIOWIsOWFtuWFs+iBlOair+W6pueahOaYoOWwhO+8jOW5tuS4lOWPr+S7peS9v+eUqCBnZXRfZ3JhZGllbnRzKCkgQVBJ5qOA57Si6K+l5pig5bCEIOOAgjwvcD4gPC9ibG9ja3F1b3RlPiA8cD7lsLHmmK/miorlvILlnLAv5pys5Zyw55qE5qKv5bqm57Sv56ev5Yiw5pys5Zyw5LiK5LiL5paH5LmL5Lit77yM5omA5Lul5oiR5Lus5YaN5YiG5p6Q5LiA5LiLIERpc3RBY2N1bXVsYXRlR3JhZENhcHR1cmVIb29r44CCPC9wPiA8aDMgPjQuMSDlrprkuYk8L2gzPiA8cD5EaXN0QWNjdW11bGF0ZUdyYWRDYXB0dXJlSG9vayDmnInkuInkuKrkvZznlKjvvJo8L3A+IDxvbD4gPGxpPiA8cD7osIPnlKjljp/lp4tBY2N1bXVsYXRlR3JhZOeahCBwcmUgaG9va3Mg5p2l5L+u5pS56L6T5YWl5qKv5bqm44CCPC9wPiA8L2xpPiA8bGk+IDxwPuWwhiBncmFkIOe0r+enr+WIsFJQQ+S4iuS4i+aWh+OAgjwvcD4gPC9saT4gPGxpPiA8cD7osIPnlKjljp/lp4tBY2N1bXVsYXRlR3JhZOeahCBwb3N0IGhvb2tz44CCPC9wPiA8L2xpPiA8L29sPiA8cD7lhbblrprkuYnlpoLkuIvvvJo8L3A+IDxwcmU+PGNvZGUgPi8vIFRoaXMgaG9vayBkb2VzIDMgdGhpbmdzOiAvLyAxLiBDYWxsIHByZSBob29rcyBvZiB0aGUgb3JpZ2luYWwgQWNjdW11bGF0ZUdyYWQgdG8gbW9kaWZ5IHRoZSBpbnB1dCBncmFkLiAvLyAyLiBBY2N1bXVhdGUgdGhlIGdhcmQgdG8gUlBDIGNvbnRleHQuIC8vIDMuIENhbGwgcG9zdCBob29rcyBvZiB0aGUgb3JpZ2luYWwgQWNjdW11bGF0ZUdyYWQuIGNsYXNzIERpc3RBY2N1bXVsYXRlR3JhZENhcHR1cmVIb29rIDogcHVibGljIEdyYXBoVGFzazo6RXhlY0luZm86OkNhcHR1cmU6OkdyYWRDYXB0dXJlSG9vayB7IHB1YmxpYzogRGlzdEFjY3VtdWxhdGVHcmFkQ2FwdHVyZUhvb2soIHN0ZDo6c2hhcmVkX3B0ciZsdDtBY2N1bXVsYXRlR3JhZCZndDsgYWNjdW11bGF0ZUdyYWQsIENvbnRleHRQdHIgYXV0b2dyYWRDb250ZXh0KSA6IGFjY3VtdWxhdGVHcmFkXyhzdGQ6Om1vdmUoYWNjdW11bGF0ZUdyYWQpKSwgYXV0b2dyYWRDb250ZXh0XyhzdGQ6Om1vdmUoYXV0b2dyYWRDb250ZXh0KSkge30gYXQ6OlRlbnNvciBvcGVyYXRvcigpKGNvbnN0IGF0OjpUZW5zb3IgZ3JhZCkgb3ZlcnJpZGUgeyBUaHJlYWRMb2NhbERpc3RBdXRvZ3JhZENvbnRleHQgY29udGV4dEd1YXJke0NvbnRleHRQdHIoYXV0b2dyYWRDb250ZXh0Xyl9OyB2YXJpYWJsZV9saXN0IGlucHV0R3JhZHMgPSB7Z3JhZH07IC8vIEl0J3MgaW50ZW5kZWQgdGhhdCBwcmUvcG9zdCBob29rcyBhcmUgc3RpbGwgY2FsbGVkIGV2ZW4gaWYgdGhlIGdyYWQgaXMgLy8gdW5kZW5maW5lZCBoZXJlLiBmb3IgKGNvbnN0IGF1dG8gaG9vayA6IGFjY3VtdWxhdGVHcmFkXy0mZ3Q7cHJlX2hvb2tzKCkpIHsgaW5wdXRHcmFkcyA9ICgqaG9vaykoaW5wdXRHcmFkcyk7IC8vIOiwg+eUqCBwcmUtaG9va3MgfSAvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSBncmFkIGlzIG5vdCBkZWZpbmVkIHNpbmNlIGEgc2VwYXJhdGUgLy8gaW52b2NhdGlvbiBvZiB0aGUgYXV0b2dyYWQgZW5naW5lIG9uIHRoZSBzYW1lIG5vZGUgbWlnaHQgYWN0dWFsbHkgLy8gY29tcHV0ZSB0aGlzIGdyYWRpZW50LiBpZiAoaW5wdXRHcmFkc1swXS5kZWZpbmVkKCkpIHsgLy8gVGhlcmUgYXJlIDMgaW50ZXJuYWwgcmVmZXJlbmNlcyB0byAnaW5wdXRHcmFkc1swXScgYXQgdGhpcyBtb21lbnQ6IC8vIDEuICdpbnB1dEdyYWRzWzBdJyBpbiB0aGlzIGZ1bmN0aW9uLiAvLyAyLiAnZ3JhcGhfdGFzay0mZ3Q7Y2FwdHVyZWRfdmFyc18nIG9uIHRoZSBjYWxsc2l0ZSBpbiB0aGUgbG9jYWwgZW5naW5lLiAvLyAzLiAnSW5wdXRCdWZmZXIgaW5wdXRzJyBvbiB0aGUgY2FsbHNpdGUgYXMgdGhlIGlucHV0cyBvZiB0aGUgLy8gZnVuY3Rpb24gbm9kZS4gYXV0b2dyYWRDb250ZXh0Xy0mZ3Q7YWNjdW11bGF0ZUdyYWQoIC8vIOe0r+enr+air+W6piBhY2N1bXVsYXRlR3JhZF8tJmd0O3ZhcmlhYmxlLCBpbnB1dEdyYWRzWzBdLCAzIC8qIG51bV9leHBlY3RlZF9yZWZzICovKTsgfSBjb25zdCB2YXJpYWJsZV9saXN0IGtFbXB0eU91cHV0OyBmb3IgKGNvbnN0IGF1dG8gaG9vayA6IGFjY3VtdWxhdGVHcmFkXy0mZ3Q7cG9zdF9ob29rcygpKSB7ICgqaG9vaykoa0VtcHR5T3VwdXQsIGlucHV0R3JhZHMpOyAvLyDosIPnlKggcG9zdC1ob29rcyB9IHJldHVybiBpbnB1dEdyYWRzWzBdOyB9IHByaXZhdGU6IHN0ZDo6c2hhcmVkX3B0ciZsdDtBY2N1bXVsYXRlR3JhZCZndDsgYWNjdW11bGF0ZUdyYWRfOyAvLyDov5nlsLHmmK/pnIDopoHntK/np6/nmoTnm67moIflkJHph4/vvIzlkI7nu63mk43kvZzlnKjlhbbkuYvkuIogQ29udGV4dFB0ciBhdXRvZ3JhZENvbnRleHRfOyB9OyA8L2NvZGU+PC9wcmU+IDxoMyA+NC4yIOeUn+aIkDwvaDM+IDxwPuWmguS9leeUn+aIkCBEaXN0QWNjdW11bGF0ZUdyYWRDYXB0dXJlSG9va++8n+iuoeeul+S+nei1luaXtuWAmeeUn+aIkCBEaXN0QWNjdW11bGF0ZUdyYWRDYXB0dXJlSG9va++8jOS9huaYr+iusOW9leWcqCBjYXB0dXJlLmhvb2tzXy5wdXNoX2JhY2sg5LmL5Lit44CCPC9wPiA8cD7ov5nph4zmmK/kuLrkuoblpITnkIYgQWNjdW11bGF0ZUdyYWTjgII8L3A+IDx1bD4gPGxpPiA8cD5BY2N1bXVsYXRlR3JhZCDkuIDlrprmmK/lj7blrZDoioLngrnvvIzkuI3pnIDmiafooYzvvIzogIzpnIDopoHlnKjlhbbkuIrnp6/ntK/moq/luqbvvIzkvYbmmK9SZWN2UnBjQmFja3dhcmTpnIDopoHmiafooYzjgII8L3A+IDwvbGk+IDxsaT4gPHA+QWNjdW11bGF0ZUdyYWQg5bCx5L+d5a2Y5ZyoIERpc3RBY2N1bXVsYXRlR3JhZENhcHR1cmVIb29rIOS5i+S4reOAgjwvcD4gPC9saT4gPC91bD4gPHByZT48Y29kZSA+dm9pZCBEaXN0RW5naW5lOjpjb21wdXRlRGVwZW5kZW5jaWVzKCBjb25zdCBDb250ZXh0UHRyIGF1dG9ncmFkQ29udGV4dCwgY29uc3QgZWRnZV9saXN0IHJvb3RFZGdlcywgY29uc3QgdmFyaWFibGVfbGlzdCBncmFkcywgY29uc3Qgc3RkOjpzaGFyZWRfcHRyJmx0O05vZGUmZ3Q7IGdyYXBoUm9vdCwgZWRnZV9saXN0IG91dHB1dEVkZ2VzLCBib29sIHJldGFpbkdyYXBoKSB7IGlmICghb3V0cHV0RWRnZXMuZW1wdHkoKSkgeyAvLyBDb21wdXRlICduZWVkZWQgZXhlY3V0aW9uJyBzdGFydGluZyBmcm9tIGFsbCAnc2VuZCcgZnVuY3Rpb25zIGFuZCB0aGUgLy8gb3JpZ2luYWwgZ3JhcGhSb290LiBlZGdlX2xpc3QgZWRnZXM7IC8vIENyZWF0ZSBzb21lIGR1bW15IGVkZ2VzIChpbnB1dF9uciBub3QgaW1wb3J0YW50IGZvciBpbml0X3RvX2V4ZWN1dGUpLiBmb3IgKGNvbnN0IGF1dG8gbWFwRW50cnkgOiBzZW5kRnVuY3Rpb25zKSB7IGVkZ2VzLmVtcGxhY2VfYmFjayhtYXBFbnRyeS5zZWNvbmQsIDApOyB9IC8vIEFkZCB0aGUgb3JpZ2luYWwgZ3JhcGhSb290IGFzIGFuIGVkZ2UuIGVkZ2VzLmVtcGxhY2VfYmFjayhncmFwaFJvb3QsIDApOyAvLyBDcmVhdGUgYSBkdW1teSBHcmFwaFJvb3QgYW5kIHJ1biBpbml0X3RvX2V4ZWN1dGUgd2l0aCBpdC4gR3JhcGhSb290IGR1bW15Um9vdChlZGdlcywge30pOyBncmFwaFRhc2stJmd0O2luaXRfdG9fZXhlY3V0ZShkdW1teVJvb3QsIG91dHB1dEVkZ2VzLCAvKmFjY3VtdWxhdGVfZ3JhZD0qL2ZhbHNlLCAvKm1pbl90b3BvX25yPSovMCk7IGZvciAoYXV0byBtYXBFbnRyeSA6IGdyYXBoVGFzay0mZ3Q7ZXhlY19pbmZvXykgeyBhdXRvIGV4ZWNJbmZvID0gbWFwRW50cnkuc2Vjb25kOyBpZiAoIWV4ZWNJbmZvLmNhcHR1cmVzXykgeyBjb250aW51ZTsgfSBhdXRvIGZuID0gbWFwRW50cnkuZmlyc3Q7IC8vIFRoZXJlIG1heSBiZSBub2RlcyBvdGhlciB0aGFuICdBY2N1bXVsYXRlR3JhZCcsIGUuZy4gUmVjdlJQQ0JhY2t3YXJkLCAvLyB0byBiZSBjYXB0dXJlZC4gaWYgKGF1dG8gYWNjdW11bGF0ZUdyYWRGbiA9IGR5bmFtaWNfY2FzdCZsdDtBY2N1bXVsYXRlR3JhZComZ3Q7KGZuKSkgeyBmb3IgKGF1dG8gY2FwdHVyZSA6ICpleGVjSW5mby5jYXB0dXJlc18pIHsgY2FwdHVyZS5ob29rc18ucHVzaF9iYWNrKCAvLyDov5nph4zkvJrnlJ/miJAgc3RkOjptYWtlX3VuaXF1ZSZsdDtEaXN0QWNjdW11bGF0ZUdyYWRDYXB0dXJlSG9vayZndDsoIHN0ZDo6ZHluYW1pY19wb2ludGVyX2Nhc3QmbHQ7QWNjdW11bGF0ZUdyYWQmZ3Q7KCAvLyDkvJrkv53lrZggQWNjdW11bGF0ZUdyYWQgYWNjdW11bGF0ZUdyYWRGbi0mZ3Q7c2hhcmVkX2Zyb21fdGhpcygpKSwgYXV0b2dyYWRDb250ZXh0KSk7IH0gfSB9IC8vIE1hcmsgYWxsICdSZWN2UlBDQmFja3dhcmQnIGFzIG5lZWRpbmcgZXhlY3V0aW9uLiBmb3IgKGNvbnN0IGF1dG8gcmVjdkJhY2t3YXJkRWRnZSA6IHJlY3ZCYWNrd2FyZEVkZ2VzKSB7IGdyYXBoVGFzay0mZ3Q7ZXhlY19pbmZvX1tyZWN2QmFja3dhcmRFZGdlLmZ1bmN0aW9uLmdldCgpXS5uZWVkZWRfID0gdHJ1ZTsgfSB9IH0gPC9jb2RlPjwvcHJlPiA8aDMgPjQuMyDkvb/nlKg8L2gzPiA8cD7ku6PnoIHmmK/nvKnlh4/niYjjgII8L3A+IDxwPummluWFiO+8jGV4ZWN1dGVfZ3JhcGhfdGFza191bnRpbF9yZWFkeV9xdWV1ZV9lbXB0eSDkvJrosIPnlKjliLDljp/lp4vlvJXmk44gZW5naW5lXy5ldmFsdWF0ZV9mdW5jdGlvbuOAgjwvcD4gPHByZT48Y29kZSA+dm9pZCBEaXN0RW5naW5lOjpleGVjdXRlX2dyYXBoX3Rhc2tfdW50aWxfcmVhZHlfcXVldWVfZW1wdHkoIE5vZGVUYXNrIG5vZGVfdGFzaywgYm9vbCBpbmNyZW1lbnRPdXRzdGFuZGluZ1Rhc2tzKSB7IHdoaWxlICghY3B1X3JlYWR5X3F1ZXVlLSZndDtlbXB0eSgpKSB7IHN0ZDo6c2hhcmVkX3B0ciZsdDtHcmFwaFRhc2smZ3Q7IGxvY2FsX2dyYXBoX3Rhc2s7IHsgTm9kZVRhc2sgdGFzayA9IGNwdV9yZWFkeV9xdWV1ZS0mZ3Q7cG9wKCk7IGlmICh0YXNrLmZuXyAhbG9jYWxfZ3JhcGhfdGFzay0mZ3Q7aGFzX2Vycm9yXy5sb2FkKCkpIHsgQXV0b0dyYWRNb2RlIGdyYWRfbW9kZShsb2NhbF9ncmFwaF90YXNrLSZndDtncmFkX21vZGVfKTsgR3JhcGhUYXNrR3VhcmQgZ3VhcmQobG9jYWxfZ3JhcGhfdGFzayk7IGVuZ2luZV8uZXZhbHVhdGVfZnVuY3Rpb24oIC8vIOiwg+eUqOWOn+Wni+W8leaTjiBsb2NhbF9ncmFwaF90YXNrLCB0YXNrLmZuXy5nZXQoKSwgdGFzay5pbnB1dHNfLCBjcHVfcmVhZHlfcXVldWUpOyB9IH0gLy8gRGVjcmVtZW50IHRoZSBvdXRzdGFuZGluZyB0YXNrLiAtLWxvY2FsX2dyYXBoX3Rhc2stJmd0O291dHN0YW5kaW5nX3Rhc2tzXzsgfSB9IDwvY29kZT48L3ByZT4gPHA+5YW25qyh77yM5Y6f5aeL5byV5pOO5Luj56CB5LmL5Lit77yM5Lya6LCD55SoaG9va3PjgII8L3A+IDxwcmU+PGNvZGUgPnZvaWQgRW5naW5lOjpldmFsdWF0ZV9mdW5jdGlvbiggc3RkOjpzaGFyZWRfcHRyJmx0O0dyYXBoVGFzayZndDsgZ3JhcGhfdGFzaywgTm9kZSogZnVuYywgSW5wdXRCdWZmZXIgaW5wdXRzLCBjb25zdCBzdGQ6OnNoYXJlZF9wdHImbHQ7UmVhZHlRdWV1ZSZndDsgY3B1X3JlYWR5X3F1ZXVlKSB7IC8vIElmIGV4ZWNfaW5mb18gaXMgbm90IGVtcHR5LCB3ZSBoYXZlIHRvIGluc3RydW1lbnQgdGhlIGV4ZWN1dGlvbiBhdXRvIGV4ZWNfaW5mb18gPSBncmFwaF90YXNrLSZndDtleGVjX2luZm9fOyBpZiAoIWV4ZWNfaW5mb18uZW1wdHkoKSkgeyBhdXRvIGZuX2luZm8gPSBleGVjX2luZm9fLmF0KGZ1bmMpOyBpZiAoYXV0byogY2FwdHVyZV92ZWMgPSBmbl9pbmZvLmNhcHR1cmVzXy5nZXQoKSkgeyAvLyBMb2NrIG11dGV4IGZvciB3cml0aW5nIHRvIGdyYXBoX3Rhc2stJmd0O2NhcHR1cmVkX3ZhcnNfLiBzdGQ6OmxvY2tfZ3VhcmQmbHQ7c3RkOjptdXRleCZndDsgbG9jayhncmFwaF90YXNrLSZndDttdXRleF8pOyBmb3IgKGNvbnN0IGF1dG8gY2FwdHVyZSA6ICpjYXB0dXJlX3ZlYykgeyBhdXRvIGNhcHR1cmVkX2dyYWQgPSBncmFwaF90YXNrLSZndDtjYXB0dXJlZF92YXJzX1tjYXB0dXJlLm91dHB1dF9pZHhfXTsgY2FwdHVyZWRfZ3JhZCA9IGlucHV0c1tjYXB0dXJlLmlucHV0X2lkeF9dOyBmb3IgKGF1dG8gaG9vayA6IGNhcHR1cmUuaG9va3NfKSB7IGNhcHR1cmVkX2dyYWQgPSAoKmhvb2spKGNhcHR1cmVkX2dyYWQpOyAvLyDov5nph4zosIPnlKggaG9va++8jOWwseaYryBEaXN0QWNjdW11bGF0ZUdyYWRDYXB0dXJlSG9vayDnmoQgb3BlcmF0b3IoKe+8jGNhcHR1cmVkX2dyYWQg5bCx5piv57Sv56ev55qE5qKv5bqmIH0gfSB9IH0gLy8g5ZCO57ut55yB55WlIDwvY29kZT48L3ByZT4gPHA+RGlzdEFjY3VtdWxhdGVHcmFkQ2FwdHVyZUhvb2sg55qEIG9wZXJhdG9yKCkg5pa55rOV5LmL5Lit77yM5Lya6LCD55So5LiL6Z2i5p2l57Sv56ev5qKv5bqm44CCPC9wPiA8cHJlPjxjb2RlID4gYXV0b2dyYWRDb250ZXh0Xy0mZ3Q7YWNjdW11bGF0ZUdyYWQoIGFjY3VtdWxhdGVHcmFkXy0mZ3Q7dmFyaWFibGUsIGlucHV0R3JhZHNbMF0sIDMgLyogbnVtX2V4cGVjdGVkX3JlZnMgKi8pOyA8L2NvZGU+PC9wcmU+IDxoMyA+NC40IOe0r+enr+air+W6pjwvaDM+IDxoNCA+NC40LjEg5LiK5LiL5paH57Sv56evPC9oND4gPHByZT48Y29kZSA+dm9pZCBEaXN0QXV0b2dyYWRDb250ZXh0OjphY2N1bXVsYXRlR3JhZCggY29uc3QgdG9yY2g6OmF1dG9ncmFkOjpWYXJpYWJsZSB2YXJpYWJsZSwgLy8gdmFyaWFibGXlsLHmmK/nm67moIflj5jph48gY29uc3QgdG9yY2g6OlRlbnNvciBncmFkLCAvLyBncmFk5bCx5piv5qKv5bqm77yM6ZyA6KaB57Sv56ev5YiwdmFyaWFibGXkuYvkuIogc2l6ZV90IG51bV9leHBlY3RlZF9yZWZzKSB7IHN0ZDo6bG9ja19ndWFyZCZsdDtzdGQ6Om11dGV4Jmd0OyBndWFyZChsb2NrXyk7IGF1dG8gaXQgPSBhY2N1bXVsYXRlZEdyYWRzXy5maW5kKHZhcmlhYmxlKTsgYXQ6OlRlbnNvciBvbGRfZ3JhZDsgaWYgKGl0ICE9IGFjY3VtdWxhdGVkR3JhZHNfLmVuZCgpKSB7IC8vIEFjY3VtdWxhdGUgbXVsdGlwbGUgZ3JhZHMgb24gdGhlIHNhbWUgdmFyaWFibGUuIG9sZF9ncmFkID0gaXQtJmd0O3ZhbHVlKCk7IH0gLy8gR3JhZGllbnRzIGFyZSBjb21wdXRlZCB1c2luZyB0aGUgZm9yd2FyZCBzdHJlYW1zLiBMb2NhbCBhdXRvZ3JhZCAvLyBlbmdpbmUgdXNlcyBBY2N1bXVsYXRlR3JhZCBmdW5jdGlvbiB0byByZXRyaWV2ZSBhbmQgYXBwbHkgZm9yd2FyZCAvLyBzdHJlYW0gZHVyaW5nIHRoZSBiYWNrd2FyZCBjb21wdXRhdGlvbi4gSW4gZGlzdHJpYnV0ZWQgYXV0b2dyYWQsIC8vIHdlIGRpcmVjdGx5IGNhbGwgQWNjdW11bGF0ZUdyYWQ6OmFjY3VtdWxhdGVHcmFkLCBhbmQgc2tpcCB0aGUgLy8gQ1VEQSBzdHJlYW0gcmVzdG9yYXRpb24gZnJvbSBhdXRvZ3JhZCBmdW5jdGlvbi4gSGVuY2UsIHdlIG1hbnVhbGx5IC8vIGNhbGwgaXQgaGVyZSB0byBnZXQgdGhlIHN0cmVhbXMgY29ycmVjdC4gYXV0byBmb3J3YXJkX3N0cmVhbSA9IHRvcmNoOjphdXRvZ3JhZDo6aW1wbDo6Z3JhZF9hY2N1bXVsYXRvcih2YXJpYWJsZSktJmd0O3N0cmVhbSggZ3JhZC5kZXZpY2UoKS50eXBlKCkpOyBjMTA6Ok9wdGlvbmFsU3RyZWFtR3VhcmQgc3RyZWFtX2d1YXJkKGZvcndhcmRfc3RyZWFtKTsgLy8gTm8gaGlnaGVyIG9yZGVyIGdyYWRpZW50cyBzdXBwb3J0ZWQgaW4gZGlzdHJpYnV0ZWQgYXV0b2dyYWQuIEF1dG9HcmFkTW9kZSBncmFkX21vZGUoZmFsc2UpOyBhdDo6VGVuc29yIG5ld19ncmFkID0gQWNjdW11bGF0ZUdyYWQ6OmNhbGxIb29rcyh2YXJpYWJsZSwgZ3JhZCk7IC8vIOiuoeeulyBBY2N1bXVsYXRlR3JhZDo6YWNjdW11bGF0ZUdyYWQoIC8vIOiwg+eUqOeul+WtkOWHveaVsOadpee0r+enr+air+W6piB2YXJpYWJsZSwgb2xkX2dyYWQsIG5ld19ncmFkLCAvLyBBZGQgKzEgaGVyZSBzaW5jZSB3ZSBjYW4ndCBzdGQ6Om1vdmUoZ3JhZCkgd2hlbiBjYWxsIC8vIEFjY3VtdWxhdGVHcmFkOjpjYWxsSG9va3MsIHNpbmNlIGl0IGlzIGEgY29uc3QgcmVmLCBhbmQgdGhhdCBpbmN1cnMgYSAvLyByZWZjb3VudCBidW1wIGZvciB0aGUgbmV3X2dyYWQuIG51bV9leHBlY3RlZF9yZWZzICsgMSwgW3RoaXMsIHZhcmlhYmxlXShhdDo6VGVuc29yIGdyYWRfdXBkYXRlKSB7IGF1dG8gZGV2aWNlID0gZ3JhZF91cGRhdGUuZGV2aWNlKCk7IGFjY3VtdWxhdGVkR3JhZHNfLmluc2VydCh2YXJpYWJsZSwgc3RkOjptb3ZlKGdyYWRfdXBkYXRlKSk7IHJlY29yZEdyYWRFdmVudChkZXZpY2UpOyB9KTsgfSA8L2NvZGU+PC9wcmU+IDxoNCA+NC40LjIg566X5a2Q57Sv56evPC9oND4gPHA+5Luj56CB5L2N5LqOIHRvcmNoL2NzcmMvYXV0b2dyYWQvZnVuY3Rpb25zL2FjY3VtdWxhdGVfZ3JhZC5o44CCQWNjdW11bGF0ZUdyYWQg55qE5a6a5LmJ5aaC5LiL77yaPC9wPiA8cHJlPjxjb2RlID5zdHJ1Y3QgVE9SQ0hfQVBJIEFjY3VtdWxhdGVHcmFkIDogcHVibGljIE5vZGUgeyBleHBsaWNpdCBBY2N1bXVsYXRlR3JhZChWYXJpYWJsZSB2YXJpYWJsZV8pOyB2YXJpYWJsZV9saXN0IGFwcGx5KHZhcmlhYmxlX2xpc3QgZ3JhZHMpIG92ZXJyaWRlOyBzdGF0aWMgYXQ6OlRlbnNvciBjYWxsSG9va3MoIGNvbnN0IFZhcmlhYmxlIHZhcmlhYmxlLCBhdDo6VGVuc29yIG5ld19ncmFkKSB7IGZvciAoYXV0byBob29rIDogaW1wbDo6aG9va3ModmFyaWFibGUpKSB7IG5ld19ncmFkID0gKCpob29rKSh7bmV3X2dyYWR9KVswXTsgfSByZXR1cm4gbmV3X2dyYWQ7IH0gLy8gR2l2ZW4gYSB2YXJpYWJsZSB3aXRoIGl0cyBjdXJyZW50IGdyYWQgYXMgdmFyaWFibGVfZ3JhZCwgYWNjdW11bGF0ZXMgLy8gbmV3X2dyYWQgaW50byB2YXJpYWJsZV9ncmFkIGlmIGluIHBsYWNlIGFjY3VtdWxhdGlvbiBpcyBwb3NzaWJsZS4gLy8gT3RoZXJ3aXNlLCB1c2VzICd1cGRhdGVfZ3JhZCcgdG8gdXBkYXRlIHRoZSBncmFkIGZvciB0aGUgdmFyaWFibGUuIC8vICJHcmFkaWVudCBMYXlvdXQgQ29udHJhY3QiIC8vIC8vIEFjY3VtdWxhdGVHcmFkIHRyaWVzIHRvIHN0YXNoIHN0cmlkZWQgKG5vbi1zcGFyc2UpIGdyYWRzIHdpdGggbWVtb3J5IGxheW91dCAvLyAoc3RyaWRlcykgc3VjaCB0aGF0IHZhcmlhYmxlcyBhbmQgZ3JhZHMgaW50ZXJhY3QgZWZmaWNpZW50bHkgaW4gbGF0ZXIgLy8gb3B0aW1pemVyIGtlcm5lbHMsIGFuZCBncmFkcyBpbnRlcmFjdCBlZmZpY2llbnRseSB3aXRoIGMxMGQ6OlJlZHVjZXIuY3BwLiAvLyAvLyBTcGVjaWZpY2FsbHksIEFjY3VtdWxhdGVHcmFkIHRyaWVzIHRvIGVuc3VyZSB0aGUgZm9sbG93aW5nIC8vIChjZiB0b3JjaC9jc3JjL2F1dG9ncmFkL3V0aWxzL2dyYWRfbGF5b3V0X2NvbnRyYWN0LmgpOiAvLyAoMSkgaWYgdmFyaWFibGUuaXNfbm9uX292ZXJsYXBwaW5nX2FuZF9kZW5zZSgpLCB0aGUgc3Rhc2hlZCBncmFkJ3MgLy8gc3RyaWRlcyBtYXRjaCB2YXJpYWJsZS4gLy8gKDIpIGVsc2UsIHN0YXNoZWQgZ3JhZCBpcyByb3dtYWpvciBjb250aWd1b3VzLiAvLyBJZiB2YXJpYWJsZSdzIGdyYWQgZG9lcyBub3QgZXhpc3QgKCF2YXJpYWJsZV9ncmFkLmRlZmluZWQoKSkgLy8gQWNjdW11bGF0ZUdyYWQgc3RlYWxzIG5ld19ncmFkIGlmIGl0J3Mgc3RlYWxhYmxlIGFuZCBvYmV5cyB0aGUgY29udHJhY3QgLy8gYWxyZWFkeSwgb3RoZXJ3aXNlIGl0IGRlZXAgY29waWVzIG5ld19ncmFkIGludG8gYW4gb2JlZGllbnQgY2xvbmUuIC8vIC8vIElmIHZhcmlhYmxlJ3MgZ3JhZCBhbHJlYWR5IGV4aXN0cyAodmFyaWFibGVfZ3JhZC5kZWZpbmVkKCkpLCBuZXdfZ3JhZCBtdXN0IC8vIGJlIGFkZGVkIHRvIHZhcmlhYmxlX2dyYWQuIElmIHdlIGFyZW4ndCBzZXR0aW5nIHVwIGZvciBkb3VibGUgYmFja3dhcmQgLy8gKCFHcmFkTW9kZTo6aXNfZW5hYmxlZCgpKSwgQWNjdW11bGF0ZUdyYWQgcGVyZm9ybXMgInZhcmlhYmxlX2dyYWQgKz0gbmV3X2dyYWQiIC8vIGluLXBsYWNlLCB3aGljaCBrZWVwcyB2YXJpYWJsZV9ncmFkJ3MgbGF5b3V0LiBXZSBhc3N1bWUgKGhvcGUpIHZhcmlhYmxlX2dyYWQgLy8gd2FzIGNyZWF0ZWQgb2JleWluZyAoMSkgb3IgKDIpIGF0IHNvbWUgcG9pbnQgaW4gdGhlIHBhc3QuIC8vIC8vIElmIHdlIGFyZSBzZXR0aW5nIHVwIGZvciBkb3VibGUgYmFja3dhcmQsIEFjY3VtdWxhdGVHcmFkIHVwZGF0ZXMgdGhlIGdyYWQgLy8gb3V0LW9mLXBsYWNlIHZpYSAidmFyaWFibGVfZ3JhZCArIG5ld19ncmFkLiIgVGVuc29ySXRlcmF0b3Igb3BlcmF0b3IrIGRlY2lkZXMgLy8gcmVzdWx0J3MgbGF5b3V0LiBUeXBpY2FsbHkgVGVuc29ySXRlcmF0b3IgbWF0Y2hlcyBzdHJpZGVzIG9mIHRoZSBmaXJzdCBhcmcsIC8vIHNvIHdlIG9uY2UgYWdhaW4gYXNzdW1lIChob3BlKSB2YXJpYWJsZV9ncmFkIHdhcyBvcmlnaW5hbGx5IGNyZWF0ZWQgb2JleWluZyAvLyAoMSkgb3IgKDIpLiAvLyAvLyBBY2N1bXVsYXRlR3JhZCBkb2VzIG5vdCBlbmZvcmNlIHRoZSBjb250cmFjdCB3aXRoIDEwMCUgY2VydGFpbnR5LiBFeGFtcGxlczogLy8gLSBJZiBhIHVzZXIgbWFudWFsbHkgcGVybXV0ZXMgYSBwYXJhbSBvciBpdHMgZ3JhZCwgdGhlbiBydW5zIGEgZndkK2J3ZCwgLy8gdmFyaWFibGVfZ3JhZCArPSBuZXdfZ3JhZCBrZWVwcyB2YXJpYWJsZV9ncmFkJ3MgbGF5b3V0IHdpdGhvdXQgcmVjaGVja2luZyAvLyB0aGUgY29udHJhY3QuIC8vIC0gSWYgVGVuc29ySXRlcmF0b3IgY2hhbmdlcyBpdHMgY29ybmVyIGNhc2VzIGFib3V0IG9wZXJhdG9yKydzIHJlc3VsdCAvLyAoZm9yIGV4YW1wbGUsIGdpdmluZyBtb3JlIG9yIGxlc3MgcHJpb3JpdHkgdG8gY2hhbm5lbHNfbGFzdCBpbnB1dHMsIHNlZSAvLyBodHRwczovL2dpdGh1Yi5jb20vcHl0b3JjaC9weXRvcmNoL3B1bGwvMzc5NjgpIHRoZSByZXN1bHQgbWF5IG5vdCBvYmV5LiAvLyAvLyBGb3J0dW5hdGVseSwgaWYgYSBnaXZlbiBncmFkIGRvZXNuJ3Qgc2F0aXNmeSAoMSkgb3IgKDIpLCB0aGUgcGVuYWx0eSBpcyAvLyBkZWdyYWRlZCBwZXJmb3JtYW5jZSBpbiBSZWR1Y2VyLmNwcCBvciBvcHRpbWl6ZXIga2VybmVscywgbm90IGRlYXRoIGJ5IC8vIGFzc2VydCBvciBzaWxlbnRseSBiYWQgbnVtZXJpY3MuIC8vIHZhcmlhYmxlOiB0aGUgdmFyaWFibGUgd2hvc2UgZ3JhZCB3ZSdyZSBhY2N1bXVsYXRpbmcuIC8vIHZhcmlhYmxlX2dyYWQ6IHRoZSBjdXJyZW50IGdyYWQgZm9yIHRoZSB2YXJpYWJsZS4gLy8gbmV3X2dyYWQ6IG5ldyBncmFkIHdlIHdhbnQgdG8gYWN1bW11bGF0ZSBmb3IgdGhlIHZhcmlhYmxlLiAvLyBudW1fZXhwZWN0ZWRfcmVmczogdGhlIG51bWJlciBvZiByZWZzIHdlIGV4cGVjdCB0byBob2xkIGludGVybmFsbHkgLy8gc3VjaCB0aGF0IGl0IGlzIHNhZmUgdG8gYXZvaWQgY2xvbmluZyB0aGUgZ3JhZCAvLyBpZiB1c2VfY291bnQoKSBvZiB0aGUgZ3JhZCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgLy8gdG8gdGhpcyB2YWx1ZSAoaW4gYWRkaXRpb24gdG8gcG9zdF9ob29rcykuIC8vIHVwZGF0ZV9ncmFkOiBGdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gdXBkYXRlIGdyYWQgZm9yIHRoZSB2YXJpYWJsZS4gLy8gVGhlIGFyZ3VtZW50IHRvIHRoZSBmdW5jdGlvbiBpcyBhIFRlbnNvciB3aGljaCAvLyBpcyB1c2VkIHRvIHNldCBhIG5ldyB2YWx1ZSBmb3IgdGhlIGdyYWQuIHRlbXBsYXRlICZsdDt0eXBlbmFtZSBUJmd0OyBzdGF0aWMgdm9pZCBhY2N1bXVsYXRlR3JhZCggLy8g6L+Z6YeM5Lya6L+b6KGM5YW35L2T55qE57Sv56ev5qKv5bqmIGNvbnN0IFZhcmlhYmxlIHZhcmlhYmxlLCBhdDo6VGVuc29yIHZhcmlhYmxlX2dyYWQsIGNvbnN0IGF0OjpUZW5zb3IgbmV3X2dyYWQsIHNpemVfdCBudW1fZXhwZWN0ZWRfcmVmcywgY29uc3QgVCB1cGRhdGVfZ3JhZCkgeyBpZiAoIXZhcmlhYmxlX2dyYWQuZGVmaW5lZCgpKSB7IGlmICghR3JhZE1vZGU6OmlzX2VuYWJsZWQoKSAhbmV3X2dyYWQuaXNfc3BhcnNlKCkgbmV3X2dyYWQudXNlX2NvdW50KCkgJmx0Oz0gbnVtX2V4cGVjdGVkX3JlZnMgKG5ld19ncmFkLmlzX21rbGRubigpIHx8IHV0aWxzOjpvYmV5c19sYXlvdXRfY29udHJhY3QobmV3X2dyYWQsIHZhcmlhYmxlKSkpIHsgLy8gd2UgYXJlbid0IHNldHRpbmcgdXAgZm9yIGRvdWJsZS1iYWNrd2FyZCAvLyBub3Qgc3BhcnNlIC8vIG5vIG90aGVyIHVzZXItdmlzaWJsZSB0ZW5zb3IgcmVmZXJlbmNlcyBuZXdfZ3JhZCAvLyBuZXdfZ3JhZCBvYmV5cyB0aGUgIkdyYWRpZW50IExheW91dCBDb250cmFjdCIsIHRoZXJlIGhhcyBhIHNwZWNpYWwgY2FzZSwgLy8gRm9yIE1LTEROTiB0ZW5zb3IsIHdoaWNoIGlzIGEgb3BhcXVlIHRlbnNvciwgYXNzdW1pbmcgaXQgb2JleXMgbGF5b3V0X2NvbnRyYWN0LiAvLyBVbmRlciB0aGVzZSBjb25kaXRpb25zLCB3ZSBjYW4gc3RlYWwgbmV3X2dyYWQgd2l0aG91dCBhIGRlZXAgY29weS4gdXBkYXRlX2dyYWQobmV3X2dyYWQuZGV0YWNoKCkpOyB9IGVsc2UgaWYgKCAhR3JhZE1vZGU6OmlzX2VuYWJsZWQoKSBuZXdfZ3JhZC5pc19zcGFyc2UoKSBuZXdfZ3JhZC5faW5kaWNlcygpLmlzX2NvbnRpZ3VvdXMoKSBuZXdfZ3JhZC5fdmFsdWVzKCkuaXNfY29udGlndW91cygpIC8vIFVzZSBjb3VudCBmb3IgaW5kaWNlcyBhbmQgdmFsdWVzIHNob3VsZCBhbHdheXMgYmUgJmx0Oz0xIHNpbmNlIHRoZSAvLyBTcGFyc2VUZW5zb3Igc2hvdWxkIGJlIHRoZSBvbmx5IG9uZSBob2xkaW5nIGEgcmVmZXJlbmNlIHRvIHRoZXNlLiBuZXdfZ3JhZC5faW5kaWNlcygpLnVzZV9jb3VudCgpICZsdDs9IDEgbmV3X2dyYWQuX3ZhbHVlcygpLnVzZV9jb3VudCgpICZsdDs9IDEgbmV3X2dyYWQudXNlX2NvdW50KCkgJmx0Oz0gbnVtX2V4cGVjdGVkX3JlZnMpIHsgLy8gQ2FuJ3QgZGV0YWNoIHNwYXJzZSB0ZW5zb3IgKHNpbmNlIG1ldGFkYXRhIGNoYW5nZXMgYXJlIG5vdCBhbGxvd2VkIC8vIGFmdGVyIGRldGFjaCksIHNvIGp1c3QgY3JlYXRlIGEgbmV3IG9uZSBmb3IgdGhlIGdyYWQgd2hpY2ggaXMgYSAvLyBzaGFsbG93IGNvcHkuIFdlIG5lZWQgYSBzaGFsbG93IGNvcHkgc28gdGhhdCBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsIC8vIGdyYWQgdGVuc29yIGRvZXNuJ3QgbW9kaWZ5IHRoZSBncmFkIHdlIGFjY3VtdWxhdGUuIC8vIFdlIG9ubHkgc2tpcCBjbG9uZSBpZiBpbmRpY2VzIGFuZCB2YWx1ZXMgdGhlbXNlbHZlcyBhcmUgY29udGlndW91cyAvLyBmb3IgYmFja3dhcmQgY29tcGF0aWJsaXR5IHJlYXNvbnMuIFNpbmNlIHdpdGhvdXQgdGhpcyBvcHRpbWl6YXRpb24sIC8vIGVhcmxpZXIgd2Ugd291bGQgY2xvbmUgdGhlIGVudGlyZSBTcGFyc2VUZW5zb3Igd2hpY2ggY2xvbmVkIGluZGljZXMgLy8gYW5kIHZhbHVlcy4gLy8gRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9weXRvcmNoL3B5dG9yY2gvaXNzdWVzLzM0Mzc1LiB1cGRhdGVfZ3JhZChhdDo6X3NwYXJzZV9jb29fdGVuc29yX3Vuc2FmZSggbmV3X2dyYWQuX2luZGljZXMoKSwgbmV3X2dyYWQuX3ZhbHVlcygpLCBuZXdfZ3JhZC5zaXplcygpLCBuZXdfZ3JhZC5vcHRpb25zKCkpKTsgfSBlbHNlIHsgaWYgKG5ld19ncmFkLmlzX3NwYXJzZSgpKSB7IHVwZGF0ZV9ncmFkKG5ld19ncmFkLmNsb25lKCkpOyB9IGVsc2UgeyBpZiAobmV3X2dyYWQuaXNfbWtsZG5uKCkpIHsgdXBkYXRlX2dyYWQobmV3X2dyYWQuY2xvbmUoKSk7IH0gZWxzZSB7IC8vIERlZXAgY29waWVzIG5ld19ncmFkIGFjY29yZGluZyB0byB0aGUgIkdyYWRpZW50IExheW91dCBDb250cmFjdC4iIHVwZGF0ZV9ncmFkKHV0aWxzOjpjbG9uZV9vYmV5X2NvbnRyYWN0KG5ld19ncmFkLCB2YXJpYWJsZSkpOyB9IH0gfSB9IGVsc2UgaWYgKCFHcmFkTW9kZTo6aXNfZW5hYmxlZCgpKSB7IC8vIFRoaXMgY2FzZSBpcyBub3Qgc3RyaWN0bHkgbmVjZXNzYXJ5LCBidXQgaXQgbWFrZXMgdGhlIGZpcnN0LW9yZGVyIG9ubHkgLy8gY2FzZSBzbGlnaHRseSBtb3JlIGVmZmljaWVudC4gaWYgKHZhcmlhYmxlX2dyYWQuaXNfc3BhcnNlKCkgIW5ld19ncmFkLmlzX3NwYXJzZSgpKSB7IC8vIElmIGB2YXJpYWJsZV9ncmFkYCBpcyBzcGFyc2UgYW5kIGBuZXdfZ3JhZGAgaXMgbm90IHNwYXJzZSwgdGhlaXIgLy8gc3VtIGlzIG5vdCBzcGFyc2UsIGFuZCB3ZSBtdXN0IGNoYW5nZSB0aGUgVGVuc29ySW1wbCB0eXBlIG9mIC8vIGB2YXJpYWJsZV9ncmFkYCBmb3IgaXQgdG8gc3RvcmUgdGhlIHJlc3VsdC4gSG93ZXZlciwgY2hhbmdpbmcgdGhlIC8vIFRlbnNvckltcGwgdHlwZSBvZiBhIHRlbnNvciByZXF1aXJlcyBjaGFuZ2luZyB0aGUgdGVuc29yIGl0c2VsZiwgYW5kIC8vIHRodXMgaW4gdGhpcyBjYXNlIHdlIGhhdmUgdG8gY2hhbmdlIHRoZSBncmFkIHRlbnNvci4gYXV0byByZXN1bHQgPSBuZXdfZ3JhZCArIHZhcmlhYmxlX2dyYWQ7IENIRUNLX1JFU1VMVChyZXN1bHQsIHZhcmlhYmxlKTsgdXBkYXRlX2dyYWQoc3RkOjptb3ZlKHJlc3VsdCkpOyB9IGVsc2UgaWYgKCFhdDo6aW5wbGFjZUlzVm1hcENvbXBhdGlibGUodmFyaWFibGVfZ3JhZCwgbmV3X2dyYWQpKSB7IC8vIElkZWFsbHkgd2UnZCBwZXJmb3JtIGFuIGluLXBsYWNlIG9wZXJhdGlvbiB0byBhdm9pZCBjaGFuZ2luZyAvLyB0aGUgZ3JhZCB0ZW5zb3IuIEhvd2V2ZXIsIGlmIHRoYXQncyBpbXBvc3NpYmxlIGJlY2F1c2UgdGhlIGdyYWRzIC8vIGFyZSB2bWFwLWluY29tcGF0aWJsZSAoU2VlIE5PVEU6IFt2bWFwLWluY29tcGF0aWJsZSBpbi1wbGFjZSBvcGVyYXRpb25zXSksIC8vIHRoZW4gd2UganVzdCBhZGQgdGhlbSBvdXQtb2YtcGxhY2UuIGF1dG8gcmVzdWx0ID0gdmFyaWFibGVfZ3JhZCArIG5ld19ncmFkOyBDSEVDS19SRVNVTFQocmVzdWx0LCB2YXJpYWJsZSk7IHVwZGF0ZV9ncmFkKHN0ZDo6bW92ZShyZXN1bHQpKTsgfSBlbHNlIHsgLy8gSW4gdGhpcyBjYXNlIHdlIGNhbiBhdm9pZCBjaGFuZ2luZyB0aGUgZ3JhZCB0ZW5zb3IuIFRoZXJlIGFyZSB0aHJlZSAvLyBzY2VuYXJpb3Mgd2hlbiB3ZSdsbCBoaXQgdGhpcyBjYXNlOiAvLyAvLyAxLiBgdmFyaWFibGVfZ3JhZGAgaXMgc3BhcnNlLCBhbmQgYG5ld19ncmFkYCBpcyBzcGFyc2UuIC8vIDIuIGB2YXJpYWJsZV9ncmFkYCBpcyBkZW5zZSwgYW5kIGBuZXdfZ3JhZGAgaXMgc3BhcnNlLiAvLyAzLiBgdmFyaWFibGVfZ3JhZGAgaXMgZGVuc2UsIGFuZCBgbmV3X2dyYWRgIGlzIGRlbnNlLiAvLyA0LiBgdmFyaWFibGVfZ3JhZGAgaXMgbWtsZG5uLCBhbmQgYG5ld19ncmFkYCBpcyBta2xkbm4uIC8vIC8vIEluIGFsbCBvZiB0aGVzZSBmb3VyIGNhc2VzLCBgdmFyaWFibGVfZ3JhZCArPSBuZXdfZ3JhZGAgaXMgYSAvLyB2YWxpZCBvcGVyYXRpb24gd2hpY2ggYWRkcyBgbmV3X2dyYWRgIHRvIGB2YXJpYWJsZV9ncmFkYCBpbiAvLyBwbGFjZS4gYHZhcmlhYmxlX2dyYWRgIGlzIHRodXMgc3RpbGwgcmVmZXJyaW5nIHRvIHRoZSBzYW1lIHRlbnNvciAvLyBhZnRlciB0aGUgb3BlcmF0aW9uLiAvLyBBbHNvIERpc3RyaWJ1dGVkRGF0YVBhcmFsbGVsKEREUCkgcGFja2FnZSByZWxpZXMgb24gZ3JhZCBiZWluZyAvLyBtdXRhdGVkIGluIHBsYWNlIGZvciBzYXZpbmcgcGVhayBtZW1vcnkgdXNhZ2UuIEREUCB3aWxsIHN0aWxsIC8vIHdvcmsgY29ycmVjdGx5IGlmIGl0IGlzIG11dGF0ZWQgb3V0IG9mIHBsYWNlIGhlcmUsIGJ1dCBERFAgd2lsbCAvLyBtYWludGFpbiBvbmUgZXh0cmEgY29weSBvZiBncmFkIHRlbnNvcnMgaW4gYnVmZmVyIGFuZCB0aHVzIC8vIGluY3JlYXNlIHBlYWsgbWVtb3J5IHVzYWdlLiB2YXJpYWJsZV9ncmFkICs9IG5ld19ncmFkOyBDSEVDS19SRVNVTFQodmFyaWFibGVfZ3JhZCwgdmFyaWFibGUpOyAvLyBeIFdlIGNvdWxkIGVuZm9yY2UgdGhlIGNvbnRyYWN0IG1vcmUgYWdncmVzc2l2ZWx5IGhlcmUgYnkgd3JpdGluZzogLy8gaWYgKHZhcmlhYmxlX2dyYWQuaXNfc3BhcnNlKCkgfHwgbmV3X2dyYWQuaXNfc3BhcnNlKCkpIHsgLy8gdmFyaWFibGVfZ3JhZCArPSBuZXdfZ3JhZDsgLy8gfSBlbHNlIGlmIChvYmV5c19sYXlvdXRfY29udHJhY3QodmFyaWFibGVfZ3JhZCwgdmFyaWFibGUpKSB7IC8vIHZhcmlhYmxlX2dyYWQgKz0gbmV3X2dyYWQ7IC8vIH0gZWxzZSB7IC8vIHJlc3VsdCA9IGF0OjplbXB0eV9zdHJpZGVkKHZhcmlhYmxlLnNpemVzKCksIHZhcmlhYmxlLnN0cmlkZXMoKSwgLy8gdmFyaWFibGUub3B0aW9ucygpLm1lbW9yeV9mb3JtYXQoYzEwOjpudWxsb3B0KSk7IC8vIHVwZGF0ZV9ncmFkKGF0OjpuYXRpdmU6OmFkZF9vdXQocmVzdWx0LCB2YXJpYWJsZV9ncmFkLCBuZXdfZ3JhZCwgMS4wKTsgLy8gfSAvLyBIb3dldmVyLCB0aGF0IGFjY3VtdWxhdGlvbiBpcyBzb21ldGltZXMgaW4gcGxhY2UgYW5kIHNvbWV0aW1lcyBub3QsIC8vIHdoaWNoIG1heSBicmVhayB1c2VyIGNvZGUuIH0gfSBlbHNlIHsgYXQ6OlRlbnNvciByZXN1bHQ7IGlmICh2YXJpYWJsZV9ncmFkLmlzX3NwYXJzZSgpICFuZXdfZ3JhZC5pc19zcGFyc2UoKSkgeyAvLyBDUFUgYmFja2VuZCB0aHJvd3MgYW4gZXJyb3Igb24gc3BhcnNlICsgZGVuc2UsIHNvIHByZWZlciBkZW5zZSArIHNwYXJzZSBoZXJlLiByZXN1bHQgPSBuZXdfZ3JhZCArIHZhcmlhYmxlX2dyYWQ7IH0gZWxzZSB7IC8vIEFzc3VtZXMgb3BlcmF0b3IrIHJlc3VsdCB0eXBpY2FsbHkgbWF0Y2hlcyBzdHJpZGVzIG9mIGZpcnN0IGFyZywgLy8gYW5kIGhvcGVzIHZhcmlhYmxlX2dyYWQgd2FzIG9yaWdpbmFsbHkgY3JlYXRlZCBvYmV5aW5nIGxheW91dCBjb250cmFjdC4gcmVzdWx0ID0gdmFyaWFibGVfZ3JhZCArIG5ld19ncmFkOyB9IENIRUNLX1JFU1VMVChyZXN1bHQsIHZhcmlhYmxlKTsgdXBkYXRlX2dyYWQoc3RkOjptb3ZlKHJlc3VsdCkpOyAvLyBeIFdlIGNvdWxkIGVuZm9yY2UgdGhlIGNvbnRyYWN0IG1vcmUgYWdncmVzc2l2ZWx5IGhlcmUgYnkgc2F5aW5nIC8vIGlmIChvYmV5c19sYXlvdXRfY29udHJhY3QobmV3X2dyYWQsIHZhcmlhYmxlKSkgeyAvLyB1cGRhdGVfZ3JhZChuZXdfZ3JhZCArIHZhcmlhYmxlX2dyYWQpOyAvLyB9IGVsc2UgeyAvLyB1cGRhdGVfZ3JhZCh2YXJpYWJsZV9ncmFkICsgbmV3X2dyYWQpOyAvLyB9IC8vIHN1Y2ggdGhhdCB0aGUgc3Rhc2hlZCBncmFkIGlzIGxpa2VseSB0byBoYXZlIHRoZSByaWdodCBzdHJpZGVzIGlmIC8vIGVpdGhlciB2YXJpYWJsZV9ncmFkIG9yIG5ld19ncmFkIGFscmVhZHkgaGFzIHRoZSByaWdodCBzdHJpZGVzLiAvLyBXZSBjb3VsZCBlbmZvcmNlIHRoZSBjb250cmFjdCB3aXRoIGNlcnRhaW50eSBieSBzYXlpbmcgLy8gYXV0byByZXN1bHQgPSB2YXJpYWJsZV9ncmFkICsgbmV3X2dyYWQgKG9yIHZpY2UgdmVyc2EpLCBjaGVja2luZyByZXN1bHQncyAvLyBsYXlvdXQsIGFuZCBjb3B5aW5nIHRvIGFuIG9iZWRpZW50IGNsb25lIGlmIG5lY2Vzc2FyeSBiZWZvcmUgdXBkYXRlX2dyYWQuIC8vIFRoZSBjb3B5IHdvdWxkIHJlcXVpcmUgYW5vdGhlciBnbWVtIHBhc3MuIFdlIGNhbid0IGNyZWF0ZSBlbXB0eSByZXN1bHQgd2l0aCAvLyB0aGUgcmlnaHQgbGF5b3V0IHRoZW4gYWRkX291dCBpbnRvIGl0IHdpdGggYSBzaW5nbGUga2VybmVsLCBiZWNhdXNlIEdyYWRNb2RlIC8vIGlzIGVuYWJsZWQgaW4gdGhpcyBicmFuY2gsIGFuZCBhZGRfb3V0IGlzbid0IGRpZmZlcmVudGlhYmxlLiAvLyBNYXliZSBtb3JlIHRyb3VibGUgdGhhbiBpdCdzIHdvcnRoLiB9IH0gVmFyaWFibGUgdmFyaWFibGU7IH07IDwvY29kZT48L3ByZT4gPHA+5YW35L2T5Y+v5Lul5aaC5LiL5Zu+5omA56S677yM5bem6L655piv5pWw5o2u57uT5p6E77yM5Y+z6Z2i5piv566X5rOV5rWB56iL77yM5Y+z6Z2i55qE5bqP5Y+36KGo56S65omn6KGM5LuO5LiK6Iez5LiL77yM5omn6KGM6L+H56iL5LmL5Lit5Lya55So5Yiw5bem6L6555qE5pWw5o2u57uT5p6E77yM566X5rOV5LiO5pWw5o2u57uT5p6E55qE6LCD55So5YWz57O755Sx5qiq5ZCR566t5aS06KGo56S644CCPC9wPiA8b2w+IDxsaT7liIbluIPlvI/lvJXmk47osIPnlKhleGVjdXRlX2dyYXBoX3Rhc2tfdW50aWxfcmVhZHlfcXVldWVfZW1wdHnmnaXmiafooYzlhbfkvZPnmoQgR3JhcGhUYXNr44CCPC9saT4gPGxpPkVuZ2luZTo6ZXZhbHVhdGVfZnVuY3Rpb24g5Lya6LCD55SoIEdyYXBoVGFzayDkuYvkuK3nmoQgRXhlY0luZm/jgII8L2xpPiA8bGk+54S25ZCO5Lya6K6/6ZeuIEdyYWRDYXB0dXJlSG9va++8jOiwg+eUqGhvb2vvvIxob29rIOeahCBvcGVyYXRvcuWHveaVsOS8muiwg+eUqOWIsCBhdXRvZ3JhZENvbnRleHRfLSZndDthY2N1bXVsYXRlR3JhZOOAgjwvbGk+IDxsaT5hdXRvZ3JhZENvbnRleHRfIOS8muaJp+ihjCBhY2N1bXVsYXRlR3JhZO+8jOWvuSBob29r77yIRGlzdEFjY3VtdWxhdGVHcmFkQ2FwdHVyZUhvb2vvvInkuYvkuK3kv53lrZjnmoQgYWNjdW11bGF0ZUdyYWRfIOWBmuaTjeS9nOOAgjwvbGk+IDxsaT5BY2N1bXVsYXRlR3JhZDo6YWNjdW11bGF0ZUdyYWQg5Lya5a6M5oiQ5pyA57uI55qE5qKv5bqm5pu05paw5pON5L2c44CCPC9saT4gPC9vbD4gPHByZT48Y29kZSA+IERBVEEgU1RSVUNUVVJFICsgQUxHT1JJVEhNIHwgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyB8IHwgR3JhcGhUYXNrIHwgfCBEaXN0RW5naW5lOjpleGVjdXRlX2dyYXBoX3Rhc2tfdW50aWxfcmVhZHlfcXVldWVfZW1wdHkgfCB8IHwgKyB8IHwgdW5vcmRlcmVkX21hcCZsdDtOb2RlKiwgRXhlY0luZm8mZ3Q7IGV4ZWNfaW5mb18gfCB8IHwgfCB8ICsgfCAmbHQ7LS0tLS0tLS0tLSsgfCB8IHwgfCB8IHwgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyB8IHwgMSB8IHwgfCB8IHwgfCB2IHwgfCArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLSsgfCB2IHwgRXhlY0luZm8gfCAmbHQ7LS0tLS0tLS0tLS0tLSsgRW5naW5lOjpldmFsdWF0ZV9mdW5jdGlvbiB8IHwgfCArIHwgJmx0OyB2ZWN0b3ImbHQ7Q2FwdHVyZSZndDsgJmd0OyBjYXB0dXJlc18gfCB8IHwgfCArIHwgfCB8IHwgfCB8IHwgfCAyICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyB8IHwgfCB8IHYgfCB8IHYgfCArLS0rIGNhcHR1cmVkX2dyYWQgPSAoKmhvb2spKGNhcHR1cmVkX2dyYWQpICstLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKyB8IHwgKyB8IENhcHR1cmUgfCB8IHwgfCB8IHwgfCB8IHwgfCB2ZWN0b3ImbHQ7ICZsdDtHcmFkQ2FwdHVyZUhvb2smZ3Q7ICZndDsgaG9va3NfICZsdDstLS0tLS0tLS0tLS0tLSsgfCAzIHwgKyB8IHwgfCArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgfCB2IHwgfCB8IHwgKy0tKyBhdXRvZ3JhZENvbnRleHRfLSZndDthY2N1bXVsYXRlR3JhZCggdiB8IHwgYWNjdW11bGF0ZUdyYWRfLSZndDsgdmFyaWFibGUsIGlucHV0R3JhZHNbMF0sIDMpICstLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKyB8IHwgKyB8IERpc3RBY2N1bXVsYXRlR3JhZENhcHR1cmVIb29rIHwgfCB8IHwgfCB8IHwgfCB8IHwgQ29udGV4dFB0ciBhdXRvZ3JhZENvbnRleHRfICZsdDstLS0tLS0tLS0tLS0rIHwgNCB8IHwgfCB8IHwgfCBBY2N1bXVsYXRlR3JhZCBhY2N1bXVsYXRlR3JhZF8gJmx0Oy0tLS0tLS0tLS0tLSsgdiB8ICsgfCB8ICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyB8ICstKyBuZXdfZ3JhZCA9IEFjY3VtdWxhdGVHcmFkOjpjYWxsSG9va3ModmFyaWFibGUsIGdyYWQpIHwgfCB8ICsgfCB8IHwgfCB2IHwgfCB8IDUgKy0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tKyB8IHwgdiB8IEFjY3VtdWxhdGVHcmFkIHwgfCB8IHwgfCB8IHwgQWNjdW11bGF0ZUdyYWQ6OmFjY3VtdWxhdGVHcmFkKCB8IFZhcmlhYmxlIHZhcmlhYmxlICZsdDstLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tKyB2YXJpYWJsZSwgb2xkX2dyYWQsIG5ld19ncmFkLCkgfCB8IHwgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyArIDwvY29kZT48L3ByZT4gPHA+5omL5py65aaC5LiL77yaPC9wPiA8aDIgPjB4MDUg562J5b6F5a6M5oiQPC9oMj4gPHA+5pyA5ZCO77yM5YiG5biD5byP5byV5pOO5Lya6LCD55SoIGNsZWFyQW5kV2FpdEZvck91dHN0YW5kaW5nUnBjc0FzeW5jIOadpeetieW+heWkhOeQhuWujOaIkOOAgjwvcD4gPHByZT48Y29kZSA+YzEwOjppbnRydXNpdmVfcHRyJmx0O2MxMDo6aXZhbHVlOjpGdXR1cmUmZ3Q7IERpc3RBdXRvZ3JhZENvbnRleHQ6OiBjbGVhckFuZFdhaXRGb3JPdXRzdGFuZGluZ1JwY3NBc3luYygpIHsgc3RkOjp1bmlxdWVfbG9jayZsdDtzdGQ6Om11dGV4Jmd0OyBsb2NrKGxvY2tfKTsgYXV0byBvdXRTdGFuZGluZ1JwY3MgPSBzdGQ6Om1vdmUob3V0U3RhbmRpbmdScGNzXyk7IGxvY2sudW5sb2NrKCk7IHN0cnVjdCBTdGF0ZSB7IGV4cGxpY2l0IFN0YXRlKGludDMyX3QgY291bnQpIDogZnV0dXJlKCBjMTA6Om1ha2VfaW50cnVzaXZlJmx0O2MxMDo6aXZhbHVlOjpGdXR1cmUmZ3Q7KGMxMDo6Tm9uZVR5cGU6OmdldCgpKSksIHJlbWFpbmluZyhjb3VudCkge30gYzEwOjppbnRydXNpdmVfcHRyJmx0O2MxMDo6aXZhbHVlOjpGdXR1cmUmZ3Q7IGZ1dHVyZTsgc3RkOjphdG9taWMmbHQ7aW50MzJfdCZndDsgcmVtYWluaW5nOyBzdGQ6OmF0b21pYyZsdDtib29sJmd0OyBhbHJlYWR5U2VudEVycm9ye2ZhbHNlfTsgfTsgYXV0byBzdGF0ZSA9IHN0ZDo6bWFrZV9zaGFyZWQmbHQ7U3RhdGUmZ3Q7KG91dFN0YW5kaW5nUnBjcy5zaXplKCkpOyBpZiAob3V0U3RhbmRpbmdScGNzLmVtcHR5KCkpIHsgc3RhdGUtJmd0O2Z1dHVyZS0mZ3Q7bWFya0NvbXBsZXRlZChjMTA6OklWYWx1ZSgpKTsgfSBlbHNlIHsgZm9yIChhdXRvIHJwYyA6IG91dFN0YW5kaW5nUnBjcykgeyBycGMtJmd0O2FkZENhbGxiYWNrKFtzdGF0ZV0ocnBjOjpKaXRGdXR1cmUgZnV0dXJlKSB7IGlmIChmdXR1cmUuaGFzRXJyb3IoKSkgeyAvLyBJZiB0aGVyZSdzIGFuIGVycm9yLCB3ZSB3YW50IHRvIHNldEVycm9yKCkgb24gdGhlIGZ1dHVyZSwgLy8gdW5sZXNzIGFub3RoZXIgZXJyb3IgaGFzIGFscmVhZHkgYmVlbiBzZW50IC0gdXNlIGEgQ0FTIHRvIC8vIGd1YXJkLiAvLyAvLyBEb24ndCBkZWNyZW1lbnQgbnVtIHJlbWFpbmluZyBoZXJlISAoV2UgZG9uJ3QgbmVlZCB0bywgc2luY2UgLy8gbWVtb3J5IGhhbmRsaW5nIGlzIHNlcGFyYXRlKS4gSWYgd2Ugc2ltcGx5IGRvbid0IGRlY3JlbWVudCBvbiAvLyBlcnJvcnMsIHJlYWNoaW5nIDAgbWVhbnMgdGhhdCB0aGVyZSB3ZXJlIG5vIGVycm9ycyAtIGFuZCBoZW5jZSwgLy8gd2UgY2FuIGp1c3QgbWFya0NvbXBsZXRlZCgpIHdpdGhvdXQgYW55IG90aGVyIGNoZWNraW5nIHRoZXJlLiBib29sIGV4cGVjdGVkQWxyZWFkeVNlbnQgPSBmYWxzZTsgaWYgKHN0YXRlLSZndDthbHJlYWR5U2VudEVycm9yLmNvbXBhcmVfZXhjaGFuZ2Vfc3Ryb25nKCBleHBlY3RlZEFscmVhZHlTZW50LCB0cnVlKSkgeyBzdGF0ZS0mZ3Q7ZnV0dXJlLSZndDtzZXRFcnJvcihmdXR1cmUuZXhjZXB0aW9uX3B0cigpKTsgfSByZXR1cm47IH0gaWYgKC0tc3RhdGUtJmd0O3JlbWFpbmluZyA9PSAwKSB7IHN0YXRlLSZndDtmdXR1cmUtJmd0O21hcmtDb21wbGV0ZWQoYzEwOjpJVmFsdWUoKSk7IH0gfSk7IH0gfSByZXR1cm4gc3RhdGUtJmd0O2Z1dHVyZTsgfSA8L2NvZGU+PC9wcmU+IDxwPuaUr+aMge+8jOWIhuW4g+W8jyBhdXRvZ3JhZCDlhajpg6jliIbmnpDlrozmr5XvvIzliY3pnaLor7Tov4fvvIzliIbluIPlvI/lpITnkIbmnInlm5vlpKfph5HliJrvvIzmiJHku6znroDku4vkuoYgUlBD77yMUlJlZu+8jOWIhuaekOS6huWIhuW4g+W8j+W8leaTju+8jOS7juS4i+S4gOevh+W8gOWni++8jOaIkeS7rOW8gOWni+WIhuaekOWJqeS4i+eahOWIhuW4g+W8j+S8mOWMluWZqO+8jOatpOezu+WIl+WPr+iDveWMheaLrDR+Nuevh+OAgjwvcD4gPGgyID4weEZGIOWPguiAgzwvaDI+IDxwPjxhID5EaXN0cmlidXRlZCBBdXRvZ3JhZCBEZXNpZ248L2E+PC9wPiA8cD48YSA+UmVtb3RlIFJlZmVyZW5jZSBQcm90b2NvbDwvYT48L3A+IDxwPjxhID5QeVRvcmNoIOa6kOeggeino+ivu+S5i+WIhuW4g+W8j+iuree7g+S6huino+S4gOS4i++8nzwvYT48L3A+IDxwPjxhID5odHRwczovL3B5dG9yY2gub3JnL2RvY3Mvc3RhYmxlL2Rpc3RyaWJ1dGVkLmh0bWw8L2E+PC9wPiA8cD48YSA+aHR0cHM6Ly9weXRvcmNoLmFwYWNoZWNuLm9yZy9kb2NzLzEuNy81OS5odG1sPC9hPjwvcD4gPHA+PGEgPmh0dHBzOi8vcHl0b3JjaC5vcmcvZG9jcy9zdGFibGUvZGlzdHJpYnV0ZWQuaHRtbCNtb2R1bGUtdG9yY2guZGlzdHJpYnV0ZWQ8L2E+PC9wPiA8cD48YSA+aHR0cHM6Ly9weXRvcmNoLm9yZy9kb2NzL21hc3Rlci9ub3Rlcy9hdXRvZ3JhZC5odG1sPC9hPjwvcD4gPHA+PGEgPmh0dHBzOi8vcHl0b3JjaC5vcmcvZG9jcy9tYXN0ZXIvcnBjL2Rpc3RyaWJ1dGVkX2F1dG9ncmFkLmh0bWw8L2E+IDxhID5odHRwczovL3B5dG9yY2gub3JnL2RvY3MvbWFzdGVyL3JwYy9ycGMuaHRtbDwvYT48L3A+IDxwPjxhID5odHRwczovL3d3dy53M2NzY2hvb2wuY24vcHl0b3JjaC9weXRvcmNoLWNkdmEzYnVmLmh0bWw8L2E+PC9wPiA8cD48YSA+UHlUb3JjaCDliIbluIPlvI8gQXV0b2dyYWQg6K6+6K6hPC9hPjwvcD4gPHA+PGEgPkdldHRpbmcgc3RhcnRlZCB3aXRoIERpc3RyaWJ1dGVkIFJQQyBGcmFtZXdvcms8L2E+PC9wPiA8cD48YSA+SW1wbGVtZW50aW5nIGEgUGFyYW1ldGVyIFNlcnZlciB1c2luZyBEaXN0cmlidXRlZCBSUEMgRnJhbWV3b3JrPC9hPjwvcD4gPHA+PGEgPkNvbWJpbmluZyBEaXN0cmlidXRlZCBEYXRhUGFyYWxsZWwgd2l0aCBEaXN0cmlidXRlZCBSUEMgRnJhbWV3b3JrPC9hPjwvcD4gPHA+PGEgPlByb2ZpbGluZyBSUEMtYmFzZWQgV29ya2xvYWRzPC9hPjwvcD4gPHA+PGEgPkltcGxlbWVudGluZyBiYXRjaCBSUEMgcHJvY2Vzc2luZzwvYT48L3A+IDxwPjxhID5EaXN0cmlidXRlZCBQaXBlbGluZSBQYXJhbGxlbDwvYT48L3A+IDwvZGl2PiA8L2Rpdj4gPGRpdiA+cG9zdGVkIEAgMjAyMS0xMi0wNiAxODoxMiA8YSA+572X6KW/55qE5oCd6ICDPC9hPiDpmIXor7soMCkg6K+E6K66KDApIOe8lui+kSDmlLbol48gPGEgPuS4vuaKpTwvYT48L2Rpdj4gPC9kaXY+IDxkaXYgPiA8ZGl2ID48YSA+5Yi35paw6K+E6K66PC9hPjxhID7liLfmlrDpobXpnaI8L2E+PGEgPui/lOWbnumhtumDqDwvYT48L2Rpdj4gPC9kaXY+IDwvZGl2PiA8L2Rpdj4gPC9kaXY+IDwvZGl2PiA8L2Rpdj4gPGRpdiA+IENvcHlyaWdodCDCqSAyMDIxIOe9l+ilv+eahOaAneiAgyA8c3BhbiA+UG93ZXJlZCBieSAuTkVUIDYgb24gS3ViZXJuZXRlczwvc3Bhbj4gPC9kaXY+IDwvZGl2PiA8L2JvZHk+'</script>

      </head>
        <body class="valid" valid="valid" title="valid: True, node: 1, level: 1" node_number="1"> <div class="valid" valid="valid" title="valid: True, node: 2, level: 2" node_number="2">  </div> <div class="valid" valid="valid" title="valid: True, node: 3, level: 2" node_number="3"> <div class="valid" valid="valid" title="valid: True, node: 4, level: 3" node_number="4"> <div class="valid" valid="valid" title="valid: True, node: 5, level: 4" node_number="5"> <div class="valid" valid="valid" title="valid: True, node: 6, level: 5" node_number="6"><a class="valid" valid="valid" title="valid: True, node: 7, level: 6" node_number="7">&#32599;&#35199;&#30340;&#24605;&#32771;</a> </div> <div class="valid" valid="valid" title="valid: True, node: 8, level: 5" node_number="8">&#19968;&#25163;&#20280;&#21521;&#25216;&#26415;&#65292;&#19968;&#25163;&#20280;&#21521;&#29983;&#27963;</div> </div> <div class="valid" valid="valid" title="valid: True, node: 9, level: 4" node_number="9"> <ul class="valid" valid="valid" title="valid: True, node: 10, level: 5" node_number="10"> <li class="valid" valid="valid" title="valid: True, node: 11, level: 6" node_number="11"><a class="valid" valid="valid" title="valid: True, node: 12, level: 7" node_number="12"> &#21338;&#23458;&#22253;</a> </li> <li class="valid" valid="valid" title="valid: True, node: 13, level: 6" node_number="13"> <a class="valid" valid="valid" title="valid: True, node: 14, level: 7" node_number="14"> &#39318;&#39029;</a> </li> <li class="valid" valid="valid" title="valid: True, node: 15, level: 6" node_number="15"> <a class="valid" valid="valid" title="valid: True, node: 16, level: 7" node_number="16"> &#26032;&#38543;&#31508;</a> </li> <li class="valid" valid="valid" title="valid: True, node: 17, level: 6" node_number="17"> <a class="valid" valid="valid" title="valid: True, node: 18, level: 7" node_number="18"> &#32852;&#31995;</a></li> <li class="valid" valid="valid" title="valid: True, node: 19, level: 6" node_number="19"> <a class="valid" valid="valid" title="valid: True, node: 20, level: 7" node_number="20"> &#35746;&#38405;</a></li> <li class="valid" valid="valid" title="valid: True, node: 21, level: 6" node_number="21"> <a class="valid" valid="valid" title="valid: True, node: 22, level: 7" node_number="22"> &#31649;&#29702;</a> </li> </ul> </div> </div> <div class="valid" valid="valid" title="valid: True, node: 23, level: 3" node_number="23"> <div class="valid" valid="valid" title="valid: True, node: 24, level: 4" node_number="24"> <div class="valid" valid="valid" title="valid: True, node: 25, level: 5" node_number="25"> <div class="valid" valid="valid" title="valid: True, node: 26, level: 6" node_number="26"> <div class="valid" valid="valid" title="valid: True, node: 27, level: 7" node_number="27"> <div class="valid" valid="valid" title="valid: True, node: 28, level: 8" node_number="28"> <h1 class="valid" valid="valid" title="valid: True, node: 29, level: 9" node_number="29"> <a class="valid" valid="valid" title="valid: True, node: 30, level: 10" node_number="30"> [&#28304;&#30721;&#35299;&#26512;] PyTorch &#20998;&#24067;&#24335; Autograd (6) ---- &#24341;&#25806;(&#19979;) </a> </h1> <div class="valid" valid="valid" title="valid: True, node: 31, level: 9" node_number="31"> <div class="valid" valid="valid" title="valid: True, node: 32, level: 10" node_number="32"> &#19978;&#25991;&#25105;&#20204;&#20171;&#32461;&#20102;&#24341;&#25806;&#22914;&#20309;&#33719;&#24471;&#21518;&#21521;&#35745;&#31639;&#22270;&#30340;&#20381;&#36182;&#65292;&#26412;&#25991;&#25105;&#20204;&#23601;&#25509;&#30528;&#30475;&#30475;&#24341;&#25806;&#22914;&#20309;&#20381;&#25454;&#36825;&#20123;&#20381;&#36182;&#36827;&#34892;&#21518;&#21521;&#20256;&#25773;&#12290; </div> <div class="valid" valid="valid" title="valid: True, node: 33, level: 10" node_number="33"> <h1 class="valid" valid="valid" title="valid: True, node: 34, level: 11" node_number="34">[&#28304;&#30721;&#35299;&#26512;] PyTtorch &#20998;&#24067;&#24335; Autograd (6) ---- &#24341;&#25806;(&#19979;)</h1> <div class="valid" valid="valid" title="valid: True, node: 35, level: 11" node_number="35"><div class="valid" valid="valid" title="valid: True, node: 36, level: 12" node_number="36">&#30446;&#24405;</div><ul class="valid" valid="valid" title="valid: True, node: 37, level: 12" node_number="37"><li class="valid" valid="valid" title="valid: True, node: 38, level: 13" node_number="38">[&#28304;&#30721;&#35299;&#26512;] PyTtorch &#20998;&#24067;&#24335; Autograd (6) ---- &#24341;&#25806;(&#19979;)<ul class="valid" valid="valid" title="valid: True, node: 39, level: 14" node_number="39"><li title="valid: False, node: 40, level: 15" node_number="40"><a title="valid: False, node: 41, level: 16" node_number="41">0x00 &#25688;&#35201;</a></li><li title="valid: False, node: 42, level: 15" node_number="42"><a title="valid: False, node: 43, level: 16" node_number="43">0x01 &#22238;&#39038;</a></li><li title="valid: False, node: 44, level: 15" node_number="44"><a title="valid: False, node: 45, level: 16" node_number="45">0x02 &#25191;&#34892;GraphTask</a><ul title="valid: False, node: 46, level: 16" node_number="46"><li title="valid: False, node: 47, level: 17" node_number="47"><a title="valid: False, node: 48, level: 18" node_number="48">2.1 runEngineAndAccumulateGradients</a></li><li title="valid: False, node: 49, level: 17" node_number="49"><a title="valid: False, node: 50, level: 18" node_number="50">2.2 execute_graph_task_until_ready_queue_empty</a></li><li title="valid: False, node: 51, level: 17" node_number="51"><a title="valid: False, node: 52, level: 18" node_number="52">2.3 evaluate_function</a></li><li title="valid: False, node: 53, level: 17" node_number="53"><a title="valid: False, node: 54, level: 18" node_number="54">2.4 globalCpuThread</a></li><li title="valid: False, node: 55, level: 17" node_number="55"><a title="valid: False, node: 56, level: 18" node_number="56">2.5 &#23567;&#32467;</a></li></ul></li><li title="valid: False, node: 57, level: 15" node_number="57"><a title="valid: False, node: 58, level: 16" node_number="58">0x03 RPC&#35843;&#29992;</a><ul title="valid: False, node: 59, level: 16" node_number="59"><li title="valid: False, node: 60, level: 17" node_number="60"><a title="valid: False, node: 61, level: 18" node_number="61">3.1 RecvRpcBackward</a><ul title="valid: False, node: 62, level: 18" node_number="62"><li title="valid: False, node: 63, level: 19" node_number="63"><a title="valid: False, node: 64, level: 20" node_number="64">3.1.1 &#23450;&#20041;</a></li><li title="valid: False, node: 65, level: 19" node_number="65"><a title="valid: False, node: 66, level: 20" node_number="66">3.1.2 &#26500;&#24314;</a></li><li title="valid: False, node: 67, level: 19" node_number="67"><a title="valid: False, node: 68, level: 20" node_number="68">3.1.3 apply</a></li></ul></li><li title="valid: False, node: 69, level: 17" node_number="69"><a title="valid: False, node: 70, level: 18" node_number="70">3.2 PropagateGradientsReq</a><ul title="valid: False, node: 71, level: 18" node_number="71"><li title="valid: False, node: 72, level: 19" node_number="72"><a title="valid: False, node: 73, level: 20" node_number="73">3.2.1 &#23450;&#20041;</a></li></ul></li><li title="valid: False, node: 74, level: 17" node_number="74"><a title="valid: False, node: 75, level: 18" node_number="75">3.3 &#25509;&#21463;&#26041;</a><ul title="valid: False, node: 76, level: 18" node_number="76"><li title="valid: False, node: 77, level: 19" node_number="77"><a title="valid: False, node: 78, level: 20" node_number="78">3.3.1 &#25509;&#21463;&#28040;&#24687;</a></li><li title="valid: False, node: 79, level: 19" node_number="79"><a title="valid: False, node: 80, level: 20" node_number="80">3.3.2 processBackwardAutogradReq</a></li><li title="valid: False, node: 81, level: 19" node_number="81"><a title="valid: False, node: 82, level: 20" node_number="82">3.3.3 executeSendFunctionAsync</a></li></ul></li></ul></li><li title="valid: False, node: 83, level: 15" node_number="83"><a title="valid: False, node: 84, level: 16" node_number="84">0x04 DistAccumulateGradCaptureHook</a><ul title="valid: False, node: 85, level: 16" node_number="85"><li title="valid: False, node: 86, level: 17" node_number="86"><a title="valid: False, node: 87, level: 18" node_number="87">4.1 &#23450;&#20041;</a></li><li title="valid: False, node: 88, level: 17" node_number="88"><a title="valid: False, node: 89, level: 18" node_number="89">4.2 &#29983;&#25104;</a></li><li title="valid: False, node: 90, level: 17" node_number="90"><a title="valid: False, node: 91, level: 18" node_number="91">4.3 &#20351;&#29992;</a></li><li title="valid: False, node: 92, level: 17" node_number="92"><a title="valid: False, node: 93, level: 18" node_number="93">4.4 &#32047;&#31215;&#26799;&#24230;</a><ul title="valid: False, node: 94, level: 18" node_number="94"><li title="valid: False, node: 95, level: 19" node_number="95"><a title="valid: False, node: 96, level: 20" node_number="96">4.4.1 &#19978;&#19979;&#25991;&#32047;&#31215;</a></li><li title="valid: False, node: 97, level: 19" node_number="97"><a title="valid: False, node: 98, level: 20" node_number="98">4.4.2 &#31639;&#23376;&#32047;&#31215;</a></li></ul></li></ul></li><li title="valid: False, node: 99, level: 15" node_number="99"><a title="valid: False, node: 100, level: 16" node_number="100">0x05 &#31561;&#24453;&#23436;&#25104;</a></li><li title="valid: False, node: 101, level: 15" node_number="101"><a title="valid: False, node: 102, level: 16" node_number="102">0xFF &#21442;&#32771;</a></li></ul></li></ul></div> <h2 class="valid" valid="valid" title="valid: True, node: 103, level: 11" node_number="103">0x00 &#25688;&#35201;</h2> <p class="valid" valid="valid" title="valid: True, node: 104, level: 11" node_number="104">&#19978;&#25991;&#25105;&#20204;&#20171;&#32461;&#20102;&#24341;&#25806;&#22914;&#20309;&#33719;&#24471;&#21518;&#21521;&#35745;&#31639;&#22270;&#30340;&#20381;&#36182;&#65292;&#26412;&#25991;&#25105;&#20204;&#23601;&#25509;&#30528;&#30475;&#30475;&#24341;&#25806;&#22914;&#20309;&#20381;&#25454;&#36825;&#20123;&#20381;&#36182;&#36827;&#34892;&#21518;&#21521;&#20256;&#25773;&#12290;&#36890;&#36807;&#26412;&#25991;&#30340;&#23398;&#20064;&#65292;&#22823;&#23478;&#21487;&#20197;&#65306;</p> <ul class="valid" valid="valid" title="valid: True, node: 105, level: 11" node_number="105"> <li class="valid" valid="valid" title="valid: True, node: 106, level: 12" node_number="106">&#20102;&#35299; RecvRpcBackward &#22914;&#20309;&#32473;&#23545;&#24212;&#30340;&#19979;&#28216;&#33410;&#28857;&#21457;&#36865; RPC &#28040;&#24687;&#65292;&#21487;&#20197;&#20877;&#27425;&#26803;&#29702;&#19968;&#19979;worker&#20043;&#38388;&#21518;&#21521;&#20256;&#25773;&#30340;&#20132;&#20114;&#27969;&#31243;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 107, level: 12" node_number="107">&#20102;&#35299; AccumulateGrad &#22914;&#20309;&#22312;&#19978;&#19979;&#25991;&#32047;&#31215;&#26799;&#24230;&#12290;</li> </ul> <p class="valid" valid="valid" title="valid: True, node: 108, level: 11" node_number="108">PyTorch&#20998;&#24067;&#24335;&#20854;&#20182;&#25991;&#31456;&#22914;&#19979;&#65306;</p> <p class="valid" valid="valid" title="valid: True, node: 109, level: 11" node_number="109"><a class="valid" valid="valid" title="valid: True, node: 110, level: 12" node_number="110">&#28145;&#24230;&#23398;&#20064;&#21033;&#22120;&#20043;&#33258;&#21160;&#24494;&#20998;(1)</a></p> <p class="valid" valid="valid" title="valid: True, node: 111, level: 11" node_number="111"><a class="valid" valid="valid" title="valid: True, node: 112, level: 12" node_number="112">&#28145;&#24230;&#23398;&#20064;&#21033;&#22120;&#20043;&#33258;&#21160;&#24494;&#20998;(2)</a></p> <p class="valid" valid="valid" title="valid: True, node: 113, level: 11" node_number="113">[<a class="valid" valid="valid" title="valid: True, node: 114, level: 12" node_number="114">&#28304;&#30721;&#35299;&#26512;]&#28145;&#24230;&#23398;&#20064;&#21033;&#22120;&#20043;&#33258;&#21160;&#24494;&#20998;(3) --- &#31034;&#20363;&#35299;&#35835;</a></p> <p class="valid" valid="valid" title="valid: True, node: 115, level: 11" node_number="115">[<a class="valid" valid="valid" title="valid: True, node: 116, level: 12" node_number="116">&#28304;&#30721;&#35299;&#26512;]PyTorch&#22914;&#20309;&#23454;&#29616;&#21069;&#21521;&#20256;&#25773;(1) --- &#22522;&#30784;&#31867;(&#19978;)</a></p> <p class="valid" valid="valid" title="valid: True, node: 117, level: 11" node_number="117">[<a class="valid" valid="valid" title="valid: True, node: 118, level: 12" node_number="118">&#28304;&#30721;&#35299;&#26512;]PyTorch&#22914;&#20309;&#23454;&#29616;&#21069;&#21521;&#20256;&#25773;(2) --- &#22522;&#30784;&#31867;(&#19979;)</a></p> <p class="valid" valid="valid" title="valid: True, node: 119, level: 11" node_number="119">[<a class="valid" valid="valid" title="valid: True, node: 120, level: 12" node_number="120">&#28304;&#30721;&#35299;&#26512;] PyTorch&#22914;&#20309;&#23454;&#29616;&#21069;&#21521;&#20256;&#25773;(3) --- &#20855;&#20307;&#23454;&#29616;</a></p> <p class="valid" valid="valid" title="valid: True, node: 121, level: 11" node_number="121">[<a class="valid" valid="valid" title="valid: True, node: 122, level: 12" node_number="122">&#28304;&#30721;&#35299;&#26512;] Pytorch &#22914;&#20309;&#23454;&#29616;&#21518;&#21521;&#20256;&#25773; (1)---- &#35843;&#29992;&#24341;&#25806;</a></p> <p class="valid" valid="valid" title="valid: True, node: 123, level: 11" node_number="123">[<a class="valid" valid="valid" title="valid: True, node: 124, level: 12" node_number="124">&#28304;&#30721;&#35299;&#26512;] Pytorch &#22914;&#20309;&#23454;&#29616;&#21518;&#21521;&#20256;&#25773; (2)---- &#24341;&#25806;&#38745;&#24577;&#32467;&#26500;</a></p> <p class="valid" valid="valid" title="valid: True, node: 125, level: 11" node_number="125">[<a class="valid" valid="valid" title="valid: True, node: 126, level: 12" node_number="126">&#28304;&#30721;&#35299;&#26512;] Pytorch &#22914;&#20309;&#23454;&#29616;&#21518;&#21521;&#20256;&#25773; (3)---- &#24341;&#25806;&#21160;&#24577;&#36923;&#36753;</a></p> <p class="valid" valid="valid" title="valid: True, node: 127, level: 11" node_number="127">[<a class="valid" valid="valid" title="valid: True, node: 128, level: 12" node_number="128">&#28304;&#30721;&#35299;&#26512;] PyTorch &#22914;&#20309;&#23454;&#29616;&#21518;&#21521;&#20256;&#25773; (4)---- &#20855;&#20307;&#31639;&#27861;</a></p> <p class="valid" valid="valid" title="valid: True, node: 129, level: 11" node_number="129">[<a class="valid" valid="valid" title="valid: True, node: 130, level: 12" node_number="130">&#28304;&#30721;&#35299;&#26512;] PyTorch &#20998;&#24067;&#24335;(1)------&#21382;&#21490;&#21644;&#27010;&#36848;</a></p> <p class="valid" valid="valid" title="valid: True, node: 131, level: 11" node_number="131">[<a class="valid" valid="valid" title="valid: True, node: 132, level: 12" node_number="132">&#28304;&#30721;&#35299;&#26512;] PyTorch &#20998;&#24067;&#24335;(2) ----- DataParallel(&#19978;)</a></p> <p class="valid" valid="valid" title="valid: True, node: 133, level: 11" node_number="133">[<a class="valid" valid="valid" title="valid: True, node: 134, level: 12" node_number="134">&#28304;&#30721;&#35299;&#26512;] PyTorch &#20998;&#24067;&#24335;(3) ----- DataParallel(&#19979;)</a></p> <p class="valid" valid="valid" title="valid: True, node: 135, level: 11" node_number="135">[<a class="valid" valid="valid" title="valid: True, node: 136, level: 12" node_number="136">&#28304;&#30721;&#35299;&#26512;] PyTorch &#20998;&#24067;&#24335;(4)------&#20998;&#24067;&#24335;&#24212;&#29992;&#22522;&#30784;&#27010;&#24565;</a></p> <p class="valid" valid="valid" title="valid: True, node: 137, level: 11" node_number="137">[<a class="valid" valid="valid" title="valid: True, node: 138, level: 12" node_number="138">&#28304;&#30721;&#35299;&#26512;] PyTorch&#20998;&#24067;&#24335;(5) ------ DistributedDataParallel &#24635;&#36848;&#22914;&#20309;&#20351;&#29992;</a></p> <p class="valid" valid="valid" title="valid: True, node: 139, level: 11" node_number="139">[<a class="valid" valid="valid" title="valid: True, node: 140, level: 12" node_number="140">&#28304;&#30721;&#35299;&#26512;] PyTorch&#20998;&#24067;&#24335;(6) ---DistributedDataParallel -- &#21021;&#22987;&#21270;store</a></p> <p class="valid" valid="valid" title="valid: True, node: 141, level: 11" node_number="141">[<a class="valid" valid="valid" title="valid: True, node: 142, level: 12" node_number="142">&#28304;&#30721;&#35299;&#26512;] PyTorch &#20998;&#24067;&#24335;(7) ----- DistributedDataParallel &#20043;&#36827;&#31243;&#32452;</a></p> <p class="valid" valid="valid" title="valid: True, node: 143, level: 11" node_number="143">[<a class="valid" valid="valid" title="valid: True, node: 144, level: 12" node_number="144">&#28304;&#30721;&#35299;&#26512;] PyTorch &#20998;&#24067;&#24335;(8) -------- DistributedDataParallel&#20043;&#35770;&#25991;&#31687;</a></p> <p class="valid" valid="valid" title="valid: True, node: 145, level: 11" node_number="145">[<a class="valid" valid="valid" title="valid: True, node: 146, level: 12" node_number="146">&#28304;&#30721;&#35299;&#26512;] PyTorch &#20998;&#24067;&#24335;(9) ----- DistributedDataParallel &#20043;&#21021;&#22987;&#21270;</a></p> <p class="valid" valid="valid" title="valid: True, node: 147, level: 11" node_number="147">[<a class="valid" valid="valid" title="valid: True, node: 148, level: 12" node_number="148">&#28304;&#30721;&#35299;&#26512;] PyTorch &#20998;&#24067;&#24335;(10)------DistributedDataParallel &#20043; Reducer&#38745;&#24577;&#26550;&#26500;</a></p> <p class="valid" valid="valid" title="valid: True, node: 149, level: 11" node_number="149">[<a class="valid" valid="valid" title="valid: True, node: 150, level: 12" node_number="150">&#28304;&#30721;&#35299;&#26512;] PyTorch &#20998;&#24067;&#24335;(11) ----- DistributedDataParallel &#20043; &#26500;&#24314;Reducer&#21644;Join&#25805;&#20316;</a></p> <p class="valid" valid="valid" title="valid: True, node: 151, level: 11" node_number="151">[<a class="valid" valid="valid" title="valid: True, node: 152, level: 12" node_number="152">&#28304;&#30721;&#35299;&#26512;] PyTorch &#20998;&#24067;&#24335;(12) ----- DistributedDataParallel &#20043; &#21069;&#21521;&#20256;&#25773;</a></p> <p class="valid" valid="valid" title="valid: True, node: 153, level: 11" node_number="153">[<a class="valid" valid="valid" title="valid: True, node: 154, level: 12" node_number="154">&#28304;&#30721;&#35299;&#26512;] PyTorch &#20998;&#24067;&#24335;(13) ----- DistributedDataParallel &#20043; &#21453;&#21521;&#20256;&#25773;</a></p> <p class="valid" valid="valid" title="valid: True, node: 155, level: 11" node_number="155">[<a class="valid" valid="valid" title="valid: True, node: 156, level: 12" node_number="156">&#28304;&#30721;&#35299;&#26512;] PyTorch &#20998;&#24067;&#24335; Autograd (1) ---- &#35774;&#35745;</a></p> <p class="valid" valid="valid" title="valid: True, node: 157, level: 11" node_number="157">[<a class="valid" valid="valid" title="valid: True, node: 158, level: 12" node_number="158">&#28304;&#30721;&#35299;&#26512;] PyTorch &#20998;&#24067;&#24335; Autograd (2) ---- RPC&#22522;&#30784;</a></p> <p class="valid" valid="valid" title="valid: True, node: 159, level: 11" node_number="159">[<a class="valid" valid="valid" title="valid: True, node: 160, level: 12" node_number="160">&#28304;&#30721;&#35299;&#26512;] PyTorch &#20998;&#24067;&#24335; Autograd (3) ---- &#19978;&#19979;&#25991;&#30456;&#20851;</a></p> <p class="valid" valid="valid" title="valid: True, node: 161, level: 11" node_number="161">[<a class="valid" valid="valid" title="valid: True, node: 162, level: 12" node_number="162">&#28304;&#30721;&#35299;&#26512;] PyTorch &#20998;&#24067;&#24335; Autograd (4) ---- &#22914;&#20309;&#20999;&#20837;&#24341;&#25806;</a></p> <p class="valid" valid="valid" title="valid: True, node: 163, level: 11" node_number="163">[<a class="valid" valid="valid" title="valid: True, node: 164, level: 12" node_number="164">&#28304;&#30721;&#35299;&#26512;] PyTorch &#20998;&#24067;&#24335; Autograd (5) ---- &#24341;&#25806;(&#19978;)</a></p> <p class="valid" valid="valid" title="valid: True, node: 165, level: 11" node_number="165">&#20026;&#20102;&#26356;&#22909;&#30340;&#35828;&#26126;&#65292;&#26412;&#25991;&#20195;&#30721;&#20250;&#20381;&#25454;&#20855;&#20307;&#24773;&#20917;&#26469;&#36827;&#34892;&#30456;&#24212;&#31934;&#31616;&#12290;</p> <h2 class="valid" valid="valid" title="valid: True, node: 166, level: 11" node_number="166">0x01 &#22238;&#39038;</h2> <p class="valid" valid="valid" title="valid: True, node: 167, level: 11" node_number="167">&#25105;&#20204;&#39318;&#20808;&#22238;&#39038;FAST&#27169;&#24335;&#31639;&#27861;&#31639;&#27861;&#22914;&#19979;&#65292;&#26412;&#25991;&#38656;&#35201;&#35752;&#35770;&#21518;&#38754;&#33509;&#24178;&#37096;&#20998;&#12290;</p> <ol class="valid" valid="valid" title="valid: True, node: 168, level: 11" node_number="168"> <li class="valid" valid="valid" title="valid: True, node: 169, level: 12" node_number="169">&#25105;&#20204;&#20174;&#20855;&#26377;&#21453;&#21521;&#20256;&#25773;&#26681;&#30340;worker&#24320;&#22987;&#65288;&#25152;&#26377;&#26681;&#37117;&#24517;&#39035;&#26159;&#26412;&#22320;&#30340;&#65289;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 170, level: 12" node_number="170">&#26597;&#25214;&#24403;&#21069;Distributed Autograd Context &#30340;&#25152;&#26377;<code class="valid" valid="valid" title="valid: True, node: 171, level: 13" node_number="171">send</code>&#20989;&#25968; &#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 172, level: 12" node_number="172">&#20174;&#25552;&#20379;&#30340;&#26681;&#21644;&#25105;&#20204;&#26816;&#32034;&#21040;&#30340;&#25152;&#26377;<code class="valid" valid="valid" title="valid: True, node: 173, level: 13" node_number="173">send</code>&#20989;&#25968;&#24320;&#22987;&#65292;&#25105;&#20204;&#22312;&#26412;&#22320;&#35745;&#31639;&#20381;&#36182;&#39033; &#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 174, level: 12" node_number="174">&#35745;&#31639;&#20381;&#36182;&#39033;&#21518;&#65292;&#20351;&#29992;&#25552;&#20379;&#30340;&#26681;&#26469;&#21551;&#21160;&#26412;&#22320; autograd &#24341;&#25806;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 175, level: 12" node_number="175">&#24403; autograd &#24341;&#25806;&#25191;&#34892;&#35813;<code class="valid" valid="valid" title="valid: True, node: 176, level: 13" node_number="176">recv</code>&#20989;&#25968;&#26102;&#65292;&#35813;<code class="valid" valid="valid" title="valid: True, node: 177, level: 13" node_number="177">recv</code> &#20989;&#25968;&#36890;&#36807; RPC &#23558;&#36755;&#20837;&#26799;&#24230;&#21457;&#36865;&#21040;&#36866;&#24403;&#30340;worker&#12290;&#27599;&#20010;<code class="valid" valid="valid" title="valid: True, node: 178, level: 13" node_number="178">recv</code>&#20989;&#25968;&#37117;&#30693;&#36947;&#30446;&#26631; worker id&#65292;&#22240;&#20026;&#23427;&#34987;&#35760;&#24405;&#20026;&#21069;&#21521;&#20256;&#25773;&#30340;&#19968;&#37096;&#20998;&#12290;&#36890;&#36807;<code class="valid" valid="valid" title="valid: True, node: 179, level: 13" node_number="179">autograd_context_id</code>&#21644; <code class="valid" valid="valid" title="valid: True, node: 180, level: 13" node_number="180">autograd_message_id</code> &#35813;<code class="valid" valid="valid" title="valid: True, node: 181, level: 13" node_number="181">recv</code>&#20989;&#25968;&#34987;&#21457;&#36865;&#21040;&#36828;&#31243;&#20027;&#26426;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 182, level: 12" node_number="182">&#24403;&#36828;&#31243;&#20027;&#26426;&#25910;&#21040;&#36825;&#20010;&#35831;&#27714;&#26102;&#65292;&#25105;&#20204;&#20351;&#29992; <code class="valid" valid="valid" title="valid: True, node: 183, level: 13" node_number="183">autograd_context_id</code>&#21644;<code class="valid" valid="valid" title="valid: True, node: 184, level: 13" node_number="184">autograd_message_id</code>&#26469;&#26597;&#25214;&#36866;&#24403;&#30340;<code class="valid" valid="valid" title="valid: True, node: 185, level: 13" node_number="185">send</code>&#20989;&#25968;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 186, level: 12" node_number="186">&#22914;&#26524;&#36825;&#26159;worker&#31532;&#19968;&#27425;&#25910;&#21040;&#23545;&#32473;&#23450; <code class="valid" valid="valid" title="valid: True, node: 187, level: 13" node_number="187">autograd_context_id</code>&#30340;&#35831;&#27714;&#65292;&#23427;&#23558;&#25353;&#29031;&#19978;&#38754;&#30340;&#31532; 1-3 &#28857;&#25152;&#36848;&#22312;&#26412;&#22320;&#35745;&#31639;&#20381;&#36182;&#39033;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 188, level: 12" node_number="188">&#28982;&#21518;&#23558;&#22312;&#31532;6&#28857;&#25509;&#21463;&#21040;&#30340;<code class="valid" valid="valid" title="valid: True, node: 189, level: 13" node_number="189">send</code>&#26041;&#27861;&#25554;&#20837;&#38431;&#21015;&#65292;&#20197;&#20415;&#22312;&#35813;worker&#30340;&#26412;&#22320; autograd &#24341;&#25806;&#19978;&#25191;&#34892;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 190, level: 12" node_number="190">&#26368;&#21518;&#65292;&#25105;&#20204;&#19981;&#26159;&#22312; Tensor&#30340;<code class="valid" valid="valid" title="valid: True, node: 191, level: 13" node_number="191">.grad</code>&#20043;&#19978;&#32047;&#31215;&#26799;&#24230;&#65292;&#32780;&#26159;&#22312;&#27599;&#20010;Distributed Autograd Context&#20043;&#19978;&#20998;&#21035;&#32047;&#31215;&#26799;&#24230; &#12290;&#26799;&#24230;&#23384;&#20648;&#22312;<code class="valid" valid="valid" title="valid: True, node: 192, level: 13" node_number="192">Dict[Tensor, Tensor]</code>&#20043;&#20013; &#65292;<code class="valid" valid="valid" title="valid: True, node: 193, level: 13" node_number="193">Dict[Tensor, Tensor]</code>&#22522;&#26412;&#19978;&#26159;&#20174; Tensor &#21040;&#20854;&#20851;&#32852;&#26799;&#24230;&#30340;&#26144;&#23556;&#65292;&#24182;&#19988;&#21487;&#20197;&#20351;&#29992; get_gradients() API&#26816;&#32034;&#35813;&#26144;&#23556; &#12290;</li> </ol> <p class="valid" valid="valid" title="valid: True, node: 194, level: 11" node_number="194">&#20854;&#27425;&#65292;&#25105;&#20204;&#30475;&#30475;&#24635;&#20307;&#25191;&#34892;&#20195;&#30721;&#65292;&#24635;&#20307;&#25191;&#34892;&#26159;&#22312; DistEngine::execute &#20043;&#20013;&#23436;&#25104;&#65292;&#20855;&#20307;&#20998;&#20026;&#22914;&#19979;&#27493;&#39588;&#65306;</p> <ul class="valid" valid="valid" title="valid: True, node: 195, level: 11" node_number="195"> <li class="valid" valid="valid" title="valid: True, node: 196, level: 12" node_number="196">&#20351;&#29992; contextId &#24471;&#21040;&#21069;&#21521;&#30340;&#19978;&#19979;&#25991;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 197, level: 12" node_number="197">&#20351;&#29992; validateRootsAndRetrieveEdges &#36827;&#34892;&#39564;&#35777;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 198, level: 12" node_number="198">&#26500;&#36896;&#19968;&#20010;GraphRoot&#65292;&#29992;&#23427;&#26469;&#39537;&#21160;&#21518;&#21521;&#20256;&#25773;&#65292;&#21487;&#20197;&#35748;&#20026;&#26159;&#19968;&#20010;&#34394;&#25311;&#26681;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 199, level: 12" node_number="199">&#20351;&#29992; computeDependencies &#35745;&#31639;&#20381;&#36182;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 200, level: 12" node_number="200">&#20351;&#29992; runEngineAndAccumulateGradients &#36827;&#34892;&#21453;&#21521;&#20256;&#25773;&#35745;&#31639;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 201, level: 12" node_number="201">&#20351;&#29992; clearAndWaitForOutstandingRpcsAsync &#31561;&#24453; RPC &#23436;&#25104;&#12290;</li> </ul> <pre class="valid" valid="valid" title="valid: True, node: 202, level: 11" node_number="202"><code class="valid" valid="valid" title="valid: True, node: 203, level: 12" node_number="203">void DistEngine::execute( int64_t contextId, const variable_list roots, bool retainGraph) { // Retrieve the context for the given context_id. This will throw if the // context_id is invalid. auto autogradContext = DistAutogradContainer::getInstance().retrieveContext(contextId); // Perform initial pre-processing. edge_list rootEdges; variable_list grads; validateRootsAndRetrieveEdges(roots, rootEdges, grads); // &#26500;&#36896;&#19968;&#20010;GraphRoot&#65292;&#29992;&#23427;&#26469;&#39537;&#21160;&#21518;&#21521;&#20256;&#25773;&#65292;&#21487;&#20197;&#35748;&#20026;&#26159;&#19968;&#20010;&#34394;&#25311;&#26681; std::shared_ptr&lt;Node&gt; graphRoot = std::make_shared&lt;GraphRoot&gt;(rootEdges, grads); edge_list outputEdges; // Compute dependencies locally, starting from all roots and all 'send' // functions. { std::lock_guard&lt;std::mutex&gt; guard(initializedContextIdsLock_); // Context should not have been initialized already. TORCH_INTERNAL_ASSERT( initializedContextIds_.find(autogradContext-&gt;contextId()) == initializedContextIds_.end()); // &#35745;&#31639;&#20381;&#36182; computeDependencies( autogradContext, rootEdges, grads, graphRoot, outputEdges, retainGraph); // Mark the autograd context id as initialized. initializedContextIds_.insert(autogradContext-&gt;contextId()); } BackwardPassCleanupGuard guard(autogradContext); // This needs to be blocking and as a result we wait for the future to // complete. runEngineAndAccumulateGradients(autogradContext, graphRoot, outputEdges) -&gt;waitAndThrow(); // &#21453;&#21521;&#20256;&#25773;&#35745;&#31639; // Wait for all of the outstanding rpcs to complete. autogradContext-&gt;clearAndWaitForOutstandingRpcsAsync()-&gt;waitAndThrow(); } </code></pre> <p class="valid" valid="valid" title="valid: True, node: 204, level: 11" node_number="204">&#20877;&#27425;&#65292;<u class="valid" valid="valid" title="valid: True, node: 205, level: 12" node_number="205">&#20174;&#21069;&#25991;&#25105;&#20204;&#30693;&#36947;&#65292;&#20381;&#36182;&#39033;&#24050;&#32463;&#22312; computeDependencies &#20043;&#20013;&#22788;&#29702;&#23436;&#27605;&#65292;&#25152;&#26377;&#38656;&#35201;&#35745;&#31639;&#30340;&#20989;&#25968;&#20449;&#24687;&#37117;&#20301;&#20110; GraphTask.exec_info_ &#20043;&#19978;</u>&#12290;&#25105;&#20204;&#25509;&#19979;&#26469;&#23601;&#30475;&#30475;&#22914;&#20309;&#35745;&#31639;&#65292;&#23601;&#26159; runEngineAndAccumulateGradients &#21644; clearAndWaitForOutstandingRpcsAsync &#36825;&#20004;&#20010;&#26041;&#27861;&#12290;</p> <h2 class="valid" valid="valid" title="valid: True, node: 206, level: 11" node_number="206">0x02 &#25191;&#34892;GraphTask</h2> <p class="valid" valid="valid" title="valid: True, node: 207, level: 11" node_number="207">&#25105;&#20204;&#39318;&#20808;&#30475;&#30475;&#22914;&#20309;&#20351;&#29992; runEngineAndAccumulateGradients &#36827;&#34892;&#21453;&#21521;&#20256;&#25773;&#35745;&#31639;&#65292;&#32047;&#31215;&#26799;&#24230;&#12290;</p> <h3 class="valid" valid="valid" title="valid: True, node: 208, level: 11" node_number="208">2.1 runEngineAndAccumulateGradients</h3> <p class="valid" valid="valid" title="valid: True, node: 209, level: 11" node_number="209">&#24341;&#25806;&#20043;&#20013;&#65292;&#39318;&#20808;&#35843;&#29992;&#20102; runEngineAndAccumulateGradients&#12290;&#20027;&#35201;&#26159;&#23553;&#35013;&#20102;&#19968;&#20010; NodeTask&#65292;&#28982;&#21518;&#20197;&#27492;&#35843;&#29992; execute_graph_task_until_ready_queue_empty&#12290;&#20854;&#20013;&#20351;&#29992; at::launch &#26469;&#21551;&#21160;&#32447;&#31243;&#12290;</p> <pre class="valid" valid="valid" title="valid: True, node: 210, level: 11" node_number="210"><code class="valid" valid="valid" title="valid: True, node: 211, level: 12" node_number="211">c10::intrusive_ptr&lt;c10::ivalue::Future&gt; DistEngine:: runEngineAndAccumulateGradients( const ContextPtr autogradContext, const std::shared_ptr&lt;Node&gt; graphRoot, const edge_list outputEdges, bool incrementOutstandingTasks) { // Cleanup previous state for outstanding RPCs. Outstanding RPCs could be // lingering if we're running backward multiple times and some of the // passes ran into errors. autogradContext-&gt;clearOutstandingRpcs(); // &#24471;&#21040;GraphTask auto graphTask = autogradContext-&gt;retrieveGraphTask(); // &#21551;&#21160;&#20102;&#19968;&#20010;&#32447;&#31243;&#26469;&#36816;&#34892; execute_graph_task_until_ready_queue_empty at::launch([this, graphTask, graphRoot, incrementOutstandingTasks]() { execute_graph_task_until_ready_queue_empty( /*node_task*/ NodeTask(graphTask, graphRoot, InputBuffer(0)), /*incrementOutstandingTasks*/ incrementOutstandingTasks); }); // Use a reference here to avoid refcount bump on futureGrads. // &#22788;&#29702;&#32467;&#26524; auto futureGrads = graphTask-&gt;future_result_; // Build a future that waits for the callbacks to execute (since callbacks // execute after the original future is completed). This ensures we return a // future that waits for all gradient accumulation to finish. auto accumulateGradFuture = c10::make_intrusive&lt;c10::ivalue::Future&gt;(c10::NoneType::get()); futureGrads-&gt;addCallback( [autogradContext, outputEdges, accumulateGradFuture](c10::ivalue::Future futureGrads) { if (futureGrads.hasError()) { // &#30465;&#30053;&#38169;&#35823;&#22788;&#29702;&#37096;&#20998; return; } try { const variable_list grads = futureGrads.constValue().toTensorVector(); // &#26631;&#35782;&#24050;&#32463;&#32467;&#26463; accumulateGradFuture-&gt;markCompleted(c10::IValue()); } catch (std::exception e) { accumulateGradFuture-&gt;setErrorIfNeeded(std::current_exception()); } }); return accumulateGradFuture; } </code></pre> <p class="valid" valid="valid" title="valid: True, node: 212, level: 11" node_number="212">at::launch &#20301;&#20110; aten/src/ATen/ParallelThreadPoolNative.cpp&#65292;&#36825;&#37324;&#20250;&#22312;&#32447;&#31243;&#20043;&#20013;&#35843;&#29992;&#20256;&#20837;&#30340; func&#12290;</p> <pre class="valid" valid="valid" title="valid: True, node: 213, level: 11" node_number="213"><code class="valid" valid="valid" title="valid: True, node: 214, level: 12" node_number="214">void launch(std::function&lt;void()&gt; func) { internal::launch_no_thread_state(std::bind([]( std::function&lt;void()&gt; f, ThreadLocalState thread_locals) { ThreadLocalStateGuard guard(std::move(thread_locals)); f(); }, std::move(func), ThreadLocalState() )); } namespace internal { void launch_no_thread_state(std::function&lt;void()&gt; fn) { #if AT_EXPERIMENTAL_SINGLE_THREAD_POOL intraop_launch(std::move(fn)); #else get_pool().run(std::move(fn)); #endif } } </code></pre> <p class="valid" valid="valid" title="valid: True, node: 215, level: 11" node_number="215">&#25105;&#20204;&#25509;&#19979;&#26469;&#19968;&#19968;&#30475;&#30475;&#20869;&#37096;&#36825;&#20960;&#20010;&#26041;&#27861;&#22914;&#20309;&#25191;&#34892;&#12290;</p> <h3 class="valid" valid="valid" title="valid: True, node: 216, level: 11" node_number="216">2.2 execute_graph_task_until_ready_queue_empty</h3> <p class="valid" valid="valid" title="valid: True, node: 217, level: 11" node_number="217">&#27492;&#20989;&#25968;&#31867;&#20284; Engine::thread_main&#65292;&#36890;&#36807;&#19968;&#20010; NodeTask &#26469;&#23436;&#25104;&#26412; GraphTask&#30340;&#25191;&#34892;&#65292;&#20854;&#20013; evaluate_function &#20250;&#19981;&#20572;&#30340;&#21521; cpu_ready_queue &#25554;&#20837;&#26032;&#30340; NodeTask&#12290;engine_.evaluate_function &#26041;&#27861;&#20250;&#65306;</p> <ul class="valid" valid="valid" title="valid: True, node: 218, level: 11" node_number="218"> <li class="valid" valid="valid" title="valid: True, node: 219, level: 12" node_number="219">&#39318;&#20808;&#65292;&#21021;&#22987;&#21270;&#21407;&#29983;&#24341;&#25806;&#32447;&#31243;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 220, level: 12" node_number="220">&#20854;&#27425;&#65292;&#27599;&#20010;&#35843;&#29992;&#24314;&#31435;&#19968;&#20010; cpu_ready_queue&#65292;&#29992;&#26469;&#20174;root_to_execute&#24320;&#22987;&#36941;&#21382;graph_task&#65292;&#36825;&#20801;&#35768;&#29992;&#19981;&#21516;&#30340;&#32447;&#31243;&#26469;&#23545;GraphTask&#24182;&#34892;&#25191;&#34892;&#65292;&#36825;&#26159;&#19968;&#20010;CPU&#30456;&#20851;&#30340;queue&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 221, level: 12" node_number="221">&#25226;&#20256;&#20837;&#30340; node_task &#25554;&#20837;&#21040; cpu_ready_queue&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 222, level: 12" node_number="222">&#27839;&#30528;&#21453;&#21521;&#35745;&#31639;&#22270;&#20174;&#26681;&#37096;&#24320;&#22987;&#65292;&#19968;&#30452;&#35745;&#31639;&#21040;&#21494;&#23376;&#33410;&#28857;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 223, level: 12" node_number="223"> <ul class="valid" valid="valid" title="valid: True, node: 224, level: 13" node_number="224"> <li class="valid" valid="valid" title="valid: True, node: 225, level: 14" node_number="225"> <p title="valid: False, node: 226, level: 15" node_number="226">&#36825;&#37324;&#21494;&#23376;&#33410;&#28857;&#37117;&#26159; AccumulateGrad &#25110;&#32773; RecvRpcBackward&#12290;</p> </li> <li class="valid" valid="valid" title="valid: True, node: 227, level: 14" node_number="227"> <p title="valid: False, node: 228, level: 15" node_number="228">&#22914;&#26524;&#26159;&#20013;&#38388;&#33410;&#28857;&#65292;&#21017;&#27491;&#24120;&#35745;&#31639;&#12290;</p> </li> <li class="valid" valid="valid" title="valid: True, node: 229, level: 14" node_number="229"> <p title="valid: False, node: 230, level: 15" node_number="230"><u title="valid: False, node: 231, level: 16" node_number="231">&#22914;&#26524;&#26159; RecvRpcBackward &#21017;&#20250;&#32473;&#23545;&#24212;&#30340;&#19979;&#28216;&#33410;&#28857;&#21457;&#36865; RPC &#28040;&#24687;</u>&#12290;</p> </li> <li class="valid" valid="valid" title="valid: True, node: 232, level: 14" node_number="232"> <p title="valid: False, node: 233, level: 15" node_number="233"><u title="valid: False, node: 234, level: 16" node_number="234">&#22914;&#26524;&#26159; AccumulateGrad&#65292;&#21017;&#22312;&#19978;&#19979;&#25991;&#32047;&#31215;&#26799;&#24230;</u>&#12290;</p> </li> </ul> </li> </ul> <p class="valid" valid="valid" title="valid: True, node: 235, level: 11" node_number="235">&#20855;&#20307;&#20195;&#30721;&#22914;&#19979;&#65306;</p> <pre class="valid" valid="valid" title="valid: True, node: 236, level: 11" node_number="236"><code class="valid" valid="valid" title="valid: True, node: 237, level: 12" node_number="237">void DistEngine::execute_graph_task_until_ready_queue_empty( NodeTask node_task, bool incrementOutstandingTasks) { // &#21021;&#22987;&#21270;&#21407;&#29983;&#24341;&#25806;&#32447;&#31243; engine_.initialize_device_threads_pool(); // Create a ready queue per call to traverse the graph_task from // root_to_execute This allow concurrent execution of the same GraphTask from // different threads // &#27599;&#20010;&#35843;&#29992;&#24314;&#31435;&#19968;&#20010; ready queue&#65292;&#29992;&#26469;&#20174;root_to_execute&#24320;&#22987;&#36941;&#21382;graph_task&#65292;&#36825;&#20801;&#35768;&#29992;&#19981;&#21516;&#30340;&#32447;&#31243;&#26469;&#23545;GraphTask&#24182;&#34892;&#25191;&#34892;&#65292;&#36825;&#26159;&#19968;&#20010;CPU&#30456;&#20851;&#30340;queue std::shared_ptr&lt;ReadyQueue&gt; cpu_ready_queue = std::make_shared&lt;ReadyQueue&gt;(); auto graph_task = node_task.base_.lock(); if (graph_task == nullptr) { LOG(ERROR) &lt;&lt; "GraphTask has expired for NodeTask: " &lt;&lt; node_task.fn_-&gt;name() &lt;&lt; ", skipping execution."; return; } cpu_ready_queue-&gt;push(std::move(node_task), incrementOutstandingTasks); torch::autograd::set_device(torch::autograd::CPU_DEVICE); graph_task-&gt;owner_ = torch::autograd::CPU_DEVICE; while (!cpu_ready_queue-&gt;empty()) { std::shared_ptr&lt;GraphTask&gt; local_graph_task; { // Scope this block of execution since NodeTask is not needed after this // block and can be deallocated (release any references to grad tensors // as part of inputs_) NodeTask task = cpu_ready_queue-&gt;pop(); // &#21462;&#20986;&#19968;&#20010;NodeTask if (!(local_graph_task = task.base_.lock())) { continue; } if (task.fn_ !local_graph_task-&gt;has_error_.load()) { AutoGradMode grad_mode(local_graph_task-&gt;grad_mode_); try { GraphTaskGuard guard(local_graph_task); engine_.evaluate_function( // &#36825;&#37324;&#20250;&#35843;&#29992;&#20855;&#20307;Node&#23545;&#24212;&#30340;&#20989;&#25968; local_graph_task, task.fn_.get(), task.inputs_, cpu_ready_queue); } catch (std::exception e) { engine_.thread_on_exception(local_graph_task, task.fn_, e); // break the loop in error so that we immediately stop the execution // of this GraphTask, mark it completed if necessary and return the // future with proper ErrorMessage break; } } } // Decrement the outstanding task. --local_graph_task-&gt;outstanding_tasks_; // &#22788;&#29702;&#20102;&#19968;&#20010;NodeTask } // Check if we've completed execution. if (graph_task-&gt;completed()) { // We don't need to explicitly notify the owner thread, since // 'mark_as_completed_and_run_post_processing' would mark the Future as // completed and this would notify the owner thread that the task has been // completed. graph_task-&gt;mark_as_completed_and_run_post_processing(); } } </code></pre> <p class="valid" valid="valid" title="valid: True, node: 238, level: 11" node_number="238">&#21478;&#22806;&#65292;&#19968;&#20849;&#26377;&#19977;&#20010;&#22320;&#26041;&#35843;&#29992; execute_graph_task_until_ready_queue_empty&#12290;</p> <ol class="valid" valid="valid" title="valid: True, node: 239, level: 11" node_number="239"> <li class="valid" valid="valid" title="valid: True, node: 240, level: 12" node_number="240">runEngineAndAccumulateGradients &#20250;&#35843;&#29992;&#65292;<u class="valid" valid="valid" title="valid: True, node: 241, level: 13" node_number="241">&#36825;&#37324;&#23601;&#26159;&#29992;&#25143;&#20027;&#21160;&#35843;&#29992; backward &#30340;&#24773;&#24418;</u>&#65292;&#23601;&#26159;&#26412;&#33410;&#20171;&#32461;&#30340;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 242, level: 12" node_number="242">executeSendFunctionAsync &#20250;&#35843;&#29992;&#65292;<u class="valid" valid="valid" title="valid: True, node: 243, level: 13" node_number="243">&#36825;&#37324;&#23545;&#24212;&#20102;&#26576;&#33410;&#28857;&#20174;&#21453;&#21521;&#20256;&#25773;&#19978;&#19968;&#33410;&#28857;&#25509;&#21463;&#21040;&#26799;&#24230;&#20043;&#21518;&#30340;&#25805;&#20316;</u>&#65292;&#25105;&#20204;&#20250;&#22312;&#19979;&#19968;&#33410;&#20171;&#32461;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 244, level: 12" node_number="244">globalCpuThread &#20250;&#35843;&#29992;&#65292;&#36825;&#26159;CPU&#24037;&#20316;&#19987;&#29992;&#32447;&#31243;&#65292;&#25105;&#20204;&#39532;&#19978;&#20250;&#20171;&#32461;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 245, level: 12" node_number="245">&#22312; Engine.evaluate_function &#20043;&#20013;&#65292;&#20250;&#38024;&#23545; AccumulateGrad &#26469;&#32047;&#31215;&#26799;&#24230;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 246, level: 12" node_number="246">&#22312; Engine.evaluate_function &#20043;&#20013;&#65292;&#20250;&#35843;&#29992; RecvRpcBackward &#26469;&#21521;&#21453;&#21521;&#20256;&#25773;&#19979;&#28216;&#21457;&#36865;&#28040;&#24687;&#12290;</li> </ol> <p class="valid" valid="valid" title="valid: True, node: 247, level: 11" node_number="247">&#25105;&#20204;&#24635;&#32467;&#19968;&#19979;&#20960;&#20010;&#35745;&#31639;&#26799;&#24230;&#30340;&#27969;&#31243;&#65292;&#20998;&#21035;&#23545;&#24212;&#19979;&#38754;&#19977;&#20010;&#25968;&#23383;&#12290;</p> <pre class="valid" valid="valid" title="valid: True, node: 248, level: 11" node_number="248"><code class="valid" valid="valid" title="valid: True, node: 249, level: 12" node_number="249"> User Training Script RPC BACKWARD_AUTOGRAD_REQ + + | | | 1 | 2 v v backward RequestCallbackNoPython.processRpc + + | | | | v v DistEngine.execute RequestCallbackNoPython.processBackwardAutogradReq + + | | | | | v | +----------+ DistEngine.executeSendFunctionAsync | | + | | | v v | DistEngine.computeDependencies | | | | | v | DistEngine.runEngineAndAccumulateGradients | DistEngine.globalCpuThread + | + | +------------------+ | | | | 3 | | +------------------------+ | | | | | | v v v DistEngine.execute_graph_task_until_ready_queue_empty + | | v DistEngine.evaluate_function + | +--------------------------------------------------------------+ | | | 4 AccumulateGrad | 5 RecvRpcBackward v v (*hook)(captured_grad) call_function(graph_task, func, inputs) </code></pre> <h3 class="valid" valid="valid" title="valid: True, node: 250, level: 11" node_number="250">2.3 evaluate_function</h3> <p class="valid" valid="valid" title="valid: True, node: 251, level: 11" node_number="251">&#19978;&#38754;&#20195;&#30721;&#20043;&#20013;&#65292;&#23454;&#38469;&#19978;&#20250;&#35843;&#29992;&#21407;&#29983;&#24341;&#25806;&#30340; evaluate_function &#26469;&#23436;&#25104;&#25805;&#20316;&#12290;</p> <p class="valid" valid="valid" title="valid: True, node: 252, level: 11" node_number="252">&#25105;&#20204;&#30475;&#30475;&#22914;&#20309;&#20351;&#29992; <code class="valid" valid="valid" title="valid: True, node: 253, level: 12" node_number="253">exec_info_</code>&#65292;&#22914;&#26524;&#27809;&#26377;&#35774;&#32622;&#20026;&#38656;&#35201;&#25191;&#34892;&#65292;&#21017;&#23601;&#19981;&#22788;&#29702;&#12290;&#22312;&#27492;&#22788;&#65292;&#25105;&#20204;&#21487;&#20197;&#30475;&#21040; &#19978;&#25991;&#25552;&#21040;&#30340;<code class="valid" valid="valid" title="valid: True, node: 254, level: 12" node_number="254">recvBackwardEdges</code> &#22914;&#20309;&#19982; <code class="valid" valid="valid" title="valid: True, node: 255, level: 12" node_number="255">exec_info_</code> &#20132;&#20114;&#12290;</p> <blockquote class="valid" valid="valid" title="valid: True, node: 256, level: 11" node_number="256"> <p class="valid" valid="valid" title="valid: True, node: 257, level: 12" node_number="257">&#36941;&#21382; recvBackwardEdges&#65292;&#23545;&#20110;&#27599;&#20010; recvBackward&#65292;&#22312; GraphTask.exec_info_ &#20043;&#20013;&#23545;&#24212;&#39033;&#20043;&#19978;&#35774;&#27490;&#20026;&#38656;&#35201;&#25191;&#34892;&#12290;</p> </blockquote> <p class="valid" valid="valid" title="valid: True, node: 258, level: 11" node_number="258">&#20855;&#20307;&#20195;&#30721;&#22914;&#19979;&#65292;&#36825;&#37324;&#20250;&#65306;</p> <ul class="valid" valid="valid" title="valid: True, node: 259, level: 11" node_number="259"> <li class="valid" valid="valid" title="valid: True, node: 260, level: 12" node_number="260">&#38024;&#23545; AccumulateGrad &#26469;&#32047;&#31215;&#26799;&#24230;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 261, level: 12" node_number="261">&#35843;&#29992; RecvRpcBackward &#26469;&#21521;&#21453;&#21521;&#20256;&#25773;&#19979;&#28216;&#21457;&#36865;&#28040;&#24687;&#12290;</li> </ul> <pre class="valid" valid="valid" title="valid: True, node: 262, level: 11" node_number="262"><code class="valid" valid="valid" title="valid: True, node: 263, level: 12" node_number="263">void Engine::evaluate_function( std::shared_ptr&lt;GraphTask&gt; graph_task, Node* func, InputBuffer inputs, const std::shared_ptr&lt;ReadyQueue&gt; cpu_ready_queue) { // If exec_info_ is not empty, we have to instrument the execution auto exec_info_ = graph_task-&gt;exec_info_; if (!exec_info_.empty()) { auto fn_info = exec_info_.at(func); if (auto* capture_vec = fn_info.captures_.get()) { // Lock mutex for writing to graph_task-&gt;captured_vars_. std::lock_guard&lt;std::mutex&gt; lock(graph_task-&gt;mutex_); for (const auto capture : *capture_vec) { auto captured_grad = graph_task-&gt;captured_vars_[capture.output_idx_]; captured_grad = inputs[capture.input_idx_]; for (auto hook : capture.hooks_) { captured_grad = (*hook)(captured_grad); //&#36825;&#37324;&#35843;&#29992; hook&#65292;&#23601;&#26159; DistAccumulateGradCaptureHook &#30340; operator()&#65292;captured_grad &#23601;&#26159;&#32047;&#31215;&#30340;&#26799;&#24230; } } } if (!fn_info.needed_) { // Skip execution if we don't need to execute the function. return; // &#22914;&#26524;&#27809;&#26377;&#35774;&#32622;&#38656;&#35201;&#25191;&#34892;&#65292;&#21017;&#30452;&#25509;&#36820;&#22238;&#12290;recvBackward &#20250;&#35774;&#32622;&#38656;&#35201;&#25191;&#34892; } } // &#36825;&#37324;&#23601;&#26159;&#35843;&#29992; recvBackward auto outputs = call_function(graph_task, func, inputs); // &#21518;&#32493;&#20195;&#30721;&#30465;&#30053; </code></pre> <h3 class="valid" valid="valid" title="valid: True, node: 264, level: 11" node_number="264">2.4 globalCpuThread</h3> <p class="valid" valid="valid" title="valid: True, node: 265, level: 11" node_number="265">globalCpuThread &#21487;&#20197;&#21442;&#35265;&#19978;&#25991;&#30340; [GPU to CPU continuations] &#19968;&#33410;&#65292;globalCpuThread&#26159;&#24037;&#20316;&#32447;&#31243;&#65292;&#20854;&#23601;&#26159;&#20174; ready queue &#37324;&#38754;&#24377;&#20986; NodeTask&#65292;&#28982;&#21518;&#25191;&#34892;&#12290;</p> <p class="valid" valid="valid" title="valid: True, node: 266, level: 11" node_number="266">&#23545;&#20110;globalCpuThread&#65292;&#20854;&#21442;&#25968; ready_queue &#26159; global_cpu_ready_queue_</p> <pre class="valid" valid="valid" title="valid: True, node: 267, level: 11" node_number="267"><code class="valid" valid="valid" title="valid: True, node: 268, level: 12" node_number="268">void DistEngine::globalCpuThread( const std::shared_ptr&lt;ReadyQueue&gt; ready_queue) { while (true) { NodeTask task = ready_queue-&gt;pop(); if (task.isShutdownTask_) { // Need to shutdown this thread. break; } auto graphTask = task.base_.lock(); if (graphTask == nullptr) { // GraphTask has expired, ignore and continue processing. continue; } // Launch the execution on a JIT thread. at::launch([this, graphTask, graphRoot = task.fn_, variables = InputBuffer::variables(std::move(task.inputs_))]() mutable { InputBuffer inputs(variables.size()); for (size_t i = 0; i &lt; variables.size(); i++) { inputs.add(i, std::move(variables[i]), c10::nullopt, c10::nullopt); } execute_graph_task_until_ready_queue_empty( // &#36825;&#37324;&#20250;&#35843;&#29992; /*node_task*/ NodeTask(graphTask, graphRoot, std::move(inputs)), /*incrementOutstandingTasks*/ false); }); } } </code></pre> <p class="valid" valid="valid" title="valid: True, node: 269, level: 11" node_number="269">&#23545;&#20110;&#26222;&#36890;&#24341;&#25806;&#20063;&#20250;&#35774;&#32622;&#19968;&#20010; cpu &#19987;&#29992; queue&#12290;</p> <pre class="valid" valid="valid" title="valid: True, node: 270, level: 11" node_number="270"><code class="valid" valid="valid" title="valid: True, node: 271, level: 12" node_number="271">auto graph_task = std::make_shared&lt;GraphTask&gt;( /* keep_graph */ keep_graph, /* create_graph */ create_graph, /* depth */ not_reentrant_backward_call ? 0 : total_depth + 1, /* cpu_ready_queue */ local_ready_queue); </code></pre> <h3 class="valid" valid="valid" title="valid: True, node: 272, level: 11" node_number="272">2.5 &#23567;&#32467;</h3> <p class="valid" valid="valid" title="valid: True, node: 273, level: 11" node_number="273">&#23545;&#20110;&#20998;&#24067;&#24335;&#24341;&#25806;&#65292;&#19982;&#26222;&#36890;&#24341;&#25806;&#22312;&#35745;&#31639;&#37096;&#20998;&#20027;&#35201;&#19981;&#21516;&#20043;&#22788;&#20026;&#65306;</p> <ul class="valid" valid="valid" title="valid: True, node: 274, level: 11" node_number="274"> <li class="valid" valid="valid" title="valid: True, node: 275, level: 12" node_number="275"> <p class="valid" valid="valid" title="valid: True, node: 276, level: 13" node_number="276"><u class="valid" valid="valid" title="valid: True, node: 277, level: 14" node_number="277">&#22914;&#26524;&#26159; RecvRpcBackward &#21017;&#20250;&#32473;&#23545;&#24212;&#30340;&#19979;&#28216;&#33410;&#28857;&#21457;&#36865; RPC &#28040;&#24687;</u>&#12290;</p> </li> <li class="valid" valid="valid" title="valid: True, node: 278, level: 12" node_number="278"> <p class="valid" valid="valid" title="valid: True, node: 279, level: 13" node_number="279"><u class="valid" valid="valid" title="valid: True, node: 280, level: 14" node_number="280">&#22914;&#26524;&#26159; AccumulateGrad&#65292;&#21017;&#22312;&#19978;&#19979;&#25991;&#32047;&#31215;&#26799;&#24230;</u>&#12290;</p> </li> </ul> <p class="valid" valid="valid" title="valid: True, node: 281, level: 11" node_number="281">&#25152;&#20197;&#25105;&#20204;&#25509;&#19979;&#26469;&#30475;&#30475;&#20855;&#20307;&#36825;&#20004;&#37096;&#20998;&#22914;&#20309;&#22788;&#29702;&#12290;</p> <h2 class="valid" valid="valid" title="valid: True, node: 282, level: 11" node_number="282">0x03 RPC&#35843;&#29992;</h2> <p class="valid" valid="valid" title="valid: True, node: 283, level: 11" node_number="283">&#22312;&#20043;&#21069;&#25991;&#31456;&#20013;&#65292;&#25105;&#20204;&#30475;&#21040;&#20102;&#25509;&#21463;&#26041;&#22914;&#20309;&#22788;&#29702;&#21453;&#21521;&#20256;&#25773; RPC &#35843;&#29992;&#65292;&#25105;&#20204;&#25509;&#19979;&#26469;&#30475;&#30475;&#24341;&#25806;&#22914;&#20309;&#21457;&#36215;&#21453;&#21521;&#20256;&#25773; RPC &#35843;&#29992;&#65292;&#23601;&#26159;&#22914;&#20309;&#35843;&#29992; recv &#26041;&#27861;&#12290;</p> <p class="valid" valid="valid" title="valid: True, node: 284, level: 11" node_number="284">&#36825;&#37324;&#23601;&#36866;&#29992;&#20110;&#19979;&#38754;worker 0 &#35843;&#29992; recv &#65292;&#25191;&#34892;&#26469;&#21040; worker 1 &#36825;&#31181;&#24773;&#20917;&#65292;&#23545;&#24212;&#35774;&#35745;&#25991;&#26723;&#20013;&#22914;&#19979;&#12290;</p> <blockquote class="valid" valid="valid" title="valid: True, node: 285, level: 11" node_number="285"> <p class="valid" valid="valid" title="valid: True, node: 286, level: 12" node_number="286">&#24403; autograd &#24341;&#25806;&#25191;&#34892;&#35813;<code class="valid" valid="valid" title="valid: True, node: 287, level: 13" node_number="287">recv</code>&#20989;&#25968;&#26102;&#65292;&#35813;<code class="valid" valid="valid" title="valid: True, node: 288, level: 13" node_number="288">recv</code> &#20989;&#25968;&#36890;&#36807; RPC &#23558;&#36755;&#20837;&#26799;&#24230;&#21457;&#36865;&#21040;&#36866;&#24403;&#30340;worker&#12290;&#27599;&#20010;<code class="valid" valid="valid" title="valid: True, node: 289, level: 13" node_number="289">recv</code>&#20989;&#25968;&#37117;&#30693;&#36947;&#30446;&#26631; worker id&#65292;&#22240;&#20026;&#23427;&#34987;&#35760;&#24405;&#20026;&#21069;&#21521;&#20256;&#25773;&#30340;&#19968;&#37096;&#20998;&#12290;&#36890;&#36807;<code class="valid" valid="valid" title="valid: True, node: 290, level: 13" node_number="290">autograd_context_id</code>&#21644; <code class="valid" valid="valid" title="valid: True, node: 291, level: 13" node_number="291">autograd_message_id</code> &#35813;<code class="valid" valid="valid" title="valid: True, node: 292, level: 13" node_number="292">recv</code>&#20989;&#25968;&#34987;&#21457;&#36865;&#21040;&#36828;&#31243;&#20027;&#26426;&#12290;</p> </blockquote> <p class="valid" valid="valid" title="valid: True, node: 293, level: 11" node_number="293">&#25105;&#20204;&#23601;&#30475;&#30475;&#22914;&#20309;&#25191;&#34892; recv &#20989;&#25968;&#12290;</p> <p class="valid" valid="valid" title="valid: True, node: 294, level: 11" node_number="294"><u class="valid" valid="valid" title="valid: True, node: 295, level: 12" node_number="295">&#20855;&#20307;&#32467;&#21512;&#21040;&#20998;&#24067;&#24335;&#24341;&#25806;&#65292;&#23601;&#26159;&#24403;&#24341;&#25806;&#21457;&#29616;&#26576;&#19968;&#20010; Node &#26159; RecvRpcBackward&#65292;&#23601;&#35843;&#29992;&#20854; apply &#20989;&#25968;</u>&#12290;</p> <pre class="valid" valid="valid" title="valid: True, node: 296, level: 11" node_number="296"><code class="valid" valid="valid" title="valid: True, node: 297, level: 12" node_number="297">void Engine::evaluate_function( std::shared_ptr&lt;GraphTask&gt; graph_task, Node* func, InputBuffer inputs, const std::shared_ptr&lt;ReadyQueue&gt; cpu_ready_queue) { // If exec_info_ is not empty, we have to instrument the execution auto exec_info_ = graph_task-&gt;exec_info_; if (!exec_info_.empty()) { // &#30465;&#30053;&#20102;&#26799;&#24230;&#32047;&#31215;&#37096;&#20998;&#20195;&#30721;&#65292;&#20855;&#20307;&#21487;&#20197;&#21442;&#35265;&#19978;&#38754;&#31456;&#33410; if (!fn_info.needed_) { // Skip execution if we don't need to execute the function. return; // &#22914;&#26524;&#27809;&#26377;&#35774;&#32622;&#38656;&#35201;&#25191;&#34892;&#65292;&#21017;&#30452;&#25509;&#36820;&#22238;&#12290;recvBackward &#20250;&#35774;&#32622;&#38656;&#35201;&#25191;&#34892; } } // &#36825;&#37324;&#23601;&#26159;&#35843;&#29992; recvBackward.apply &#20989;&#25968; auto outputs = call_function(graph_task, func, inputs); // &#21518;&#32493;&#20195;&#30721;&#30465;&#30053; </code></pre> <h3 class="valid" valid="valid" title="valid: True, node: 298, level: 11" node_number="298">3.1 RecvRpcBackward</h3> <h4 class="valid" valid="valid" title="valid: True, node: 299, level: 11" node_number="299">3.1.1 &#23450;&#20041;</h4> <p class="valid" valid="valid" title="valid: True, node: 300, level: 11" node_number="300">RecvRpcBackward &#23450;&#20041;&#22914;&#19979;&#65292;</p> <pre class="valid" valid="valid" title="valid: True, node: 301, level: 11" node_number="301"><code class="valid" valid="valid" title="valid: True, node: 302, level: 12" node_number="302">class TORCH_API RecvRpcBackward : public torch::autograd::Node { public: explicit RecvRpcBackward( const AutogradMetadata autogradMetadata, std::shared_ptr&lt;DistAutogradContext&gt; autogradContext, rpc::worker_id_t fromWorkerId, std::unordered_map&lt;c10::Device, c10::Device&gt; deviceMap); torch::autograd::variable_list apply( torch::autograd::variable_list grads) override; private: const AutogradMetadata autogradMetadata_; // Hold a weak reference to the autograd context to avoid circular // dependencies with the context (since it holds a reference to // RecvRpcBackward). std::weak_ptr&lt;DistAutogradContext&gt; autogradContext_; // The worker id from which the RPC was received. During the backward pass, // we need to propagate the gradients to this workerId. rpc::worker_id_t fromWorkerId_; // Device mapping for tensors sent over RPC. const std::unordered_map&lt;c10::Device, c10::Device&gt; deviceMap_; }; </code></pre> <h4 class="valid" valid="valid" title="valid: True, node: 303, level: 11" node_number="303">3.1.2 &#26500;&#24314;</h4> <p class="valid" valid="valid" title="valid: True, node: 304, level: 11" node_number="304">&#26500;&#36896;&#20989;&#25968;&#22914;&#19979;&#12290;</p> <pre class="valid" valid="valid" title="valid: True, node: 305, level: 11" node_number="305"><code class="valid" valid="valid" title="valid: True, node: 306, level: 12" node_number="306">RecvRpcBackward::RecvRpcBackward( const AutogradMetadata autogradMetadata, ContextPtr autogradContext, rpc::worker_id_t fromWorkerId, std::unordered_map&lt;c10::Device, c10::Device&gt; deviceMap) : autogradMetadata_(autogradMetadata), autogradContext_(std::move(autogradContext)), fromWorkerId_(fromWorkerId), deviceMap_(std::move(deviceMap)) {} </code></pre> <h4 class="valid" valid="valid" title="valid: True, node: 307, level: 11" node_number="307">3.1.3 apply</h4> <p class="valid" valid="valid" title="valid: True, node: 308, level: 11" node_number="308">torch/csrc/distributed/autograd/functions/recvrpc_backward.cpp &#23450;&#20041;&#20102;&#20854; apply &#20989;&#25968;&#65292;&#20854;&#20316;&#29992;&#23601;&#26159;&#65306;</p> <ul class="valid" valid="valid" title="valid: True, node: 309, level: 11" node_number="309"> <li class="valid" valid="valid" title="valid: True, node: 310, level: 12" node_number="310">&#25226;&#20256;&#20837;&#30340;&#26799;&#24230; grads &#25918;&#20837;outputGrads&#65292;&#22240;&#20026;&#35201;&#36755;&#20986;&#32473;&#19979;&#19968;&#29615;&#33410;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 311, level: 12" node_number="311">&#26500;&#24314; PropagateGradientsReq&#65292;&#36825;&#23601;&#26159; BACKWARD_AUTOGRAD_REQ&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 312, level: 12" node_number="312">&#21457;&#36865; RPC &#32473;&#19979;&#19968;&#29615;&#33410;&#12290;</li> </ul> <pre class="valid" valid="valid" title="valid: True, node: 313, level: 11" node_number="313"><code class="valid" valid="valid" title="valid: True, node: 314, level: 12" node_number="314">variable_list RecvRpcBackward::apply(variable_list grads) { std::vector&lt;Variable&gt; outputGrads; for (size_t i = 0; i &lt; grads.size(); i++) { // &#19979;&#38754;&#23601;&#26159;&#25226;&#20256;&#20837;&#30340;&#26799;&#24230; grads &#25918;&#20837;outputGrads const auto grad = grads[i]; if (grad.defined()) { outputGrads.emplace_back(grad); } else { // Put in zeros for a tensor with no grad. outputGrads.emplace_back(input_metadata(i).zeros_like()); } } auto sharedContext = autogradContext_.lock(); // Send the gradients over the wire and record the future in the autograd // context. PropagateGradientsReq gradCall( // &#26500;&#24314; PropagateGradientsReq autogradMetadata_, outputGrads, sharedContext-&gt;retrieveGraphTask()-&gt;keep_graph_); // Send the gradients over to the appropriate node. auto rpcAgent = rpc::RpcAgent::getCurrentRpcAgent(); auto jitFuture = rpcAgent-&gt;send( // &#21457;&#36865; RPC rpcAgent-&gt;getWorkerInfo(fromWorkerId_), std::move(gradCall).toMessage(), // &#35843;&#29992;&#20102;toMessageImpl rpc::kUnsetRpcTimeout, deviceMap_); // Record the future in the context. sharedContext-&gt;addOutstandingRpc(jitFuture); // 'recv' function sends the gradients over the wire using RPC, it doesn't // need to return anything for any downstream autograd function. return variable_list(); } </code></pre> <p class="valid" valid="valid" title="valid: True, node: 315, level: 11" node_number="315">&#22240;&#20026;&#36825;&#37324;&#21457;&#36865;&#20102; PropagateGradientsReq&#65292;&#25152;&#20197;&#25105;&#20204;&#25509;&#30528;&#30475;&#12290;</p> <h3 class="valid" valid="valid" title="valid: True, node: 316, level: 11" node_number="316">3.2 PropagateGradientsReq</h3> <h4 class="valid" valid="valid" title="valid: True, node: 317, level: 11" node_number="317">3.2.1 &#23450;&#20041;</h4> <p class="valid" valid="valid" title="valid: True, node: 318, level: 11" node_number="318">PropagateGradientsReq &#25193;&#23637;&#20102; RpcCommandBase&#12290;</p> <pre class="valid" valid="valid" title="valid: True, node: 319, level: 11" node_number="319"><code class="valid" valid="valid" title="valid: True, node: 320, level: 12" node_number="320">// Used to propagate gradients from one node to another during a distributed // backwards pass. This RPC call is invoked when we hit a `recv` autograd // function during backward pass execution. class TORCH_API PropagateGradientsReq : public rpc::RpcCommandBase { public: PropagateGradientsReq( const AutogradMetadata autogradMetadata, std::vector&lt;torch::autograd::Variable&gt; grads, bool retainGraph = false); const AutogradMetadata getAutogradMetadata(); const std::vector&lt;torch::autograd::Variable&gt; getGrads(); // Serialization and deserialization methods. rpc::Message toMessageImpl() override; static std::unique_ptr&lt;PropagateGradientsReq&gt; fromMessage( const rpc::Message message); // Whether or not to retain the autograd graph. bool retainGraph(); private: AutogradMetadata autogradMetadata_; std::vector&lt;torch::autograd::Variable&gt; grads_; bool retainGraph_; }; </code></pre> <p class="valid" valid="valid" title="valid: True, node: 321, level: 11" node_number="321">&#20854; toMessageImpl &#25351;&#26126;&#20102;&#26412;&#28040;&#24687;&#26159; BACKWARD_AUTOGRAD_REQ&#12290;</p> <pre class="valid" valid="valid" title="valid: True, node: 322, level: 11" node_number="322"><code class="valid" valid="valid" title="valid: True, node: 323, level: 12" node_number="323">Message PropagateGradientsReq::toMessageImpl() { std::vector&lt;at::IValue&gt; ivalues; // Add all the grad tensors. for (const auto grad : grads_) { ivalues.emplace_back(grad); } // Now add autograd metadata. ivalues.emplace_back(autogradMetadata_.autogradContextId); ivalues.emplace_back(autogradMetadata_.autogradMessageId); // Add retain graph. ivalues.emplace_back(retainGraph_); // Now pickle using JIT pickler. std::vector&lt;torch::Tensor&gt; tensorTable; std::vector&lt;char&gt; payload = jit::pickle(c10::ivalue::Tuple::create(std::move(ivalues)), tensorTable); return Message( std::move(payload), std::move(tensorTable), MessageType::BACKWARD_AUTOGRAD_REQ); // &#36825;&#37324;&#25351;&#26126;&#20102;&#28040;&#24687;&#31867;&#22411;&#12290; } </code></pre> <h3 class="valid" valid="valid" title="valid: True, node: 324, level: 11" node_number="324">3.3 &#25509;&#21463;&#26041;</h3> <p class="valid" valid="valid" title="valid: True, node: 325, level: 11" node_number="325">&#20026;&#20102;&#35770;&#36848;&#23436;&#25972;&#65292;&#25105;&#20204;&#25509;&#19979;&#26469;&#30475;&#30475;&#25509;&#25910;&#26041;&#22914;&#20309;&#22788;&#29702;&#21453;&#21521;&#20256;&#25773;&#12290;</p> <h4 class="valid" valid="valid" title="valid: True, node: 326, level: 11" node_number="326">3.3.1 &#25509;&#21463;&#28040;&#24687;</h4> <p class="valid" valid="valid" title="valid: True, node: 327, level: 11" node_number="327">&#22312;&#29983;&#25104; TensorPipeAgent &#26102;&#20505;&#65292;&#25226; RequestCallbackImpl &#37197;&#32622;&#20026;&#22238;&#35843;&#20989;&#25968;&#12290;&#36825;&#26159; agent &#30340;&#32479;&#19968;&#21709;&#24212;&#20989;&#25968;&#12290;&#21069;&#38754;&#20851;&#20110;&#20195;&#29702;&#25509;&#25910;&#36923;&#36753;&#26102;&#20505;&#65292;&#25105;&#20204;&#20063;&#25552;&#21040;&#20102;&#65292;&#20250;&#36827;&#20837; RequestCallbackNoPython::processRpc &#20989;&#25968;&#12290;&#20854;&#20013;&#21487;&#20197;&#30475;&#21040;&#26377;&#23545; BACKWARD_AUTOGRAD_REQ &#30340;&#22788;&#29702;&#36923;&#36753;&#12290;</p> <p class="valid" valid="valid" title="valid: True, node: 328, level: 11" node_number="328">&#36825;&#31181;&#26159; RPC &#30340;&#27491;&#24120;&#27969;&#31243;&#12290;</p> <pre class="valid" valid="valid" title="valid: True, node: 329, level: 11" node_number="329"><code class="valid" valid="valid" title="valid: True, node: 330, level: 12" node_number="330">void RequestCallbackNoPython::processRpc( RpcCommandBase rpc, const MessageType messageType, const int64_t messageId, const c10::intrusive_ptr&lt;JitFuture&gt; responseFuture, std::shared_ptr&lt;LazyStreamContext&gt; ctx) const { switch (messageType) { case MessageType::BACKWARD_AUTOGRAD_REQ: { processBackwardAutogradReq(rpc, messageId, responseFuture); // &#36825;&#37324;&#35843;&#29992; return; }; </code></pre> <h4 class="valid" valid="valid" title="valid: True, node: 331, level: 11" node_number="331">3.3.2 processBackwardAutogradReq</h4> <p class="valid" valid="valid" title="valid: True, node: 332, level: 11" node_number="332">&#22312; processBackwardAutogradReq &#20043;&#20013;&#20250;&#65306;</p> <ul class="valid" valid="valid" title="valid: True, node: 333, level: 11" node_number="333"> <li class="valid" valid="valid" title="valid: True, node: 334, level: 12" node_number="334">&#33719;&#21462; DistAutogradContainer&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 335, level: 12" node_number="335">&#33719;&#21462; &#19978;&#19979;&#25991;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 336, level: 12" node_number="336">&#35843;&#29992; executeSendFunctionAsync &#36827;&#34892;&#24341;&#25806;&#22788;&#29702;&#12290;</li> </ul> <p class="valid" valid="valid" title="valid: True, node: 337, level: 11" node_number="337">&#30001;&#27492;&#65292;&#25105;&#20204;&#21487;&#20197;&#30475;&#21040;&#26377;&#20004;&#20010;&#36884;&#24452;&#36827;&#20837;&#24341;&#25806;&#65306;</p> <ul class="valid" valid="valid" title="valid: True, node: 338, level: 11" node_number="338"> <li class="valid" valid="valid" title="valid: True, node: 339, level: 12" node_number="339">&#19968;&#20010;&#26159;&#31034;&#20363;&#20195;&#30721;&#26174;&#24335;&#20027;&#21160;&#35843;&#29992; backward&#65292;&#36827;&#32780;&#35843;&#29992;&#21040; DistEngine::getInstance().execute&#65292;&#23601;&#26159; worker 0&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 340, level: 12" node_number="340">&#19968;&#20010;&#26159;&#34987;&#21160;&#35843;&#29992; DistEngine::getInstance().executeSendFunctionAsync&#65292;&#23601;&#26159; worker 1&#12290;</li> </ul> <pre class="valid" valid="valid" title="valid: True, node: 341, level: 11" node_number="341"><code class="valid" valid="valid" title="valid: True, node: 342, level: 12" node_number="342">void RequestCallbackNoPython::processBackwardAutogradReq( RpcCommandBase rpc, const int64_t messageId, const c10::intrusive_ptr&lt;JitFuture&gt; responseFuture) const { auto gradientsCall = static_cast&lt;PropagateGradientsReq&gt;(rpc); const auto autogradMetadata = gradientsCall.getAutogradMetadata(); // Retrieve the appropriate autograd context. auto autogradContext = DistAutogradContainer::getInstance().retrieveContext( autogradMetadata.autogradContextId); // &#24471;&#21040;&#21457;&#36865;&#32773;&#30340;context id // Lookup the appropriate 'send' function to enqueue. std::shared_ptr&lt;SendRpcBackward&gt; sendFunction = // &#20381;&#25454;&#21457;&#36865;&#32773;context id&#21644;&#28040;&#24687;id&#24471;&#21040;sendFunction autogradContext-&gt;retrieveSendFunction(autogradMetadata.autogradMessageId); // Attach the gradients to the send function. sendFunction-&gt;setGrads(gradientsCall.getGrads()); // &#35774;&#32622;&#26799;&#24230; // Now execute the autograd graph using the "distributed engine." auto execFuture = DistEngine::getInstance().executeSendFunctionAsync( // &#35843;&#29992;&#24341;&#25806; autogradContext, sendFunction, gradientsCall.retainGraph()); // Our response is satisfied when the rpcs come back. execFuture-&gt;addCallback([responseFuture, messageId](JitFuture execFuture) { if (!execFuture.hasError()) { Message m = std::move(PropagateGradientsResp()).toMessage(); m.setId(messageId); responseFuture-&gt;markCompleted( IValue(c10::make_intrusive&lt;Message&gt;(std::move(m)))); } else { responseFuture-&gt;setError(execFuture.exception_ptr()); } }); } </code></pre> <h4 class="valid" valid="valid" title="valid: True, node: 343, level: 11" node_number="343">3.3.3 executeSendFunctionAsync</h4> <p class="valid" valid="valid" title="valid: True, node: 344, level: 11" node_number="344">executeSendFunctionAsync &#36825;&#37324;&#24320;&#22987;&#36827;&#20837;&#20102;&#24341;&#25806;&#65292;&#27880;&#24847;&#65292;&#36825;&#37324;&#26159;&#25509;&#25910;&#26041;&#20063;&#36827;&#20837;&#20102;&#24341;&#25806;&#65292;&#22312;&#25509;&#25910;&#26041;&#19978;&#36827;&#34892;&#35745;&#31639;&#12290;executeSendFunctionAsync &#20250;&#30452;&#25509;&#35843;&#29992; execute_graph_task_until_ready_queue_empty&#65292;&#20063;&#21487;&#33021;&#20808;&#35745;&#31639;&#20381;&#36182;&#28982;&#21518;&#32487;&#32493;&#25191;&#34892;&#12290;&#27492;&#22788;&#21487;&#20197;&#21442;&#32771;&#35774;&#35745;&#20043;&#20013;&#30340;&#65306;</p> <ul class="valid" valid="valid" title="valid: True, node: 345, level: 11" node_number="345"> <li class="valid" valid="valid" title="valid: True, node: 346, level: 12" node_number="346">6&#65289;&#24403;&#36828;&#31243;&#20027;&#26426;&#25910;&#21040;&#36825;&#20010;&#35831;&#27714;&#26102;&#65292;&#25105;&#20204;&#20351;&#29992; <code class="valid" valid="valid" title="valid: True, node: 347, level: 13" node_number="347">autograd_context_id</code>&#21644;<code class="valid" valid="valid" title="valid: True, node: 348, level: 13" node_number="348">autograd_message_id</code>&#26469;&#26597;&#25214;&#36866;&#24403;&#30340;<code class="valid" valid="valid" title="valid: True, node: 349, level: 13" node_number="349">send</code>&#20989;&#25968;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 350, level: 12" node_number="350">7&#65289;&#22914;&#26524;&#36825;&#26159;worker&#31532;&#19968;&#27425;&#25910;&#21040;&#23545;&#32473;&#23450; <code class="valid" valid="valid" title="valid: True, node: 351, level: 13" node_number="351">autograd_context_id</code>&#30340;&#35831;&#27714;&#65292;&#23427;&#23558;&#25353;&#29031;&#19978;&#38754;&#30340;&#31532; 1-3 &#28857;&#25152;&#36848;&#22312;&#26412;&#22320;&#35745;&#31639;&#20381;&#36182;&#39033;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 352, level: 12" node_number="352">8&#65289;&#28982;&#21518;&#23558;&#22312;&#31532;6&#28857;&#25509;&#21463;&#21040;&#30340;<code class="valid" valid="valid" title="valid: True, node: 353, level: 13" node_number="353">send</code>&#26041;&#27861;&#25554;&#20837;&#38431;&#21015;&#65292;&#20197;&#20415;&#22312;&#35813;worker&#30340;&#26412;&#22320; autograd &#24341;&#25806;&#19978;&#25191;&#34892;&#12290;</li> </ul> <p class="valid" valid="valid" title="valid: True, node: 354, level: 11" node_number="354">&#20855;&#20307;&#20195;&#30721;&#22914;&#19979;&#65306;</p> <pre class="valid" valid="valid" title="valid: True, node: 355, level: 11" node_number="355"><code class="valid" valid="valid" title="valid: True, node: 356, level: 12" node_number="356">c10::intrusive_ptr&lt;c10::ivalue::Future&gt; DistEngine::executeSendFunctionAsync( const ContextPtr autogradContext, const std::shared_ptr&lt;SendRpcBackward&gt; sendFunction, bool retainGraph) { // Typically the local autograd engine ensures stream synchronizations between // nodes in the graph. However, for distributed autograd the sendFunction // inputs might have been retrieved over the wire on a separate stream and the // sendFunction itself runs on a different stream. As a result, we need to // manually synchronize those two streams here. const auto send_backward_stream = sendFunction-&gt;stream(c10::DeviceType::CUDA); if (send_backward_stream) { // &#25343;&#21040;&#26412;&#27425;&#25191;&#34892;&#23545;&#24212;&#30340;Stream for (const auto grad : sendFunction-&gt;getGrads()) { const auto guard = c10::impl::VirtualGuardImpl{c10::DeviceType::CUDA}; const auto default_stream = guard.getStream(grad.device()); if (send_backward_stream != default_stream) { auto event = c10::Event{c10::DeviceType::CUDA}; event.record(default_stream); send_backward_stream-&gt;wait(event); // &#38656;&#35201;&#21516;&#27493;&#65292;&#20445;&#35777;&#24403;&#21069;&#25805;&#20316;&#23436;&#25104; } } } std::unique_lock&lt;std::mutex&gt; lock(initializedContextIdsLock_); if (initializedContextIds_.find(autogradContext-&gt;contextId()) == initializedContextIds_.end()) { // &#36941;&#21382;&#65292;&#26597;&#25214;sendFunction&#23545;&#24212;&#30340;&#19978;&#19979;&#25991;&#26159;&#21542;&#22312;&#26412;&#33410;&#28857;&#20043;&#20013;&#24050;&#32463;&#35760;&#24405; // &#27809;&#26377;&#25214;&#21040;&#19978;&#19979;&#25991;&#65292;&#38656;&#35201;&#35745;&#31639;&#20381;&#36182; edge_list outputEdges; // Pass in a dummy graphRoot since all send functions are the roots. auto dummyRoot = std::make_shared&lt;GraphRoot&gt;(edge_list(), variable_list()); computeDependencies( // &#35745;&#31639;&#20381;&#36182; autogradContext, {}, {}, dummyRoot, outputEdges, retainGraph); // Mark the autograd context id as initialized and unlock. initializedContextIds_.insert(autogradContext-&gt;contextId()); lock.unlock(); // Enqueue the current send function. auto graphTask = autogradContext-&gt;retrieveGraphTask(); // Run the autograd engine. auto accumulateGradFuture = runEngineAndAccumulateGradients( // &#35745;&#31639;&#26799;&#24230; autogradContext, sendFunction, outputEdges, /*incrementOutstandingTasks=*/false); // Build the 'uber' future that waits for everything. auto callbackFuture = c10::make_intrusive&lt;c10::ivalue::Future&gt;(c10::NoneType::get()); // &#27880;&#20876;&#22238;&#35843; accumulateGradFuture-&gt;addCallback([autogradContext, callbackFuture](c10::ivalue::Future accumulateGradFuture) { try { if (accumulateGradFuture.hasError()) { // Perform cleanup at the end of the backward pass (before we mark // the future as completed). DistEngine::getInstance().cleanupBackwardPass(autogradContext); // Skip any further processing on errors. callbackFuture-&gt;setError(accumulateGradFuture.exception_ptr()); return; } // Wait for all RPCs after the autograd engine is done. auto rpcFuture = autogradContext-&gt;clearAndWaitForOutstandingRpcsAsync(); rpcFuture-&gt;addCallback([callbackFuture, autogradContext](c10::ivalue::Future rpcFuture) { try { // Perform cleanup at the end of the backward pass (before // we mark the future as completed). DistEngine::getInstance().cleanupBackwardPass(autogradContext); } catch (std::exception e) { callbackFuture-&gt;setErrorIfNeeded(std::current_exception()); return; } // Finally mark the 'uber' future as completed. if (!rpcFuture.hasError()) { callbackFuture-&gt;markCompleted(c10::IValue()); } else { callbackFuture-&gt;setError(rpcFuture.exception_ptr()); } }); } catch (std::exception e) { callbackFuture-&gt;setErrorIfNeeded(std::current_exception()); } }); // Return the future which waits for all async processing to be done. return callbackFuture; } else { // &#21487;&#20197;&#22312;&#24403;&#21069;Node&#25214;&#21040;&#19978;&#19979;&#25991; lock.unlock(); auto graphTask = autogradContext-&gt;retrieveGraphTask(); at::launch([this, graphTask, sendFunction]() { execute_graph_task_until_ready_queue_empty( /*node_task*/ NodeTask(graphTask, sendFunction, InputBuffer(0)), /*incrementOutstandingTasks*/ false); }); auto fut = c10::make_intrusive&lt;c10::ivalue::Future&gt;(c10::NoneType::get()); fut-&gt;markCompleted(c10::IValue()); return fut; } } </code></pre> <p class="valid" valid="valid" title="valid: True, node: 357, level: 11" node_number="357">&#20855;&#20307;&#22914;&#19979;&#22270;&#65306;</p> <pre class="valid" valid="valid" title="valid: True, node: 358, level: 11" node_number="358"><code class="valid" valid="valid" title="valid: True, node: 359, level: 12" node_number="359"> + worker 0 | worker 1 | Engine RecvRpcBackward RpcAgent | RequestCallbackNoPython DistEngine + + + | + + | | | | | | | | | | | | evaluate_function | | | | | + | | | | | | | | | | | + | | | | | call_function | | | | | + | | | | | | grads v | | | | +----------------&gt; apply | | | | | + | | | | | | | | | | | + | | | | | gradCall | | | | | + | | | | | | PropagateGradientsReq | | | | | +------------------------&gt; | | | | | | | + | | | | + BACKWARD_AUTOGRAD_REQ | | | | send +---------+---------&gt; | | | | + | | | | | | | + | | | | | processBackwardAutogradReq | | | | | + | | | | | | + | | | | +------------&gt; executeSendFunctionAsync | | | | | + | | | | | | | | | | | | v v v + v v </code></pre> <p class="valid" valid="valid" title="valid: True, node: 360, level: 11" node_number="360">&#25163;&#26426;&#22914;&#19979;&#65306;</p> <h2 class="valid" valid="valid" title="valid: True, node: 361, level: 11" node_number="361">0x04 DistAccumulateGradCaptureHook</h2> <p class="valid" valid="valid" title="valid: True, node: 362, level: 11" node_number="362">&#30446;&#21069;&#30475;&#36215;&#26469;&#24635;&#20307;&#36923;&#36753;&#24050;&#32463;&#23436;&#25104;&#20102;&#65292;&#20294;&#26159;&#23454;&#38469;&#19978;&#32570;&#20102;&#19968;&#22359;&#65292;&#23545;&#24212;&#20102;&#35774;&#35745;&#25991;&#26723;&#20013;&#30340;&#65306;</p> <blockquote class="valid" valid="valid" title="valid: True, node: 363, level: 11" node_number="363"> <p class="valid" valid="valid" title="valid: True, node: 364, level: 12" node_number="364">&#26368;&#21518;&#65292;&#25105;&#20204;&#19981;&#26159;&#22312; Tensor&#30340;<code class="valid" valid="valid" title="valid: True, node: 365, level: 13" node_number="365">.grad</code>&#20043;&#19978;&#32047;&#31215;&#26799;&#24230;&#65292;&#32780;&#26159;&#22312;&#27599;&#20010;Distributed Autograd Context&#20043;&#19978;&#20998;&#21035;&#32047;&#31215;&#26799;&#24230; &#12290;&#26799;&#24230;&#23384;&#20648;&#22312;<code class="valid" valid="valid" title="valid: True, node: 366, level: 13" node_number="366">Dict[Tensor, Tensor]</code>&#20043;&#20013; &#65292;<code class="valid" valid="valid" title="valid: True, node: 367, level: 13" node_number="367">Dict[Tensor, Tensor]</code>&#22522;&#26412;&#19978;&#26159;&#20174; Tensor &#21040;&#20854;&#20851;&#32852;&#26799;&#24230;&#30340;&#26144;&#23556;&#65292;&#24182;&#19988;&#21487;&#20197;&#20351;&#29992; get_gradients() API&#26816;&#32034;&#35813;&#26144;&#23556; &#12290;</p> </blockquote> <p class="valid" valid="valid" title="valid: True, node: 368, level: 11" node_number="368">&#23601;&#26159;&#25226;&#24322;&#22320;/&#26412;&#22320;&#30340;&#26799;&#24230;&#32047;&#31215;&#21040;&#26412;&#22320;&#19978;&#19979;&#25991;&#20043;&#20013;&#65292;&#25152;&#20197;&#25105;&#20204;&#20877;&#20998;&#26512;&#19968;&#19979; DistAccumulateGradCaptureHook&#12290;</p> <h3 class="valid" valid="valid" title="valid: True, node: 369, level: 11" node_number="369">4.1 &#23450;&#20041;</h3> <p class="valid" valid="valid" title="valid: True, node: 370, level: 11" node_number="370">DistAccumulateGradCaptureHook &#26377;&#19977;&#20010;&#20316;&#29992;&#65306;</p> <ol class="valid" valid="valid" title="valid: True, node: 371, level: 11" node_number="371"> <li class="valid" valid="valid" title="valid: True, node: 372, level: 12" node_number="372"> <p class="valid" valid="valid" title="valid: True, node: 373, level: 13" node_number="373">&#35843;&#29992;&#21407;&#22987;AccumulateGrad&#30340; pre hooks &#26469;&#20462;&#25913;&#36755;&#20837;&#26799;&#24230;&#12290;</p> </li> <li class="valid" valid="valid" title="valid: True, node: 374, level: 12" node_number="374"> <p class="valid" valid="valid" title="valid: True, node: 375, level: 13" node_number="375">&#23558; grad &#32047;&#31215;&#21040;RPC&#19978;&#19979;&#25991;&#12290;</p> </li> <li class="valid" valid="valid" title="valid: True, node: 376, level: 12" node_number="376"> <p class="valid" valid="valid" title="valid: True, node: 377, level: 13" node_number="377">&#35843;&#29992;&#21407;&#22987;AccumulateGrad&#30340; post hooks&#12290;</p> </li> </ol> <p class="valid" valid="valid" title="valid: True, node: 378, level: 11" node_number="378">&#20854;&#23450;&#20041;&#22914;&#19979;&#65306;</p> <pre class="valid" valid="valid" title="valid: True, node: 379, level: 11" node_number="379"><code class="valid" valid="valid" title="valid: True, node: 380, level: 12" node_number="380">// This hook does 3 things: // 1. Call pre hooks of the original AccumulateGrad to modify the input grad. // 2. Accumuate the gard to RPC context. // 3. Call post hooks of the original AccumulateGrad. class DistAccumulateGradCaptureHook : public GraphTask::ExecInfo::Capture::GradCaptureHook { public: DistAccumulateGradCaptureHook( std::shared_ptr&lt;AccumulateGrad&gt; accumulateGrad, ContextPtr autogradContext) : accumulateGrad_(std::move(accumulateGrad)), autogradContext_(std::move(autogradContext)) {} at::Tensor operator()(const at::Tensor grad) override { ThreadLocalDistAutogradContext contextGuard{ContextPtr(autogradContext_)}; variable_list inputGrads = {grad}; // It's intended that pre/post hooks are still called even if the grad is // undenfined here. for (const auto hook : accumulateGrad_-&gt;pre_hooks()) { inputGrads = (*hook)(inputGrads); // &#35843;&#29992; pre-hooks } // It is possible that the grad is not defined since a separate // invocation of the autograd engine on the same node might actually // compute this gradient. if (inputGrads[0].defined()) { // There are 3 internal references to 'inputGrads[0]' at this moment: // 1. 'inputGrads[0]' in this function. // 2. 'graph_task-&gt;captured_vars_' on the callsite in the local engine. // 3. 'InputBuffer inputs' on the callsite as the inputs of the // function node. autogradContext_-&gt;accumulateGrad( // &#32047;&#31215;&#26799;&#24230; accumulateGrad_-&gt;variable, inputGrads[0], 3 /* num_expected_refs */); } const variable_list kEmptyOuput; for (const auto hook : accumulateGrad_-&gt;post_hooks()) { (*hook)(kEmptyOuput, inputGrads); // &#35843;&#29992; post-hooks } return inputGrads[0]; } private: std::shared_ptr&lt;AccumulateGrad&gt; accumulateGrad_; // &#36825;&#23601;&#26159;&#38656;&#35201;&#32047;&#31215;&#30340;&#30446;&#26631;&#21521;&#37327;&#65292;&#21518;&#32493;&#25805;&#20316;&#22312;&#20854;&#20043;&#19978; ContextPtr autogradContext_; }; </code></pre> <h3 class="valid" valid="valid" title="valid: True, node: 381, level: 11" node_number="381">4.2 &#29983;&#25104;</h3> <p class="valid" valid="valid" title="valid: True, node: 382, level: 11" node_number="382">&#22914;&#20309;&#29983;&#25104; DistAccumulateGradCaptureHook&#65311;&#35745;&#31639;&#20381;&#36182;&#26102;&#20505;&#29983;&#25104; DistAccumulateGradCaptureHook&#65292;&#20294;&#26159;&#35760;&#24405;&#22312; capture.hooks_.push_back &#20043;&#20013;&#12290;</p> <p class="valid" valid="valid" title="valid: True, node: 383, level: 11" node_number="383">&#36825;&#37324;&#26159;&#20026;&#20102;&#22788;&#29702; AccumulateGrad&#12290;</p> <ul class="valid" valid="valid" title="valid: True, node: 384, level: 11" node_number="384"> <li class="valid" valid="valid" title="valid: True, node: 385, level: 12" node_number="385"> <p class="valid" valid="valid" title="valid: True, node: 386, level: 13" node_number="386">AccumulateGrad &#19968;&#23450;&#26159;&#21494;&#23376;&#33410;&#28857;&#65292;&#19981;&#38656;&#25191;&#34892;&#65292;&#32780;&#38656;&#35201;&#22312;&#20854;&#19978;&#31215;&#32047;&#26799;&#24230;&#65292;&#20294;&#26159;RecvRpcBackward&#38656;&#35201;&#25191;&#34892;&#12290;</p> </li> <li class="valid" valid="valid" title="valid: True, node: 387, level: 12" node_number="387"> <p class="valid" valid="valid" title="valid: True, node: 388, level: 13" node_number="388">AccumulateGrad &#23601;&#20445;&#23384;&#22312; DistAccumulateGradCaptureHook &#20043;&#20013;&#12290;</p> </li> </ul> <pre class="valid" valid="valid" title="valid: True, node: 389, level: 11" node_number="389"><code class="valid" valid="valid" title="valid: True, node: 390, level: 12" node_number="390">void DistEngine::computeDependencies( const ContextPtr autogradContext, const edge_list rootEdges, const variable_list grads, const std::shared_ptr&lt;Node&gt; graphRoot, edge_list outputEdges, bool retainGraph) { if (!outputEdges.empty()) { // Compute 'needed execution' starting from all 'send' functions and the // original graphRoot. edge_list edges; // Create some dummy edges (input_nr not important for init_to_execute). for (const auto mapEntry : sendFunctions) { edges.emplace_back(mapEntry.second, 0); } // Add the original graphRoot as an edge. edges.emplace_back(graphRoot, 0); // Create a dummy GraphRoot and run init_to_execute with it. GraphRoot dummyRoot(edges, {}); graphTask-&gt;init_to_execute(dummyRoot, outputEdges, /*accumulate_grad=*/false, /*min_topo_nr=*/0); for (auto mapEntry : graphTask-&gt;exec_info_) { auto execInfo = mapEntry.second; if (!execInfo.captures_) { continue; } auto fn = mapEntry.first; // There may be nodes other than 'AccumulateGrad', e.g. RecvRPCBackward, // to be captured. if (auto accumulateGradFn = dynamic_cast&lt;AccumulateGrad*&gt;(fn)) { for (auto capture : *execInfo.captures_) { capture.hooks_.push_back( // &#36825;&#37324;&#20250;&#29983;&#25104; std::make_unique&lt;DistAccumulateGradCaptureHook&gt;( std::dynamic_pointer_cast&lt;AccumulateGrad&gt;( // &#20250;&#20445;&#23384; AccumulateGrad accumulateGradFn-&gt;shared_from_this()), autogradContext)); } } } // Mark all 'RecvRPCBackward' as needing execution. for (const auto recvBackwardEdge : recvBackwardEdges) { graphTask-&gt;exec_info_[recvBackwardEdge.function.get()].needed_ = true; } } } </code></pre> <h3 class="valid" valid="valid" title="valid: True, node: 391, level: 11" node_number="391">4.3 &#20351;&#29992;</h3> <p class="valid" valid="valid" title="valid: True, node: 392, level: 11" node_number="392">&#20195;&#30721;&#26159;&#32553;&#20943;&#29256;&#12290;</p> <p class="valid" valid="valid" title="valid: True, node: 393, level: 11" node_number="393">&#39318;&#20808;&#65292;execute_graph_task_until_ready_queue_empty &#20250;&#35843;&#29992;&#21040;&#21407;&#22987;&#24341;&#25806; engine_.evaluate_function&#12290;</p> <pre class="valid" valid="valid" title="valid: True, node: 394, level: 11" node_number="394"><code class="valid" valid="valid" title="valid: True, node: 395, level: 12" node_number="395">void DistEngine::execute_graph_task_until_ready_queue_empty( NodeTask node_task, bool incrementOutstandingTasks) { while (!cpu_ready_queue-&gt;empty()) { std::shared_ptr&lt;GraphTask&gt; local_graph_task; { NodeTask task = cpu_ready_queue-&gt;pop(); if (task.fn_ !local_graph_task-&gt;has_error_.load()) { AutoGradMode grad_mode(local_graph_task-&gt;grad_mode_); GraphTaskGuard guard(local_graph_task); engine_.evaluate_function( // &#35843;&#29992;&#21407;&#22987;&#24341;&#25806; local_graph_task, task.fn_.get(), task.inputs_, cpu_ready_queue); } } // Decrement the outstanding task. --local_graph_task-&gt;outstanding_tasks_; } } </code></pre> <p class="valid" valid="valid" title="valid: True, node: 396, level: 11" node_number="396">&#20854;&#27425;&#65292;&#21407;&#22987;&#24341;&#25806;&#20195;&#30721;&#20043;&#20013;&#65292;&#20250;&#35843;&#29992;hooks&#12290;</p> <pre class="valid" valid="valid" title="valid: True, node: 397, level: 11" node_number="397"><code class="valid" valid="valid" title="valid: True, node: 398, level: 12" node_number="398">void Engine::evaluate_function( std::shared_ptr&lt;GraphTask&gt; graph_task, Node* func, InputBuffer inputs, const std::shared_ptr&lt;ReadyQueue&gt; cpu_ready_queue) { // If exec_info_ is not empty, we have to instrument the execution auto exec_info_ = graph_task-&gt;exec_info_; if (!exec_info_.empty()) { auto fn_info = exec_info_.at(func); if (auto* capture_vec = fn_info.captures_.get()) { // Lock mutex for writing to graph_task-&gt;captured_vars_. std::lock_guard&lt;std::mutex&gt; lock(graph_task-&gt;mutex_); for (const auto capture : *capture_vec) { auto captured_grad = graph_task-&gt;captured_vars_[capture.output_idx_]; captured_grad = inputs[capture.input_idx_]; for (auto hook : capture.hooks_) { captured_grad = (*hook)(captured_grad); // &#36825;&#37324;&#35843;&#29992; hook&#65292;&#23601;&#26159; DistAccumulateGradCaptureHook &#30340; operator()&#65292;captured_grad &#23601;&#26159;&#32047;&#31215;&#30340;&#26799;&#24230; } } } } // &#21518;&#32493;&#30465;&#30053; </code></pre> <p class="valid" valid="valid" title="valid: True, node: 399, level: 11" node_number="399">DistAccumulateGradCaptureHook &#30340; operator() &#26041;&#27861;&#20043;&#20013;&#65292;&#20250;&#35843;&#29992;&#19979;&#38754;&#26469;&#32047;&#31215;&#26799;&#24230;&#12290;</p> <pre class="valid" valid="valid" title="valid: True, node: 400, level: 11" node_number="400"><code class="valid" valid="valid" title="valid: True, node: 401, level: 12" node_number="401"> autogradContext_-&gt;accumulateGrad( accumulateGrad_-&gt;variable, inputGrads[0], 3 /* num_expected_refs */); </code></pre> <h3 class="valid" valid="valid" title="valid: True, node: 402, level: 11" node_number="402">4.4 &#32047;&#31215;&#26799;&#24230;</h3> <h4 class="valid" valid="valid" title="valid: True, node: 403, level: 11" node_number="403">4.4.1 &#19978;&#19979;&#25991;&#32047;&#31215;</h4> <pre class="valid" valid="valid" title="valid: True, node: 404, level: 11" node_number="404"><code class="valid" valid="valid" title="valid: True, node: 405, level: 12" node_number="405">void DistAutogradContext::accumulateGrad( const torch::autograd::Variable variable, // variable&#23601;&#26159;&#30446;&#26631;&#21464;&#37327; const torch::Tensor grad, // grad&#23601;&#26159;&#26799;&#24230;&#65292;&#38656;&#35201;&#32047;&#31215;&#21040;variable&#20043;&#19978; size_t num_expected_refs) { std::lock_guard&lt;std::mutex&gt; guard(lock_); auto it = accumulatedGrads_.find(variable); at::Tensor old_grad; if (it != accumulatedGrads_.end()) { // Accumulate multiple grads on the same variable. old_grad = it-&gt;value(); } // Gradients are computed using the forward streams. Local autograd // engine uses AccumulateGrad function to retrieve and apply forward // stream during the backward computation. In distributed autograd, // we directly call AccumulateGrad::accumulateGrad, and skip the // CUDA stream restoration from autograd function. Hence, we manually // call it here to get the streams correct. auto forward_stream = torch::autograd::impl::grad_accumulator(variable)-&gt;stream( grad.device().type()); c10::OptionalStreamGuard stream_guard(forward_stream); // No higher order gradients supported in distributed autograd. AutoGradMode grad_mode(false); at::Tensor new_grad = AccumulateGrad::callHooks(variable, grad); // &#35745;&#31639; AccumulateGrad::accumulateGrad( // &#35843;&#29992;&#31639;&#23376;&#20989;&#25968;&#26469;&#32047;&#31215;&#26799;&#24230; variable, old_grad, new_grad, // Add +1 here since we can't std::move(grad) when call // AccumulateGrad::callHooks, since it is a const ref, and that incurs a // refcount bump for the new_grad. num_expected_refs + 1, [this, variable](at::Tensor grad_update) { auto device = grad_update.device(); accumulatedGrads_.insert(variable, std::move(grad_update)); recordGradEvent(device); }); } </code></pre> <h4 class="valid" valid="valid" title="valid: True, node: 406, level: 11" node_number="406">4.4.2 &#31639;&#23376;&#32047;&#31215;</h4> <p class="valid" valid="valid" title="valid: True, node: 407, level: 11" node_number="407">&#20195;&#30721;&#20301;&#20110; torch/csrc/autograd/functions/accumulate_grad.h&#12290;AccumulateGrad &#30340;&#23450;&#20041;&#22914;&#19979;&#65306;</p> <pre class="valid" valid="valid" title="valid: True, node: 408, level: 11" node_number="408"><code class="valid" valid="valid" title="valid: True, node: 409, level: 12" node_number="409">struct TORCH_API AccumulateGrad : public Node { explicit AccumulateGrad(Variable variable_); variable_list apply(variable_list grads) override; static at::Tensor callHooks( const Variable variable, at::Tensor new_grad) { for (auto hook : impl::hooks(variable)) { new_grad = (*hook)({new_grad})[0]; } return new_grad; } // Given a variable with its current grad as variable_grad, accumulates // new_grad into variable_grad if in place accumulation is possible. // Otherwise, uses 'update_grad' to update the grad for the variable. // "Gradient Layout Contract" // // AccumulateGrad tries to stash strided (non-sparse) grads with memory layout // (strides) such that variables and grads interact efficiently in later // optimizer kernels, and grads interact efficiently with c10d::Reducer.cpp. // // Specifically, AccumulateGrad tries to ensure the following // (cf torch/csrc/autograd/utils/grad_layout_contract.h): // (1) if variable.is_non_overlapping_and_dense(), the stashed grad's // strides match variable. // (2) else, stashed grad is rowmajor contiguous. // If variable's grad does not exist (!variable_grad.defined()) // AccumulateGrad steals new_grad if it's stealable and obeys the contract // already, otherwise it deep copies new_grad into an obedient clone. // // If variable's grad already exists (variable_grad.defined()), new_grad must // be added to variable_grad. If we aren't setting up for double backward // (!GradMode::is_enabled()), AccumulateGrad performs "variable_grad += new_grad" // in-place, which keeps variable_grad's layout. We assume (hope) variable_grad // was created obeying (1) or (2) at some point in the past. // // If we are setting up for double backward, AccumulateGrad updates the grad // out-of-place via "variable_grad + new_grad." TensorIterator operator+ decides // result's layout. Typically TensorIterator matches strides of the first arg, // so we once again assume (hope) variable_grad was originally created obeying // (1) or (2). // // AccumulateGrad does not enforce the contract with 100% certainty. Examples: // - If a user manually permutes a param or its grad, then runs a fwd+bwd, // variable_grad += new_grad keeps variable_grad's layout without rechecking // the contract. // - If TensorIterator changes its corner cases about operator+'s result // (for example, giving more or less priority to channels_last inputs, see // https://github.com/pytorch/pytorch/pull/37968) the result may not obey. // // Fortunately, if a given grad doesn't satisfy (1) or (2), the penalty is // degraded performance in Reducer.cpp or optimizer kernels, not death by // assert or silently bad numerics. // variable: the variable whose grad we're accumulating. // variable_grad: the current grad for the variable. // new_grad: new grad we want to acummulate for the variable. // num_expected_refs: the number of refs we expect to hold internally // such that it is safe to avoid cloning the grad // if use_count() of the grad is less than or equal // to this value (in addition to post_hooks). // update_grad: Function that is used to update grad for the variable. // The argument to the function is a Tensor which // is used to set a new value for the grad. template &lt;typename T&gt; static void accumulateGrad( // &#36825;&#37324;&#20250;&#36827;&#34892;&#20855;&#20307;&#30340;&#32047;&#31215;&#26799;&#24230; const Variable variable, at::Tensor variable_grad, const at::Tensor new_grad, size_t num_expected_refs, const T update_grad) { if (!variable_grad.defined()) { if (!GradMode::is_enabled() !new_grad.is_sparse() new_grad.use_count() &lt;= num_expected_refs (new_grad.is_mkldnn() || utils::obeys_layout_contract(new_grad, variable))) { // we aren't setting up for double-backward // not sparse // no other user-visible tensor references new_grad // new_grad obeys the "Gradient Layout Contract", there has a special case, // For MKLDNN tensor, which is a opaque tensor, assuming it obeys layout_contract. // Under these conditions, we can steal new_grad without a deep copy. update_grad(new_grad.detach()); } else if ( !GradMode::is_enabled() new_grad.is_sparse() new_grad._indices().is_contiguous() new_grad._values().is_contiguous() // Use count for indices and values should always be &lt;=1 since the // SparseTensor should be the only one holding a reference to these. new_grad._indices().use_count() &lt;= 1 new_grad._values().use_count() &lt;= 1 new_grad.use_count() &lt;= num_expected_refs) { // Can't detach sparse tensor (since metadata changes are not allowed // after detach), so just create a new one for the grad which is a // shallow copy. We need a shallow copy so that modifying the original // grad tensor doesn't modify the grad we accumulate. // We only skip clone if indices and values themselves are contiguous // for backward compatiblity reasons. Since without this optimization, // earlier we would clone the entire SparseTensor which cloned indices // and values. // For details see https://github.com/pytorch/pytorch/issues/34375. update_grad(at::_sparse_coo_tensor_unsafe( new_grad._indices(), new_grad._values(), new_grad.sizes(), new_grad.options())); } else { if (new_grad.is_sparse()) { update_grad(new_grad.clone()); } else { if (new_grad.is_mkldnn()) { update_grad(new_grad.clone()); } else { // Deep copies new_grad according to the "Gradient Layout Contract." update_grad(utils::clone_obey_contract(new_grad, variable)); } } } } else if (!GradMode::is_enabled()) { // This case is not strictly necessary, but it makes the first-order only // case slightly more efficient. if (variable_grad.is_sparse() !new_grad.is_sparse()) { // If `variable_grad` is sparse and `new_grad` is not sparse, their // sum is not sparse, and we must change the TensorImpl type of // `variable_grad` for it to store the result. However, changing the // TensorImpl type of a tensor requires changing the tensor itself, and // thus in this case we have to change the grad tensor. auto result = new_grad + variable_grad; CHECK_RESULT(result, variable); update_grad(std::move(result)); } else if (!at::inplaceIsVmapCompatible(variable_grad, new_grad)) { // Ideally we'd perform an in-place operation to avoid changing // the grad tensor. However, if that's impossible because the grads // are vmap-incompatible (See NOTE: [vmap-incompatible in-place operations]), // then we just add them out-of-place. auto result = variable_grad + new_grad; CHECK_RESULT(result, variable); update_grad(std::move(result)); } else { // In this case we can avoid changing the grad tensor. There are three // scenarios when we'll hit this case: // // 1. `variable_grad` is sparse, and `new_grad` is sparse. // 2. `variable_grad` is dense, and `new_grad` is sparse. // 3. `variable_grad` is dense, and `new_grad` is dense. // 4. `variable_grad` is mkldnn, and `new_grad` is mkldnn. // // In all of these four cases, `variable_grad += new_grad` is a // valid operation which adds `new_grad` to `variable_grad` in // place. `variable_grad` is thus still referring to the same tensor // after the operation. // Also DistributedDataParallel(DDP) package relies on grad being // mutated in place for saving peak memory usage. DDP will still // work correctly if it is mutated out of place here, but DDP will // maintain one extra copy of grad tensors in buffer and thus // increase peak memory usage. variable_grad += new_grad; CHECK_RESULT(variable_grad, variable); // ^ We could enforce the contract more aggressively here by writing: // if (variable_grad.is_sparse() || new_grad.is_sparse()) { // variable_grad += new_grad; // } else if (obeys_layout_contract(variable_grad, variable)) { // variable_grad += new_grad; // } else { // result = at::empty_strided(variable.sizes(), variable.strides(), // variable.options().memory_format(c10::nullopt)); // update_grad(at::native::add_out(result, variable_grad, new_grad, 1.0); // } // However, that accumulation is sometimes in place and sometimes not, // which may break user code. } } else { at::Tensor result; if (variable_grad.is_sparse() !new_grad.is_sparse()) { // CPU backend throws an error on sparse + dense, so prefer dense + sparse here. result = new_grad + variable_grad; } else { // Assumes operator+ result typically matches strides of first arg, // and hopes variable_grad was originally created obeying layout contract. result = variable_grad + new_grad; } CHECK_RESULT(result, variable); update_grad(std::move(result)); // ^ We could enforce the contract more aggressively here by saying // if (obeys_layout_contract(new_grad, variable)) { // update_grad(new_grad + variable_grad); // } else { // update_grad(variable_grad + new_grad); // } // such that the stashed grad is likely to have the right strides if // either variable_grad or new_grad already has the right strides. // We could enforce the contract with certainty by saying // auto result = variable_grad + new_grad (or vice versa), checking result's // layout, and copying to an obedient clone if necessary before update_grad. // The copy would require another gmem pass. We can't create empty result with // the right layout then add_out into it with a single kernel, because GradMode // is enabled in this branch, and add_out isn't differentiable. // Maybe more trouble than it's worth. } } Variable variable; }; </code></pre> <p class="valid" valid="valid" title="valid: True, node: 410, level: 11" node_number="410">&#20855;&#20307;&#21487;&#20197;&#22914;&#19979;&#22270;&#25152;&#31034;&#65292;&#24038;&#36793;&#26159;&#25968;&#25454;&#32467;&#26500;&#65292;&#21491;&#38754;&#26159;&#31639;&#27861;&#27969;&#31243;&#65292;&#21491;&#38754;&#30340;&#24207;&#21495;&#34920;&#31034;&#25191;&#34892;&#20174;&#19978;&#33267;&#19979;&#65292;&#25191;&#34892;&#36807;&#31243;&#20043;&#20013;&#20250;&#29992;&#21040;&#24038;&#36793;&#30340;&#25968;&#25454;&#32467;&#26500;&#65292;&#31639;&#27861;&#19982;&#25968;&#25454;&#32467;&#26500;&#30340;&#35843;&#29992;&#20851;&#31995;&#30001;&#27178;&#21521;&#31661;&#22836;&#34920;&#31034;&#12290;</p> <ol class="valid" valid="valid" title="valid: True, node: 411, level: 11" node_number="411"> <li class="valid" valid="valid" title="valid: True, node: 412, level: 12" node_number="412">&#20998;&#24067;&#24335;&#24341;&#25806;&#35843;&#29992;execute_graph_task_until_ready_queue_empty&#26469;&#25191;&#34892;&#20855;&#20307;&#30340; GraphTask&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 413, level: 12" node_number="413">Engine::evaluate_function &#20250;&#35843;&#29992; GraphTask &#20043;&#20013;&#30340; ExecInfo&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 414, level: 12" node_number="414">&#28982;&#21518;&#20250;&#35775;&#38382; GradCaptureHook&#65292;&#35843;&#29992;hook&#65292;hook &#30340; operator&#20989;&#25968;&#20250;&#35843;&#29992;&#21040; autogradContext_-&gt;accumulateGrad&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 415, level: 12" node_number="415">autogradContext_ &#20250;&#25191;&#34892; accumulateGrad&#65292;&#23545; hook&#65288;DistAccumulateGradCaptureHook&#65289;&#20043;&#20013;&#20445;&#23384;&#30340; accumulateGrad_ &#20570;&#25805;&#20316;&#12290;</li> <li class="valid" valid="valid" title="valid: True, node: 416, level: 12" node_number="416">AccumulateGrad::accumulateGrad &#20250;&#23436;&#25104;&#26368;&#32456;&#30340;&#26799;&#24230;&#26356;&#26032;&#25805;&#20316;&#12290;</li> </ol> <pre class="valid" valid="valid" title="valid: True, node: 417, level: 11" node_number="417"><code class="valid" valid="valid" title="valid: True, node: 418, level: 12" node_number="418"> DATA STRUCTURE + ALGORITHM | +-----------------------------------------------+ | | GraphTask | | DistEngine::execute_graph_task_until_ready_queue_empty | | | + | | unordered_map&lt;Node*, ExecInfo&gt; exec_info_ | | | | | + | &lt;----------+ | | | | | | +-----------------------------------------------+ | | 1 | | | | | | v | | +---------------------+------------------+ | v | ExecInfo | &lt;-------------+ Engine::evaluate_function | | | + | &lt; vector&lt;Capture&gt; &gt; captures_ | | | | + | | | | | | | | 2 +----------------------------------------+ | | | | v | | v | +--+ captured_grad = (*hook)(captured_grad) +-------------------+--------------------+ | | + | Capture | | | | | | | | | | vector&lt; &lt;GradCaptureHook&gt; &gt; hooks_ &lt;--------------+ | 3 | + | | | +----------------------------------------+ | v | | | | +--+ autogradContext_-&gt;accumulateGrad( v | | accumulateGrad_-&gt; variable, inputGrads[0], 3) +-------------------+--------------------+ | | + | DistAccumulateGradCaptureHook | | | | | | | | | | ContextPtr autogradContext_ &lt;------------+ | 4 | | | | | | AccumulateGrad accumulateGrad_ &lt;------------+ v | + | | +----------------------------------------+ | +-+ new_grad = AccumulateGrad::callHooks(variable, grad) | | | + | | | | v | | | 5 +-------------------+------+ | | v | AccumulateGrad | | | | | | | AccumulateGrad::accumulateGrad( | Variable variable &lt;------------------+------+ variable, old_grad, new_grad,) | | | +--------------------------+ + </code></pre> <p class="valid" valid="valid" title="valid: True, node: 419, level: 11" node_number="419">&#25163;&#26426;&#22914;&#19979;&#65306;</p> <h2 class="valid" valid="valid" title="valid: True, node: 420, level: 11" node_number="420">0x05 &#31561;&#24453;&#23436;&#25104;</h2> <p class="valid" valid="valid" title="valid: True, node: 421, level: 11" node_number="421">&#26368;&#21518;&#65292;&#20998;&#24067;&#24335;&#24341;&#25806;&#20250;&#35843;&#29992; clearAndWaitForOutstandingRpcsAsync &#26469;&#31561;&#24453;&#22788;&#29702;&#23436;&#25104;&#12290;</p> <pre class="valid" valid="valid" title="valid: True, node: 422, level: 11" node_number="422"><code class="valid" valid="valid" title="valid: True, node: 423, level: 12" node_number="423">c10::intrusive_ptr&lt;c10::ivalue::Future&gt; DistAutogradContext:: clearAndWaitForOutstandingRpcsAsync() { std::unique_lock&lt;std::mutex&gt; lock(lock_); auto outStandingRpcs = std::move(outStandingRpcs_); lock.unlock(); struct State { explicit State(int32_t count) : future( c10::make_intrusive&lt;c10::ivalue::Future&gt;(c10::NoneType::get())), remaining(count) {} c10::intrusive_ptr&lt;c10::ivalue::Future&gt; future; std::atomic&lt;int32_t&gt; remaining; std::atomic&lt;bool&gt; alreadySentError{false}; }; auto state = std::make_shared&lt;State&gt;(outStandingRpcs.size()); if (outStandingRpcs.empty()) { state-&gt;future-&gt;markCompleted(c10::IValue()); } else { for (auto rpc : outStandingRpcs) { rpc-&gt;addCallback([state](rpc::JitFuture future) { if (future.hasError()) { // If there's an error, we want to setError() on the future, // unless another error has already been sent - use a CAS to // guard. // // Don't decrement num remaining here! (We don't need to, since // memory handling is separate). If we simply don't decrement on // errors, reaching 0 means that there were no errors - and hence, // we can just markCompleted() without any other checking there. bool expectedAlreadySent = false; if (state-&gt;alreadySentError.compare_exchange_strong( expectedAlreadySent, true)) { state-&gt;future-&gt;setError(future.exception_ptr()); } return; } if (--state-&gt;remaining == 0) { state-&gt;future-&gt;markCompleted(c10::IValue()); } }); } } return state-&gt;future; } </code></pre> <p class="valid" valid="valid" title="valid: True, node: 424, level: 11" node_number="424">&#25903;&#25345;&#65292;&#20998;&#24067;&#24335; autograd &#20840;&#37096;&#20998;&#26512;&#23436;&#27605;&#65292;&#21069;&#38754;&#35828;&#36807;&#65292;&#20998;&#24067;&#24335;&#22788;&#29702;&#26377;&#22235;&#22823;&#37329;&#21018;&#65292;&#25105;&#20204;&#31616;&#20171;&#20102; RPC&#65292;RRef&#65292;&#20998;&#26512;&#20102;&#20998;&#24067;&#24335;&#24341;&#25806;&#65292;&#20174;&#19979;&#19968;&#31687;&#24320;&#22987;&#65292;&#25105;&#20204;&#24320;&#22987;</p> <h2 class="valid" valid="valid" title="valid: True, node: 425, level: 11" node_number="425">0xFF &#21442;&#32771;</h2> <p class="valid" valid="valid" title="valid: True, node: 426, level: 11" node_number="426"><a class="valid" valid="valid" title="valid: True, node: 427, level: 12" node_number="427">Distributed Autograd Design</a></p> <p class="valid" valid="valid" title="valid: True, node: 428, level: 11" node_number="428"><a class="valid" valid="valid" title="valid: True, node: 429, level: 12" node_number="429">Remote Reference Protocol</a></p> <p class="valid" valid="valid" title="valid: True, node: 430, level: 11" node_number="430"><a class="valid" valid="valid" title="valid: True, node: 431, level: 12" node_number="431">PyTorch &#28304;&#30721;&#35299;&#35835;&#20043;&#20998;&#24067;&#24335;&#35757;&#32451;&#20102;&#35299;&#19968;&#19979;&#65311;</a></p> <p class="valid" valid="valid" title="valid: True, node: 432, level: 11" node_number="432"><a class="valid" valid="valid" title="valid: True, node: 433, level: 12" node_number="433">https://pytorch.org/docs/stable/distributed.html</a></p> <p class="valid" valid="valid" title="valid: True, node: 434, level: 11" node_number="434"><a class="valid" valid="valid" title="valid: True, node: 435, level: 12" node_number="435">https://pytorch.apachecn.org/docs/1.7/59.html</a></p> <p class="valid" valid="valid" title="valid: True, node: 436, level: 11" node_number="436"><a class="valid" valid="valid" title="valid: True, node: 437, level: 12" node_number="437">https://pytorch.org/docs/stable/distributed.html#module-torch.distributed</a></p> <p class="valid" valid="valid" title="valid: True, node: 438, level: 11" node_number="438"><a class="valid" valid="valid" title="valid: True, node: 439, level: 12" node_number="439">https://pytorch.org/docs/master/notes/autograd.html</a></p> <p class="valid" valid="valid" title="valid: True, node: 440, level: 11" node_number="440"><a class="valid" valid="valid" title="valid: True, node: 441, level: 12" node_number="441">https://pytorch.org/docs/master/rpc/distributed_autograd.html</a> <a class="valid" valid="valid" title="valid: True, node: 442, level: 12" node_number="442">https://pytorch.org/docs/master/rpc/rpc.html</a></p> <p class="valid" valid="valid" title="valid: True, node: 443, level: 11" node_number="443"><a class="valid" valid="valid" title="valid: True, node: 444, level: 12" node_number="444">https://www.w3cschool.cn/pytorch/pytorch-cdva3buf.html</a></p> <p class="valid" valid="valid" title="valid: True, node: 445, level: 11" node_number="445"><a class="valid" valid="valid" title="valid: True, node: 446, level: 12" node_number="446">PyTorch &#20998;&#24067;&#24335; Autograd &#35774;&#35745;</a></p> <p class="valid" valid="valid" title="valid: True, node: 447, level: 11" node_number="447"><a class="valid" valid="valid" title="valid: True, node: 448, level: 12" node_number="448">Getting started with Distributed RPC Framework</a></p> <p class="valid" valid="valid" title="valid: True, node: 449, level: 11" node_number="449"><a class="valid" valid="valid" title="valid: True, node: 450, level: 12" node_number="450">Implementing a Parameter Server using Distributed RPC Framework</a></p> <p class="valid" valid="valid" title="valid: True, node: 451, level: 11" node_number="451"><a class="valid" valid="valid" title="valid: True, node: 452, level: 12" node_number="452">Combining Distributed DataParallel with Distributed RPC Framework</a></p> <p class="valid" valid="valid" title="valid: True, node: 453, level: 11" node_number="453"><a class="valid" valid="valid" title="valid: True, node: 454, level: 12" node_number="454">Profiling RPC-based Workloads</a></p> <p class="valid" valid="valid" title="valid: True, node: 455, level: 11" node_number="455"><a class="valid" valid="valid" title="valid: True, node: 456, level: 12" node_number="456">Implementing batch RPC processing</a></p> <p class="valid" valid="valid" title="valid: True, node: 457, level: 11" node_number="457"><a class="valid" valid="valid" title="valid: True, node: 458, level: 12" node_number="458">Distributed Pipeline Parallel</a></p> </div> </div> <div class="valid" valid="valid" title="valid: True, node: 459, level: 9" node_number="459">posted @ 2021-12-06 18:12 <a class="valid" valid="valid" title="valid: True, node: 460, level: 10" node_number="460">&#32599;&#35199;&#30340;&#24605;&#32771;</a> &#38405;&#35835;(0) &#35780;&#35770;(0) &#32534;&#36753; &#25910;&#34255; <a class="valid" valid="valid" title="valid: True, node: 461, level: 10" node_number="461">&#20030;&#25253;</a></div> </div> <div class="valid" valid="valid" title="valid: True, node: 462, level: 8" node_number="462"> <div class="valid" valid="valid" title="valid: True, node: 463, level: 9" node_number="463"><a class="valid" valid="valid" title="valid: True, node: 464, level: 10" node_number="464">&#21047;&#26032;&#35780;&#35770;</a><a class="valid" valid="valid" title="valid: True, node: 465, level: 10" node_number="465">&#21047;&#26032;&#39029;&#38754;</a><a class="valid" valid="valid" title="valid: True, node: 466, level: 10" node_number="466">&#36820;&#22238;&#39030;&#37096;</a></div> </div> </div> </div> </div> </div> </div> <div class="valid" valid="valid" title="valid: True, node: 467, level: 3" node_number="467"> Copyright &#169; 2021 &#32599;&#35199;&#30340;&#24605;&#32771; <span class="valid" valid="valid" title="valid: True, node: 468, level: 4" node_number="468">Powered by .NET 6 on Kubernetes</span> </div> </div> </body>
        <style tyle='text/css'>
body{
    position: relative;
    padding-left: 30px;
    top: 60px;
}
* {
    border: 1px solid #eee;
    padding: 5px 12px;
    margin: 3px 0;
    box-sizing: content-box;
    background-color: #fff;
    cursor: no-drop;
}
main:hover > *, section:hover > *, header:hover > *, nav:hover > *, a:hover > *, div:hover > *, p:hover > *, ul:hover > *, h1:hover > *, h2:hover > *, h3:hover > *, li:hover > *, span:hover > *{
    border: 2px solid green;
    background-color: #fffeee;
    padding: 5px 23px !important;
    margin: 1px 0;
    color: green;
}
main:hover, section:hover, header:hover, nav:hover, a:hover, div:hover, p:hover, ul:hover, h1:hover, h2:hover, h3:hover, li:hover, span:hover{
    border: 1px solid #fff;
    background-color: #eee;
}
a, span {
    display: block;
}
.selected {
    border: 2px solid orchid !important;
    opacity: 0.8;
    color: orchid !important;
}
.selected * {
    padding: 2px !important;
    color: orchid !important;
}
.valid {
  cursor: pointer;
}
.btn{
  cursor: pointer;
  font-weight: bolder;
  padding: 8px;
}
</style> 
        <script>function OpenOriginalLink($event){
    $event.stopPropagation();
    console.log(url);
}

function removeItem($event){
    $event.stopPropagation();
    console.log('Remove item: ', url)
    localStorage.removeItem(url)
}

function exportData($event){
    $event.stopPropagation();

    result = []
    for(let i=0; i<localStorage.length; i++) {
        let key = localStorage.key(i);
        result.push(localStorage.getItem(key))
    }
    const _url = URL.createObjectURL(new Blob([result.join("\n")], {type: 'text/plain'}))
    $event.target.href = _url;
    localStorage.clear()
}

var removeItemBtn = document.createElement("BUTTON");   // Create a <button> element
removeItemBtn.innerHTML = "Remove Item";
removeItemBtn.classList.add('btn');
removeItemBtn.style.position = "fixed";
removeItemBtn.style.left = '5px';
removeItemBtn.style.top = 0;
removeItemBtn.style.border = "1px solid";
removeItemBtn.style.boxShadow = "3px 3px #888";
removeItemBtn.onclick = removeItem;
document.body.appendChild(removeItemBtn);

var goToOriginLink = document.createElement("A");   // Create a <button> element
goToOriginLink.innerHTML = "GoToOrigin";
goToOriginLink.classList.add('btn');
goToOriginLink.style.position = "fixed"
goToOriginLink.style.left = '115px'
goToOriginLink.style.top = 0;
goToOriginLink.onclick = OpenOriginalLink;
goToOriginLink.setAttribute('href', decodeURIComponent(url));
goToOriginLink.target = '_blank';
document.body.appendChild(goToOriginLink);

var current = new Date
var exportDataLink = document.createElement("A");   // Create a <button> element
exportDataLink.innerHTML = "Export data";
exportDataLink.classList.add('btn');
exportDataLink.download = current.toISOString() + '.exported.txt';
exportDataLink.style.position = "fixed";
exportDataLink.style.right = '5px';
exportDataLink.style.top = 0;
exportDataLink.style.border = "1px solid #888";
exportDataLink.style.boxShadow = "3px 3px #888";
exportDataLink.onclick = exportData;
document.body.appendChild(exportDataLink);

data = {
    'title': null ,
    'article': null
}

var body = document.getElementsByTagName("body")[0];

body.onclick = function($e){
    var num = $e.target.getAttribute('node_number')
    var valid = $e.target.getAttribute('valid')

    if(!valid){
        console.log("Element is invalid")
        return
    }

    if(data.length > 2){
        data = data.splice(0, 2)
    }

    console.log("node:", $e.target)

    if(!data.title && !data.article){
        data.title = num;
        console.log("data:", data)
        $e.target.classList.add('selected')
    }else if (data.title && !data.article){
        data.article = num;
        console.log("data:", data)
        $e.target.classList.add('selected')
    }else{
        selected = Array.from(document.getElementsByClassName("selected"))
        selected.forEach(function(el){
            el.classList.remove('selected')
        })

        data.title = num;
        data.article = null;
        $e.target.classList.add('selected')

    }

    if(data.title && data.article){
        var obj = {
            url: url,
            text: body_html,
            title: data.title,
            article: data.article,
        }

        var datasetItem = JSON.stringify(obj)
        localStorage.setItem(url, datasetItem)
    }
}
</script> 
      </html>